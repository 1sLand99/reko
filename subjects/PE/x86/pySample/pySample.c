// pySample.c
// Generated by decompiling pySample.dll
// using Reko decompiler version 0.8.0.2.

#include "pySample.h"

// 10001000: Register (ptr32 Eq_2) fn10001000(Stack (ptr32 Eq_3) ptrArg04, Stack (ptr32 Eq_4) ptrArg08)
PyObject * fn10001000(PyObject * ptrArg04, PyObject * ptrArg08)
{
	PyObject * eax_17 = PyArg_ParseTuple(ptrArg08, "ii:sum", fp - 0x04, fp - 0x08);
	if (eax_17 != null)
		return Py_BuildValue("i", dwLoc04 + dwLoc08);
	return eax_17;
}

// 10001050: Register (ptr32 Eq_2) fn10001050(Stack (ptr32 Eq_3) ptrArg04, Stack (ptr32 Eq_4) ptrArg08)
PyObject * fn10001050(PyObject * ptrArg04, PyObject * ptrArg08)
{
	PyObject * eax_17 = PyArg_ParseTuple(ptrArg08, "ii:dif", fp - 0x08, fp - 0x04);
	if (eax_17 != null)
		return Py_BuildValue("i", dwLoc08 - dwLoc04);
	return eax_17;
}

// 100010A0: Register (ptr32 Eq_2) fn100010A0(Stack (ptr32 Eq_3) ptrArg04, Stack (ptr32 Eq_4) ptrArg08)
PyObject * fn100010A0(PyObject * ptrArg04, PyObject * ptrArg08)
{
	PyObject * eax_17 = PyArg_ParseTuple(ptrArg08, "ii:div", fp - 0x08, fp - 0x04);
	if (eax_17 != null)
		return Py_BuildValue("i", (int32) ((int64) dwLoc08 / dwLoc04));
	return eax_17;
}

// 100010F0: Register (ptr32 Eq_2) fn100010F0(Stack (ptr32 Eq_3) ptrArg04, Stack (ptr32 Eq_4) ptrArg08)
PyObject * fn100010F0(PyObject * ptrArg04, PyObject * ptrArg08)
{
	PyObject * eax_17 = PyArg_ParseTuple(ptrArg08, "ff:fdiv", fp - 0x08, fp - 0x04);
	if (eax_17 != null)
		return Py_BuildValue("f", (real64) rLoc08 / rLoc04);
	return eax_17;
}

// 10001140: Register (ptr32 Eq_99) py_unused(Stack (ptr32 Eq_100) self, Stack (ptr32 Eq_4) args)
PyObject * py_unused(PyObject * self, PyObject * args)
{
	PyObject * eax_10 = PyArg_ParseTuple(args, ":unused");
	if (eax_10 == null)
		return eax_10;
	PyObject * eax_16 = &_Py_NoneStruct;
	++eax_16->ob_refcnt;
	return &_Py_NoneStruct;
}

// 10001170: void initpySample()
void initpySample()
{
	Py_InitModule4("pySample", globals->methods, null, null, 1007);
}

// 100011E9: Register word32 fn100011E9(Register Eq_136 edx, Register Eq_137 ebx, Register (ptr32 Eq_138) ebp, Register Eq_136 esi, Register Eq_140 edi, Stack word32 dwArg08, Register out (ptr32 word32) ecxOut, Register out Eq_136 edxOut, Register out Eq_137 ebxOut, Register out Eq_136 esiOut, Register out Eq_140 ediOut)
word32 fn100011E9(Eq_136 edx, Eq_137 ebx, struct Eq_138 * ebp, Eq_136 esi, Eq_140 edi, word32 dwArg08, word32 & ecxOut, union Eq_136 & edxOut, union Eq_137 & ebxOut, union Eq_136 & esiOut, LPVOID & ediOut)
{
	word32 eax_14;
	int8 Top_101 = 0x00;
	Eq_150 ebp_147 = 0x00;
	if (dwArg08 == 0x00)
	{
		if (globals->dw10003070 <= 0x00)
		{
			eax_14 = 0x00;
			goto l10001384;
		}
		--globals->dw10003070;
	}
	ecx = *adjust_fdiv;
	globals->ptr100033A4 = ecx;
	LPVOID * esp_120 = fp - 0x0010;
	if (dwArg08 == 0x01)
	{
		Eq_150 edi_126 = fs->ptr0018->t0004;
		while (true)
		{
			Eq_150 eax_138 = InterlockedCompareExchange(&globals->t100033AC, edi_126, 0x00);
			if (eax_138 == 0x00)
				break;
			if (eax_138 == edi_126)
			{
				ebp_147 = 0x01;
				break;
			}
			Sleep(1000);
		}
		if (globals->dw100033A8 != 0x00)
			_amsg_exit(0x1F);
		globals->dw100033A8 = 0x01;
		ecx = &globals->dw100020A8;
		esp_120 = fp - 0x0010;
		if (_initterm_e(&globals->t100020A0, &globals->dw100020A8) != 0x00)
		{
			eax_14 = 0x00;
l10001381:
			struct Eq_319 * esp_264 = (char *) esp_120 + 0x04;
			edi = (Eq_140) *esp_120;
			esi = esp_264->t0000;
			ebx = esp_264->t0004;
l10001384:
			ecxOut = ecx;
			edxOut = edx;
			ebxOut = ebx;
			esiOut = esi;
			ediOut = edi;
			return eax_14;
		}
		_initterm(&globals->t10002098, &globals->t1000209C);
		globals->dw100033A8 = 0x02;
		ptr32 dwLoc18_309 = 0x10002098;
		ecx = &globals->t1000209C;
		if (ebp_147 == 0x00)
		{
			InterlockedExchange(&globals->t100033AC, ebp_147);
			dwLoc18_309 = 268448684;
		}
		esp_120 = fp - 0x0010;
		if (globals->ptr100033B8 != null)
		{
			word32 ebp_213;
			word32 ebx_214;
			word32 edi_216;
			word32 esi_218;
			struct Eq_382 * esp_219;
			word32 eax_212 = fn10001742(InterlockedCompareExchange, 268448684, 0x02, out edx, out ebx_214, out ebp_213, out esi_218, out edi_216);
			ecx = esp_219->ptr0000;
			esp_120 = (LPVOID *) ((char *) &esp_219->ptr0000 + 0x04);
			if (eax_212 != 0x00)
			{
				esp_219->ptr0000 = esp_219->ptr0020;
				*(esp_219 - 0x04) = edi_216;
				*(esp_219 - 0x08) = esp_219->dw0018;
				globals->ptr100033B8();
			}
		}
		++globals->dw10003070;
	}
	else if (dwArg08 == 0x00)
	{
		while (InterlockedCompareExchange(&globals->t100033AC, 0x01, 0x00) != 0x00)
			Sleep(1000);
		if (globals->dw100033A8 != 0x02)
			_amsg_exit(0x1F);
		word32 * v15_65 = globals->ptr100033B4;
		word32 * eax_69 = _decode_pointer(v15_65);
		ecx = v15_65;
		ptr32 esp_107 = fp - 0x0010;
		if (eax_69 != null)
		{
			word32 * v16_76 = globals->ptr100033B0;
			word32 * ecx_80 = v16_76;
			ptr32 esp_81 = fp - 0x0010;
			word32 * edi_82 = _decode_pointer(v16_76);
			while (true)
			{
				edi_82 -= 0x04;
				if (edi_82 < eax_69)
					break;
				<anonymous> * eax_89 = *edi_82;
				if (eax_89 != null)
					eax_89();
			}
			word32 ** esp_104 = esp_81 - 0x04;
			*esp_104 = eax_69;
			free(*esp_104);
			ecx = *esp_104;
			word32 * eax_108 = _encoded_null();
			globals->ptr100033B0 = eax_108;
			globals->ptr100033B4 = eax_108;
			esp_107 = (char *) esp_104 + 0x04;
		}
		LONG * esp_112 = esp_107 - 0x04;
		*esp_112 = (int32) 0x00;
		*(esp_112 - 0x04) = 268448684;
		globals->dw100033A8 = 0x00;
		InterlockedExchange(*(esp_112 - 0x04), *esp_112);
		esp_120 = (LPVOID *) (esp_112 + 0x01);
	}
	eax_14 = 0x01;
	goto l10001381;
}

// 10001388: Register word32 fn10001388(Register Eq_140 ecx, Register Eq_136 edx, Register (ptr32 Eq_188) ebx, Register ptr32 esi, Register word32 edi)
word32 fn10001388(Eq_140 ecx, Eq_136 edx, Eq_150 (* ebx)(LONG *, Eq_150, Eq_150), ptr32 esi, word32 edi)
{
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	ptr32 stackArg4 = <invalid>;
	struct Eq_439 * esp_103;
	struct Eq_138 * ebp_13 = fn100017E8(ebx, esi, edi, dwLoc0C, stackArg4, 0x10);
	Eq_137 ebx_116 = ebp_13->t0008;
	*(ebp_13 - 0x1C) = 0x01;
	*(ebp_13 - 0x04) = 0x00;
	globals->t10003008 = edx;
	*(ebp_13 - 0x04) = 0x01;
	Eq_140 edi_110 = ecx;
	Eq_136 esi_113 = edx;
	if (edx == 0x00 && globals->dw10003070 == 0x00)
	{
		*(ebp_13 - 0x1C) = 0x00;
		goto l1000147A;
	}
	if (edx == 0x01 || edx == 0x02)
	{
		Eq_136 edx_65;
		word32 eax_43 = globals->dw100020CC;
		edx_65 = edx;
		if (eax_43 != 0x00)
		{
			*(esp_103 - 0x04) = (LPVOID *) ecx;
			*(esp_103 - 0x08) = (union Eq_136 *) edx;
			*(esp_103 - 0x0C) = (union Eq_137 *) ebx_116;
			word32 eax_68;
			fn00000000();
			*(ebp_13 - 0x1C) = eax_68;
		}
		if (*(ebp_13 - 0x1C) == 0x00)
		{
l1000147A:
			*(ebp_13 - 0x04) &= 0x00;
			*(ebp_13 - 0x04) = ~0x01;
			fn10001493();
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			word32 eax_261 = *(ebp_13 - 0x1C);
			ptr32 stackArg4 = <invalid>;
			ptr32 stackArg8 = <invalid>;
			ptr32 stackArg12 = <invalid>;
			ptr32 stackArg16 = <invalid>;
			fn1000182D(ebp_13, esp_103->ptrFFFFFFFC, stackArg4, stackArg8, stackArg12, stackArg16, out ebp_307, out esi_308, out edi_309);
			return eax_261;
		}
		LPVOID * esp_81 = esp_103 - 0x04;
		*esp_81 = (LPVOID *) ecx;
		*(esp_81 - 0x04) = (union Eq_136 *) edx;
		*(esp_81 - 0x08) = (union Eq_137 *) ebx_116;
		ui32 eax_92 = fn100011E9(edx_65, ebx_116, ebp_13, edx, ecx, *(esp_81 - 0x04), out ecx_310, out edx, out ebx_116, out esi_113, out edi_110);
		*(ebp_13 - 0x1C) = eax_92;
		esp_103 = (struct Eq_439 *) ((char *) esp_81 + 0x04);
		if (eax_92 == 0x00)
			goto l1000147A;
	}
	LPVOID * esp_109 = esp_103 - 0x04;
	*esp_109 = (LPVOID *) edi_110;
	*(esp_109 - 0x04) = (union Eq_136 *) esi_113;
	*(esp_109 - 0x08) = (union Eq_137 *) ebx_116;
	word32 eax_118 = fn100017C6(*(esp_109 - 0x08), *(esp_109 - 0x04));
	*(ebp_13 - 0x1C) = eax_118;
	esp_103 = (struct Eq_439 *) ((char *) esp_109 + 0x04);
	if (esi_113 == 0x01 && eax_118 == 0x00)
	{
		*esp_109 = (LPVOID *) edi_110;
		*(esp_109 - 0x04) = eax_118;
		*(esp_109 - 0x08) = (union Eq_137 *) ebx_116;
		fn100017C6(*(esp_109 - 0x08), *(esp_109 - 0x04));
		*esp_109 = (LPVOID *) edi_110;
		*(esp_109 - 0x04) = 0x00;
		*(esp_109 - 0x08) = (union Eq_137 *) ebx_116;
		word32 ecx_153;
		int8 Top_155;
		fn100011E9(edx, ebx_116, ebp_13, esi_113, edi_110, *(esp_109 - 0x04), out ecx_153, out edx, out ebx_116, out esi_113, out edi_110);
		esp_103 = (struct Eq_439 *) ((char *) esp_109 + 0x04);
		word32 eax_163 = globals->dw100020CC;
		if (eax_163 != 0x00)
		{
			*esp_109 = (LPVOID *) edi_110;
			*(esp_109 - 0x04) = 0x00;
			*(esp_109 - 0x08) = (union Eq_137 *) ebx_116;
			fn00000000();
		}
	}
	if (esi_113 == 0x00 || esi_113 == 0x03)
	{
		LPVOID * esp_187 = esp_103 - 0x04;
		*esp_187 = (LPVOID *) edi_110;
		*(esp_187 - 0x04) = (union Eq_136 *) esi_113;
		*(esp_187 - 0x08) = (union Eq_137 *) ebx_116;
		word32 ebx_205;
		word32 ecx_206;
		word32 esi_207;
		int8 Top_208;
		Eq_140 edi_209;
		word32 edx_210;
		ui32 eax_204 = fn100011E9(edx, ebx_116, ebp_13, esi_113, edi_110, *(esp_187 - 0x04), out ecx_206, out edx_210, out ebx_205, out esi_207, out edi_209);
		esp_103 = (struct Eq_439 *) ((char *) esp_187 + 0x04);
		if (eax_204 == 0x00)
			*(ebp_13 - 0x1C) &= eax_204;
		if (*(ebp_13 - 0x1C) != 0x00)
		{
			word32 eax_227 = globals->dw100020CC;
			if (eax_227 != 0x00)
			{
				*esp_187 = (LPVOID *) edi_209;
				*(esp_187 - 0x04) = esi_207;
				*(esp_187 - 0x08) = ebx_205;
				word32 eax_246;
				fn00000000();
				*(ebp_13 - 0x1C) = eax_246;
			}
		}
	}
	goto l1000147A;
}

// 10001493: void fn10001493()
void fn10001493()
{
	globals->t10003008.u0 = ~0x00;
}

// 1000149E: Register Eq_829 DllMain(Stack Eq_830 hModule, Stack Eq_136 dwReason, Stack Eq_140 lpReserved)
Eq_829 DllMain(Eq_830 hModule, Eq_136 dwReason, Eq_140 lpReserved)
{
	if (dwReason == 0x01)
		fn10001864();
	return fn10001388(lpReserved, dwReason, ebx, esi, edi);
}

// 100015CF: Register Eq_844 fn100015CF(Register (ptr32 Eq_188) ebx, Register ptr32 esi, Register word32 edi)
Eq_844 fn100015CF(Eq_150 (* ebx)(LONG *, Eq_150, Eq_150), ptr32 esi, word32 edi)
{
	Eq_844 eax_110;
	struct Eq_849 * esp_81;
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	ptr32 stackArg4 = <invalid>;
	struct Eq_849 * esp_14;
	struct Eq_138 * ebp_13 = fn100017E8(ebx, esi, edi, dwLoc0C, stackArg4, 0x14);
	*(esp_14 - 0x04) = globals->ptr100033B4;
	word32 * eax_23 = _decode_pointer(*(esp_14 - 0x04));
	word32 ecx_24 = *(esp_14 - 0x04);
	*(ebp_13 - 0x1C) = eax_23;
	if (eax_23 == (word32 *) ~0x00)
	{
		*(esp_14 - 0x04) = (union Eq_137 *) ebp_13->t0008;
		eax_110 = _onexit(*(esp_14 - 0x04));
		esp_81 = esp_14;
	}
	else
	{
		*(esp_14 - 0x04) = 0x08;
		word32 ** esp_31;
		int8 Top_34;
		lock();
		word32 * ecx_36 = *esp_31;
		*(ebp_13 - 0x04) &= 0x00;
		*esp_31 = globals->ptr100033B4;
		*(ebp_13 - 0x1C) = _decode_pointer(*esp_31);
		*(esp_31 - 0x04) = globals->ptr100033B0;
		*(ebp_13 - 0x20) = _decode_pointer(*(esp_31 - 0x04));
		*(esp_31 - 0x08) = ebp_13 - 0x20;
		*(esp_31 - 0x0C) = ebp_13 - 0x1C;
		*(esp_31 - 0x0010) = (union Eq_137 *) ebp_13->t0008;
		Eq_844 eax_61 = __dllonexit(*(esp_31 - 0x0010), *(esp_31 - 0x0C), *(esp_31 - 0x08));
		*(ebp_13 - 0x24) = (_onexit_t *) eax_61;
		*(esp_31 - 0x0014) = *(ebp_13 - 0x1C);
		ptr32 esp_67;
		word32 * eax_68;
		word32 ecx_69;
		int8 Top_70;
		encode_pointer();
		globals->ptr100033B4 = eax_68;
		*(esp_67 - 0x04) = *(ebp_13 - 0x20);
		word32 esp_76;
		word32 * eax_77;
		word32 ecx_78;
		encode_pointer();
		globals->ptr100033B0 = eax_77;
		*(ebp_13 - 0x04) = ~0x01;
		fn10001665(ecx_78);
		esp_81 = esp_76 + 0x1C;
		eax_110 = (Eq_844) *(ebp_13 - 0x24);
	}
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	ptr32 stackArg4 = <invalid>;
	ptr32 stackArg8 = <invalid>;
	ptr32 stackArg12 = <invalid>;
	ptr32 stackArg16 = <invalid>;
	fn1000182D(ebp_13, esp_81->ptrFFFFFFFC, stackArg4, stackArg8, stackArg12, stackArg16, out ebp_125, out esi_126, out edi_127);
	return eax_110;
}

// 10001665: void fn10001665(Register word32 ecx)
void fn10001665(word32 ecx)
{
	unlock();
}

// 1000166E: void fn1000166E(Register (ptr32 Eq_188) ebx, Register ptr32 esi, Register word32 edi, Stack word32 dwArg04)
void fn1000166E(Eq_150 (* ebx)(LONG *, Eq_150, Eq_150), ptr32 esi, word32 edi, word32 dwArg04)
{
	fn100015CF(ebx, esi, edi);
}

// 10001680: void fn10001680(Register word32 esi, Register word32 edi)
void fn10001680(word32 esi, word32 edi)
{
	int8 Top_25 = 0x00;
	ptr32 esp_21 = fp - 0x08;
	word32 * esi_13 = globals->a100021D8;
	if (false)
	{
		do
		{
			word32 eax_17 = *esi_13;
			if (eax_17 != 0x00)
				fn00000000();
			++esi_13;
		} while (esi_13 < globals->a100021D8);
	}
}

// 100016D0: Register word32 fn100016D0(Stack (ptr32 Eq_1105) dwArg04)
word32 fn100016D0(struct Eq_1105 * dwArg04)
{
	if (dwArg04->w0000 != 23117)
		return 0x00;
	struct Eq_1111 * eax_9 = dwArg04 + dwArg04->dw003C / 0x0040;
	if (eax_9->dw0000 != 0x4550)
		return 0x00;
	return (word32) (eax_9->w0018 == 0x010B);
}

// 10001700: Register (ptr32 Eq_1128) fn10001700(Stack (ptr32 Eq_1129) dwArg04, Stack up32 dwArg08, Register out ptr32 edxOut)
struct Eq_1128 * fn10001700(struct Eq_1129 * dwArg04, up32 dwArg08, ptr32 & edxOut)
{
	struct Eq_1132 * ecx_7 = dwArg04 + dwArg04->dw003C / 0x0040;
	ptr32 esi_15 = (word32) ecx_7->w0006;
	ptr32 edx_16 = 0x00;
	struct Eq_1128 * eax_22 = ecx_7 + ((word32) ecx_7->w0014 + 0x18) / 22;
	if (esi_15 > 0x00)
	{
		do
		{
			up32 ecx_28 = eax_22->dw000C;
			if (dwArg08 >= ecx_28 && dwArg08 < eax_22->dw0008 + ecx_28)
				goto l1000173E;
			++edx_16;
			++eax_22;
		} while (edx_16 < esi_15);
	}
	eax_22 = null;
l1000173E:
	edxOut = edx_16;
	return eax_22;
}

// 10001742: Register ui32 fn10001742(Register (ptr32 Eq_188) ebx, Register ptr32 esi, Register word32 edi, Register out ptr32 edxOut, Register out ptr32 ebxOut, Register out ptr32 ebpOut, Register out ptr32 esiOut, Register out ptr32 ediOut)
ui32 fn10001742(Eq_150 (* ebx)(LONG *, Eq_150, Eq_150), ptr32 esi, word32 edi, ptr32 & edxOut, ptr32 & ebxOut, ptr32 & ebpOut, ptr32 & esiOut, ptr32 & ediOut)
{
	ui32 eax_60;
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	ptr32 stackArg4 = <invalid>;
	struct Eq_1173 * esp_14;
	struct Eq_138 * ebp_13 = fn100017E8(ebx, esi, edi, dwLoc0C, stackArg4, 0x08);
	*(ebp_13 - 0x04) &= 0x00;
	*(esp_14 - 0x04) = 0x10000000;
	ptr32 edx_23 = 0x10000000;
	if (fn100016D0(*(esp_14 - 0x04)) != 0x00)
	{
		*(esp_14 - 0x04) = ebp_13->t0008 - 0x10000000;
		*(esp_14 - 0x08) = 0x10000000;
		struct Eq_1231 * eax_44 = fn10001700(*(esp_14 - 0x08), *(esp_14 - 0x04), out edx_23);
		if (eax_44 != null)
		{
			eax_60 = ~(eax_44->dw0024 >> 0x1F) & 0x01;
			*(ebp_13 - 0x04) = ~0x01;
l100017A8:
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			ptr32 stackArg4 = <invalid>;
			ptr32 stackArg8 = <invalid>;
			ptr32 stackArg12 = <invalid>;
			ptr32 stackArg16 = <invalid>;
			ptr32 ebp_76;
			ptr32 edi_79;
			ptr32 esi_80;
			ptr32 ebx_77 = fn1000182D(ebp_13, esp_14->ptrFFFFFFFC, stackArg4, stackArg8, stackArg12, stackArg16, out ebp_76, out esi_80, out edi_79);
			edxOut = edx_23;
			ebxOut = ebx_77;
			ebpOut = ebp_76;
			esiOut = esi_80;
			ediOut = edi_79;
			return eax_60;
		}
	}
	*(ebp_13 - 0x04) = ~0x01;
	eax_60 = 0x00;
	goto l100017A8;
}

// 100017C6: Register word32 fn100017C6(Stack Eq_571 dwArg04, Stack word32 dwArg08)
word32 fn100017C6(Eq_571 dwArg04, word32 dwArg08)
{
	if (dwArg08 == 0x01 && globals->dw100020CC == 0x00)
		DisableThreadLibraryCalls(dwArg04);
	return 0x01;
}

// 100017E8: Register ptr32 fn100017E8(Register (ptr32 Eq_188) ebx, Register ptr32 esi, Register word32 edi, Stack word32 dwArg00, Stack ptr32 dwArg04, Stack ui32 dwArg08)
ptr32 fn100017E8(Eq_150 (* ebx)(LONG *, Eq_150, Eq_150), ptr32 esi, word32 edi, word32 dwArg00, ptr32 dwArg04, ui32 dwArg08)
{
	ptr32 esp_14 = fp - 0x08 - dwArg08;
	*(esp_14 - 0x04) = (Eq_150 (**)(LONG *, Eq_150, Eq_150)) ebx;
	*(esp_14 - 0x08) = esi;
	*(esp_14 - 0x0C) = edi;
	*(esp_14 - 0x0010) = globals->dw10003000 ^ fp + 0x08;
	*(esp_14 - 0x0014) = dwArg00;
	fs->ptr0000 = fp - 0x08;
	return fp + 0x08;
}

// 1000182D: Register ptr32 fn1000182D(Register (ptr32 Eq_138) ebp, Stack ptr32 dwArg00, Stack ptr32 dwArg04, Stack ptr32 dwArg08, Stack ptr32 dwArg0C, Stack ptr32 dwArg10, Register out ptr32 ebpOut, Register out ptr32 esiOut, Register out ptr32 ediOut)
ptr32 fn1000182D(struct Eq_138 * ebp, ptr32 dwArg00, ptr32 dwArg04, ptr32 dwArg08, ptr32 dwArg0C, ptr32 dwArg10, ptr32 & ebpOut, ptr32 & esiOut, ptr32 & ediOut)
{
	fs->dw0000 = *(ebp - 0x10);
	ptr32 ebp_19 = ebp->ptr0000;
	ebp->ptr0000 = dwArg00;
	ebpOut = ebp_19;
	esiOut = dwArg0C;
	ediOut = dwArg08;
	return dwArg10;
}

// 10001864: void fn10001864()
void fn10001864()
{
	ui32 eax_9 = globals->dw10003000;
	if (eax_9 != 0xBB40E64E && (eax_9 & 0xFFFF0000) != 0x00)
		globals->dw10003004 = ~eax_9;
	else
	{
		GetSystemTimeAsFileTime(fp - 0x0C);
		ui32 esi_46 = dwLoc08 & 0x00 ^ dwLoc0C & 0x00 ^ GetCurrentProcessId() ^ GetCurrentThreadId() ^ GetTickCount();
		QueryPerformanceCounter(fp - 0x14);
		ui32 esi_54 = esi_46 ^ (dwLoc10 ^ dwLoc14);
		if (esi_54 == 0xBB40E64E)
			esi_54 = ~0x44BF19B0;
		else if ((esi_54 & 0xFFFF0000) == 0x00)
			esi_54 |= esi_54 << 0x10;
		globals->dw10003000 = esi_54;
		globals->dw10003004 = ~esi_54;
	}
}

