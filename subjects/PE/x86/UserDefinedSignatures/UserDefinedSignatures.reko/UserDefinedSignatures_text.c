// UserDefinedSignatures_text.c
// Generated by decompiling UserDefinedSignatures.exe
// using Reko decompiler version 0.11.4.0.

#include "UserDefinedSignatures.h"

// 00401000: void setInteger(Stack word32 d, Stack Eq_n value)
// Called from:
//      setParameter
void setInteger(word32 d, Eq_n value)
{
	*d = value;
}

// 00401010: void setFloat(Stack word32 d, Stack Eq_n value)
// Called from:
//      setParameter
void setFloat(word32 d, Eq_n value)
{
	d->r0004 = value;
}

// 00401020: void setDouble(Stack word32 d, Stack Eq_n value)
// Called from:
//      setParameter
void setDouble(word32 d, Eq_n value)
{
	d->r0008 = value;
}

// 00401030: void setParameter(Stack (ptr32 Eq_n) d, Stack int32 type, Stack (ptr32 word32) value)
// Called from:
//      main
void setParameter(struct Eq_n * d, int32 type, word32 * value)
{
	switch (type)
	{
	case 0x00:
		setInteger(d, value->u0);
		break;
	case 0x01:
		setFloat(d, value->u1);
		break;
	case 0x02:
		setDouble(d, value->u2);
		break;
	}
}

// 004010B0: Register (ptr32 void) new_data_struct()
// Called from:
//      main
void * new_data_struct()
{
	return operator new(0x10);
}

// 004010D0: Register int32 main(Stack int32 argc, Stack (ptr32 (ptr32 char)) argv)
int32 main(int32 argc, char ** argv)
{
	word32 dwLoc1C;
	word32 dwLoc14;
	word32 dwLoc10;
	struct Eq_n * eax_n = new_data_struct();
	int32 dwLoc0C_n;
	for (dwLoc0C_n = 0x01; dwLoc0C_n < argc - 0x01; ++dwLoc0C_n)
	{
		if (strcmp(argv[dwLoc0C_n].u0, "i32") == 0x00)
		{
			++dwLoc0C_n;
			dwLoc10 = atoi(argv[dwLoc0C_n].u0);
			setParameter(eax_n, 0x00, &dwLoc10);
		}
		else if (strcmp(argv[dwLoc0C_n].u0, "r32") == 0x00)
		{
			++dwLoc0C_n;
			dwLoc14 = (real32) atof(argv[dwLoc0C_n].u0);
			setParameter(eax_n, 0x01, &dwLoc14);
		}
		else if (strcmp(argv[dwLoc0C_n].u0, "r64") == 0x00)
		{
			++dwLoc0C_n;
			dwLoc1C = (word32) atof(argv[dwLoc0C_n].u0);
			setParameter(eax_n, 0x02, &dwLoc1C);
		}
	}
	g_dw403018 = eax_n->dw0000;
	g_dw40301C = eax_n->dw0004;
	g_dw403020 = eax_n->dw0008;
	g_dw403024 = eax_n->dw000C;
	free(eax_n);
	return 0x00;
}

