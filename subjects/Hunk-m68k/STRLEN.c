// STRLEN.c
// Generated by decompiling STRLEN
// using Reko decompiler version 0.8.0.2.

#include "STRLEN.h"

// 00001000: void fn00001000(Register int32 d0, Register (ptr32 Eq_3) a0)
void fn00001000(int32 d0, union Eq_3 * a0)
{
	struct Eq_4 * a6_9 = (struct Eq_4 **) 0x04;
	int32 d2_102 = d0;
	union Eq_3 * a2_196 = a0;
	if (a6_9->w0014 < 0x24)
	{
		word32 * a0_13 = &globals->ptr13C8;
		uint32 d0_16;
		do
		{
			*a0_13 = 0x00;
			++a0_13;
			--d0_16;
		} while (d0_16 != 0x00);
	}
	globals->ptr13C8 = fp;
	globals->ptr13CC = a6_9;
	struct Eq_19 * d0_37 = FindTask(0x00);
	byte * a1_255 = &globals->b12BC;
	struct Eq_27 * d0_112 = OpenLibrary(0x12BC, 0x00);
	if (d0_112 != null)
	{
		int32 d4_75;
		globals->ptr13D0 = d0_112;
		if (d0_37->ptr00AC == null)
		{
			d4_75 = 0x02;
			d2_102 = 0x08;
		}
		else
		{
			union Eq_3 * a0_74 = a0;
			d4_75 = 0x03;
			do
			{
				if (*a0_721 == 0x20)
					d4_75 = DPB(d4_75, (word16) d4_75 + 0x01, 0);
				a0_74 = (union Eq_3 *) ((char *) a0_721 + 0x01);
				a0_721 = a0_74;
			} while (*a0_721 != 0x00);
		}
		int32 d0_100 = d4_75 << 0x02;
		ui32 d0_107 = d0_100 + d2_102;
		Eq_75 d1_111 = 0x00010001;
		d0_112 = AllocMem(d0_107 + 0x11, 0x00010001);
		if (d0_112 != null)
		{
			struct Eq_4 * a6_235;
			word32 a0_436;
			union Eq_3 * dwLoc0C_581;
			d0_112->dw0000 = d0_107 + 0x11;
			d0_112->dw000C = d4_75 - 0x01;
			d0_112->ptr0008 = (byte *) (&d0_112->ptr0010 + d0_100 / 0x0014);
			null = null;
			union Eq_3 * d0_180 = d0_37->ptr00AC;
			if (d0_180 == null)
			{
				fn00001214(d0_37);
				globals->ptr13D4 = d0_180;
				globals->ptr13D8 = d0_180;
				null = null;
				dwLoc0C_581 = d0_180;
				a2_196 = d0_180;
				int32 d0_197 = *((char *) d0_180 + 0x0024);
				if (d0_197 != 0x00)
					Enable();
				Supervisor(d0_112);
				d0_112->dw0004 = d0_197;
				d1_111.u1 = 4808;
				d2_102 = 1005;
				if (d0_197 == 0x00)
				{
					fn0000127C(0x0014);
					return;
				}
				globals->dw13DC = d0_197;
				(int32 *) 5088 = d0_197;
				(int32 *) 0x13E4 = d0_197;
				d0_37->dw009C = d0_197;
				d0_37->dw00A0 = d0_197;
				word32 d0_227 = ((word32[]) 0x08)[d0_197];
				if (d0_227 != 0x00)
					d0_37->dw00A4 = d0_227;
				a6_235 = globals->ptr13CC;
l000011F8:
				a0_436 = d0_37->dw003A;
				goto l00001202;
			}
			ui32 d0_252 = ((ui32[]) 0x0010)[d0_180];
			a1_255 = d0_112->ptr0008;
			Eq_162 a0_260[] = (d0_252 << 0x02) + 0x01;
			int32 d0_261 = (int32) null[d0_252].b0000;
			(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&a0_260[d0_261].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00] = (Eq_162) 0x00;
			d0_112->ptr0010 = a0_260;
			word32 * a6_265 = (char *) &d0_112->ptr0010 + 0x04;
			int32 d3_266 = 0x01;
			struct Eq_173 * a0_271 = (char *) a0 + d2_102;
			do
			{
				--a0_271;
				if (a0_271->b0000 > 0x20)
					break;
				--d2_102;
			} while (d2_102 != ~0x00);
			a0_271[0x01] = (struct Eq_173) 0x00;
			do
			{
l000010E6:
				byte v37_288 = *a2_196;
				a2_196 = (union Eq_3 *) ((char *) a2_196 + 0x01);
				d1_111 = DPB(d1_111, v37_288, 0);
				if (v37_288 == 0x00)
					goto l00001148;
			} while (v37_288 == 0x20 || v37_288 == 0x09);
			if (d3_266 - d0_112->dw000C != 0x00)
			{
				*a6_265 = a1_255;
				++a6_265;
				d3_266 = DPB(d3_266, (word16) d3_266 + 0x01, 0);
				if (v37_288 != 0x22)
				{
					*a1_255 = v37_288;
					++a1_255;
					while (true)
					{
						byte v45_361 = *a2_196;
						a2_196 = (union Eq_3 *) ((char *) a2_196 + 0x01);
						d1_111 = DPB(d1_111, v45_361, 0);
						if (v45_361 == 0x00)
							break;
						if (v45_361 == 0x20)
							goto l00001116;
						*a1_255 = v45_361;
						++a1_255;
					}
				}
				else
				{
					while (true)
					{
						byte v64_318 = *a2_196;
						a2_196 = (union Eq_3 *) ((char *) a2_196 + 0x01);
						d1_111 = DPB(d1_111, v64_318, 0);
						if (v64_318 == 0x00)
							break;
						if (v64_318 == 0x22)
						{
l00001116:
							*a1_255 = 0x00;
							++a1_255;
							goto l000010E6;
						}
						if (v64_318 == 0x2A)
						{
							byte v67_330 = *a2_196;
							a2_196 = (union Eq_3 *) ((char *) a2_196 + 0x01);
							d1_111 = DPB(d1_111, v67_330, 0);
							d2_102 = DPB(d2_102, v67_330 & 223, 0);
							if ((v67_330 & 223) == 0x4E)
								d1_111.u0 = 0x0A;
							else if ((v67_330 & 223) == 0x45)
								d1_111.u0 = 0x001B;
						}
						*a1_255 = (byte) d1_111;
						++a1_255;
					}
				}
			}
l00001148:
			*a1_255 = 0x00;
			*a6_265 = 0x00;
			execPrivate4();
			globals->dw13DC = d0_261;
			execPrivate5();
			(int32 *) 5088 = d0_261;
			a6_235 = globals->ptr13CC;
			dwLoc0C_581 = (union Eq_3 *) &d0_112->ptr0010;
			dwLoc10 = d3_266;
			if (a6_235->w0014 >= 0x24)
			{
				int32 v81_417 = d0_37->dw00E0;
				(int32 *) 0x13E4 = v81_417;
				if (v81_417 != 0x00)
				{
l0000117E:
					if (d0_37->b0008 == 0x0D)
					{
						word32 * a0_439 = d0_37->ptr00B0;
						a0_436 = a0_439 + 0x01 - *a0_439;
l00001202:
						(word32 *) 0x13F0 = a0_436;
						(ptr32 *) 0x13F4 = fp - 0x0010;
						fn00001354(d1_111, d2_102, a0_436, a1_255, a2_196, d0_37, 37822, d0_112, a6_235, dwLoc10, dwLoc0C_581);
						fn0000127C(0x00);
						return;
					}
					goto l000011F8;
				}
			}
			(int32 *) 0x13E4 = d0_261;
			goto l0000117E;
		}
		CloseLibrary(globals->ptr13D0);
		Alert(0x00010000);
	}
	else
		Alert(0x00038007);
	if (d0_37->ptr00AC == null)
	{
		fn00001214(d0_37);
		fn0000126C(d0_112);
	}
}

// 00001214: void fn00001214(Register (ptr32 Eq_19) a3)
void fn00001214(struct Eq_19 * a3)
{
	WaitPort((char *) &a3->dw003A + 0x0022);
	GetMsg((char *) &a3->dw003A + 0x0022);
}

// 0000126C: void fn0000126C(Register (ptr32 Eq_27) a2)
void fn0000126C(struct Eq_27 * a2)
{
	Forbid();
	ReplyMsg(a2);
}

// 00001278: void fn00001278(Stack int32 dwArg04)
void fn00001278(int32 dwArg04)
{
	fn0000127C(dwArg04);
}

// 0000127C: void fn0000127C(Register int32 d2)
void fn0000127C(int32 d2)
{
	ptr32 a7_4 = globals->ptr13C8;
	struct Eq_455 * v8_9 = *(a7_4 - 0x04);
	struct Eq_27 * v6_6 = *(a7_4 - 0x08);
	if (v8_9->dw0004 != 0x00)
		execPrivate1();
	CloseLibrary(globals->ptr13D0);
	if (v6_6 != null)
		fn0000126C(v6_6);
	FreeMem(v8_9, v8_9->dw0000);
}

// 000012D0: void fn000012D0(Register Eq_75 d1, Register int32 d2, Register word32 a1, Register (ptr32 Eq_3) a2, Register (ptr32 Eq_495) a3, Register ptr32 a4, Register (ptr32 Eq_27) a5, Register (ptr32 Eq_4) a6, Stack int32 dwArg04)
void fn000012D0(Eq_75 d1, int32 d2, word32 a1, union Eq_3 * a2, struct Eq_495 * a3, ptr32 a4, struct Eq_27 * a5, struct Eq_4 * a6, int32 dwArg04)
{
	if (0x1404 != 0x00)
	{
		int32 d2_16 = 0x01;
		if ((word32 *) 0x1408 != 0x00)
		{
			do
				++d2_16;
			while (((word32[]) 0x1404)[d2_16] != 0x00);
		}
		int32 d2_33;
		for (d2_33 = d2_16 - 0x01; d2_33 != 0x00; --d2_33)
		{
			int32 d0_38 = d2_33 << 0x02;
			Eq_528 a2_42 = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&((Eq_528[]) 0x1404)[d0_38].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00];
			a2_42();
		}
	}
	fn00001278(dwArg04);
}

// 0000131C: void fn0000131C(Register Eq_75 d1, Register int32 d2, Register word32 a1, Register (ptr32 Eq_3) a2, Register (ptr32 word32) a3, Register ptr32 a4, Register (ptr32 Eq_27) a5, Register (ptr32 Eq_4) a6, Stack int32 dwArg04)
void fn0000131C(Eq_75 d1, int32 d2, word32 a1, union Eq_3 * a2, word32 * a3, ptr32 a4, struct Eq_27 * a5, struct Eq_4 * a6, int32 dwArg04)
{
	if ((int32 *) 5112 == 0x00)
	{
		struct Eq_495 * a3_13 = (struct Eq_495 **) 0x140C;
		(int32 *) 5112 = 0x01;
		struct Eq_495 * d0_17 = a3_13;
		while (a3_13 != null)
		{
			a2 = a3_13->ptr0004;
			a2();
			a3_13 = a3_13->ptr0000;
			d0_17 = a3_13;
		}
		fn000012D0(d1, d2, a1, a2, a3_13, a4, a5, a6, dwArg04);
	}
}

// 00001354: void fn00001354(Register Eq_75 d1, Register int32 d2, Register word32 a0, Register (ptr32 byte) a1, Register (ptr32 Eq_3) a2, Register (ptr32 Eq_19) a3, Register ptr32 a4, Register (ptr32 Eq_27) a5, Register (ptr32 Eq_4) a6, Stack int32 dwArg04, Stack (ptr32 Eq_3) dwArg08)
void fn00001354(Eq_75 d1, int32 d2, word32 a0, byte * a1, union Eq_3 * a2, struct Eq_19 * a3, ptr32 a4, struct Eq_27 * a5, struct Eq_4 * a6, int32 dwArg04, union Eq_3 * dwArg08)
{
	word32 * a3_17 = (word32 *) 0x1400;
	word32 d0_10 = 5116;
	if (5116 != 0x00 && (word32 *) 0x1400 != 0x00)
	{
		do
		{
			union Eq_3 * v11_19 = *a3_17;
			++a3_17;
			v11_19();
			a2 = v11_19;
		} while (*a3_17 != 0x00);
	}
	word32 a1_42;
	fn0000131C(d1, d2, a1_42, a2, a3_17, a4, a5, a6, fn00001390(out a1_42));
}

// 00001390: Register word32 fn00001390(Register out ptr32 a1Out)
word32 fn00001390(ptr32 & a1Out)
{
	ptr32 a1_12;
	word32 d0_13 = fn000013AC(&globals->b13A4, out a1_12);
	a1Out = a1_12;
	return d0_13;
}

// 000013AC: Register int32 fn000013AC(Stack (ptr32 byte) dwArg04, Register out (ptr32 byte) a1Out)
int32 fn000013AC(byte * dwArg04, byte & a1Out)
{
	byte * a1_4 = dwArg04;
	int32 d0_15 = 0x00;
	while (true)
	{
		++a1_4;
		if (*a1_4 == 0x00)
			break;
		++d0_15;
	}
	a1Out = a1_4;
	return d0_15;
}

