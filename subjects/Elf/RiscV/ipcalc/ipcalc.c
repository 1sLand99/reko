// ipcalc.c
// Generated by decompiling ipcalc
// using Reko decompiler version 0.8.2.0.

#include "ipcalc.h"

// 0000000000014F20: void herror()
void herror()
{
}

// 0000000000014F30: void __strdup()
void __strdup()
{
}

// 0000000000014F40: void clock_gettime()
void clock_gettime()
{
}

// 0000000000014F50: void close()
void close()
{
}

// 0000000000014F60: void read()
void read()
{
}

// 0000000000014F70: void inet_ntop()
void inet_ntop()
{
}

// 0000000000014F80: void snprintf()
void snprintf()
{
}

// 0000000000014F90: void getaddrinfo()
void getaddrinfo()
{
}

// 0000000000014FA0: void dlopen()
void dlopen()
{
}

// 0000000000014FB0: void open()
void open()
{
}

// 0000000000014FC0: void __snprintf_chk()
void __snprintf_chk()
{
}

// 0000000000014FD0: void dlsym()
void dlsym()
{
}

// 0000000000014FE0: void exit()
void exit()
{
}

// 0000000000014FF0: void getopt_long()
void getopt_long()
{
}

// 0000000000015000: void __vasprintf_chk()
void __vasprintf_chk()
{
}

// 0000000000015010: void __asprintf_chk()
void __asprintf_chk()
{
}

// 0000000000015020: void getnameinfo()
void getnameinfo()
{
}

// 0000000000015030: void memset()
void memset()
{
}

// 0000000000015040: void inet_pton()
void inet_pton()
{
}

// 0000000000015050: void strcmp()
void strcmp()
{
}

// 0000000000015060: void free()
void free()
{
}

// 0000000000015070: void __printf_chk()
void __printf_chk()
{
}

// 0000000000015080: void __sprintf_chk()
void __sprintf_chk()
{
}

// 0000000000015090: void fwrite()
void fwrite()
{
}

// 00000000000150A0: void memcmp()
void memcmp()
{
}

// 00000000000150B0: void fputs()
void fputs()
{
}

// 00000000000150C0: void isatty()
void isatty()
{
}

// 00000000000150D0: void __fprintf_chk()
void __fprintf_chk()
{
}

// 00000000000150E0: void __libc_start_main()
void __libc_start_main()
{
}

// 00000000000150F0: void putchar()
void putchar()
{
}

// 0000000000015100: void fputc()
void fputc()
{
}

// 0000000000015110: void __stack_chk_fail()
void __stack_chk_fail()
{
}

// 0000000000015120: void __errno_location()
void __errno_location()
{
}

// 0000000000015130: void strtol()
void strtol()
{
}

// 0000000000015140: void strchr()
void strchr()
{
}

// 0000000000015150: void memcpy()
void memcpy()
{
}

// 0000000000015160: void abort()
void abort()
{
}

// 0000000000015170: void freeaddrinfo()
void freeaddrinfo()
{
}

// 0000000000015180: void fn0000000000015180(Register word64 ra, Register (ptr64 Eq_n) gp, Register Eq_n a0, Register (ptr64 (ptr64 char)) a1, Register word64 a7, Register word64 s5, Register word64 s11)
void fn0000000000015180(word64 ra, struct Eq_n * gp, Eq_n a0, char ** a1, word64 a7, word64 s5, word64 s11)
{
	struct Eq_n * sp_n = fp + -448 + ~0x17;
	Eq_n a5_n = gp->tFFFFF870;
	Eq_n s3_n = a0;
	Eq_n s0_n = 0x00;
	Eq_n s6_n = 0x00;
	Eq_n s9_n = 0x00;
	Eq_n s10_n = 0x00;
	Eq_n s7_n = 0x01;
	do
	{
		Eq_n a0_n = (uint64) (uint32) getopt_long(a0, a1, "cr:i46bho:gmnpsv", &globals->t108E0, 0x00);
		sp_n = &sp_n->qwFFFFFFF8;
		if (a0_n == -0x01)
		{
			Eq_n s1_n;
			Eq_n s4_n;
			Eq_n a4_n = (int64) gp->dwFFFFF890;
			if (a4_n < a0)
			{
				Eq_n a1_n = (int64) ((word32) a4_n + 0x01);
				gp->dw0890 = (word32) a1_n;
				struct Eq_n * s2_n = (char *) a1 + (a4_n << 0x03);
				s1_n = s2_n->t0000;
				s4_n.u0 = 0x00;
				if (a1_n < a0)
				{
					s4_n = s2_n->t0008;
					gp->dw0890 = (word32) (int64) ((word32) a4_n + 0x02);
				}
			}
			else
			{
				s4_n.u0 = 0x00;
				s1_n.u0 = 0x00;
			}
			if (s6_n != 0x00)
			{
				__printf_chk(0x01, "ipcalc %s\n", 0x00);
				goto l00000000000153DC;
			}
			if ((int64) sp_n->dw001C != 0x00 && (int64) sp_n->t0000 != 0x00)
			{
				if ((int64) gp->dwFFFFF814 != 0x00)
					goto l00000000000153D8;
				fwrite(&globals->v119D8, 0x01, 0x002E, gp->tFFFFF880);
				goto l00000000000153DC;
			}
			word64 a6_n;
			Eq_n a4_n;
			int64 a0_n;
			Eq_n a5_n;
			Eq_n a0_n;
			char * a0_n;
			Eq_n a5_n;
			Eq_n s2_n;
			sp_n[0x01] = (struct Eq_n) a0_n;
			if (s9_n != 0x00)
			{
				word64 a1_n;
				word64 a2_n;
				word64 a3_n;
				word64 a4_n;
				word64 a0_n = fn0000000000017924(gp, out a1_n, out a2_n, out a3_n, out a4_n, out a6_n);
				s2_n = s0_n | 0x02;
				a5_n = sp_n[0x01];
				if (a0_n != 0x00 || (s0_n & 0x00010008) != 0x00010008)
					goto l00000000000153CC;
				s0_n |= 0x02;
				goto l0000000000015448;
			}
			word64 a1_n;
			word64 a2_n;
			word64 a3_n;
			word64 a4_n;
			word64 a0_n = fn0000000000017924(gp, out a1_n, out a2_n, out a3_n, out a4_n, out a6_n);
			a5_n = sp_n[0x01];
			if (a0_n == 0x00 && (s0_n & 0x00010008) == 0x00010008)
			{
l0000000000015448:
				s2_n = s0_n | 0x4000;
				if (s9_n == 0x00)
				{
					s0_n = s2_n;
					goto l0000000000015458;
				}
l00000000000153CC:
				if (s10_n != 0x00)
				{
					if ((int64) gp->dwFFFFF814 == 0x00)
						fwrite(&globals->v11A08, 0x01, 0x0025, gp->tFFFFF880);
					goto l00000000000153D8;
				}
				if ((int64) sp_n->dw001C != 0x00)
				{
					sp_n[0x01] = (struct Eq_n) a5_n;
					Eq_n a0_n = fn00000000000169D8(gp, s9_n);
					s1_n = a0_n;
					s0_n = s2_n;
					a5_n = sp_n[0x01];
					if (a0_n == 0x00)
						goto l0000000000015964;
					goto l0000000000015510;
				}
				if ((int64) sp_n->t0000 != 0x00)
				{
					sp_n->t0000.u3 = a5_n;
					Eq_n a0_n = fn00000000000169D8(gp, s9_n);
					s1_n = a0_n;
					if (a0_n == 0x00)
						goto l0000000000015964;
					a5_n = sp_n->t0000;
					s0_n = s2_n;
					goto l00000000000155D8;
				}
				sp_n->t0000.u3 = a5_n;
				Eq_n a0_n = fn00000000000169D8(gp, s9_n);
				s1_n = a0_n;
				if (a0_n != 0x00)
				{
					s0_n = s2_n;
					a5_n = sp_n->t0000;
					goto l0000000000015518;
				}
l0000000000015964:
				if ((int64) gp->dwFFFFF814 != 0x00)
					goto l00000000000153D8;
				__fprintf_chk(gp->tFFFFF880, 0x01, "ipcalc: could not resolve %s\n", 0x00);
				goto l00000000000153DC;
			}
l0000000000015458:
			if (s10_n == 0x00)
			{
				if (s1_n != 0x00)
					goto l0000000000015510;
				if ((int64) gp->dwFFFFF814 != 0x00)
					goto l00000000000153D8;
				fwrite(&globals->v11A30, 0x01, 0x001C, gp->tFFFFF880);
				fn0000000000015FCC(gp, 0x01);
				goto l00000000000153DC;
			}
			Eq_n a0_n = fn00000000000166F4(gp, &sp_n->dw001C, s10_n, 0x01);
			if (a0_n < 0x00)
			{
				if ((int64) gp->dwFFFFF814 != 0x00)
					goto l00000000000153D8;
				a0_n = gp->tFFFFF880;
				(int64) sp_n->dw001C != 0x00;
				goto l0000000000015B8C;
			}
			sp_n[0x01] = (struct Eq_n) a0_n;
			int64 s1_n = (int64) sp_n->dw001C;
			sp_n[0x04] = (struct Eq_n) 0x00;
			Eq_n a0_n = (uint64) (uint32) clock_gettime(0x02, sp_n + 0x05);
			Eq_n a5_n = sp_n->t0000;
			if (a0_n < 0x00)
			{
l0000000000015CB0:
				if ((int64) gp->dwFFFFF814 != 0x00)
					goto l00000000000153D8;
				__fprintf_chk(gp->tFFFFF880, 0x01, "ipcalc: cannot generate network with prefix: %u\n", 0x00);
				goto l00000000000153DC;
			}
			word64 a5_n;
			if (s1_n != 0x00)
			{
				sp_n[0x06] = (struct Eq_n) (byte) (sp_n[0x05] & 0x01 | -0x04);
				if (fn00000000000164D0(&sp_n->b0030 + 0x01, 0x0F) < 0x00)
					goto l0000000000015CB0;
				char * a0_n = inet_ntop(0x0A, sp_n + 0x06, sp_n + 0x0020, 0x0040);
				a5_n = sp_n->qwFFFFFFF8;
				if (a0_n != null)
					goto l00000000000154DC;
				goto l0000000000015CB0;
			}
			sp_n->t0000 = a5_n;
			ui64 s1_n = sp_n[0x05];
			int64 a0_n = fn00000000000164D0(sp_n + 0x001F, 0x04);
			Eq_n a5_n = sp_n->t0000;
			if (a0_n < 0x00)
				goto l0000000000015CB0;
			if (a5_n > 0x0F)
			{
				Eq_n a3_n = 0x01;
				if (a3_n < (s1_n | 0x04))
					goto l0000000000015C7C;
				if ((s1_n | 0x04) != a3_n)
				{
					sp_n[0x001F] = (struct Eq_n) 0xAC;
					sp_n->b00F9 = (byte) (sp_n[0x05] >> 0x04 & 0x0F | 0x0010);
				}
				else
				{
					sp_n[0x001F] = (struct Eq_n) 0xC0;
					sp_n->b00F9 = 0xA8;
				}
			}
			else
			{
l0000000000015C7C:
				sp_n[0x001F] = (struct Eq_n) 0x0A;
			}
			int64 a4_n = (int64) sp_n[0x001F];
			sp_n->t0000.u4 = a5_n;
			sp_n[0x02] = (struct Eq_n) (word32) a4_n;
			char * a0_n = inet_ntop(0x02, sp_n + 0x02, sp_n + 0x0020, 0x0040);
			a5_n = sp_n->qwFFFFFFF8;
			if (a0_n == null)
				goto l0000000000015CB0;
l00000000000154DC:
			struct Eq_n * sp_n = &sp_n->t0000;
			sp_n->qw0008 = a5_n;
			Eq_n a0_n = (uint64) (uint32) __asprintf_chk((char *) &sp_n->t0018 + 0x08, 0x01, "%s/%u", 0x00);
			sp_n = (struct Eq_n *) ((char *) sp_n - 0x08);
			a5_n.u0 = sp_n->dw0000;
			if (a0_n == -0x01)
				goto l0000000000015CB0;
			s1_n = sp_n->t0018;
			if (s1_n == 0x00)
				goto l0000000000015CB0;
l0000000000015510:
			if ((int64) sp_n->t0000 == 0x00)
			{
l0000000000015518:
				sp_n->t0000.u3 = a5_n;
				char * a0_n = strchr(s1_n, 0x003A);
				sp_n = &sp_n->qwFFFFFFF8;
				a5_n = sp_n->t0000;
				if (a0_n == null)
					goto l00000000000155D8;
				sp_n->dw001C = 0x01;
				if (s4_n != 0x00)
					goto l000000000001553C;
				sp_n->t0000.u3 = a5_n;
				a0_n = strchr(s1_n, 0x002F);
				sp_n = &sp_n->qwFFFFFFF8;
				a5_n = sp_n->qwFFFFFFF8;
				if (a0_n == null)
					goto l0000000000015604;
				goto l0000000000015BB8;
			}
l00000000000155D8:
			if (s4_n != 0x00)
			{
				if ((int64) sp_n->dw001C == 0x00)
					goto l00000000000155E4;
l000000000001553C:
				if ((int64) gp->dwFFFFF814 != 0x00)
					goto l00000000000153D8;
				__fprintf_chk(gp->tFFFFF880, 0x01, "ipcalc: unexpected argument: %s\n", 0x00);
				fn0000000000015FCC(gp, 0x01);
				goto l00000000000153DC;
			}
			sp_n->t0000.u3 = a5_n;
			a0_n = strchr(s1_n, 0x002F);
			sp_n = &sp_n->qwFFFFFFF8;
			a5_n = sp_n->t0000;
			if (a0_n != null)
			{
l0000000000015BB8:
				*a0_n = 0x00;
				s4_n = a0_n + 0x01;
				if (s4_n == 0x00)
					goto l00000000000155FC;
l00000000000155E4:
				Eq_n a0_n = fn00000000000166F4(gp, &sp_n->dw001C, s4_n, 0x00);
				a5_n = a0_n;
				if (a0_n >= 0x00)
					goto l00000000000155FC;
				if ((int64) gp->dwFFFFF814 == 0x00)
				{
					a0_n = gp->tFFFFF880;
					(int64) sp_n->dw001C != 0x00;
l0000000000015B8C:
					__fprintf_chk(a0_n, 0x01, "ipcalc: bad %s prefix: %s\n", 0x00);
				}
				goto l00000000000153D8;
			}
l00000000000155FC:
			if ((int64) sp_n->dw001C != 0x00)
			{
l0000000000015604:
				a0_n = fn00000000000175BC(gp, s1_n, a5_n, sp_n + 0x07, s0_n, out a4_n);
			}
			else
				a0_n = fn0000000000016D74(ra, gp, s1_n, a5_n, sp_n + 0x07, s0_n, out a4_n);
			if (a0_n < 0x00)
			{
l00000000000153D8:
				goto l00000000000153DC;
			}
			if ((s0_n & 0xFFFABFFF) == 0x00)
				s0_n |= 0x08;
			struct Eq_n * sp_n = &sp_n->qwFFFFFFF8;
			if ((uint64) (uint32) isatty(0x01) != 0x00)
			{
				a4_n.u0 = 0x01;
				gp->dw0810 = (word32) a4_n;
			}
			if ((s0_n & 0x08) == 0x00)
			{
				if ((s0_n & 0x0080) != 0x00)
				{
					__printf_chk(0x01, "NETMASK=%s\n", 0x00);
					sp_n = (struct Eq_n *) ((char *) sp_n - 0x08);
				}
				if ((s0_n & 0x0200) != 0x00)
				{
					__printf_chk(0x01, "PREFIX=%u\n", 0x00);
					sp_n = (struct Eq_n *) ((char *) sp_n - 0x08);
				}
				if ((s0_n & 0x0040) != 0x00 && (int64) sp_n->dw001C == 0x00)
				{
					__printf_chk(0x01, "BROADCAST=%s\n", 0x00);
					sp_n = (struct Eq_n *) ((char *) sp_n - 0x08);
				}
				if ((s0_n & 0x0100) != 0x00)
				{
					__printf_chk(0x01, "NETWORK=%s\n", 0x00);
					sp_n = (struct Eq_n *) ((char *) sp_n - 0x08);
				}
				if (s0_n << 0x0E < 0x00)
				{
					__printf_chk(0x01, "REVERSEDNS=%s\n", 0x00);
					sp_n = (struct Eq_n *) ((char *) sp_n - 0x08);
				}
				if ((s0_n & 0x0400) != 0x00 && sp_n->t00E0 != 0x00)
				{
					__printf_chk(0x01, "MINADDR=%s\n", 0x00);
					sp_n = (struct Eq_n *) ((char *) sp_n - 0x08);
				}
				if (s0_n << 0x14 < 0x00 && sp_n->t00E8 != 0x00)
				{
					__printf_chk(0x01, "MAXADDR=%s\n", 0x00);
					sp_n = (struct Eq_n *) ((char *) sp_n - 0x08);
				}
				if (s0_n << 0x12 < 0x00)
				{
					Eq_n s2_n = sp_n->t00F0;
					if (s2_n != 0x00)
					{
						ptr64 sp_n = (char *) sp_n - 0x08;
						if (strchr(s2_n, 0x0020) != null)
						{
							__printf_chk(0x01, "ADDRSPACE=\"%s\"\n", 0x00);
							sp_n = sp_n + ~0x07;
						}
						else
						{
							__printf_chk(0x01, "ADDRSPACE=%s\n", 0x00);
							sp_n = sp_n + ~0x07;
						}
					}
				}
				if (s0_n << 0x13 < 0x00)
				{
					ptr64 sp_n = (char *) sp_n - 0x08;
					if (strchr((char *) &sp_n->t0090 + 0x08, 0x0020) != null)
					{
						__printf_chk(0x01, "ADDRESSES=\"%s\"\n", 0x00);
						sp_n = sp_n + ~0x07;
					}
					else
					{
						__printf_chk(0x01, "ADDRESSES=%s\n", 0x00);
						sp_n = sp_n + ~0x07;
					}
				}
				if ((s0_n & 0x01) != 0x00 && sp_n->qw0070 != 0x00)
				{
					__printf_chk(0x01, "HOSTNAME=%s\n", 0x00);
					sp_n = (struct Eq_n *) ((char *) sp_n - 0x08);
				}
				if ((s0_n & 0x02) != 0x00)
				{
					__printf_chk(0x01, "ADDRESS=%s\n", 0x00);
					sp_n = (struct Eq_n *) ((char *) sp_n - 0x08);
				}
				if ((s0_n & 0xC000) == 0xC000)
				{
					if (sp_n->qw0080 != 0x00)
					{
						__printf_chk(0x01, "COUNTRYCODE=%s\n", 0x00);
						sp_n = (struct Eq_n *) ((char *) sp_n - 0x08);
					}
					Eq_n s0_n = sp_n->t0078;
					if (s0_n != 0x00)
					{
						ptr64 sp_n = (char *) sp_n - 0x08;
						if (strchr(s0_n, 0x0020) != null)
						{
							__printf_chk(0x01, "COUNTRY=\"%s\"\n", 0x00);
							sp_n = sp_n + ~0x07;
						}
						else
						{
							__printf_chk(0x01, "COUNTRY=%s\n", 0x00);
							sp_n = sp_n + ~0x07;
						}
					}
					Eq_n s0_n = sp_n->t0088;
					if (s0_n != 0x00)
					{
						ptr64 sp_n = (char *) sp_n - 0x08;
						if (strchr(s0_n, 0x0020) != null)
						{
							__printf_chk(0x01, "CITY=\"%s\"\n", 0x00);
							sp_n = sp_n + ~0x07;
						}
						else
						{
							__printf_chk(0x01, "CITY=%s\n", 0x00);
							sp_n = sp_n + ~0x07;
						}
					}
					if (sp_n->t0090 != 0x00)
						__printf_chk(0x01, "COORDINATES=\"%s\"\n", 0x00);
				}
				goto l00000000000153DC;
			}
			Eq_n a4_n;
			Eq_n s0_n;
			Eq_n a5_n;
			Eq_n a3_n;
			Eq_n a5_n;
			Eq_n s4_n;
			Eq_n a3_n;
			Eq_n s2_n = (int64) sp_n->dw00D8;
			if ((int64) sp_n->dw001C == 0x00)
			{
				a5_n.u0 = 0x0020;
				if (s2_n != a5_n)
					goto l0000000000015660;
				goto l0000000000015914;
			}
			a5_n.u0 = 0x0080;
			if (s2_n == a5_n)
			{
l0000000000015914:
				a3_n = sp_n->t0040;
				if (a3_n != 0x00)
				{
					s4_n.u0 = 0x01;
					goto l0000000000015880;
				}
				word64 a5_n;
				gp = fn000000000001654C(ra, gp, s0_n, 0x00012000, 0x00011B08, 0x00011B10, sp_n->t0038, a4_n, a5_n, a6_n, a7, 0x00012000, a0, out a4_n, out a5_n, out a6_n, out a7);
				goto l00000000000158B8;
			}
l0000000000015660:
			if (s10_n != 0x00)
			{
l0000000000015664:
				goto l0000000000015668;
			}
			s3_n = sp_n->t0038;
			sp_n = (struct Eq_n *) ((char *) sp_n - 0x08);
			if ((uint64) (uint32) strcmp(sp_n->t0058, s3_n) == 0x00)
				goto l0000000000015664;
			a3_n = sp_n->t0038;
			s4_n.u0 = 0x00;
			if (a3_n == 0x00)
			{
				word64 a4_n;
				gp = fn000000000001654C(ra, gp, s0_n, 0x00012000, 0x00011B08, 0x00011B10, s3_n, a4_n, a5_n, a6_n, a7, 0x00012000, s3_n, out a4_n, out a5_n, out a6_n, out a7);
				s2_n = (int64) sp_n->dw00D0;
				goto l0000000000015668;
			}
l0000000000015880:
			Eq_n a4_n;
			Eq_n a5_n;
			word64 a6_n;
			word64 a7_n;
			gp = fn000000000001654C(ra, fn000000000001654C(ra, gp, s0_n, 0x00012000, 0x00011B08, 0x00011AF8, a3_n, a4_n, a5_n, a6_n, a7, 0x00012000, s3_n, out a4_n, out a5_n, out a6_n, out a7_n), s0_n, 0x00012000, 0x00011B08, 0x00011B10, sp_n->t0038, a4_n, a5_n, a6_n, a7_n, 0x00012000, s3_n, out a4_n, out a5_n, out a6_n, out a7);
			if (s4_n != 0x00)
			{
l00000000000158B8:
				a5_n.u0 = 0x00010008;
				s0_n = s0_n & 0x00010008;
				if (s0_n != 0x00010008)
					goto l00000000000158C8;
				a3_n = sp_n->t0050;
				s0_n.u0 = 0x01;
				if (a3_n == 0x00)
					goto l00000000000158C8;
				goto l0000000000015C2C;
			}
			s2_n = (int64) sp_n->dw00D8;
l0000000000015668:
			Eq_n a3_n = sp_n->t0048;
			s3_n.u0 = 0x00012000;
			if (a3_n != 0x00)
			{
				word64 a4_n;
				gp = fn000000000001654C(ra, gp, s0_n, 0x00012000, 0x00011B08, 0x00011B28, a3_n, s2_n, a5_n, a6_n, a7, s2_n, 0x00012000, out a4_n, out a5_n, out a6_n, out a7);
				s2_n = (int64) sp_n->dw00D8;
			}
			Eq_n a5_n;
			word64 a6_n;
			word64 a7_n;
			Eq_n a5_n;
			word64 a4_n;
			gp = fn000000000001654C(ra, fn000000000001654C(ra, gp, s0_n, 0x00012000, 0x00011B08, 0x00011B38, sp_n->t0058, s2_n, a5_n, a6_n, a7, s2_n, 0x00012000, out a4_n, out a5_n, out a6_n, out a7_n), s0_n, 0x00012000, 0x00011B08, 0x00011B58, sp_n->t0068, (int64) sp_n->dw00D8, a5_n, a6_n, a7_n, s2_n, 0x00012000, out a4_n, out a5_n, out a6_n, out a7);
			Eq_n a3_n = sp_n->t0060;
			if (a3_n != 0x00)
			{
				s2_n.u0 = 0x00012000;
				word64 a5_n;
				gp = fn000000000001654C(ra, gp, s0_n, 0x00012000, 0x00011B08, 72552, a3_n, a4_n, a5_n, a6_n, a7, 0x00012000, 0x00012000, out a4_n, out a5_n, out a6_n, out a7);
			}
			a5_n.u0 = 0x00010008;
			s0_n = s0_n & 0x00010008;
			if (s0_n == 0x00010008)
			{
				a3_n = sp_n->t0050;
				if (a3_n == 0x00)
					goto l00000000000156FC;
				s0_n.u0 = 0x00;
l0000000000015C2C:
				s2_n.u0 = 0x00012000;
				gp = fn000000000001654C(ra, gp, s0_n, 0x00012000, 0x00011B08, 0x00011B78, a3_n, a4_n, 0x00010008, a6_n, a7, 0x00012000, s3_n, out a4_n, out a5_n, out a6_n, out a7);
				if (s0_n == 0x00)
					goto l00000000000156FC;
l00000000000158C8:
				s2_n.u0 = 0x00012000;
				Eq_n a3_n = sp_n->t00F0;
				if (a3_n != 0x00)
					gp = fn000000000001654C(ra, gp, s0_n, 0x00012000, 0x00011B98, 0x00011B88, a3_n, a4_n, a5_n, a6_n, a7, 0x00012000, s3_n, out a4_n, out a5_n, out a6_n, out a7);
				Eq_n a3_n = sp_n->t00F8;
				if (a3_n != 0x00)
				{
					word64 a5_n;
					gp = fn000000000001654C(ra, gp, s0_n, 0x00012000, 0x00011B98, 0x00011BA0, a3_n, a4_n, a5_n, a6_n, a7, 0x00012000, s3_n, out a4_n, out a5_n, out a6_n, out a7);
				}
				goto l00000000000157BC;
			}
l00000000000156FC:
			putchar(0x0A);
			sp_n = (struct Eq_n *) ((char *) sp_n - 0x08);
			Eq_n a3_n = sp_n->t00F0;
			if (a3_n != 0x00)
				gp = fn000000000001654C(ra, gp, s0_n, 0x00012000, 0x00011B98, 0x00011B88, a3_n, a4_n, a5_n, a6_n, a7, s2_n, s3_n, out a4_n, out a5_n, out a6_n, out a7);
			Eq_n a3_n = sp_n->t00F8;
			if (a3_n != 0x00)
				gp = fn000000000001654C(ra, gp, s0_n, 0x00012000, 0x00011B98, 0x00011BA0, a3_n, a4_n, a5_n, a6_n, a7, s2_n, s3_n, out a4_n, out a5_n, out a6_n, out a7);
			Eq_n a3_n = sp_n->t00E0;
			if (a3_n != 0x00)
				gp = fn000000000001654C(ra, gp, s0_n, 0x00012000, 0x00011B08, 0x00011BB0, a3_n, a4_n, a5_n, a6_n, a7, s2_n, s3_n, out a4_n, out a5_n, out a6_n, out a7);
			Eq_n a3_n = sp_n->t00E8;
			if (a3_n != 0x00)
			{
				word64 a5_n;
				gp = fn000000000001654C(ra, gp, s0_n, 0x00012000, 0x00011B08, 0x00011BC0, a3_n, a4_n, a5_n, a6_n, a7, s2_n, s3_n, out a4_n, out a5_n, out a6_n, out a7);
			}
			Eq_n a5_n = (int64) sp_n->dw001C;
			if (a5_n != 0x00)
			{
				a5_n = (int64) sp_n->dw00D8;
				a4_n.u0 = 111;
				if (a4_n < a5_n)
					goto l00000000000157A0;
				word64 a5_n;
				gp = fn000000000001654C(ra, gp, s0_n, 0x00012000, 0x00011B08, 72672, (int64) (word32) (0x0080 - a5_n), (char *) &sp_n->t0090 + 0x08, a5_n, a6_n, a7, s2_n, s3_n, out a4_n, out a5_n, out a6_n, out a7);
			}
			else
			{
l00000000000157A0:
				word64 a5_n;
				gp = fn000000000001654C(ra, gp, s0_n, 0x00012000, 0x00011B08, 72672, (char *) &sp_n->t0090 + 0x08, a4_n, a5_n, a6_n, a7, s2_n, s3_n, out a4_n, out a5_n, out a6_n, out a7);
			}
l00000000000157BC:
			Eq_n a5_n = sp_n->t0078;
			if (a5_n == 0x00)
			{
				a5_n = sp_n->t0088;
				if (a5_n == 0x00)
				{
					a5_n = sp_n->t0090;
					if (a5_n == 0x00)
					{
l00000000000153DC:
						if (a5_n != gp->tFFFFF870)
							__stack_chk_fail();
						else
							return;
					}
				}
			}
			putchar(0x0A);
			struct Eq_n * sp_n = (char *) sp_n - 0x08;
			Eq_n a3_n = sp_n->t0080;
			if (a3_n != 0x00)
				gp = fn000000000001654C(ra, gp, s0_n, 0x00012000, 0x00011B98, 0x00011BF0, a3_n, a4_n, a5_n, a6_n, a7, s2_n, s3_n, out a4_n, out a5_n, out a6_n, out a7);
			Eq_n a3_n = sp_n->t0078;
			if (a3_n != 0x00)
				gp = fn000000000001654C(ra, gp, s0_n, 0x00012000, 0x00011B98, 0x00011C00, a3_n, a4_n, a5_n, a6_n, a7, s2_n, s3_n, out a4_n, out a5_n, out a6_n, out a7);
			Eq_n a3_n = sp_n->t0088;
			if (a3_n != 0x00)
				gp = fn000000000001654C(ra, gp, s0_n, 0x00012000, 0x00011B98, 0x00011C10, a3_n, a4_n, a5_n, a6_n, a7, s2_n, s3_n, out a4_n, out a5_n, out a6_n, out a7);
			Eq_n a3_n = sp_n->t0090;
			if (a3_n != 0x00)
			{
				word64 a6_n;
				word64 a5_n;
				word64 a4_n;
				word64 a7_n;
				gp = fn000000000001654C(ra, gp, s0_n, 0x00012000, 0x00011B98, 0x00011C18, a3_n, a4_n, a5_n, a6_n, a7, s2_n, s3_n, out a4_n, out a5_n, out a6_n, out a7_n);
			}
			goto l00000000000153DC;
		}
	} while (a0_n > 118);
	<anonymous> * a5_n = (int64) (a0_n << 0x00 >> 0x1E)->dw102A0;
	word64 a6_n;
	word64 a7_n;
	word64 t1_n;
	word64 t3_n;
	a5_n();
}

// 0000000000015EB8: void fn0000000000015EB8(Register (ptr64 Eq_n) a0, Stack word32 dwArg00)
void fn0000000000015EB8(void (* a0)(), word32 dwArg00)
{
	__libc_start_main(&globals->t15180, qwArg00, (word64) fp + 0x08, &globals->t182E8, &globals->t18378, a0, fp & -0x0010);
}

// 0000000000015EF0: void fn0000000000015EF0()
void fn0000000000015EF0()
{
	if (true || 0x00 == 0x00)
		return;
	word64 t1_n;
	word64 ra_n;
	null();
}

// 0000000000015F24: void fn0000000000015F24()
void fn0000000000015F24()
{
	if (0x00 == 0x00 || 0x00 == 0x00)
		return;
	word64 t1_n;
	null();
}

// 0000000000015F64: void fn0000000000015F64(Register (ptr64 Eq_n) gp)
void fn0000000000015F64(struct Eq_n * gp)
{
	if ((int64) gp->bFFFFF894 == 0x00)
	{
		fn0000000000015EF0();
		gp->b0894 = 0x01;
	}
}

// 0000000000015F94: void fn0000000000015F94(Register word64 ra)
void fn0000000000015F94(word64 ra)
{
	if (globals->qw19E28 != 0x00 && 0x00 != 0x00)
	{
		null();
		fn0000000000015F24();
	}
	else
		fn0000000000015F24();
}

// 0000000000015FCC: void fn0000000000015FCC(Register (ptr64 Eq_n) gp, Register Eq_n a0)
void fn0000000000015FCC(struct Eq_n * gp, Eq_n a0)
{
	Eq_n a3_n = gp->tFFFFF880;
	if (a0 != 0x00)
	{
		fwrite(&globals->v10BE0, 0x01, 0x001A, a3_n);
		fwrite(&globals->v10C00, 0x01, 0x0036, gp->tFFFFF880);
		fwrite(&globals->v10C38, 0x01, 77, gp->tFFFFF880);
		fwrite(&globals->v10C88, 0x01, 0x003E, gp->tFFFFF880);
		fwrite(&globals->v10CC8, 0x01, 0x004F, gp->tFFFFF880);
		fwrite(&globals->v10D18, 0x01, 0x004F, gp->tFFFFF880);
		fwrite(&globals->v10D68, 0x01, 0x002A, gp->tFFFFF880);
		fwrite(&globals->v10D98, 0x01, 0x004C, gp->tFFFFF880);
		fwrite(&globals->v10DE8, 0x01, 77, gp->tFFFFF880);
		fwrite(&globals->v10E38, 0x01, 77, gp->tFFFFF880);
		fputc(0x0A, gp->tFFFFF880);
		fwrite(&globals->v10E88, 0x01, 0x0017, gp->tFFFFF880);
		fwrite(&globals->v10EA0, 0x01, 0x0047, gp->tFFFFF880);
		fwrite(&globals->v10EE8, 0x01, 0x0039, gp->tFFFFF880);
		fwrite(&globals->v10F28, 0x01, 0x003A, gp->tFFFFF880);
		fwrite(&globals->v10F68, 0x01, 0x0039, gp->tFFFFF880);
		fwrite(&globals->v10FA8, 0x01, 77, gp->tFFFFF880);
		fwrite(&globals->v10FF8, 0x01, 77, gp->tFFFFF880);
		fwrite(&globals->v11048, 0x01, 77, gp->tFFFFF880);
		fwrite(&globals->v11098, 0x01, 0x002E, gp->tFFFFF880);
		fwrite(&globals->v110C8, 0x01, 0x0048, gp->tFFFFF880);
		fwrite(&globals->v11118, 0x01, 0x002D, gp->tFFFFF880);
		fwrite(&globals->v11148, 0x01, 0x0043, gp->tFFFFF880);
		fwrite(&globals->v11190, 0x01, 0x0040, gp->tFFFFF880);
		fwrite(&globals->v111D8, 0x01, 0x0048, gp->tFFFFF880);
		fwrite(&globals->v11228, 0x01, 0x002E, gp->tFFFFF880);
		fputc(0x0A, gp->tFFFFF880);
		fwrite(&globals->v11258, 0x01, 0x0F, gp->tFFFFF880);
		fwrite(&globals->v11268, 0x01, 0x0057, gp->tFFFFF880);
		fwrite(&globals->v112C0, 0x01, 0x003C, gp->tFFFFF880);
		fwrite(&globals->v11300, 0x01, 0x0044, gp->tFFFFF880);
		fwrite(&globals->v11348, 0x01, 0x003A, gp->tFFFFF880);
		fwrite(&globals->v11388, 0x01, 0x0039, gp->tFFFFF880);
		fwrite(&globals->v113C8, 0x01, 0x003E, gp->tFFFFF880);
	}
	else
	{
		fwrite(&globals->v11408, 0x01, 77, a3_n);
		fwrite(&globals->v11458, 0x01, 0x003E, gp->tFFFFF880);
		fwrite(&globals->v11498, 0x01, 0x0041, gp->tFFFFF880);
		fwrite(&globals->v114E0, 0x01, 0x004C, gp->tFFFFF880);
		fwrite(&globals->v11530, 0x01, 0x0041, gp->tFFFFF880);
		fwrite(&globals->v11578, 0x01, 0x0029, gp->tFFFFF880);
		fwrite(&globals->v115A8, 0x01, 0x001E, gp->tFFFFF880);
	}
}

// 00000000000163B0: Register Eq_n fn00000000000163B0(Register (ptr64 Eq_n) gp)
Eq_n fn00000000000163B0(struct Eq_n * gp)
{
	Eq_n a5_n = gp->tFFFFF870;
	__sprintf_chk(fp + -232, 0x01, 0x0080, "%.2x", 0x00);
	Eq_n s3_n = 0x0010;
	Eq_n s0_n = 0x01;
	union Eq_n * s1_n = fp + ~0xED;
	Eq_n s6_n = 0x0080;
	Eq_n s5_n = 0x01;
	Eq_n s9_n = 0x0F;
	Eq_n s7_n = 0x003A;
	if (s3_n != 0x01)
	{
		do
		{
			__sprintf_chk(s1_n, s5_n, s6_n, "%.2x", 0x00);
			union Eq_n * a4_n = (char *) s1_n + 0x02;
			if ((s0_n & 0x01) != 0x00)
			{
				if (s0_n == s9_n)
				{
					s1_n = a4_n;
					break;
				}
				*((char *) s1_n + 0x02) = (union Eq_n *) (byte) s7_n;
				s1_n = (union Eq_n *) ((char *) s1_n + 0x03);
			}
			else
				s1_n = a4_n;
			s0_n.u1 = (int64) ((word32) s0_n + 0x01);
		} while (s0_n != s3_n);
	}
	*s1_n = (union Eq_n *) 0x00;
	Eq_n a0_n = __strdup(fp - 224);
	if (a5_n == gp->tFFFFF870)
		return a0_n;
	__stack_chk_fail();
}

// 00000000000164D0: Register Eq_n fn00000000000164D0(Register Eq_n a0, Register Eq_n a1)
Eq_n fn00000000000164D0(Eq_n a0, Eq_n a1)
{
	Eq_n a0_n;
	Eq_n a0_n = (uint64) (uint32) open("/dev/urandom", 0x00);
	if (a0_n >= 0x00)
	{
		uint64 a0_n = (uint64) (uint32) read(a0_n, a0, a1 << 0x00 >> 0x00);
		close(a0_n);
		a0_n = (int64) (word32) (0x00 - (word64) ((int64) ((word32) (a0_n - a1)) != 0x00));
	}
	else
		a0_n.u0 = -0x01;
	return a0_n;
}

// 000000000001654C: Register (ptr64 Eq_n) fn000000000001654C(Register word64 ra, Register (ptr64 Eq_n) gp, Register Eq_n s0, Register word64 s1, Register word64 a0, Register word64 a1, Register Eq_n a3, Register Eq_n a4, Register Eq_n a5, Register word64 a6, Register word64 a7, Register Eq_n s2, Register Eq_n s3, Register out Eq_n a4Out, Register out Eq_n a5Out, Register out ptr64 a6Out, Register out ptr64 a7Out)
struct Eq_n * fn000000000001654C(word64 ra, struct Eq_n * gp, Eq_n s0, word64 s1, word64 a0, word64 a1, Eq_n a3, Eq_n a4, Eq_n a5, word64 a6, word64 a7, Eq_n s2, Eq_n s3, union Eq_n & a4Out, union Eq_n & a5Out, ptr64 & a6Out, ptr64 & a7Out)
{
	Eq_n t3_n = gp->tFFFFF870;
	word64 sp_n;
	struct Eq_n * gp_n;
	char * s2_n;
	char * s3_n;
	int64 a0_n;
	ptr64 a6_n;
	ptr64 a7_n;
	__vasprintf_chk();
	if (a0_n >= 0x00)
	{
		fputs(s2_n, gp_n->tFFFFF888);
		struct Eq_n * sp_n = sp_n + ~0x07;
		if ((int64) gp_n->dwFFFFF810 != 0x00)
		{
			fputs(s3_n, gp_n->tFFFFF888);
			sp_n = sp_n + ~0x0F;
		}
		fputs(sp_n->ptr0010, gp_n->tFFFFF888);
		struct Eq_n * sp_n = (char *) sp_n - 0x08;
		if ((int64) gp_n->dwFFFFF810 != 0x00)
		{
			fwrite(&globals->v115E0, 0x01, 0x04, gp_n->tFFFFF888);
			sp_n = (struct Eq_n *) ((char *) sp_n - 0x08);
		}
		free(sp_n->ptr0010);
	}
	Eq_n a5_n = gp_n->tFFFFF870;
	if (t3_n != a5_n)
		__stack_chk_fail();
	else
	{
		a4Out = t3_n;
		a5Out = a5_n;
		a6Out = a6_n;
		a7Out = a7_n;
		return gp_n;
	}
}

// 0000000000016630: Register ptr64 fn0000000000016630(Register (ptr64 Eq_n) gp, Register Eq_n a0, Register (ptr64 word32) a1, Register out ptr64 s1Out, Register out Eq_n a0Out)
ptr64 fn0000000000016630(struct Eq_n * gp, Eq_n a0, word32 * a1, ptr64 & s1Out, union Eq_n & a0Out)
{
	Eq_n a5_n;
	int32 * a0_n = __errno_location();
	*a0_n = 0x00;
	Eq_n a0_n = (uint64) (uint32) strtol(a0);
	if (qwLoc50 != 0x00 && (a0 != qwLoc50 && (int64) (*qwLoc50) == 0x00))
	{
		a5_n.u1 = (int64) *a0_n;
		if (a5_n == 0x00)
		{
			Eq_n a4_n = (int64) (word32) a0_n;
			if (a0_n == a4_n)
				*a1 = (word32) a4_n;
			else
				a5_n.u0 = -0x0022;
			goto l0000000000016698;
		}
	}
	else
		a5_n.u1 = (int64) *a0_n;
	if (a5_n > 0x00)
		a5_n.u1 = (int64) (word32) (0x00 - a5_n);
	else
		a5_n.u0 = -22;
l0000000000016698:
	if (qwLoc48 != gp->tFFFFF870)
		__stack_chk_fail();
	else
	{
		s1Out = s3;
		a0Out = a5_n;
		return fp + ~0x0F;
	}
}

// 00000000000166F4: Register Eq_n fn00000000000166F4(Register (ptr64 Eq_n) gp, Register Eq_n a0, Register Eq_n a1, Register Eq_n a2)
Eq_n fn00000000000166F4(struct Eq_n * gp, Eq_n a0, Eq_n a1, Eq_n a2)
{
	Eq_n a0_n;
	int32 * sp_n;
	word32 * sp_n = fp + -0x0040;
	Eq_n a5_n = gp->tFFFFF870;
	Eq_n s1_n = a0;
	if ((int64) *a0 == 0x00)
	{
		sp_n = fp + ~0x47;
		if (strchr(a1, 0x002E) != null)
		{
			sp_n = fp + ~0x4F;
			if ((uint64) (uint32) inet_pton(0x02, a1, fp + ~0x47) != 0x00)
			{
				word64 a3_n;
				word64 a4_n;
				Eq_n a0_n = fn00000000000182B4((int64) dwLoc50, out a3_n, out a4_n);
				while (a0_n != 0x00)
				{
					if ((a0_n & 0x01) != 0x00)
					{
l0000000000016778:
						do
						{
							a0_n.u0 = (int64) (word32) (a0_n >> 0x01);
							if (a0_n == 0x00)
								goto l0000000000016790;
						} while ((a0_n & 0x01) != 0x00);
						goto l000000000001678C;
					}
					Eq_n a5_n = (int64) (word32) (a0_n >> 0x01);
					if (a5_n == 0x00)
						break;
					if ((a5_n & 0x01) != 0x00)
					{
						a0_n = a5_n;
						goto l0000000000016778;
					}
					a0_n.u0 = (int64) (word32) (a0_n >> 0x02);
				}
			}
			else
			{
l000000000001678C:
			}
l0000000000016790:
l0000000000016794:
			Eq_n a5_n = (int64) *sp_n;
			if (a2 != 0x00 && a5_n > 0x0020)
			{
				if ((int64) *s1_n == 0x00)
					s1_n->u0 = 0x01;
			}
			else
			{
				a0_n = a5_n;
				if (a5_n < 0x00)
					goto l00000000000167C0;
				if ((int64) *s1_n == 0x00)
				{
					if (a5_n > 0x0020)
					{
l00000000000167C0:
						a0_n.u0 = -0x01;
						goto l00000000000167F4;
					}
l00000000000167F4:
					if (a5_n == gp->tFFFFF870)
						return a0_n;
					__stack_chk_fail();
				}
			}
			a0_n = a5_n;
			if (a5_n > 0x0080)
				goto l00000000000167C0;
			goto l00000000000167F4;
		}
	}
	word64 a0_n;
	sp_n = fn0000000000016630(gp, a1, sp_n, out s1_n, out a0_n);
	if (a0_n != 0x00)
		goto l00000000000167C0;
	goto l0000000000016794;
}

// 0000000000016830: Register Eq_n fn0000000000016830(Register (ptr64 Eq_n) gp, Register Eq_n a0)
Eq_n fn0000000000016830(struct Eq_n * gp, Eq_n a0)
{
	Eq_n a5_n = gp->tFFFFF870;
	if (a0 == 0x00)
	{
		if (a5_n == gp->tFFFFF870)
			return 0x00;
		__stack_chk_fail();
	}
}

// 00000000000168B8: void fn00000000000168B8(Register (ptr64 Eq_n) gp, Register Eq_n a1)
void fn00000000000168B8(struct Eq_n * gp, Eq_n a1)
{
	fn0000000000016830(gp, a1);
}

// 00000000000168E4: Register Eq_n fn00000000000168E4(Register (ptr64 Eq_n) gp, Register Eq_n a0, Register (ptr64 int32) a1)
Eq_n fn00000000000168E4(struct Eq_n * gp, Eq_n a0, int32 * a1)
{
	Eq_n a0_n;
	uint64 a0_n;
	Eq_n a4_n = gp->tFFFFF870;
	if (a0 != 0x02)
	{
		if (a0 != 0x0A)
			goto l0000000000016910;
		memcpy(fp + -0x0040, a1, 0x0010);
		a0_n = (uint64) (uint32) getnameinfo(fp + ~0x4F, 0x001C, &gp->dwFFFFF890 + 0x02, 0x0401, 0x00, 0x00, 0x00);
	}
	else
		a0_n = (uint64) (uint32) getnameinfo(fp + -88, 0x0010, &gp->dwFFFFF890 + 0x02, 0x0401, 0x00, 0x00, 0x00);
	if (a0_n == 0x00)
	{
		a0_n = __strdup(&gp->dwFFFFF890 + 0x02);
l0000000000016914:
		if (a4_n == gp->tFFFFF870)
			return a0_n;
		__stack_chk_fail();
	}
l0000000000016910:
	a0_n.u0 = 0x00;
	goto l0000000000016914;
}

// 00000000000169D8: Register Eq_n fn00000000000169D8(Register (ptr64 Eq_n) gp, Register Eq_n a1)
Eq_n fn00000000000169D8(struct Eq_n * gp, Eq_n a1)
{
	Eq_n a0_n;
	Eq_n a5_n = gp->tFFFFF870;
	word64 * sp_n = fp + ~0x77;
	if ((uint64) (uint32) getaddrinfo(a1, 0x00, fp + -0x0068, fp + -112) == 0x00)
	{
		struct addrinfo * s0_n = qwLoc78;
		if (qwLoc78 != null)
		{
			Eq_n s3_n = 0x02;
			Eq_n s2_n = 0x0040;
			do
			{
				Eq_n a0_n = (int64) s0_n->ai_family;
				char * a1_n = s0_n->ai_canonname;
				if (a0_n == s3_n)
				{
					sp_n += -0x01;
					if (inet_ntop(a0_n, a1_n + 0x04, &gp->dwFFFFF890 + 0x0104, s2_n) != null)
						goto l0000000000016A88;
				}
				else
				{
					sp_n += -0x01;
					if (inet_ntop(a0_n, a1_n + 0x08, &gp->dwFFFFF890 + 0x0104, s2_n) != null)
					{
l0000000000016A88:
						freeaddrinfo(*sp_n);
						a0_n = __strdup(&gp->dwFFFFF890 + 0x0104);
						goto l0000000000016AAC;
					}
				}
				s0_n = s0_n->ptr0028;
			} while (s0_n != null);
			s0_n = *sp_n;
		}
		freeaddrinfo(s0_n);
		a0_n.u0 = 0x00;
	}
	else
		a0_n.u0 = 0x00;
l0000000000016AAC:
	if (a5_n == gp->tFFFFF870)
		return a0_n;
	__stack_chk_fail();
}

// 0000000000016B38: void fn0000000000016B38(Register Eq_n a0)
void fn0000000000016B38(Eq_n a0)
{
	if (a0 > 0x007F)
		;
}

// 0000000000016B68: Register Eq_n fn0000000000016B68(Register Eq_n a0)
Eq_n fn0000000000016B68(Eq_n a0)
{
	Eq_n a4_n;
	word64 a3_n;
	word64 a4_n;
	Eq_n a0_n = fn00000000000182B4(a0, out a3_n, out a4_n);
	Eq_n a5_n = (int64) (word32) (a0_n >> 0x0018);
	if (a5_n == 0x00)
	{
		a4_n.u0 = 71144;
		return a4_n;
	}
	if (a5_n == 0x0A)
		return 71176;
	int64 a4_n = (int64) (word32) (a0_n >> 0x0010);
	if (a5_n != 100)
	{
		if (a5_n == 0x007F)
		{
			a4_n.u0 = 0x00011630;
			return a4_n;
		}
		int64 a2_n = (int64) (word32) (a0_n >> 0x08);
		if (a5_n != 0x00A9)
		{
			if (a5_n == 0x00AC)
			{
				if ((a4_n & 0x00F0) == 0x0010)
					return 71176;
			}
			else if (a5_n == 0x00C0)
			{
				if (((a4_n | a2_n) & 0x00FF) == 0x00)
				{
					a4_n.u0 = 0x00011660;
					return a4_n;
				}
				if ((a4_n & 0x00FF) != 0x02)
				{
					if ((a4_n & 0x00FF) != 0x0033)
					{
						if ((a4_n & 0x00FF) == 88)
						{
							if ((a2_n & 0x00FF) == 99)
							{
								a4_n.u0 = 0x000116E0;
								return a4_n;
							}
l0000000000016CB8:
							if ((a5_n & 0x00F0) != 0x00F0)
								a4_n.u0 = 0x00011650;
							else
								a4_n.u0 = 0x00011710;
							return a4_n;
						}
						if ((a4_n & 0x00FF) != 0x0034)
						{
							if ((a4_n & 0x00FF) == 0x00A8)
								return 71176;
						}
						else if ((a2_n & 0x00FF) == 0x00C1)
						{
							a4_n.u0 = 0x00011708;
							return a4_n;
						}
					}
					else if ((a2_n & 0x00FF) == 100)
					{
						a4_n.u0 = 0x000116A0;
						return a4_n;
					}
				}
				else if ((a2_n & 0x00FF) == 0x00)
				{
					a4_n.u0 = 0x00011680;
					return a4_n;
				}
			}
			else if (a5_n == 0x00CB)
			{
				if ((a4_n & 0x00FF) == 0x00 && (a2_n & 0x00FF) == 113)
				{
					a4_n.u0 = 0x000116C0;
					return a4_n;
				}
			}
			else
			{
				Eq_n a2_n = 0x00FF;
				if (a5_n == a2_n)
				{
					a4_n.u0 = 0x00011710;
					if ((a4_n & 0x00FF) == a5_n)
					{
						a4_n.u0 = 0x00011710;
						if ((a2_n & 0x00FF) == a2_n && (a0_n & a2_n) == (a2_n & 0x00FF))
							a4_n.u0 = 0x00011720;
					}
					return a4_n;
				}
				if (a5_n == 0x00C6)
				{
					a4_n.u0 = 0x00011650;
					if ((a4_n & 0x00FE) == 0x0012)
						a4_n.u0 = 0x00011738;
					return a4_n;
				}
			}
		}
		else if ((a4_n & 0x00FF) == 0x00FE)
		{
			a4_n.u0 = 0x00011640;
			return a4_n;
		}
	}
	else if ((a4_n & 0x00C0) == 0x0040)
	{
		a4_n.u0 = 0x00011618;
		return a4_n;
	}
	if ((int64) ((word32) a5_n + -224) <= 0x0F)
	{
		a4_n.u0 = 0x00011748;
		return a4_n;
	}
	goto l0000000000016CB8;
}

// 0000000000016D74: Register Eq_n fn0000000000016D74(Register word64 ra, Register (ptr64 Eq_n) gp, Register Eq_n a0, Register Eq_n a1, Register (ptr64 Eq_n) a2, Register Eq_n a3, Register out Eq_n a4Out)
Eq_n fn0000000000016D74(word64 ra, struct Eq_n * gp, Eq_n a0, Eq_n a1, struct Eq_n * a2, Eq_n a3, union Eq_n & a4Out)
{
	Eq_n a0_n;
	Eq_n a5_n = gp->tFFFFF870;
	memset(a2, 0x00, 200);
	struct Eq_n * s6_n = a2;
	Eq_n s5_n = a1;
	struct Eq_n * sp_n = fp + ~0x01CF;
	if ((uint64) (uint32) inet_pton(0x02, a0, fp + ~0x01BF) <= 0x00)
	{
		if ((int64) gp->dwFFFFF814 != 0x00)
			goto l0000000000016E20;
		__fprintf_chk(gp->tFFFFF880, 0x01, "ipcalc: bad IPv4 address: %s\n", 0x00);
		a0_n.u0 = -0x01;
		goto l0000000000016E24;
	}
	Eq_n a0_n;
	if (a1 >= 0x00)
	{
		Eq_n a0_n = a0;
		Eq_n s0_n = 0x03;
		Eq_n s2_n = 0x002E;
		do
		{
			char * a0_n = strchr(a0_n, s2_n);
			sp_n = (struct Eq_n *) ((char *) sp_n - 0x08 + 0x0030);
			sp_n[0x06] = (struct Eq_n) a0_n;
			if (a0_n == null)
			{
				Eq_n s3_n = 0x01;
				Eq_n s2_n = -0x01;
				do
				{
					sp_n = (struct Eq_n *) ((char *) sp_n - 0x08);
					if ((uint64) (uint32) __asprintf_chk(sp_n, s3_n, "%s.0", 0x00) == s2_n)
					{
						a0_n = gp->tFFFFF880;
						goto l00000000000172C4;
					}
					s0_n.u1 = (int64) ((word32) s0_n + -0x01);
				} while (s0_n != 0x00);
				break;
			}
			sp_n[0x06] = (struct Eq_n) (a0_n + 0x01);
			a0_n = a0_n + 0x01;
			s0_n.u1 = (int64) ((word32) s0_n + -0x01);
		} while (s0_n != 0x00);
		if (a1 > 0x0020)
		{
			if ((int64) gp->dwFFFFF814 == 0x00)
			{
				__fprintf_chk(gp->tFFFFF880, 0x01, "ipcalc: bad IPv4 prefix %d\n", 0x00);
				a0_n.u0 = -0x01;
				goto l0000000000016E24;
			}
			goto l0000000000016E20;
		}
	}
	else
	{
		s5_n.u0 = 0x0020;
		if (a3 << 0x0D < 0x00)
		{
			word64 a4_n;
			word64 a3_n;
			Eq_n a0_n = fn00000000000182B4((int64) dwLoc01C8, out a3_n, out a4_n);
			s5_n.u0 = 0x08;
			int64 a5_n = (int64) (word32) (a0_n >> 0x0018);
			if (a0_n < 0x00)
			{
				s5_n.u0 = 0x0018;
				if ((int64) ((word32) a5_n + -0x0080) <= 0x003F)
					s5_n.u0 = 0x0010;
			}
		}
	}
	union Eq_n * sp_n = (char *) sp_n - 0x08;
	if (inet_ntop(0x02, sp_n + 0x01, sp_n + 0x07, 0x002F) != null)
	{
		a2->t0000 = __strdup((char *) sp_n + 0x0038);
		*((char *) sp_n + 0x08) = (union Eq_n *) (word32) fn0000000000016830(gp, s5_n);
		*((char *) sp_n + 0x0030) = 0x00;
		*((char *) sp_n + 0x0038) = 0x00;
		*((char *) sp_n + 0x0040) = 0x00;
		*((char *) sp_n + 0x0048) = 0x00;
		*((char *) sp_n + 0x0050) = 0x00;
		*((char *) sp_n + 88) = (union Eq_n *) 0x00;
		*((char *) sp_n + 0x005C) = (union Eq_n *) 0x00;
		*((char *) sp_n + 0x005E) = (union Eq_n *) 0x00;
		if (inet_ntop(0x02, (char *) sp_n + 0x08, (char *) sp_n + 0x0030, 0x0010) == null)
		{
			a0_n = gp->tFFFFF880;
			goto l00000000000172C4;
		}
		a2->t0030 = __strdup((char *) sp_n + 0x0028);
		int64 s0_n = (int64) *((char *) sp_n - 0x0010);
		a2->dw00A0 = (word32) s5_n;
		*((char *) sp_n + 0x08) = (union Eq_n *) (word32) (fn0000000000016830(gp, s5_n) ^ -0x01 | s0_n);
		*((char *) sp_n + 0x0020) = 0x00;
		*((char *) sp_n + 0x0028) = 0x00;
		*((char *) sp_n + 0x0030) = 0x00;
		*((char *) sp_n + 0x0038) = 0x00;
		*((char *) sp_n + 0x0040) = 0x00;
		*((char *) sp_n + 0x0048) = (union Eq_n *) 0x00;
		*((char *) sp_n + 0x004C) = (union Eq_n *) 0x00;
		*((char *) sp_n + 0x004E) = (union Eq_n *) 0x00;
		if (inet_ntop(0x02, (char *) sp_n + 0x08, (char *) sp_n + 0x0020, 0x0010) == null)
		{
			a0_n = gp->tFFFFF880;
			goto l00000000000172C4;
		}
		a2->t0028 = __strdup((char *) sp_n + 0x0018);
		int64 s0_n = (int64) *((char *) sp_n - 0x0020);
		ui64 a0_n = fn0000000000016830(gp, s5_n);
		Eq_n a3_n = (int64) *((char *) sp_n - 0x08);
		Eq_n s0_n = a0_n & s0_n;
		*((char *) sp_n - 0x0010) = (union Eq_n *) (word32) s0_n;
		a2->qw0018 = fn0000000000017F04(gp, s0_n, s5_n, s0_n, a3_n);
		*((char *) sp_n + 0x0010) = 0x00;
		*((char *) sp_n + 0x0018) = 0x00;
		*((char *) sp_n + 0x0020) = 0x00;
		*((char *) sp_n + 0x0028) = 0x00;
		*((char *) sp_n + 0x0030) = 0x00;
		*((char *) sp_n + 0x0038) = (union Eq_n *) 0x00;
		*((char *) sp_n + 0x003C) = (union Eq_n *) 0x00;
		*((char *) sp_n + 0x003E) = (union Eq_n *) 0x00;
		if (inet_ntop(0x02, (char *) sp_n - 0x0010, (char *) sp_n + 0x0010, 0x0010) == null)
		{
			a0_n = gp->tFFFFF880;
			goto l00000000000172C4;
		}
		word64 a5_n;
		Eq_n a0_n = __strdup((char *) sp_n + 0x08);
		Eq_n s0_n = (int64) *((char *) sp_n - 0x0020);
		a2->t0020 = a0_n;
		a2->qw00B8 = fn0000000000016B68(s0_n);
		word64 a4_n;
		word64 a3_n;
		Eq_n a0_n = fn00000000000182B4(s0_n, out a3_n, out a4_n);
		struct Eq_n * sp_n = (char *) sp_n - 0x0038;
		int64 a5_n = (int64) (word32) (a0_n >> 0x0018);
		if (a0_n < 0x00)
		{
			if ((int64) ((word32) a5_n + -0x0080) > 0x003F)
			{
				if ((int64) ((word32) a5_n + -0x00C0) > 0x001F)
				{
					if ((int64) ((word32) a5_n + -224) <= 0x0E)
						a5_n = 0x00011770;
					else
						a5_n = 0x00011778;
				}
				else
					a5_n = 0x00011768;
			}
			else
				a5_n = 0x00011760;
		}
		else
			a5_n = 0x00011758;
		struct Eq_n * a5_n;
		a2->qw00C0 = a5_n;
		if (s5_n == 0x0020)
		{
			a2->t00A8 = a0_n;
			a2->t00B0 = a0_n;
			a5_n = &globals->t11780;
			goto l000000000001716C;
		}
		*((char *) sp_n - 0x0010) = (union Eq_n *) (word32) s0_n;
		if (s5_n != 0x001F)
		{
			*((char *) sp_n - 0x0010) = (union Eq_n *) (word32) (s0_n | 0x01000000);
			if (inet_ntop(0x02, (char *) sp_n - 0x0010, sp_n, 0x0010) != null)
			{
				Eq_n a0_n = __strdup((char *) sp_n - 0x08);
				int64 a5_n = (int64) *((char *) sp_n - 0x0038);
				a2->t00A8 = a0_n;
				word64 a4_n;
				word64 a3_n;
				word64 a4_n;
				word64 a3_n;
				*((char *) sp_n - 0x0018) = (union Eq_n *) (word32) fn00000000000182B4((int64) ((word32) fn00000000000182B4(a5_n ^ -0x01 | (int64) (*((char *) sp_n - 0x0030)), out a3_n, out a4_n) + -0x01), out a3_n, out a4_n);
				if (inet_ntop(0x02, (char *) sp_n - 0x0018, (char *) sp_n - 0x0010, 0x002F) != null)
					__strdup((char *) sp_n - 0x0018);
				goto l0000000000017074;
			}
l00000000000172E8:
			a0_n = gp->tFFFFF880;
l00000000000172C4:
			__fprintf_chk(a0_n, 0x01, "Memory allocation failure line %d\n", 0x00);
			abort();
		}
		if (inet_ntop(0x02, (char *) sp_n - 0x0010, sp_n, 0x0010) == null)
			goto l00000000000172E8;
		Eq_n a0_n = __strdup((char *) sp_n - 0x08);
		int64 a5_n = (int64) *((char *) sp_n - 0x0038);
		int64 a4_n = (int64) *((char *) sp_n - 0x0030);
		a2->t00A8 = a0_n;
		*((char *) sp_n - 0x0018) = (union Eq_n *) (word32) (a5_n ^ -0x01 | a4_n);
		if (inet_ntop(0x02, (char *) sp_n - 0x0018, (char *) sp_n - 0x0010, 0x002F) != null)
		{
			a2->t00B0 = __strdup((char *) sp_n - 0x0018);
			sp_n = (struct Eq_n *) ((char *) sp_n - 88);
			a5_n = &globals->t12660;
l000000000001716C:
			a2->b0060 = (byte) (int64) a5_n->b0000;
			a2->b0061 = (byte) (int64) a5_n->b0001;
			if (a3 << 0x11 < 0x00)
				gp = fn0000000000017B40(ra, gp, (int64) sp_n->dw0008, &a2->qw0038 + 0x01, &a2->qw0038 + 0x02, &a2->qw0038 + 0x03, &a2->qw0038 + 0x04, s5_n, a2, out s6_n);
			if ((a3 & 0x01) == 0x00)
			{
l000000000001718C:
				a0_n.u0 = 0x00;
				goto l0000000000016E24;
			}
			word64 a0_n = fn00000000000168E4(gp, 0x02, &sp_n->dw0008);
			s6_n->qw0038 = a0_n;
			if (a0_n != 0x00)
				goto l000000000001718C;
			if ((int64) gp->dwFFFFF814 != 0x00)
			{
l0000000000016E20:
				a0_n.u0 = -0x01;
				goto l0000000000016E24;
			}
			__sprintf_chk(&sp_n->dw0008 + 0x0018, 0x01, 0x00FA, "ipcalc: cannot find hostname for %s", 0x00);
			herror(&sp_n->dw0008 + 22);
			a0_n.u0 = -0x01;
l0000000000016E24:
			if (a5_n != gp->tFFFFF870)
				__stack_chk_fail();
			else
			{
				a4Out = a5_n;
				return a0_n;
			}
		}
	}
l0000000000017074:
	if ((int64) gp->dwFFFFF814 == 0x00)
		fwrite(&globals->v117F8, 0x01, 0x002B, gp->tFFFFF880);
	goto l0000000000016E20;
}

// 000000000001730C: Register Eq_n fn000000000001730C(Register (ptr64 Eq_n) gp, Register Eq_n a0, Register (ptr64 void) a1)
Eq_n fn000000000001730C(struct Eq_n * gp, Eq_n a0, void * a1)
{
	Eq_n a0_n;
	Eq_n a4_n = gp->tFFFFF870;
	if (a0 <= 0x0080)
	{
		byte * a5_n = fp + -0x00B8;
		Eq_n a3_n = 0x07;
		Eq_n a2_n = -0x01;
		while (0x00 < a0)
		{
			if (a3_n >= a0)
				;
			*a5_n = (byte) a2_n;
			a0 = (int64) ((word32) a0 + -0x08);
			++a5_n;
		}
		if (inet_ntop(0x0A, fp + -0x00B8, fp + -0x00A8, 0x0080) != null)
		{
			memcpy(a1, fp + ~0xBF, 0x0010);
			a0_n = __strdup(fp + ~0xB7);
l000000000001739C:
			if (a4_n == gp->tFFFFF870)
				return a0_n;
			__stack_chk_fail();
		}
	}
	a0_n.u0 = 0x00;
	goto l000000000001739C;
}

// 00000000000173D4: Register ptr64 fn00000000000173D4(Register (ptr64 Eq_n) a0, Register Eq_n a1, Register out ptr64 spOut, Register out ptr64 s0Out, Register out ptr64 s1Out, Register out ptr64 a0Out, Register out ptr64 s2Out, Register out ptr64 s3Out)
ptr64 fn00000000000173D4(struct Eq_n * a0, Eq_n a1, ptr64 & spOut, ptr64 & s0Out, ptr64 & s1Out, ptr64 & a0Out, ptr64 & s2Out, ptr64 & s3Out)
{
	ptr64 a0_n;
	Eq_n s2_n = (int64) a0->b0000;
	int64 s3_n = (int64) a0->b0001;
	if (a1 != 0x0080)
	{
		if (a1 <= 0x005F)
			goto l0000000000017408;
	}
	else
	{
		if ((uint64) (uint32) memcmp(a0, &globals->v10880, 0x0010) == 0x00)
		{
			spOut = fp + ~0x07;
			s0Out = s1;
			s1Out = s2;
			a0Out = 0x00011858;
			s2Out = s3;
			s3Out = qwLoc30;
			return s0;
		}
		if ((uint64) (uint32) memcmp(a0, &globals->v10898, 0x0010) == 0x00)
		{
			a0_n = 0x00011870;
			goto l0000000000017458;
		}
	}
	if ((uint64) (uint32) memcmp(a0, &globals->v108B0, 0x0C) == 0x00)
	{
		spOut = fp;
		s0Out = qwArg00;
		s1Out = ra;
		a0Out = 0x00011888;
		s2Out = s0;
		s3Out = s1;
		return qwArg08;
	}
	if ((uint64) (uint32) memcmp(a0, &globals->v108C0, 0x0C) == 0x00)
	{
		spOut = fp;
		s0Out = ra;
		s1Out = s0;
		a0Out = 0x000118A0;
		s2Out = s1;
		s3Out = s2;
		return qwArg00;
	}
	if ((uint64) (uint32) memcmp(a0, &globals->v108D0, 0x0C) == 0x00)
	{
		spOut = fp;
		s0Out = s0;
		s1Out = s1;
		a0Out = 0x000118B8;
		s2Out = s2;
		s3Out = s3;
		return ra;
	}
l0000000000017408:
	ui64 a5_n = s2_n << 0x08 | s3_n;
	if ((a5_n & 0xFFFFE000) != 0x2000)
	{
		if ((s2_n & 0x00FE) != 252)
		{
			if ((a5_n & -0x0040) != 65152)
			{
				if (s2_n != 0x00FF)
				{
					a0_n = 0x00011710;
					if ((a5_n & -0x02) == 0x00002002)
						a0_n = 0x00011918;
				}
				else
					a0_n = 0x00011748;
			}
			else
				a0_n = 0x00011900;
		}
		else
			a0_n = 0x000118E8;
	}
	else
		a0_n = 0x000118D8;
l0000000000017458:
	spOut = fp;
	s0Out = s0;
	s1Out = s1;
	a0Out = a0_n;
	s2Out = s2;
	s3Out = s3;
	return ra;
}

// 00000000000175BC: Register Eq_n fn00000000000175BC(Register (ptr64 Eq_n) gp, Register Eq_n a0, Register Eq_n a1, Register (ptr64 Eq_n) a2, Register Eq_n a3, Register out Eq_n a4Out)
Eq_n fn00000000000175BC(struct Eq_n * gp, Eq_n a0, Eq_n a1, struct Eq_n * a2, Eq_n a3, union Eq_n & a4Out)
{
	Eq_n a0_n;
	Eq_n a5_n = gp->tFFFFF870;
	memset(a2, 0x00, 200);
	Eq_n s2_n = a1;
	Eq_n s6_n = a3;
	if ((uint64) (uint32) inet_pton(0x0A, a0, fp + ~0x019F) <= 0x00)
	{
		if ((int64) gp->dwFFFFF814 != 0x00)
			goto l0000000000017770;
		__fprintf_chk(gp->tFFFFF880, 0x01, "ipcalc: bad IPv6 address: %s\n", 0x00);
		a0_n.u0 = -0x01;
		goto l0000000000017774;
	}
	a2->qw0008 = fn00000000000163B0(gp);
	if (inet_ntop(0x0A, fp + ~0x01A7, fp + ~0x0177, 0x00FA) == null)
	{
l0000000000017768:
		if ((int64) gp->dwFFFFF814 != 0x00)
			goto l0000000000017770;
		fwrite(&globals->v117F8, 0x01, 0x002B, gp->tFFFFF880);
		a0_n.u0 = -0x01;
		goto l0000000000017774;
	}
	else
	{
		a2->t0000 = __strdup(fp + ~0x0177);
		Eq_n s5_n = 0x0080;
		if (s5_n >= a1)
		{
			if (a1 >= 0x00)
				s5_n = a1;
			else
				s2_n = s5_n;
			a2->dw00A0 = (word32) s5_n;
			Eq_n a0_n = fn000000000001730C(gp, s5_n, fp + ~0x01A7);
			a2->t0030 = a0_n;
			if (a0_n != 0x00)
			{
				union Eq_n * s8_n = fp + ~0x0197;
				byte * a5_n;
				byte * s9_n = fp + ~0x01A7;
				byte * a2_n = fp + ~0x0197;
				byte * a3_n = fp + ~0x01A7;
				do
				{
					*a2_n = (byte) ((int64) *a5_n & (int64) (*a3_n));
					++a5_n;
					++a3_n;
					++a2_n;
				} while (fp + ~0x01A7 != a5_n);
				if (inet_ntop(0x0A, fp + ~0x0197, fp + ~0x0177, 0x00FA) != null)
				{
					a2->t0020 = __strdup(fp + ~0x0177);
					a2->qw0010 = fn00000000000163B0(gp);
					word64 a0_n;
					word64 s1_n;
					Eq_n s2_n;
					word64 sp_n;
					struct Eq_n * s0_n;
					union Eq_n * s3_n;
					word64 ra_n = fn00000000000173D4(fp + ~0x01A7, s2_n, out sp_n, out s0_n, out s1_n, out a0_n, out s2_n, out s3_n);
					s0_n->qw00B8 = a0_n;
					s0_n->qw0018 = fn0000000000018118(gp, sp_n + 0x0028, s5_n);
					if (s2_n == 0x0080)
					{
						Eq_n a5_n = s0_n->t0020;
						s0_n->t00A8 = a5_n;
						s0_n->t00B0 = a5_n;
						goto l0000000000017728;
					}
					s0_n->t00A8 = __strdup(s3_n);
					do
					{
						s8_n = (union Eq_n *) ((char *) s8_n + 0x01);
						*((char *) s8_n + 0x0FFF) = (union Eq_n *) (byte) ((int64) *s9_n ^ -0x01 | (int64) (*s8_n));
						++s9_n;
					} while (s3_n != s8_n);
					if (inet_ntop(0x0A, sp_n + 0x20, s3_n, 0x00FA) != null)
					{
						s0_n->t00B0 = __strdup(s3_n);
						Eq_n a5_n = 0x0080;
						sp_n += ~0x17;
						if ((int64) (word32) (a5_n - s2_n) == a5_n)
							goto l0000000000017740;
l0000000000017740:
						snprintf(&s0_n->qw0038 + 0x05, 0x0040, "%s", 0x00);
						word64 sp_n = sp_n + ~0x07;
						if (a3 << 0x11 < 0x00)
							gp = fn0000000000017D10(ra_n, gp, s1_n, sp_n + 0x08, &s0_n->qw0038 + 0x01, &s0_n->qw0038 + 0x02, &s0_n->qw0038 + 0x03, &s0_n->qw0038 + 0x04, a3, fp + ~0x01A7, out s0_n, out s3_n, out s6_n);
						if ((s6_n & 0x01) == 0x00)
						{
l0000000000017760:
							a0_n.u0 = 0x00;
							goto l0000000000017774;
						}
						word64 a0_n = fn00000000000168E4(gp, 0x0A, sp_n + 0x08);
						s0_n->qw0038 = a0_n;
						if (a0_n != 0x00)
							goto l0000000000017760;
						if ((int64) gp->dwFFFFF814 == 0x00)
						{
							__sprintf_chk(s3_n, 0x01, 0x00FA, "ipcalc: cannot find hostname for %s", 0x00);
							herror(s3_n);
						}
l0000000000017770:
						a0_n.u0 = -0x01;
						goto l0000000000017774;
					}
				}
				goto l0000000000017768;
			}
			if ((int64) gp->dwFFFFF814 != 0x00)
				goto l0000000000017770;
			__fprintf_chk(gp->tFFFFF880, 0x01, "ipcalc: error converting IPv6 prefix: %d\n", 0x00);
			a0_n.u0 = -0x01;
		}
		else
		{
			if ((int64) gp->dwFFFFF814 != 0x00)
				goto l0000000000017770;
			__fprintf_chk(gp->tFFFFF880, 0x01, "ipcalc: bad IPv6 prefix: %d\n", 0x00);
			a0_n.u0 = -0x01;
		}
l0000000000017774:
		if (a5_n != gp->tFFFFF870)
			__stack_chk_fail();
		else
		{
			a4Out = a5_n;
			return a0_n;
		}
	}
}

// 0000000000017924: Register Eq_n fn0000000000017924(Register (ptr64 Eq_n) gp, Register out Eq_n a1Out, Register out Eq_n a2Out, Register out Eq_n a3Out, Register out Eq_n a4Out, Register out Eq_n a6Out)
Eq_n fn0000000000017924(struct Eq_n * gp, union Eq_n & a1Out, union Eq_n & a2Out, union Eq_n & a3Out, union Eq_n & a4Out, union Eq_n & a6Out)
{
	Eq_n s0_n;
	if (gp->qwFFFFF820 == 0x00)
	{
		s0_n.u1 = (int64) gp->dwFFFFF818;
		if (s0_n == 0x00)
		{
			void * a0_n = dlopen("/usr/lib64/libGeoIP.so.1", 0x01);
			gp->ptr0820 = a0_n;
			if (a0_n != null)
			{
				gp->ptr0868 = dlsym(a0_n, "_GeoIP_setup_dbfilename");
				void * a0_n = dlsym(a0_n, "GeoIP_open_type");
				gp->ptr0860 = a0_n;
				void * a0_n = dlsym(a0_n, "GeoIP_country_name_by_id");
				gp->ptr0858 = a0_n;
				void * a0_n = dlsym(a0_n, "GeoIP_delete");
				gp->ptr0848 = a0_n;
				void * a0_n = dlsym(a0_n, "GeoIP_record_by_ipnum");
				gp->ptr0840 = a0_n;
				void * a0_n = dlsym(a0_n, "GeoIP_id_by_ipnum");
				gp->ptr0838 = a0_n;
				void * a0_n = dlsym(a0_n, "GeoIP_id_by_ipnum_v6");
				gp->ptr0830 = a0_n;
				void * a0_n = dlsym(a0_n, "GeoIP_record_by_ipnum_v6");
				gp->ptr0828 = a0_n;
				gp->ptr0850 = dlsym(a0_n, "GeoIP_code_by_id");
				a1.u0 = 76600;
				if (a0_n != null && (a0_n != null && (a0_n != null && (a0_n != null && (a0_n != null && (a0_n != null && a0_n != null))))))
					gp->dw0818 = 0x00;
				else
				{
					a6 = globals->t12B50;
					word64 a0_n = globals->qw12B58;
					a1 = globals->t12B60;
					a2 = globals->t12B68;
					a3 = globals->t12B70;
					a4.u0 = (int64) globals->dw12B78;
					gp->tFFFFFCE0 = a6;
					gp->qwFFFFFCE8 = a0_n;
					gp->tFFFFFCF0 = a1;
					gp->tFFFFFCF8 = a2;
					gp->tFFFFFD00 = a3;
					gp->dwFFFFFD08 = (word32) a4;
					s0_n.u0 = -0x01;
					gp->dw0818 = (word32) s0_n;
				}
			}
			else
			{
				a3.u0 = 0x0100;
				a2.u0 = 0x01;
				__snprintf_chk(&gp->tFFFFFCE0, a3, a2, a3, "ipcalc: could not open %s\n", 0x00);
				s0_n.u0 = -0x01;
				gp->dw0818 = (word32) s0_n;
				a4.u0 = 76376;
				a1 = a3;
			}
l0000000000017970:
			a1Out = a1;
			a2Out = a2;
			a3Out = a3;
			a4Out = a4;
			a6Out = a6;
			return s0_n;
		}
	}
	if ((int64) gp->dwFFFFF814 == 0x00 && (int64) gp->tFFFFFCE0 != 0x00)
	{
		a1 = gp->tFFFFF880;
		fputs(&gp->tFFFFFCE0, a1);
	}
	s0_n.u1 = (int64) gp->dwFFFFF818;
	goto l0000000000017970;
}

// 0000000000017B40: Register (ptr64 Eq_n) fn0000000000017B40(Register word64 ra, Register (ptr64 Eq_n) gp, Register Eq_n a0, Register ptr64 a1, Register ptr64 a2, Register ptr64 a3, Register ptr64 a4, Register Eq_n s5, Register (ptr64 Eq_n) s6, Register out (ptr64 Eq_n) s6Out)
struct Eq_n * fn0000000000017B40(word64 ra, struct Eq_n * gp, Eq_n a0, ptr64 a1, ptr64 a2, ptr64 a3, ptr64 a4, Eq_n s5, struct Eq_n * s6, struct Eq_n & s6Out)
{
	word64 a1_n;
	word64 a2_n;
	word64 a3_n;
	word64 a4_n;
	word64 a6_n;
	if (fn0000000000017924(gp, out a1_n, out a2_n, out a3_n, out a4_n, out a6_n) == 0x00)
	{
		word64 a3_n;
		word64 a4_n;
		Eq_n a0_n = fn00000000000182B4(a0, out a3_n, out a4_n);
		word64 sp_n;
		word64 s0_n;
		word64 s1_n;
		word64 s2_n;
		word64 s3_n;
		word64 s4_n;
		word64 ra_n;
		word64 s5_n;
		word64 s6_n;
		word64 s7_n;
		word64 a2_n;
		word64 a3_n;
		word64 a4_n;
		struct Eq_n * gp_n;
		gp->ptrFFFFF868();
		struct Eq_n * a0_n;
		word64 fa4_n;
		word64 fa5_n;
		word64 t1_n;
		word64 fa3_n;
		struct Eq_n * gp_n;
		word64 s1_n;
		word64 s2_n;
		word64 s3_n;
		word64 s4_n;
		word64 ra_n;
		word64 s5_n;
		word64 s6_n;
		word64 s7_n;
		word64 a2_n;
		word64 a3_n;
		word64 a4_n;
		word64 sp_n;
		gp_n->ptrFFFFF860();
		struct Eq_n * s0_n = a0_n;
		if (a0_n != null)
		{
			<anonymous> * a5_n = gp_n->ptrFFFFF838;
			Eq_n a4_n = 0x01;
			a0_n->dw004C = (word32) a4_n;
			word64 sp_n;
			word64 s0_n;
			word64 s1_n;
			word64 s2_n;
			word64 s3_n;
			word64 s4_n;
			word64 ra_n;
			word64 s5_n;
			word64 s7_n;
			int64 a0_n;
			word64 a2_n;
			word64 a3_n;
			word64 a4_n;
			word64 fa4_n;
			word64 fa5_n;
			word64 t1_n;
			word64 fa3_n;
			a5_n();
			if (a0_n < 0x00)
				goto l0000000000017B84;
			word64 s0_n;
			word64 s1_n;
			word64 s2_n;
			union Eq_n * s3_n;
			word64 s4_n;
			word64 ra_n;
			word64 s5_n;
			word64 s6_n;
			word64 s7_n;
			union Eq_n * a0_n;
			word64 a1_n;
			word64 a2_n;
			word64 a3_n;
			word64 a4_n;
			struct Eq_n * gp_n;
			word64 fa4_n;
			word64 fa5_n;
			word64 t1_n;
			word64 fa3_n;
			word64 sp_n;
			gp->ptrFFFFF858();
			if (a0_n != null)
			{
				*s3_n = (union Eq_n *) __strdup(a0_n);
				sp_n += ~0x07;
			}
			word64 s0_n;
			word64 s1_n;
			union Eq_n * s2_n;
			word64 s3_n;
			word64 s4_n;
			word64 ra_n;
			word64 s5_n;
			word64 s6_n;
			word64 s7_n;
			union Eq_n * a0_n;
			word64 a1_n;
			word64 a2_n;
			word64 a3_n;
			word64 a4_n;
			struct Eq_n * gp_n;
			word64 fa4_n;
			word64 fa5_n;
			word64 t1_n;
			word64 fa3_n;
			word64 sp_n;
			gp_n->ptrFFFFF850();
			if (a0_n != null)
			{
				*s2_n = (union Eq_n *) __strdup(a0_n);
				sp_n += ~0x07;
			}
			word64 fa4_n;
			word64 fa5_n;
			word64 t1_n;
			word64 fa3_n;
			gp_n->ptrFFFFF848();
		}
		word64 a4_n;
		word64 fa4_n;
		word64 fa5_n;
		word64 t1_n;
		word64 fa3_n;
		word64 s7_n;
		word64 s1_n;
		word64 s2_n;
		word64 s3_n;
		word64 s4_n;
		word64 ra_n;
		word64 s5_n;
		word64 s6_n;
		struct Eq_n * a0_n;
		word64 a2_n;
		word64 a3_n;
		word64 sp_n;
		gp_n->ptrFFFFF860();
		struct Eq_n * s0_n = a0_n;
		if (a0_n == null)
		{
			word64 fa4_n;
			word64 fa5_n;
			word64 t1_n;
			word64 fa3_n;
			gp->ptrFFFFF860();
			s0_n = a0_n;
			if (a0_n == null)
				goto l0000000000017B84;
		}
		<anonymous> * a5_n = gp->ptrFFFFF840;
		Eq_n a4_n = 0x01;
		s0_n->dw004C = (word32) a4_n;
		word64 s0_n;
		union Eq_n * s1_n;
		char ** s4_n;
		struct Eq_n * a0_n;
		word64 a3_n;
		word64 a4_n;
		struct Eq_n * gp_n;
		word64 fa4_n;
		word64 fa5_n;
		word64 t1_n;
		word64 fa3_n;
		word64 sp_n;
		Eq_n a1_n;
		word64 a2_n;
		a5_n();
		if (a0_n != null)
		{
			union Eq_n * a0_n = a0_n->ptr0020;
			if (a0_n != null)
			{
				*s1_n = (union Eq_n *) __strdup(a0_n);
				sp_n += ~0x07;
			}
			if ((word64) ((real32) a0_n->r0034 == (real32) 0x00) == 0x00)
			{
				a1_n.u0 = 0x01;
				__asprintf_chk(s4_n, a1_n, "%f,%f", 0x00);
				a2_n = 76672;
				sp_n += ~0x07;
			}
		}
		struct Eq_n * s6_n;
		struct Eq_n * gp_n;
		word64 fa4_n;
		word64 fa5_n;
		word64 t1_n;
		word64 fa3_n;
		gp_n->ptrFFFFF848();
		s6Out = s6_n;
		return gp_n;
	}
	else
	{
l0000000000017B84:
		s6Out = s6;
		return gp;
	}
}

// 0000000000017D10: Register (ptr64 Eq_n) fn0000000000017D10(Register word64 ra, Register (ptr64 Eq_n) gp, Register word64 s1, Register word64 a0, Register ptr64 a1, Register ptr64 a2, Register ptr64 a3, Register ptr64 a4, Register Eq_n s6, Register ptr64 s7, Register out (ptr64 Eq_n) s0Out, Register out (ptr64 char) s3Out, Register out Eq_n s6Out)
struct Eq_n * fn0000000000017D10(word64 ra, struct Eq_n * gp, word64 s1, word64 a0, ptr64 a1, ptr64 a2, ptr64 a3, ptr64 a4, Eq_n s6, ptr64 s7, struct Eq_n & s0Out, char & s3Out, union Eq_n & s6Out)
{
	word64 a1_n;
	word64 a2_n;
	word64 a3_n;
	word64 a4_n;
	word64 a6_n;
	word64 a0_n = fn0000000000017924(gp, out a1_n, out a2_n, out a3_n, out a4_n, out a6_n);
	if (a0_n == 0x00)
	{
		word64 sp_n;
		word64 s0_n;
		word64 s2_n;
		word64 s3_n;
		word64 s4_n;
		word64 s5_n;
		word64 ra_n;
		word64 s1_n;
		word64 s6_n;
		word64 s7_n;
		word64 a2_n;
		word64 a3_n;
		word64 a4_n;
		struct Eq_n * gp_n;
		gp->ptrFFFFF868();
		struct Eq_n * a0_n;
		word64 fa4_n;
		word64 fa5_n;
		word64 t1_n;
		word64 fa3_n;
		struct Eq_n * gp_n;
		struct Eq_n * s0_n;
		word64 s2_n;
		word64 s3_n;
		word64 s4_n;
		word64 s5_n;
		word64 ra_n;
		word64 s6_n;
		word64 s7_n;
		word64 a2_n;
		word64 a3_n;
		word64 a4_n;
		word64 sp_n;
		gp_n->ptrFFFFF860();
		struct Eq_n * s1_n = a0_n;
		if (a0_n != null)
		{
			int64 a4_n = (int64) s0_n->dw0004;
			int64 a5_n = (int64) s0_n->dw000C;
			int64 a1_n = (int64) s0_n->dw0000;
			int64 a2_n = (int64) s0_n->dw0008;
			<anonymous> * a3_n = gp_n->ptrFFFFF830;
			Eq_n a6_n = 0x01;
			a0_n->dw004C = (word32) a6_n;
			word64 sp_n;
			word64 s0_n;
			word64 s2_n;
			word64 s3_n;
			word64 s4_n;
			word64 s5_n;
			word64 ra_n;
			word64 s1_n;
			word64 s6_n;
			int64 a0_n;
			word64 a2_n;
			word64 a3_n;
			word64 a4_n;
			word64 fa4_n;
			word64 fa5_n;
			word64 t1_n;
			word64 fa3_n;
			a3_n();
			if (a0_n < 0x00)
				goto l0000000000017D54;
			word64 s0_n;
			word64 s2_n;
			word64 s3_n;
			union Eq_n * s4_n;
			word64 s5_n;
			word64 ra_n;
			word64 s1_n;
			word64 s6_n;
			word64 s7_n;
			union Eq_n * a0_n;
			word64 a1_n;
			word64 a2_n;
			word64 a3_n;
			word64 a4_n;
			struct Eq_n * gp_n;
			word64 fa4_n;
			word64 fa5_n;
			word64 t1_n;
			word64 fa3_n;
			word64 sp_n;
			gp->ptrFFFFF858();
			if (a0_n != null)
			{
				*s4_n = (union Eq_n *) __strdup(a0_n);
				sp_n += ~0x07;
			}
			word64 s0_n;
			word64 s2_n;
			union Eq_n * s3_n;
			word64 s4_n;
			word64 s5_n;
			word64 ra_n;
			word64 s1_n;
			word64 s6_n;
			word64 s7_n;
			union Eq_n * a0_n;
			word64 a1_n;
			word64 a2_n;
			word64 a3_n;
			word64 a4_n;
			struct Eq_n * gp_n;
			word64 fa4_n;
			word64 fa5_n;
			word64 t1_n;
			word64 fa3_n;
			word64 sp_n;
			gp_n->ptrFFFFF850();
			if (a0_n != null)
			{
				*s3_n = (union Eq_n *) __strdup(a0_n);
				sp_n += ~0x07;
			}
			word64 fa4_n;
			word64 fa5_n;
			word64 t1_n;
			word64 fa3_n;
			gp_n->ptrFFFFF848();
		}
		word64 a2_n;
		word64 a3_n;
		word64 a4_n;
		word64 fa4_n;
		word64 fa5_n;
		word64 t1_n;
		word64 fa3_n;
		struct Eq_n * s0_n;
		word64 s2_n;
		word64 s3_n;
		word64 s4_n;
		word64 s5_n;
		word64 ra_n;
		word64 s6_n;
		word64 s7_n;
		struct Eq_n * a0_n;
		word64 sp_n;
		gp_n->ptrFFFFF860();
		struct Eq_n * s1_n = a0_n;
		if (a0_n == null)
		{
			word64 fa4_n;
			word64 fa5_n;
			word64 t1_n;
			word64 fa3_n;
			gp->ptrFFFFF860();
			s1_n = a0_n;
			if (a0_n == null)
				goto l0000000000017D54;
		}
		int64 a4_n = (int64) s0_n->dw0004;
		int64 a5_n = (int64) s0_n->dw000C;
		int64 a1_n = (int64) s0_n->dw0000;
		int64 a2_n = (int64) s0_n->dw0008;
		<anonymous> * a3_n = gp->ptrFFFFF828;
		Eq_n a6_n = 0x01;
		s1_n->dw004C = (word32) a6_n;
		union Eq_n * s2_n;
		char ** s5_n;
		word64 s1_n;
		struct Eq_n * a0_n;
		word64 a3_n;
		word64 a4_n;
		struct Eq_n * gp_n;
		word64 fa4_n;
		word64 fa5_n;
		word64 t1_n;
		word64 fa3_n;
		word64 sp_n;
		Eq_n a1_n;
		word64 a2_n;
		a3_n();
		if (a0_n != null)
		{
			union Eq_n * a0_n = a0_n->ptr0020;
			if (a0_n != null)
			{
				*s2_n = (union Eq_n *) __strdup(a0_n);
				sp_n += ~0x07;
			}
			if ((word64) ((real32) a0_n->r0034 == (real32) 0x00) == 0x00)
			{
				a1_n.u0 = 0x01;
				__asprintf_chk(s5_n, a1_n, "%f,%f", 0x00);
				a2_n = 76672;
				sp_n += ~0x07;
			}
		}
		struct Eq_n * s0_n;
		char * s3_n;
		Eq_n s6_n;
		struct Eq_n * gp_n;
		word64 fa4_n;
		word64 fa5_n;
		word64 t1_n;
		word64 fa3_n;
		gp_n->ptrFFFFF848();
		s0Out = s0_n;
		s3Out = s3_n;
		s6Out = s6_n;
		return gp_n;
	}
	else
	{
l0000000000017D54:
		s0Out = s0;
		s3Out = s3;
		s6Out = s6;
		return gp;
	}
}

// 0000000000017F04: Register Eq_n fn0000000000017F04(Register (ptr64 Eq_n) gp, Register Eq_n a0, Register Eq_n a1, Register Eq_n a2, Register Eq_n a3)
Eq_n fn0000000000017F04(struct Eq_n * gp, Eq_n a0, Eq_n a1, Eq_n a2, Eq_n a3)
{
	Eq_n a0_n;
	Eq_n a0_n;
	Eq_n a5_n = gp->tFFFFF870;
	word64 a3_n;
	word64 a4_n;
	fn00000000000182B4(a0, out a3_n, out a4_n);
	if (a1 != 0x0020)
	{
		Eq_n a1_n = 0x0018;
		if (a1 != a1_n)
		{
			Eq_n a0_n = 0x0010;
			if (a1 != a0_n)
			{
				Eq_n a5_n = 0x08;
				if (a1 != a5_n)
				{
					if (a1_n >= a1)
					{
						if (a0_n >= a1)
						{
							if (a5_n >= a1)
								goto l0000000000017F84;
							word64 a3_n;
							word64 a4_n;
							fn00000000000182B4(a2, out a3_n, out a4_n);
							word64 a4_n;
							word64 a3_n;
							fn00000000000182B4(a3, out a3_n, out a4_n);
							a0_n.u1 = (uint64) (uint32) __asprintf_chk((char *) fp - 0x0050, 0x01, "%u-%u.%u.in-addr.arpa.", 0x00);
						}
						else
						{
							word64 a4_n;
							word64 a3_n;
							fn00000000000182B4(a2, out a3_n, out a4_n);
							word64 a3_n;
							word64 a4_n;
							fn00000000000182B4(a3, out a3_n, out a4_n);
							a0_n.u1 = (uint64) (uint32) __asprintf_chk((char *) fp - 0x0050, 0x01, "%u-%u.%u.%u.in-addr.arpa.", 0x00);
						}
					}
					else
					{
						word64 a3_n;
						word64 a4_n;
						fn00000000000182B4(a2, out a3_n, out a4_n);
						word64 a3_n;
						word64 a4_n;
						fn00000000000182B4(a3, out a3_n, out a4_n);
						a0_n.u1 = (uint64) (uint32) __asprintf_chk((char *) fp - 0x0050, 0x01, "%u-%u.%u.%u.%u.in-addr.arpa.", 0x00);
					}
				}
				else
					a0_n.u1 = (uint64) (uint32) __asprintf_chk((char *) fp - 0x0050, 0x01, "%u.in-addr.arpa.", 0x00);
			}
			else
				a0_n.u1 = (uint64) (uint32) __asprintf_chk((char *) fp - 0x0050, 0x01, "%u.%u.in-addr.arpa.", 0x00);
		}
		else
			a0_n.u1 = (uint64) (uint32) __asprintf_chk((char *) fp - 0x0050, 0x01, "%u.%u.%u.in-addr.arpa.", 0x00);
	}
	else
		a0_n.u1 = (uint64) (uint32) __asprintf_chk((char *) fp - 0x0050, 0x01, "%u.%u.%u.%u.in-addr.arpa.", 0x00);
	if (a0_n != -0x01)
	{
		a0_n = qwLoc58;
l0000000000017F88:
		if (a5_n == gp->tFFFFF870)
			return a0_n;
		__stack_chk_fail();
	}
l0000000000017F84:
	a0_n.u0 = 0x00;
	goto l0000000000017F88;
}

// 0000000000018118: Register Eq_n fn0000000000018118(Register (ptr64 Eq_n) gp, Register Eq_n a0, Register Eq_n a1)
Eq_n fn0000000000018118(struct Eq_n * gp, Eq_n a0, Eq_n a1)
{
	Eq_n a0_n;
	Eq_n a5_n = gp->tFFFFF870;
	if ((a1 & 0x03) == 0x00)
	{
		int64 t5_n = (int64) (word32) (a1 >> 0x03);
		if ((a1 & 0x07) == 0x04)
			;
		if (t5_n != 0x00)
		{
			Eq_n a1_n = (int64) ((word32) t5_n + -0x01);
			int64 a4_n = a1 & 0x03;
			Eq_n t1_n = 0x09;
			Eq_n a7_n = 0x002E;
			Eq_n t3_n = -0x01;
			do
			{
				word64 a5_n = (int64) Mem55[a0 + ((a1_n << 0x00) >>u 0x00):byte];
				int64 a3_n = (int64) ((word32) a4_n + 0x01);
				ui64 a6_n = (a5_n & 0x0F) + 0x0057;
				if (t1_n >= (a5_n & 0x0F))
					a6_n = (a5_n & 0x0F) + 0x0030;
				(word64) (a4_n << 0x00 >> 0x00) + ((word64) fp - 0x0010) + 3832 = (ptr64) (byte) a6_n;
				(word64) (a3_n << 0x00 >> 0x00) + ((word64) fp - 0x0010) + 3832 = (ptr64) (byte) a7_n;
				int64 a2_n = (int64) ((word32) a4_n + 0x02);
				int64 a3_n = (int64) ((word32) a4_n + 0x03);
				uint64 a6_n = (a5_n >> 0x04) + 0x0030;
				if (t1_n < a5_n >> 0x04)
					a6_n = (a5_n >> 0x04) + 0x0057;
				(word64) (a2_n << 0x00 >> 0x00) + ((word64) fp - 0x0010) + 3832 = (byte) a6_n;
				(word64) (a3_n << 0x00 >> 0x00) + ((word64) fp - 0x0010) + 3832 = (byte) a7_n;
				a1_n.u1 = (int64) ((word32) a1_n + -0x01);
				a4_n = (int64) ((word32) a4_n + 0x04);
			} while (a1_n != t3_n);
		}
		struct Eq_n * t4_n = (word64) ((a1 & 0x03) << 0x00 >> 0x00) + ((word64) fp - 0x0118);
		t4_n->w0004 = 29281;
		t4_n->w0000 = 28777;
		t4_n->w0006 = 24944;
		t4_n->w0002 = 11830;
		t4_n->w0008 = 0x2E;
		a0_n = __strdup((word64) fp - 0x0118);
	}
	else
		a0_n.u0 = 0x00;
	if (a5_n == gp->tFFFFF870)
		return a0_n;
	__stack_chk_fail();
}

// 00000000000182B4: Register Eq_n fn00000000000182B4(Register Eq_n a0, Register out Eq_n a3Out, Register out Eq_n a4Out)
Eq_n fn00000000000182B4(Eq_n a0, union Eq_n & a3Out, union Eq_n & a4Out)
{
	Eq_n a3_n = (int64) (word32) (a0 >> 0x0018) | (int64) ((word32) (a0 << 0x18));
	a3Out = a3_n;
	Eq_n a4_n = (int64) (word32) ((a0 & 0x00FF0000) >> 0x08);
	a4Out = a4_n;
	return a3_n | a4_n | (int64) ((word32) ((a0 & 0x0000FF00) << 0x08));
}

// 00000000000182E8: void fn00000000000182E8(Register word64 ra, Register word64 a0, Register word64 a1, Register word64 a2)
void fn00000000000182E8(word64 ra, word64 a0, word64 a1, word64 a2)
{
	int64 s2_n = 106016 - 106008;
	ptr64 sp_n = fp + -0x0040;
	<anonymous> ** s0_n = &globals->ptr19E18;
	Eq_n s2_n = s2_n >> 0x03;
	if (s2_n >> 0x03 != 0x00)
	{
		word64 s5_n = a0;
		word64 s4_n = a1;
		word64 s3_n = a2;
		Eq_n s1_n = 0x00;
		do
		{
			word64 s0_n;
			word64 a5_n;
			(*s0_n)();
			s0_n = s0_n + 0x08;
		} while (s2_n != s1_n);
	}
}

// 0000000000018378: void fn0000000000018378()
void fn0000000000018378()
{
}

