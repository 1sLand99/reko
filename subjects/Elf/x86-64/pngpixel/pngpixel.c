// pngpixel.c
// Generated by decompiling pngpixel
// using Reko decompiler version 0.8.0.2.

#include "pngpixel.h"

// 0000000000400AE8: Register ptr64 _init()
ptr64 _init()
{
	ptr64 rax_15 = __gmon_start__;
	if (__gmon_start__ != 0x00)
		__gmon_start__();
	return rax_15;
}

// 0000000000400CD0: void _start(Register (ptr64 Eq_10) rdx, Stack Eq_11 qwArg00)
void _start(void (* rdx)(), Eq_11 qwArg00)
{
	__align((char *) fp + 0x08);
	__libc_start_main(&globals->t4012F9, qwArg00, (char *) fp + 0x08, &globals->t401780, &globals->t4017F0, rdx, fp);
	__hlt();
}

// 0000000000400D00: void deregister_tm_clones(Register ptr64 rbp, Register word64 r8)
void deregister_tm_clones(ptr64 rbp, word64 r8)
{
	if (false || 0x00 == 0x00)
		return;
	null();
}

// 0000000000400D40: void register_tm_clones(Register word64 rbp)
void register_tm_clones(word64 rbp)
{
	if (0x00 == 0x00 || 0x00 == 0x00)
		return;
	null();
}

// 0000000000400D80: void __do_global_dtors_aux(Register word64 r8)
void __do_global_dtors_aux(word64 r8)
{
	if (globals->b602108 == 0x00)
	{
		deregister_tm_clones(fp - 0x08, r8);
		globals->b602108 = 0x01;
	}
}

// 0000000000400DA0: void frame_dummy(Register word64 rbp, Register word64 rsi)
void frame_dummy(word64 rbp, word64 rsi)
{
	if (globals->qw601E10 != 0x00 && 0x00 != 0x00)
	{
		fn0000000000000000();
		register_tm_clones(rbp);
	}
	else
		register_tm_clones(rbp);
}

// 0000000000400DC6: Register word32 component(Register Eq_82 ecx, Register word32 edx, Register word32 esi, Register word64 rdi, Register int32 r8d, Register out Eq_87 rcxOut)
word32 component(Eq_82 ecx, word32 edx, word32 esi, word64 rdi, int32 r8d, union Eq_87 & rcxOut)
{
	Eq_87 rcx_106 = DPB(rcx, ecx, 0);
	ui32 eax_40 = (word32) (uint64) ((word32) (uint64) (word32) (uint64) (edx + (word32) ((uint64) ((word32) ((uint64) ((word32) ((uint64) esi) & 0x3F)) *s r8d))) *s ecx);
	struct Eq_109 * v16_51 = rdi + ((uint64) ((word32) ((uint64) ((word32) ((uint64) ((word32) ((uint64) ((word32) ((uint64) esi) >> 0x06)) *s r8d)) *s ecx))) << 0x03) + (uint64) ((word32) ((uint64) ((word32) ((uint64) eax_40) >> 0x03)));
	if (ecx > 0x10)
		goto l0000000000400EC1;
	byte * rax_112;
	switch (ecx)
	{
	case 0x00:
	case 0x03:
	case 0x05:
	case 0x06:
	case 0x07:
	case 0x09:
	case 0x0A:
	case 11:
	case 0x0C:
	case 0x0D:
	case 0x0E:
	case 0x0F:
l0000000000400EC1:
		fprintf(globals->ptr602100, "pngpixel: invalid bit depth %u\n", (uint64) ecx);
		exit(0x01);
	case 0x01:
		rcx_106.u0 = (uint64) (word32) (uint64) (0x07 - (eax_40 & 0x07));
		rax_112 = (uint64) ((word32) (uint64) (word32) (uint64) ((word32) (byte) (word32) v16_51->b0000 >> (byte) rcx_106) & 0x01);
		break;
	case 0x02:
		rcx_106.u0 = (uint64) (word32) (uint64) (0x06 - (eax_40 & 0x07));
		rax_112 = (uint64) ((word32) (uint64) (word32) (uint64) ((word32) (byte) (word32) v16_51->b0000 >> (byte) rcx_106) & 0x03);
		break;
	case 0x04:
		rcx_106.u0 = (uint64) (word32) (uint64) (0x04 - (eax_40 & 0x07));
		rax_112 = (uint64) ((word32) (uint64) (word32) (uint64) ((word32) (byte) (word32) v16_51->b0000 >> (byte) rcx_106) & 0x0F);
		break;
	case 0x08:
		rax_112 = (byte *) DPB(v16_51, (word32) (byte) (word32) v16_51->b0000, 0);
		break;
	case 0x10:
		rax_112 = (uint64) (word32) ((byte) (word32) v16_51->b0001 + (uint64) ((word32) ((uint64) ((word32) ((byte) ((word32) v16_51->b0000)) << 0x08))));
		break;
	}
	rcxOut = rcx_106;
	return (word32) rax_112;
}

// 0000000000400EE9: Register Eq_243 print_pixel(Register Eq_243 rcx, Register word64 rdx, Register word64 rbx, Register ptr64 rbp, Register word64 rsi, Register word64 rdi, Register word64 r8, Register word64 r9, Register word64 r12, Register word64 r13, Register (ptr32 Eq_253) fs, Register out Eq_254 r8Out, Register out Eq_255 r9Out)
Eq_243 print_pixel(Eq_243 rcx, word64 rdx, word64 rbx, ptr64 rbp, word64 rsi, word64 rdi, word64 r8, word64 r9, word64 r12, word64 r13, struct Eq_253 * fs, union Eq_254 & r8Out, union Eq_255 & r9Out)
{
	word64 rcx_41 = DPB(rcx, ecx, 0);
	Eq_254 r8_154;
	Eq_243 rcx_156;
	word64 rax_26 = fs->qw0028;
	word64 rcx_42;
	word64 rax_43;
	word64 r8_45;
	word64 r9_47;
	png_get_bit_depth();
	word32 eax_50 = (word32) (byte) rax_43;
	word64 rdx_58;
	word64 rcx_59;
	word64 rax_60;
	word64 r8_61;
	Eq_255 r9_245;
	png_get_color_type();
	up32 eax_65 = (word32) (byte) rax_60;
	if (eax_65 > 0x06)
		goto l00000000004012C9;
	switch ((word32) globals->a401958[(uint64) eax_65 * 0x08])
	{
	case 0x00:
		printf("GRAY %u\n", (uint64) (word32) (word64) component((word32) (uint64) (word32) (uint64) eax_50, 0x00, (word32) (uint64) ecx, rdx, 0x01, out rcx_156));
		r8_154.u1 = 0x01;
		break;
	case 0x01:
	case 0x05:
l00000000004012C9:
		png_error();
		break;
	case 0x02:
		rcx_156.u1 = (uint64) (word32) (uint64) (word32) (word64) component((word32) (uint64) (word32) (uint64) eax_50, 0x02, (word32) (uint64) ecx, rdx, 0x03, out rcx_625);
		printf("RGB %u %u %u\n", (uint64) (word32) (word64) component((word32) (uint64) (word32) (uint64) eax_50, 0x00, (word32) (uint64) ecx, rdx, 0x03, out rcx_627), (uint64) (word32) (uint64) (word32) (word64) component((word32) (uint64) (word32) (uint64) eax_50, 0x01, (word32) (uint64) ecx, rdx, 0x03, out rcx_626), rcx_156);
		r8_154.u1 = 0x03;
		break;
	case 0x03:
		up32 eax_230 = (word32) (word64) component((word32) (uint64) (word32) (uint64) eax_50, 0x00, (word32) (uint64) ecx, rdx, 0x01, out rcx_628);
		word64 rax_243;
		png_get_PLTE();
		if ((word32) (uint64) ((word32) rax_243 & 0x08) != 0x00 && (false && 0x00 != 0x00))
		{
			word64 rax_281;
			png_get_tRNS();
			if ((word32) (uint64) ((word32) rax_281 & 0x10) != 0x00 && (false && 0x00 != 0x00))
			{
				word32 esi_349;
				if (eax_230 < 0x00)
					esi_349 = (word32) (byte) (word32) ((uint64) eax_230 + 0x00);
				else
					esi_349 = 0xFF;
				uint64 rdx_371 = (uint64) eax_230;
				rcx_156 = (word64) (word32) (byte) (word32) ((Eq_1108[]) 0x01)[(uint64) eax_230].b0000;
				r9_245.u1 = (uint64) esi_349;
				r8_154.u1 = (uint64) (word32) (byte) (word32) ((Eq_1109[]) 0x02)[(uint64) eax_230].b0000;
				printf("INDEXED %u = %d %d %d %d\n", (uint64) (word32) (uint64) eax_230, DPB(rdx_371, (word32) (byte) (word32) null[rdx_371].b0000, 0), rcx_156, r8_154, r9_245);
			}
			else
			{
				uint64 rdx_320 = (uint64) eax_230;
				rcx_156 = (word64) (word32) (byte) (word32) ((Eq_1105[]) 0x01)[(uint64) eax_230].b0000;
				r8_154.u1 = (uint64) (word32) (byte) (word32) ((Eq_1106[]) 0x02)[(uint64) eax_230];
				printf("INDEXED %u = %d %d %d\n", (uint64) (word32) (uint64) eax_230, DPB(rdx_320, (word32) (byte) (word32) null[rdx_320].b0000, 0), rcx_156, r8_154);
			}
		}
		else
			printf("INDEXED %u = invalid index\n", (uint64) (word32) (uint64) eax_230);
		break;
	case 0x04:
		printf("GRAY+ALPHA %u %u\n", (uint64) (word32) (word64) component((word32) (uint64) (word32) (uint64) eax_50, 0x00, (word32) (uint64) ecx, rdx, 0x02, out rcx_156), (uint64) (word32) (uint64) (word32) (word64) component((word32) (uint64) (word32) (uint64) eax_50, 0x01, (word32) (uint64) ecx, rdx, 0x02, out rcx_629));
		r8_154.u1 = 0x02;
		break;
	case 0x06:
		r8_154.u1 = (uint64) (word32) (uint64) (word32) (word64) component((word32) (uint64) (word32) (uint64) eax_50, 0x03, (word32) (uint64) ecx, rdx, 0x04, out rcx_630);
		rcx_156.u1 = (uint64) (word32) (uint64) (word32) (word64) component((word32) (uint64) (word32) (uint64) eax_50, 0x02, (word32) (uint64) ecx, rdx, 0x04, out rcx_631);
		printf("RGBA %u %u %u %u\n", (uint64) (word32) (word64) component((word32) (uint64) (word32) (uint64) eax_50, 0x00, (word32) (uint64) ecx, rdx, 0x04, out rcx_633), (uint64) (word32) (uint64) (word32) (word64) component((word32) (uint64) (word32) (uint64) eax_50, 0x01, (word32) (uint64) ecx, rdx, 0x04, out rcx_632), rcx_156, r8_154);
		break;
	}
	if ((rax_26 ^ fs->qw0028) == 0x00)
	{
		r8Out = r8_154;
		r9Out = r9_245;
		return rcx_156;
	}
	else
		__stack_chk_fail();
}

// 00000000004012F9: void main(Register word64 rbx, Register word64 rbp, Register (ptr64 Eq_636) rsi, Register word32 edi, Register word64 r8, Register word64 r9, Register word64 r12, Register word64 r13, Register (ptr32 Eq_253) fs)
void main(word64 rbx, word64 rbp, struct Eq_636 * rsi, word32 edi, word64 r8, word64 r9, word64 r12, word64 r13, struct Eq_253 * fs)
{
	word64 rax_13 = fs->qw0028;
	if (edi != 0x04)
	{
		fwrite(&globals->v401A70, 0x01, 0x27, globals->ptr602100);
		goto l000000000040175D;
	}
	char * rax_27 = rsi->ptr0008;
	uint64 rax_30 = DPB(rax_27, atol(rax_27), 0);
	char * rax_34 = rsi->ptr0010;
	uint64 rax_37 = DPB(rax_34, atol(rax_34), 0);
	FILE * rax_44 = fopen(rsi->ptr0018, "rb");
	word64 qwLoc48_667 = 0x00;
	if (rax_44 == null)
	{
		fprintf(globals->ptr602100, "pngpixel: %s: could not open file\n", rsi->ptr0018);
		goto l000000000040175D;
	}
	word64 rsi_63;
	word64 rax_64;
	word64 rcx_65;
	word64 rdx_66;
	word64 r9_68;
	word64 r8_70;
	png_create_read_struct();
	if (rax_64 == 0x00)
	{
		fwrite(&globals->v401A18, 0x01, 0x2E, globals->ptr602100);
		goto l000000000040175D;
	}
	FILE * rcx_193;
	word64 rax_87;
	word64 rcx_88;
	word64 r9_188;
	word64 r8_189;
	png_create_info_struct();
	if (rax_87 != 0x00)
	{
		word64 rcx_105;
		word64 r9_107;
		word64 r8_108;
		png_init_io();
		word64 rcx_117;
		word64 r9_119;
		word64 r8_120;
		png_read_info();
		word64 rax_128;
		word64 rcx_129;
		word64 r9_131;
		word64 r8_132;
		png_get_rowbytes();
		word64 rax_140;
		png_malloc();
		word64 rax_169;
		word64 rsi_168;
		word64 rcx_170;
		word64 rdx_171;
		word64 r9_172;
		word64 r8_173;
		png_get_IHDR();
		qwLoc48_667 = rax_140;
		qwLoc18 = rax_140;
		qwLocB8 = fp - 0x70;
		qwLocC0 = fp - 116;
		qwLocC8 = fp - 0x78;
		if ((word32) rax_169 != 0x00)
		{
			word32 eax_199 = (word32) (uint64) dwLoc78;
			if (eax_199 != 0x00)
			{
				if (eax_199 != 0x01)
					png_error();
				else
					dwLoc6C = 0x07;
			}
			else
				dwLoc6C = 0x01;
			uint64 rcx_229;
			word64 r9_233;
			word64 r8_235;
			png_start_read_image();
			dwLoc68 = 0x00;
			while ((word32) (uint64) dwLoc68 < dwLoc6C)
			{
				if ((word32) (uint64) dwLoc78 == 0x01)
				{
					word32 eax_274;
					if (dwLoc68 > 0x01)
						eax_274 = (word32) (uint64) ((word32) (uint64) (word32) (uint64) (0x01 << (byte) ((uint64) ((word32) ((uint64) ((word32) ((uint64) (0x07 - dwLoc68)) >> 0x01))))) - 0x01);
					else
						eax_274 = 0x07;
					word32 eax_321;
					uint32 edx_327 = (word32) (uint64) (word32) (uint64) ((word32) (uint64) (eax_274 - (word32) ((uint64) ((word32) ((uint64) ((word32) ((uint64) ((word32) ((uint64) ((word32) ((uint64) ((word32) ((uint64) dwLoc68))) & 0x01)) << (byte) ((uint64) ((word32) ((uint64) ((word32) ((uint64) (0x03 - (word32) ((uint64) ((word32) ((uint64) ((word32) ((uint64) dwLoc68) + 0x01)) >> 0x01)))))))))))) & 0x07))) + dwLoc88);
					if (dwLoc68 > 0x01)
						eax_321 = (word32) (uint64) ((word32) (uint64) (0x07 - dwLoc68) >> 0x01);
					else
						eax_321 = 0x03;
					rcx_229 = (uint64) eax_321;
					if ((word32) (uint64) (word32) (uint64) (edx_327 >> (byte) rcx_229) == 0x00)
						goto l000000000040166F;
					word32 eax_424;
					rcx_229 = (uint64) (word32) (uint64) ((word32) (uint64) (0x07 - dwLoc68) >> 0x01);
					dwLoc60 = (word32) (uint64) ((word32) (uint64) (word32) (uint64) ((word32) (uint64) (word32) (uint64) ((word32) (uint64) dwLoc68 & 0x01) << (byte) ((uint64) ((word32) ((uint64) ((word32) ((uint64) (0x03 - (word32) ((uint64) ((word32) ((uint64) ((word32) ((uint64) dwLoc68) + 0x01)) >> 0x01))))))))) & 0x07);
					dwLoc64 = (word32) (uint64) ((word32) (uint64) (word32) (uint64) ((word32) ((word32) (uint64) ((word32) (uint64) dwLoc68 & 0x01) == 0x00) << (byte) ((uint64) ((word32) ((uint64) ((word32) ((uint64) (0x03 - (word32) ((uint64) ((word32) ((uint64) dwLoc68) >> 0x01))))))))) & 0x07);
					dwLoc58 = (word32) (uint64) (word32) (uint64) (0x01 << (byte) rcx_229);
					if (dwLoc68 > 0x02)
					{
						rcx_229 = (uint64) (word32) (uint64) ((word32) (uint64) ((word32) (uint64) dwLoc68 - 0x01) >> 0x01);
						eax_424 = (word32) (uint64) (word32) (uint64) (0x08 >> (byte) rcx_229);
					}
					else
						eax_424 = 0x08;
					dwLoc5C = eax_424;
				}
				else
				{
					dwLoc60 = 0x00;
					dwLoc64 = 0x00;
					dwLoc58 = 0x01;
					dwLoc5C = 0x01;
				}
				for (dwLoc54 = (word32) (uint64) dwLoc64; dwLoc54 < (word32) ((uint64) dwLoc84); dwLoc54 += (word32) (uint64) dwLoc5C)
				{
					puts("png_read_row");
					png_read_row();
					if ((uint64) dwLoc54 == rax_37)
					{
						dwLoc4C = 0x00;
						for (dwLoc50 = (word32) (uint64) dwLoc60; dwLoc50 < (word32) ((uint64) dwLoc88); dwLoc50 += (word32) (uint64) dwLoc58)
						{
							if ((uint64) dwLoc50 == rax_30)
							{
								rcx_229 = print_pixel((uint64) dwLoc4C, rax_140, rbx, fp - 0x08, rax_87, rax_64, r8_235, r9_233, r12, r13, fs, out r8_235, out r9_233);
								goto l000000000040167F;
							}
							++dwLoc4C;
						}
					}
				}
l000000000040166F:
				++dwLoc68;
			}
l000000000040167F:
			word64 rcx_548;
			word64 r9_555;
			word64 r8_561;
			png_free();
			png_destroy_info_struct();
			qwLoc48_667 = 0x00;
l00000000004016DE:
			png_destroy_read_struct();
l000000000040175D:
			if ((rax_13 ^ fs->qw0028) == 0x00)
				return;
			__stack_chk_fail();
		}
		png_error();
	}
	FILE * rax_192 = globals->ptr602100;
	fwrite(&globals->v4019E8, 0x01, 44, rax_192);
	rcx_193 = rax_192;
	goto l00000000004016DE;
}

// 0000000000401780: void __libc_csu_init(Register word64 rdx, Register word64 rbx, Register word64 rbp, Register word64 rsi, Register word32 edi, Register word64 r12, Register word64 r13, Register word64 r14, Register word64 r15)
void __libc_csu_init(word64 rdx, word64 rbx, word64 rbp, word64 rsi, word32 edi, word64 r12, word64 r13, word64 r14, word64 r15)
{
	word32 r15d_83 = (word32) (uint64) edi;
	int64 rbp_29 = 0x00601E08 - 0x00601E00;
	word64 rax_33 = _init();
	if (rbp_29 >> 0x03 != 0x00)
	{
		Eq_1094 rbx_41 = 0x00;
		do
		{
			(*((char *) globals->a601E00 + rbx_41 * 0x08))();
			rbx_41 = (word64) rbx_41.u1 + 0x01;
		} while (rbx_41 != rbp_29 >> 0x03);
	}
}

// 00000000004017F0: void __libc_csu_fini()
void __libc_csu_fini()
{
}

// 00000000004017F4: void _fini()
void _fini()
{
}

