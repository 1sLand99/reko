// nbody_text.c
// Generated by decompiling nbody.wasm
// using Reko decompiler version 0.11.4.0.

#include "nbody.h"

// 000E0000: void _advance(Stack int32 arg0, Stack (ptr32 Eq_n) arg1, Stack real64 arg2)
void _advance(int32 arg0, struct Eq_n * arg1, real64 arg2)
{
	if (arg0 <= 0x00)
		return;
	int32 loc3_n = 0x00;
	while (true)
	{
		int32 v19_n = loc3_n + 0x01;
		if (v19_n < arg0)
		{
			do
			{
				real64 v24_n = arg1[loc3_n * 0x38 / 0x0118] - arg1[(v19_n * 0x38) / 0x0118];
				real64 v27_n = (&(arg1 + (loc3_n * 0x38) / 0x0118)->a0000[0].r0000)[1] - (&(((arg1 + (v19_n * 0x38) / 0x0118)->a0000))[0].r0000)[1];
				real64 v27_n = (&(arg1 + (loc3_n * 0x38) / 0x0118)->a0000[0].r0000)[2] - (&(((arg1 + (v19_n * 0x38) / 0x0118)->a0000))[0].r0000)[2];
				real64 v23_n = (arg1 + (loc3_n * 0x38) / 0x0118)->r0030;
				real64 v24_n = sqrt(v24_n * v24_n + v27_n * v27_n + v27_n * v27_n);
				struct Eq_n * v19_n = arg1 + (loc3_n * 0x38) / 0x0118;
				real64 v29_n = (arg1 + (v19_n * 0x38) / 0x0118)->r0030;
				real64 v23_n = arg2 / (v24_n * (v24_n * v24_n));
				v19_n->r0018 -= v24_n * v29_n * v23_n;
				struct Eq_n * v19_n = arg1 + (loc3_n * 0x38) / 0x0118;
				v19_n->r0020 -= v23_n * (v27_n * v29_n);
				struct Eq_n * v19_n = arg1 + (loc3_n * 0x38) / 0x0118;
				v19_n->r0028 -= v23_n * (v27_n * v29_n);
				struct Eq_n * v19_n = arg1 + (v19_n * 0x38) / 0x0118;
				v19_n->r0018 += v23_n * (v24_n * v23_n);
				struct Eq_n * v19_n = arg1 + (v19_n * 0x38) / 0x0118;
				v19_n->r0020 += v23_n * (v27_n * v23_n);
				struct Eq_n * v19_n = arg1 + (v19_n * 0x38) / 0x0118;
				v19_n->r0028 += v23_n * (v27_n * v23_n);
				loc3_n = v19_n + 0x01;
			} while (v19_n + 0x01 != arg0);
		}
		if (v19_n == arg0)
			break;
		loc3_n = v19_n;
	}
	if (arg0 <= 0x00)
		return;
	int32 loc4_n = 0x00;
	do
	{
		real64 * v19_n = arg1 + (loc4_n * 0x38) / 0x0118;
		*v19_n += (arg1 + (loc4_n * 0x38) / 0x0118)->r0018 * arg2;
		struct Eq_n * v19_n = arg1 + (loc4_n * 0x38) / 0x0118;
		v19_n->r0008 += (arg1 + (loc4_n * 0x38) / 0x0118)->r0020 * arg2;
		struct Eq_n * v19_n = arg1 + (loc4_n * 0x38) / 0x0118;
		v19_n->r0010 += (arg1 + (loc4_n * 0x38) / 0x0118)->r0028 * arg2;
		int32 v19_n = loc4_n + 0x01;
		loc4_n = v19_n;
	} while (v19_n != arg0);
}

// 000E020A: Stack real64 _energy(Stack int32 arg0, Stack (arr Eq_n) arg1)
real64 _energy(int32 arg0, Eq_n arg1[])
{
	if (arg0 <= 0x00)
		return 0.0;
	int32 loc2_n = 0x00;
	real64 loc4_n = 0.0;
	while (true)
	{
		real64 v17_n = (&(arg1 + loc2_n)->r0000)[3];
		real64 v19_n = (&(arg1 + loc2_n)->r0000)[4];
		real64 v19_n = (&(arg1 + loc2_n)->r0000)[5];
		real64 v16_n = (&(arg1 + loc2_n)->r0000)[6];
		int32 v10_n = loc2_n + 0x01;
		loc4_n += v16_n * 0.5 * ((v17_n * v17_n + v19_n * v19_n) + v19_n * v19_n);
		if (v10_n < arg0)
		{
			do
			{
				real64 v17_n = arg1[loc2_n].r0000 - (arg1)[v10_n].r0000;
				real64 v19_n = (&(arg1 + loc2_n)->r0000)[1] - (&(arg1 + v10_n)->r0000)[1];
				real64 v19_n = (&(arg1 + loc2_n)->r0000)[2] - (&(arg1 + v10_n)->r0000)[2];
				loc4_n -= v16_n * (&(arg1 + v10_n)->r0000)[6] / sqrt((v17_n * v17_n + v19_n * v19_n) + v19_n * v19_n);
				loc2_n = v10_n + 0x01;
			} while (v10_n + 0x01 != arg0);
		}
		if (v10_n == arg0)
			break;
		loc2_n = v10_n;
	}
	return loc4_n;
}

// 000E0329: void _offset_momentum(Stack int32 arg0, Stack (ptr32 Eq_n) arg1)
void _offset_momentum(int32 arg0, struct Eq_n * arg1)
{
	real64 loc3_n;
	real64 loc4_n;
	real64 loc5_n;
	if (arg0 > 0x00)
	{
		do
		{
			real64 v16_n = arg1->r0030;
			loc5_n = arg1->r0018 * v16_n + 0.0;
			loc4_n = v16_n * arg1->r0020 + 0.0;
			loc3_n = v16_n * arg1->r0028 + 0.0;
		} while (arg0 != 0x01);
	}
	else
	{
		loc3_n = 0.0;
		loc4_n = 0.0;
		loc5_n = 0.0;
	}
	arg1->r0018 = -loc5_n / 39.47841760435743;
	arg1->r0020 = -loc4_n / 39.47841760435743;
	arg1->r0028 = -loc3_n / 39.47841760435743;
}

// 000E0405: Stack real64 _start()
real64 _start()
{
	do
	{
		real64 v13_n = g_ptr100000->r0030;
		real64 v15_n = g_ptr100000->r0068;
		real64 v15_n = g_ptr100000->r00A0;
		real64 v15_n = g_ptr100000->r00D8;
		real64 v15_n = g_ptr100000->r0110;
		real64 v13_n = v13_n * g_ptr100000->r0020 + 0.0 + v15_n * g_ptr100000->r0058 + v15_n * g_ptr100000->r0090 + v15_n * g_ptr100000->r00C8 + v15_n * g_ptr100000->r0100;
		real64 v13_n = v13_n * g_ptr100000->r0028 + 0.0 + v15_n * g_ptr100000->r0060 + v15_n * g_ptr100000->r0098 + v15_n * g_ptr100000->r00D0 + v15_n * g_ptr100000->r0108;
		g_ptr100000->r0018 = -(g_ptr100000->r0018 * v13_n + 0.0 + g_ptr100000->r0050 * v15_n + g_ptr100000->r0088 * v15_n + g_ptr100000->r00C0 * v15_n + g_ptr100000->r00F8 * v15_n) / 39.47841760435743;
		g_ptr100000->r0020 = -v13_n / 39.47841760435743;
		g_ptr100000->r0028 = -v13_n / 39.47841760435743;
		while (true)
			;
	} while (true);
	return <invalid>;
}

// 000E061E: Stack real64 _run(Stack int32 arg0)
real64 _run(int32 arg0)
{
	int32 arg0_n;
	if (arg0 < 0x01)
		arg0_n = 0x00;
	else
	{
		do
			_advance(0x05, g_ptr100000, 0.01);
		while (arg0 != 0x01);
		arg0_n = 0x00;
	}
	while (true)
	{
		int32 v10_n = arg0_n + 0x01;
		if (v10_n < 0x05)
		{
			do
				;
			while (v10_n != ~0x03);
		}
		if (v10_n == 0x05)
			break;
		arg0_n = v10_n;
	}
	return <invalid>;
}

// 000E076E: void runPostSets()
void runPostSets()
{
}

// 000E0770: void __post_instantiate()
void __post_instantiate()
{
	g_ptr100008 = &g_ptr100000->r0110 + 2;
	g_dw10000C = g_ptr100008 + 0x00500000;
	runPostSets();
}

