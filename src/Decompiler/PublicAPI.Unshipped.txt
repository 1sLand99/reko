abstract Reko.Analysis.DataFlow.Emit(Reko.Core.IProcessorArchitecture! arch, System.IO.TextWriter! sb) -> void
abstract Reko.Analysis.InstructionUseVisitorBase.UseIdentifier(Reko.Core.Expressions.Identifier! id) -> void
abstract Reko.Analysis.SsaTransform.IdentifierTransformer.ReadBlockLocalVariable(Reko.Analysis.SsaTransform.SsaBlockState! bs) -> Reko.Analysis.SsaIdentifier?
abstract Reko.Analysis.SsaTransform.IdentifierTransformer.WriteVariable(Reko.Analysis.SsaTransform.SsaBlockState! bs, Reko.Analysis.SsaIdentifier! sid) -> Reko.Core.Expressions.Identifier!
abstract Reko.Loading.SignatureLoader.Load(string! filename) -> System.Collections.Generic.IEnumerable<Reko.Loading.ImageSignature!>!
abstract Reko.Scanning.StringSearch<TSymbol>.GetMatchPositions(TSymbol[]! stringToSearch) -> System.Collections.Generic.IEnumerable<int>!
abstract Reko.Scanning.ValueSet.Add(Reko.Core.Expressions.Constant! right) -> Reko.Scanning.ValueSet!
abstract Reko.Scanning.ValueSet.Add(Reko.Scanning.ValueSet! right) -> Reko.Scanning.ValueSet!
abstract Reko.Scanning.ValueSet.And(Reko.Core.Expressions.Constant! cRight) -> Reko.Scanning.ValueSet!
abstract Reko.Scanning.ValueSet.IMul(Reko.Core.Expressions.Constant! cRight) -> Reko.Scanning.ValueSet!
abstract Reko.Scanning.ValueSet.IsEmpty.get -> bool
abstract Reko.Scanning.ValueSet.Shl(Reko.Core.Expressions.Constant! cRight) -> Reko.Scanning.ValueSet!
abstract Reko.Scanning.ValueSet.SignExtend(Reko.Core.Types.DataType! dataType) -> Reko.Scanning.ValueSet!
abstract Reko.Scanning.ValueSet.Sub(Reko.Core.Expressions.Constant! cRight) -> Reko.Scanning.ValueSet!
abstract Reko.Scanning.ValueSet.Truncate(Reko.Core.Types.DataType! dt) -> Reko.Scanning.ValueSet!
abstract Reko.Scanning.ValueSet.Values.get -> System.Collections.Generic.IEnumerable<Reko.Core.Expressions.Expression!>!
abstract Reko.Scanning.ValueSet.ZeroExtend(Reko.Core.Types.DataType! dataType) -> Reko.Scanning.ValueSet!
abstract Reko.Scanning.WorkItem.Process() -> void
override Reko.Analysis.CallApplicationBuilder.Bind(Reko.Core.Expressions.Identifier! id) -> Reko.Core.Expressions.Expression?
override Reko.Analysis.CallApplicationBuilder.BindOutArg(Reko.Core.Expressions.Identifier! id) -> Reko.Core.Expressions.OutArgument!
override Reko.Analysis.CallApplicationBuilder.BindReturnValue(Reko.Core.Expressions.Identifier! id) -> Reko.Core.Expressions.Expression?
override Reko.Analysis.ComplexStackVariableTransformer.TransformCallInstruction(Reko.Core.Code.CallInstruction! ci) -> Reko.Core.Code.Instruction!
override Reko.Analysis.ComplexStackVariableTransformer.VisitBinaryExpression(Reko.Core.Expressions.BinaryExpression! bin) -> Reko.Core.Expressions.Expression!
override Reko.Analysis.ConditionCodeEliminator.TransformAssignment(Reko.Core.Code.Assignment! a) -> Reko.Core.Code.Instruction!
override Reko.Analysis.ConditionCodeEliminator.VisitTestCondition(Reko.Core.Expressions.TestCondition! tc) -> Reko.Core.Expressions.Expression!
override Reko.Analysis.DeadCode.VisitAssignment(Reko.Core.Code.Assignment! a) -> void
override Reko.Analysis.DeadCode.VisitCallInstruction(Reko.Core.Code.CallInstruction! ci) -> void
override Reko.Analysis.DeadCode.VisitIdentifier(Reko.Core.Expressions.Identifier! id) -> void
override Reko.Analysis.DeadCode.VisitStore(Reko.Core.Code.Store! store) -> void
override Reko.Analysis.EscapedFrameIntervalsFinder.VisitApplication(Reko.Core.Expressions.Application! appl) -> void
override Reko.Analysis.ExpressionIdentifierUseFinder.VisitIdentifier(Reko.Core.Expressions.Identifier! id) -> void
override Reko.Analysis.ExpressionIdentifierUseFinder.VisitOutArgument(Reko.Core.Expressions.OutArgument! outArg) -> void
override Reko.Analysis.ExpressionUseRemover.VisitIdentifier(Reko.Core.Expressions.Identifier! id) -> void
override Reko.Analysis.GrfDefinitionFinder.VisitApplication(Reko.Core.Expressions.Application! appl) -> void
override Reko.Analysis.GrfDefinitionFinder.VisitAssignment(Reko.Core.Code.Assignment! a) -> void
override Reko.Analysis.GrfDefinitionFinder.VisitBinaryExpression(Reko.Core.Expressions.BinaryExpression! binExp) -> void
override Reko.Analysis.GrfDefinitionFinder.VisitCallInstruction(Reko.Core.Code.CallInstruction! ci) -> void
override Reko.Analysis.GrfDefinitionFinder.VisitConditionOf(Reko.Core.Expressions.ConditionOf! cof) -> void
override Reko.Analysis.GrfDefinitionFinder.VisitDefInstruction(Reko.Core.Code.DefInstruction! def) -> void
override Reko.Analysis.GrfDefinitionFinder.VisitIdentifier(Reko.Core.Expressions.Identifier! id) -> void
override Reko.Analysis.GrfDefinitionFinder.VisitPhiFunction(Reko.Core.Expressions.PhiFunction! phi) -> void
override Reko.Analysis.GrfDefinitionFinder.VisitUnaryExpression(Reko.Core.Expressions.UnaryExpression! unary) -> void
override Reko.Analysis.IdentifierReplacer.TransformAssignment(Reko.Core.Code.Assignment! a) -> Reko.Core.Code.Instruction!
override Reko.Analysis.IdentifierReplacer.TransformCallInstruction(Reko.Core.Code.CallInstruction! ci) -> Reko.Core.Code.Instruction!
override Reko.Analysis.IdentifierReplacer.TransformPhiAssignment(Reko.Core.Code.PhiAssignment! phi) -> Reko.Core.Code.Instruction!
override Reko.Analysis.IdentifierReplacer.VisitIdentifier(Reko.Core.Expressions.Identifier! id) -> Reko.Core.Expressions.Expression!
override Reko.Analysis.InstructionUseAdder.UseIdentifier(Reko.Core.Expressions.Identifier! id) -> void
override Reko.Analysis.InstructionUseCollector.UseIdentifier(Reko.Core.Expressions.Identifier! id) -> void
override Reko.Analysis.InstructionUseVisitorBase.VisitAssignment(Reko.Core.Code.Assignment! a) -> void
override Reko.Analysis.InstructionUseVisitorBase.VisitCallInstruction(Reko.Core.Code.CallInstruction! ci) -> void
override Reko.Analysis.InstructionUseVisitorBase.VisitDeclaration(Reko.Core.Code.Declaration! decl) -> void
override Reko.Analysis.InstructionUseVisitorBase.VisitDefInstruction(Reko.Core.Code.DefInstruction! def) -> void
override Reko.Analysis.InstructionUseVisitorBase.VisitIdentifier(Reko.Core.Expressions.Identifier! id) -> void
override Reko.Analysis.InstructionUseVisitorBase.VisitOutArgument(Reko.Core.Expressions.OutArgument! outArg) -> void
override Reko.Analysis.InstructionUseVisitorBase.VisitPhiAssignment(Reko.Core.Code.PhiAssignment! phi) -> void
override Reko.Analysis.InstructionUseVisitorBase.VisitStore(Reko.Core.Code.Store! store) -> void
override Reko.Analysis.Interference.Equals(object? obj) -> bool
override Reko.Analysis.Interference.GetHashCode() -> int
override Reko.Analysis.LinearInductionVariableFinder.SsaGraph.VisitAssignment(Reko.Core.Code.Assignment! a) -> void
override Reko.Analysis.LinearInductionVariableFinder.SsaGraph.VisitIdentifier(Reko.Core.Expressions.Identifier! id) -> void
override Reko.Analysis.LinearInductionVariableFinder.SsaGraph.VisitMemoryAccess(Reko.Core.Expressions.MemoryAccess! access) -> void
override Reko.Analysis.LinearInductionVariableFinder.SsaGraph.VisitSideEffect(Reko.Core.Code.SideEffect! side) -> void
override Reko.Analysis.LinearInductionVariableFinder.VisitAssignment(Reko.Core.Code.Assignment! a) -> void
override Reko.Analysis.LinearInductionVariableFinder.VisitIdentifier(Reko.Core.Expressions.Identifier! id) -> void
override Reko.Analysis.LinearInductionVariableFinder.VisitMemoryAccess(Reko.Core.Expressions.MemoryAccess! access) -> void
override Reko.Analysis.LinearInductionVariableFinder.VisitSideEffect(Reko.Core.Code.SideEffect! side) -> void
override Reko.Analysis.LiveCopyInserter.DominatedUseRenamer.VisitIdentifier(Reko.Core.Expressions.Identifier! id) -> Reko.Core.Expressions.Expression!
override Reko.Analysis.LocalTypeDescender.TypeVar(Reko.Core.Expressions.Expression! exp) -> Reko.Core.Types.TypeVariable!
override Reko.Analysis.ProcedureFlow.Emit(Reko.Core.IProcessorArchitecture! arch, System.IO.TextWriter! writer) -> void
override Reko.Analysis.SegmentedAccessClassifier.VisitSegmentedAccess(Reko.Core.Expressions.SegmentedAccess! access) -> void
override Reko.Analysis.SequenceIdentifierGenerator.TransformAssignment(Reko.Core.Code.Assignment! ass) -> Reko.Core.Code.Instruction!
override Reko.Analysis.SequenceIdentifierGenerator.VisitMkSequence(Reko.Core.Expressions.MkSequence! seq) -> Reko.Core.Expressions.Expression!
override Reko.Analysis.SideEffectFinder.VisitApplication(Reko.Core.Expressions.Application! appl) -> void
override Reko.Analysis.SideEffectFinder.VisitBranch(Reko.Core.Code.Branch! b) -> void
override Reko.Analysis.SideEffectFinder.VisitMemoryAccess(Reko.Core.Expressions.MemoryAccess! access) -> void
override Reko.Analysis.SideEffectFinder.VisitSegmentedAccess(Reko.Core.Expressions.SegmentedAccess! access) -> void
override Reko.Analysis.SideEffectFinder.VisitStore(Reko.Core.Code.Store! store) -> void
override Reko.Analysis.SsaDefinitionsCollector.VisitAssignment(Reko.Core.Code.Assignment! a) -> void
override Reko.Analysis.SsaDefinitionsCollector.VisitCallInstruction(Reko.Core.Code.CallInstruction! ci) -> void
override Reko.Analysis.SsaDefinitionsCollector.VisitDefInstruction(Reko.Core.Code.DefInstruction! def) -> void
override Reko.Analysis.SsaDefinitionsCollector.VisitOutArgument(Reko.Core.Expressions.OutArgument! outArg) -> void
override Reko.Analysis.SsaDefinitionsCollector.VisitPhiAssignment(Reko.Core.Code.PhiAssignment! phi) -> void
override Reko.Analysis.SsaDefinitionsCollector.VisitStore(Reko.Core.Code.Store! store) -> void
override Reko.Analysis.SsaIdentifier.ToString() -> string!
override Reko.Analysis.SsaTransform.FlagGroupTransformer.ReadBlockLocalVariable(Reko.Analysis.SsaTransform.SsaBlockState! bs) -> Reko.Analysis.SsaIdentifier?
override Reko.Analysis.SsaTransform.FlagGroupTransformer.WriteVariable(Reko.Analysis.SsaTransform.SsaBlockState! bs, Reko.Analysis.SsaIdentifier! sid) -> Reko.Core.Expressions.Identifier!
override Reko.Analysis.SsaTransform.RegisterTransformer.ReadBlockLocalVariable(Reko.Analysis.SsaTransform.SsaBlockState! bs) -> Reko.Analysis.SsaIdentifier?
override Reko.Analysis.SsaTransform.RegisterTransformer.WriteVariable(Reko.Analysis.SsaTransform.SsaBlockState! bs, Reko.Analysis.SsaIdentifier! sid) -> Reko.Core.Expressions.Identifier!
override Reko.Analysis.SsaTransform.SequenceTransformer.ReadBlockLocalVariable(Reko.Analysis.SsaTransform.SsaBlockState! bs) -> Reko.Analysis.SsaIdentifier!
override Reko.Analysis.SsaTransform.SequenceTransformer.ReadVariable(Reko.Analysis.SsaTransform.SsaBlockState! bs) -> Reko.Analysis.SsaIdentifier!
override Reko.Analysis.SsaTransform.SequenceTransformer.WriteVariable(Reko.Analysis.SsaTransform.SsaBlockState! bs, Reko.Analysis.SsaIdentifier! sid) -> Reko.Core.Expressions.Identifier!
override Reko.Analysis.SsaTransform.SimpleTransformer.ReadBlockLocalVariable(Reko.Analysis.SsaTransform.SsaBlockState! bs) -> Reko.Analysis.SsaIdentifier?
override Reko.Analysis.SsaTransform.SimpleTransformer.WriteVariable(Reko.Analysis.SsaTransform.SsaBlockState! bs, Reko.Analysis.SsaIdentifier! sid) -> Reko.Core.Expressions.Identifier!
override Reko.Analysis.SsaTransform.SsaBlockState.ToString() -> string!
override Reko.Analysis.SsaTransform.StackTransformer.ReadBlockLocalVariable(Reko.Analysis.SsaTransform.SsaBlockState! bs) -> Reko.Analysis.SsaIdentifier?
override Reko.Analysis.SsaTransform.StackTransformer.WriteVariable(Reko.Analysis.SsaTransform.SsaBlockState! bs, Reko.Analysis.SsaIdentifier! sid) -> Reko.Core.Expressions.Identifier!
override Reko.Analysis.SsaTransform.TransformAssignment(Reko.Core.Code.Assignment! a) -> Reko.Core.Code.Instruction!
override Reko.Analysis.SsaTransform.TransformCallInstruction(Reko.Core.Code.CallInstruction! ci) -> Reko.Core.Code.Instruction!
override Reko.Analysis.SsaTransform.TransformDefInstruction(Reko.Core.Code.DefInstruction! def) -> Reko.Core.Code.Instruction!
override Reko.Analysis.SsaTransform.TransformStore(Reko.Core.Code.Store! store) -> Reko.Core.Code.Instruction!
override Reko.Analysis.SsaTransform.TransformUseInstruction(Reko.Core.Code.UseInstruction! u) -> Reko.Core.Code.Instruction!
override Reko.Analysis.SsaTransform.VisitApplication(Reko.Core.Expressions.Application! appl) -> Reko.Core.Expressions.Expression!
override Reko.Analysis.SsaTransform.VisitBinaryExpression(Reko.Core.Expressions.BinaryExpression! binExp) -> Reko.Core.Expressions.Expression!
override Reko.Analysis.SsaTransform.VisitIdentifier(Reko.Core.Expressions.Identifier! id) -> Reko.Core.Expressions.Expression!
override Reko.Analysis.SsaTransform.VisitMemoryAccess(Reko.Core.Expressions.MemoryAccess! access) -> Reko.Core.Expressions.Expression!
override Reko.Analysis.SsaTransform.VisitOutArgument(Reko.Core.Expressions.OutArgument! outArg) -> Reko.Core.Expressions.Expression!
override Reko.Analysis.SsaTransform.VisitSegmentedAccess(Reko.Core.Expressions.SegmentedAccess! access) -> Reko.Core.Expressions.Expression!
override Reko.Analysis.StrengthReduction.IncrementedUseFinder.VisitBinaryExpression(Reko.Core.Expressions.BinaryExpression! binExp) -> void
override Reko.Analysis.StrengthReduction.IncrementedUseFinder.VisitIdentifier(Reko.Core.Expressions.Identifier! id) -> void
override Reko.Analysis.UnalignedMemoryAccessFuser.VisitAssignment(Reko.Core.Code.Assignment! a) -> void
override Reko.Analysis.WebBuilder.OutDefinitionFinder.VisitOutArgument(Reko.Core.Expressions.OutArgument! outArg) -> void
override Reko.Loading.FlirtoidSignatureLoader.Load(string! filename) -> System.Collections.Generic.IEnumerable<Reko.Loading.ImageSignature!>!
override Reko.Loading.NullImageLoader.LoadProgram(Reko.Core.Address? addrLoad) -> Reko.Core.Program!
override Reko.Loading.NullImageLoader.LoadProgram(Reko.Core.Address! addrLoad, Reko.Core.IProcessorArchitecture! arch, Reko.Core.IPlatform! platform) -> Reko.Core.Program!
override Reko.Loading.NullImageLoader.PreferredBaseAddress.get -> Reko.Core.Address!
override Reko.Loading.NullImageLoader.PreferredBaseAddress.set -> void
override Reko.Loading.UnpackerSignatureLoader.Load(string! filename) -> System.Collections.Generic.IEnumerable<Reko.Loading.ImageSignature!>!
~override Reko.Scanning.AhoCorasickSearch2<TSymbol>.GetMatchPositions(TSymbol[] stringToSearch) -> System.Collections.Generic.IEnumerable<int>
~override Reko.Scanning.AhoCorasickSearch<TSymbol>.GetMatchPositions(TSymbol[] text) -> System.Collections.Generic.IEnumerable<int>
override Reko.Scanning.BackwalkBranch.Apply(int limit) -> int
override Reko.Scanning.BackwalkBranch.ToString() -> string!
override Reko.Scanning.BackwalkDereference.ToString() -> string!
override Reko.Scanning.BackwalkError.ToString() -> string!
override Reko.Scanning.BackwalkOperation.ToString() -> string!
override Reko.Scanning.BackwardSlicerContext.ToString() -> string!
override Reko.Scanning.BlockWorkitem.Process() -> void
override Reko.Scanning.BlockWorkitem.ToString() -> string!
override Reko.Scanning.ConcreteValueSet.Add(Reko.Core.Expressions.Constant! cRight) -> Reko.Scanning.ValueSet!
override Reko.Scanning.ConcreteValueSet.Add(Reko.Scanning.ValueSet! right) -> Reko.Scanning.ValueSet!
override Reko.Scanning.ConcreteValueSet.And(Reko.Core.Expressions.Constant! right) -> Reko.Scanning.ValueSet!
override Reko.Scanning.ConcreteValueSet.IMul(Reko.Core.Expressions.Constant! cRight) -> Reko.Scanning.ValueSet!
override Reko.Scanning.ConcreteValueSet.IsEmpty.get -> bool
override Reko.Scanning.ConcreteValueSet.Shl(Reko.Core.Expressions.Constant! cRight) -> Reko.Scanning.ValueSet!
override Reko.Scanning.ConcreteValueSet.SignExtend(Reko.Core.Types.DataType! dt) -> Reko.Scanning.ValueSet!
override Reko.Scanning.ConcreteValueSet.Sub(Reko.Core.Expressions.Constant! cRight) -> Reko.Scanning.ValueSet!
override Reko.Scanning.ConcreteValueSet.ToString() -> string!
override Reko.Scanning.ConcreteValueSet.Truncate(Reko.Core.Types.DataType! dt) -> Reko.Scanning.ValueSet!
override Reko.Scanning.ConcreteValueSet.Values.get -> System.Collections.Generic.IEnumerable<Reko.Core.Expressions.Expression!>!
override Reko.Scanning.ConcreteValueSet.ZeroExtend(Reko.Core.Types.DataType! dt) -> Reko.Scanning.ValueSet!
override Reko.Scanning.EscapedAccessRewriter.TransformAssignment(Reko.Core.Code.Assignment! a) -> Reko.Core.Code.Instruction!
override Reko.Scanning.EscapedAccessRewriter.TransformStore(Reko.Core.Code.Store! store) -> Reko.Core.Code.Instruction!
override Reko.Scanning.EscapedAccessRewriter.VisitIdentifier(Reko.Core.Expressions.Identifier! id) -> Reko.Core.Expressions.Expression!
override Reko.Scanning.GlobalDataWorkItem.Process() -> void
override Reko.Scanning.IdentifierRelocator.VisitIdentifier(Reko.Core.Expressions.Identifier! id) -> Reko.Core.Expressions.Expression!
override Reko.Scanning.ImageSymbolWorkItem.Process() -> void
override Reko.Scanning.ImageSymbolWorkItem.ToString() -> string!
override Reko.Scanning.IntervalValueSet.Add(Reko.Core.Expressions.Constant! right) -> Reko.Scanning.ValueSet!
override Reko.Scanning.IntervalValueSet.Add(Reko.Scanning.ValueSet! right) -> Reko.Scanning.ValueSet!
override Reko.Scanning.IntervalValueSet.And(Reko.Core.Expressions.Constant! right) -> Reko.Scanning.ValueSet!
override Reko.Scanning.IntervalValueSet.IMul(Reko.Core.Expressions.Constant! cRight) -> Reko.Scanning.ValueSet!
override Reko.Scanning.IntervalValueSet.IsEmpty.get -> bool
override Reko.Scanning.IntervalValueSet.Shl(Reko.Core.Expressions.Constant! cRight) -> Reko.Scanning.ValueSet!
override Reko.Scanning.IntervalValueSet.SignExtend(Reko.Core.Types.DataType! dataType) -> Reko.Scanning.ValueSet!
override Reko.Scanning.IntervalValueSet.Sub(Reko.Core.Expressions.Constant! right) -> Reko.Scanning.ValueSet!
override Reko.Scanning.IntervalValueSet.ToString() -> string!
override Reko.Scanning.IntervalValueSet.Truncate(Reko.Core.Types.DataType! dt) -> Reko.Scanning.ValueSet!
override Reko.Scanning.IntervalValueSet.Values.get -> System.Collections.Generic.IEnumerable<Reko.Core.Expressions.Expression!>!
override Reko.Scanning.IntervalValueSet.ZeroExtend(Reko.Core.Types.DataType! dataType) -> Reko.Scanning.ValueSet!
override Reko.Scanning.KmpStringSearch<C>.GetMatchPositions(C[]! text) -> System.Collections.Generic.IEnumerable<int>!
override Reko.Scanning.ProcedureDetector.Cluster.ToString() -> string!
override Reko.Scanning.ProcedureWorkItem.Process() -> void
override Reko.Scanning.PromoteBlockWorkItem.Process() -> void
~override Reko.Scanning.Regexp.ToString() -> string
override Reko.Scanning.RtlBlock.ToString() -> string!
override Reko.Scanning.RtlProcedure.ToString() -> string!
~override Reko.Scanning.ScanResults.link.Equals(object obj) -> bool
override Reko.Scanning.ScanResults.link.GetHashCode() -> int
~override Reko.Scanning.ScanResults.link.ToString() -> string
override Reko.Scanning.SliceState.ToString() -> string!
override Reko.Structure.Region.ToString() -> string!
override Reko.Structure.StructureAnalysis.VirtualEdge.ToString() -> string!
override Reko.Typing.ConstantPointerAnalysis.VisitConstant(Reko.Core.Expressions.Constant! c) -> void
override Reko.Typing.EquivalenceClassBuilder.VisitAddress(Reko.Core.Address! addr) -> void
override Reko.Typing.EquivalenceClassBuilder.VisitApplication(Reko.Core.Expressions.Application! appl) -> void
override Reko.Typing.EquivalenceClassBuilder.VisitArrayAccess(Reko.Core.Expressions.ArrayAccess! acc) -> void
override Reko.Typing.EquivalenceClassBuilder.VisitAssignment(Reko.Core.Code.Assignment! a) -> void
override Reko.Typing.EquivalenceClassBuilder.VisitBinaryExpression(Reko.Core.Expressions.BinaryExpression! binExp) -> void
override Reko.Typing.EquivalenceClassBuilder.VisitCast(Reko.Core.Expressions.Cast! cast) -> void
override Reko.Typing.EquivalenceClassBuilder.VisitConditionalExpression(Reko.Core.Expressions.ConditionalExpression! cond) -> void
override Reko.Typing.EquivalenceClassBuilder.VisitConditionOf(Reko.Core.Expressions.ConditionOf! cof) -> void
override Reko.Typing.EquivalenceClassBuilder.VisitConstant(Reko.Core.Expressions.Constant! c) -> void
override Reko.Typing.EquivalenceClassBuilder.VisitConversion(Reko.Core.Expressions.Conversion! conversion) -> void
override Reko.Typing.EquivalenceClassBuilder.VisitDeclaration(Reko.Core.Code.Declaration! decl) -> void
override Reko.Typing.EquivalenceClassBuilder.VisitDefInstruction(Reko.Core.Code.DefInstruction! def) -> void
override Reko.Typing.EquivalenceClassBuilder.VisitDereference(Reko.Core.Expressions.Dereference! deref) -> void
override Reko.Typing.EquivalenceClassBuilder.VisitFieldAccess(Reko.Core.Expressions.FieldAccess! acc) -> void
override Reko.Typing.EquivalenceClassBuilder.VisitIdentifier(Reko.Core.Expressions.Identifier! id) -> void
override Reko.Typing.EquivalenceClassBuilder.VisitMemberPointerSelector(Reko.Core.Expressions.MemberPointerSelector! mps) -> void
override Reko.Typing.EquivalenceClassBuilder.VisitMemoryAccess(Reko.Core.Expressions.MemoryAccess! access) -> void
override Reko.Typing.EquivalenceClassBuilder.VisitMkSequence(Reko.Core.Expressions.MkSequence! seq) -> void
override Reko.Typing.EquivalenceClassBuilder.VisitOutArgument(Reko.Core.Expressions.OutArgument! outArg) -> void
override Reko.Typing.EquivalenceClassBuilder.VisitPhiAssignment(Reko.Core.Code.PhiAssignment! phi) -> void
override Reko.Typing.EquivalenceClassBuilder.VisitPhiFunction(Reko.Core.Expressions.PhiFunction! phi) -> void
override Reko.Typing.EquivalenceClassBuilder.VisitPointerAddition(Reko.Core.Expressions.PointerAddition! pa) -> void
override Reko.Typing.EquivalenceClassBuilder.VisitProcedureConstant(Reko.Core.Expressions.ProcedureConstant! pc) -> void
override Reko.Typing.EquivalenceClassBuilder.VisitReturnInstruction(Reko.Core.Code.ReturnInstruction! ret) -> void
override Reko.Typing.EquivalenceClassBuilder.VisitSegmentedAccess(Reko.Core.Expressions.SegmentedAccess! access) -> void
override Reko.Typing.EquivalenceClassBuilder.VisitSlice(Reko.Core.Expressions.Slice! slice) -> void
override Reko.Typing.EquivalenceClassBuilder.VisitStore(Reko.Core.Code.Store! s) -> void
override Reko.Typing.EquivalenceClassBuilder.VisitTestCondition(Reko.Core.Expressions.TestCondition! tc) -> void
override Reko.Typing.EquivalenceClassBuilder.VisitUnaryExpression(Reko.Core.Expressions.UnaryExpression! unary) -> void
override Reko.Typing.ExpressionNormalizer.VisitMemoryAccess(Reko.Core.Expressions.MemoryAccess! access) -> Reko.Core.Expressions.Expression!
override Reko.Typing.ExpressionNormalizer.VisitSegmentedAccess(Reko.Core.Expressions.SegmentedAccess! access) -> Reko.Core.Expressions.Expression!
override Reko.Typing.ExpressionTypeAscender.EnsureDataType(Reko.Core.Types.DataType! dt, Reko.Core.Expressions.Expression! exp) -> Reko.Core.Types.DataType!
override Reko.Typing.ExpressionTypeAscender.RecordDataType(Reko.Core.Types.DataType! dt, Reko.Core.Expressions.Expression! exp) -> Reko.Core.Types.DataType!
override Reko.Typing.InductionVariableCollector.DefaultValue.get -> Reko.Core.LinearInductionVariable?
override Reko.Typing.InductionVariableCollector.VisitBinaryExpression(Reko.Core.Expressions.BinaryExpression! binExp) -> Reko.Core.LinearInductionVariable?
override Reko.Typing.InductionVariableCollector.VisitIdentifier(Reko.Core.Expressions.Identifier! id) -> Reko.Core.LinearInductionVariable?
override Reko.Typing.InductionVariableCollector.VisitMemoryAccess(Reko.Core.Expressions.MemoryAccess! access) -> Reko.Core.LinearInductionVariable?
override Reko.Typing.InductionVariableCollector.VisitSegmentedAccess(Reko.Core.Expressions.SegmentedAccess! access) -> Reko.Core.LinearInductionVariable?
override Reko.Typing.NestedComplexTypeExtractor.VisitArray(Reko.Core.Types.ArrayType! at) -> Reko.Core.Types.DataType!
override Reko.Typing.NestedComplexTypeExtractor.VisitStructure(Reko.Core.Types.StructureType! str) -> Reko.Core.Types.DataType!
override Reko.Typing.NestedComplexTypeExtractor.VisitUnion(Reko.Core.Types.UnionType! ut) -> Reko.Core.Types.DataType!
override Reko.Typing.PtrPrimitiveReplacer.VisitArray(Reko.Core.Types.ArrayType! at) -> Reko.Core.Types.DataType!
override Reko.Typing.PtrPrimitiveReplacer.VisitEquivalenceClass(Reko.Core.Types.EquivalenceClass! eq) -> Reko.Core.Types.DataType!
override Reko.Typing.PtrPrimitiveReplacer.VisitStructure(Reko.Core.Types.StructureType! str) -> Reko.Core.Types.DataType!
override Reko.Typing.PtrPrimitiveReplacer.VisitTypeVariable(Reko.Core.Types.TypeVariable! tv) -> Reko.Core.Types.DataType!
override Reko.Typing.TypedExpressionRewriter.TransformAssignment(Reko.Core.Code.Assignment! a) -> Reko.Core.Code.Instruction!
override Reko.Typing.TypedExpressionRewriter.TransformCallInstruction(Reko.Core.Code.CallInstruction! ci) -> Reko.Core.Code.Instruction!
override Reko.Typing.TypedExpressionRewriter.TransformDeclaration(Reko.Core.Code.Declaration! decl) -> Reko.Core.Code.Instruction!
override Reko.Typing.TypedExpressionRewriter.TransformSideEffect(Reko.Core.Code.SideEffect! side) -> Reko.Core.Code.Instruction!
override Reko.Typing.TypedExpressionRewriter.TransformStore(Reko.Core.Code.Store! store) -> Reko.Core.Code.Instruction!
override Reko.Typing.TypedExpressionRewriter.VisitAddress(Reko.Core.Address! addr) -> Reko.Core.Expressions.Expression!
override Reko.Typing.TypedExpressionRewriter.VisitApplication(Reko.Core.Expressions.Application! appl) -> Reko.Core.Expressions.Expression!
override Reko.Typing.TypedExpressionRewriter.VisitArrayAccess(Reko.Core.Expressions.ArrayAccess! acc) -> Reko.Core.Expressions.Expression!
override Reko.Typing.TypedExpressionRewriter.VisitBinaryExpression(Reko.Core.Expressions.BinaryExpression! binExp) -> Reko.Core.Expressions.Expression!
override Reko.Typing.TypedExpressionRewriter.VisitConstant(Reko.Core.Expressions.Constant! c) -> Reko.Core.Expressions.Expression!
override Reko.Typing.TypedExpressionRewriter.VisitConversion(Reko.Core.Expressions.Conversion! conversion) -> Reko.Core.Expressions.Expression!
override Reko.Typing.TypedExpressionRewriter.VisitMemoryAccess(Reko.Core.Expressions.MemoryAccess! access) -> Reko.Core.Expressions.Expression!
override Reko.Typing.TypedExpressionRewriter.VisitMkSequence(Reko.Core.Expressions.MkSequence! seq) -> Reko.Core.Expressions.Expression!
override Reko.Typing.TypedExpressionRewriter.VisitSegmentedAccess(Reko.Core.Expressions.SegmentedAccess! access) -> Reko.Core.Expressions.Expression!
override Reko.Typing.TypedExpressionRewriter.VisitSlice(Reko.Core.Expressions.Slice! slice) -> Reko.Core.Expressions.Expression!
override Reko.Typing.TypedExpressionRewriter.VisitUnaryExpression(Reko.Core.Expressions.UnaryExpression! unary) -> Reko.Core.Expressions.Expression!
override Reko.Typing.TypeVariableReplacer.VisitStructure(Reko.Core.Types.StructureType! str) -> Reko.Core.Types.DataType!
override Reko.Typing.TypeVariableReplacer.VisitTypeVariable(Reko.Core.Types.TypeVariable! tv) -> Reko.Core.Types.DataType!
readonly Reko.Analysis.AddSubCandidate.Left -> Reko.Core.Expressions.Expression!
readonly Reko.Analysis.AddSubCandidate.Op -> Reko.Core.Operators.Operator!
readonly Reko.Analysis.AddSubCandidate.Right -> Reko.Core.Expressions.Expression!
readonly Reko.Analysis.LongAddRewriter.CondMatch.FlagGroup -> Reko.Core.Expressions.Identifier!
readonly Reko.Analysis.LongAddRewriter.CondMatch.src -> Reko.Core.Expressions.Expression!
readonly Reko.Analysis.LongAddRewriter.CondMatch.Statement -> Reko.Core.Statement!
readonly Reko.Analysis.LongAddRewriter.CondMatch.StatementIndex -> int
readonly Reko.Analysis.SsaTransform.IdentifierTransformer.blockstates -> System.Collections.Generic.IDictionary<Reko.Core.Block!, Reko.Analysis.SsaTransform.SsaBlockState!>!
readonly Reko.Analysis.SsaTransform.IdentifierTransformer.outer -> Reko.Analysis.SsaTransform!
readonly Reko.Analysis.SsaTransform.IdentifierTransformer.ssaIds -> Reko.Analysis.SsaIdentifierCollection!
readonly Reko.Analysis.SsaTransform.IdentifierTransformer.stm -> Reko.Core.Statement!
readonly Reko.Analysis.SsaTransform.SsaBlockState.Block -> Reko.Core.Block!
readonly Reko.Analysis.SsaTransform.SsaBlockState.currentDef -> System.Collections.Generic.Dictionary<Reko.Core.StorageDomain, Reko.Analysis.SsaTransform.AliasState!>!
readonly Reko.Analysis.SsaTransform.SsaBlockState.currentFlagDef -> System.Collections.Generic.Dictionary<Reko.Core.StorageDomain, Reko.Analysis.SsaTransform.FlagAliasState!>!
readonly Reko.Analysis.SsaTransform.SsaBlockState.currentSimpleDef -> System.Collections.Generic.Dictionary<Reko.Core.Storage!, Reko.Analysis.SsaIdentifier!>!
readonly Reko.Analysis.SsaTransform.SsaBlockState.currentStackDef -> Reko.Core.Collections.IntervalTree<int, Reko.Analysis.SsaTransform.Alias!>!
readonly Reko.Analysis.TrashedRegisterFinder.Context.FramePointer -> Reko.Core.Expressions.Identifier!
readonly Reko.Analysis.TrashedRegisterFinder.Context.IdState -> System.Collections.Generic.Dictionary<Reko.Core.Expressions.Identifier!, (Reko.Core.Expressions.Expression!, Reko.Core.BitRange)>!
readonly Reko.Analysis.TrashedRegisterFinder.Context.StackState -> System.Collections.Generic.Dictionary<int, Reko.Core.Expressions.Expression!>!
readonly Reko.Scanning.ProcedureDetector.Cluster.Blocks -> System.Collections.Generic.SortedSet<Reko.Scanning.RtlBlock!>!
readonly Reko.Scanning.ProcedureDetector.Cluster.Entries -> System.Collections.Generic.SortedSet<Reko.Scanning.RtlBlock!>!
readonly Reko.Scanning.RtlProcedure.Blocks -> System.Collections.Generic.ISet<Reko.Scanning.RtlBlock!>!
readonly Reko.Scanning.RtlProcedure.Entry -> Reko.Scanning.RtlBlock!
readonly Reko.Scanning.ShingledScanner.Bad -> Reko.Core.Address!
readonly Reko.Typing.ExpressionTypeDescender.factory -> Reko.Core.Types.TypeFactory!
readonly Reko.Typing.ExpressionTypeDescender.globals -> Reko.Core.Expressions.Identifier!
readonly Reko.Typing.ExpressionTypeDescender.ivs -> System.Collections.Generic.Dictionary<Reko.Core.Expressions.Identifier!, Reko.Core.LinearInductionVariable!>!
readonly Reko.Typing.ExpressionTypeDescender.platform -> Reko.Core.IPlatform!
readonly Reko.Typing.ExpressionTypeDescender.store -> Reko.Core.Types.TypeStore!
readonly Reko.Typing.ExpressionTypeDescender.unifier -> Reko.Core.Types.Unifier!
Reko.Analysis.AddSubCandidate
Reko.Analysis.AddSubCandidate.AddSubCandidate(Reko.Core.Operators.Operator! op, Reko.Core.Expressions.Expression! left, Reko.Core.Expressions.Expression! right) -> void
Reko.Analysis.AddSubCandidate.Dst -> Reko.Core.Expressions.Expression?
Reko.Analysis.AddSubCandidate.Statement -> Reko.Core.Statement?
Reko.Analysis.AddSubCandidate.StatementIndex -> int
Reko.Analysis.AdjacentBranchCollector
Reko.Analysis.AdjacentBranchCollector.AdjacentBranchCollector(Reko.Core.Procedure! proc, Reko.Core.Services.DecompilerEventListener! listener) -> void
Reko.Analysis.AdjacentBranchCollector.Transform() -> void
Reko.Analysis.ApplicationBindingType
Reko.Analysis.ApplicationBindingType.In = 0 -> Reko.Analysis.ApplicationBindingType
Reko.Analysis.ApplicationBindingType.Out = 2 -> Reko.Analysis.ApplicationBindingType
Reko.Analysis.ApplicationBindingType.Return = 1 -> Reko.Analysis.ApplicationBindingType
Reko.Analysis.ArgumentGuesser
Reko.Analysis.ArgumentGuesser.ArgumentGuesser(Reko.Core.IPlatform! platform, Reko.Analysis.SsaState! ssa, Reko.Core.Services.DecompilerEventListener! eventListener) -> void
Reko.Analysis.ArgumentGuesser.Transform() -> void
Reko.Analysis.CallApplicationBuilder
Reko.Analysis.CallApplicationBuilder.CallApplicationBuilder(Reko.Analysis.SsaState! ssaCaller, Reko.Core.Statement! stmCall, Reko.Core.Code.CallInstruction! call, Reko.Core.Expressions.Expression! callee, bool guessStackArgs) -> void
Reko.Analysis.CallApplicationBuilder.VisitFlagGroupStorage(Reko.Core.FlagGroupStorage! grf, (System.Collections.Generic.Dictionary<Reko.Core.Storage!, Reko.Core.Code.CallBinding!>! map, Reko.Analysis.ApplicationBindingType bindUses) ctx) -> Reko.Core.Expressions.Expression?
Reko.Analysis.CallApplicationBuilder.VisitFpuStackStorage(Reko.Core.FpuStackStorage! fpu, (System.Collections.Generic.Dictionary<Reko.Core.Storage!, Reko.Core.Code.CallBinding!>! map, Reko.Analysis.ApplicationBindingType bindUses) ctx) -> Reko.Core.Expressions.Expression?
Reko.Analysis.CallApplicationBuilder.VisitMemoryStorage(Reko.Core.MemoryStorage! global, (System.Collections.Generic.Dictionary<Reko.Core.Storage!, Reko.Core.Code.CallBinding!>! map, Reko.Analysis.ApplicationBindingType bindUses) ctx) -> Reko.Core.Expressions.Expression!
Reko.Analysis.CallApplicationBuilder.VisitOutArgumentStorage(Reko.Core.OutArgumentStorage! arg, (System.Collections.Generic.Dictionary<Reko.Core.Storage!, Reko.Core.Code.CallBinding!>! map, Reko.Analysis.ApplicationBindingType bindUses) ctx) -> Reko.Core.Expressions.Expression!
Reko.Analysis.CallApplicationBuilder.VisitRegisterStorage(Reko.Core.RegisterStorage! reg, (System.Collections.Generic.Dictionary<Reko.Core.Storage!, Reko.Core.Code.CallBinding!>! map, Reko.Analysis.ApplicationBindingType bindUses) ctx) -> Reko.Core.Expressions.Expression?
Reko.Analysis.CallApplicationBuilder.VisitSequenceStorage(Reko.Core.SequenceStorage! seq, (System.Collections.Generic.Dictionary<Reko.Core.Storage!, Reko.Core.Code.CallBinding!>! map, Reko.Analysis.ApplicationBindingType bindUses) ctx) -> Reko.Core.Expressions.Expression!
Reko.Analysis.CallApplicationBuilder.VisitStackStorage(Reko.Core.StackStorage! stack, (System.Collections.Generic.Dictionary<Reko.Core.Storage!, Reko.Core.Code.CallBinding!>! map, Reko.Analysis.ApplicationBindingType bindUses) ctx) -> Reko.Core.Expressions.Expression!
Reko.Analysis.CallApplicationBuilder.VisitTemporaryStorage(Reko.Core.TemporaryStorage! temp, (System.Collections.Generic.Dictionary<Reko.Core.Storage!, Reko.Core.Code.CallBinding!>! map, Reko.Analysis.ApplicationBindingType bindUses) ctx) -> Reko.Core.Expressions.Expression!
Reko.Analysis.CallRewriter
Reko.Analysis.CallRewriter.CallRewriter(Reko.Core.IPlatform! platform, Reko.Analysis.ProgramDataFlow! mpprocflow, Reko.Core.Services.DecompilerEventListener! listener) -> void
Reko.Analysis.CallRewriter.EnsureSignature(Reko.Analysis.SsaState! ssa, Reko.Analysis.ProcedureFlow! flow) -> void
Reko.Analysis.CallRewriter.GetSortedStackArguments(Reko.Core.Frame! frame, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<Reko.Core.Storage!, Reko.Core.BitRange>>! mayuse) -> System.Collections.Generic.IEnumerable<(int, Reko.Core.Expressions.Identifier!)>!
Reko.Analysis.CallRewriter.MakeSignature(Reko.Analysis.SsaState! ssa, Reko.Analysis.ProcedureFlow! flow) -> Reko.Core.Types.FunctionType!
Reko.Analysis.CallRewriter.MakeSignature(Reko.Analysis.SsaState! ssa, System.Collections.Generic.IEnumerable<Reko.Core.Code.CallBinding!>! uses, System.Collections.Generic.IEnumerable<Reko.Core.Code.CallBinding!>! definitions) -> Reko.Core.Types.FunctionType!
Reko.Analysis.CallRewriter.RemoveStatementsFromExitBlock(Reko.Analysis.SsaState! ssa) -> void
Reko.Analysis.CallRewriter.RewriteCall(Reko.Analysis.SsaState! ssaCaller, Reko.Core.Statement! stm, Reko.Core.Code.CallInstruction! call) -> bool
Reko.Analysis.CallRewriter.RewriteCalls(Reko.Analysis.SsaState! ssaCaller) -> int
Reko.Analysis.CallRewriter.RewriteReturns(Reko.Analysis.SsaState! ssa) -> void
Reko.Analysis.Coalescer
Reko.Analysis.Coalescer.CanCoalesce(Reko.Analysis.SsaIdentifier! sid, Reko.Core.Statement! def, Reko.Core.Statement! use) -> bool
Reko.Analysis.Coalescer.Coalesced.get -> bool
Reko.Analysis.Coalescer.Coalesced.set -> void
Reko.Analysis.Coalescer.Coalescer(Reko.Analysis.SsaState! ssa) -> void
Reko.Analysis.Coalescer.CoalesceStatements(Reko.Analysis.SsaIdentifier! sid, Reko.Core.Expressions.Expression! defExpr, Reko.Core.Statement! def, Reko.Core.Statement! use) -> bool
Reko.Analysis.Coalescer.Process(Reko.Core.Block! block) -> void
Reko.Analysis.Coalescer.Transform() -> void
Reko.Analysis.Coalescer.TryMoveAssignment(Reko.Core.Statement! stmDef, Reko.Analysis.SsaIdentifier! sidDef, Reko.Core.Expressions.Expression! defExpr, Reko.Core.Block! block, int initialPosition) -> bool
Reko.Analysis.ComplexStackVariableTransformer
Reko.Analysis.ComplexStackVariableTransformer.ComplexStackVariableTransformer(Reko.Analysis.SsaState! ssa, Reko.Core.Collections.IntervalTree<int, Reko.Core.Types.DataType!>! escapedFrameIntervals, Reko.Core.Services.DecompilerEventListener! eventListener) -> void
Reko.Analysis.ComplexStackVariableTransformer.Transform() -> void
Reko.Analysis.ConditionCodeEliminator
Reko.Analysis.ConditionCodeEliminator.ClosureOfReachingDefinitions(Reko.Analysis.SsaIdentifier! sidUse) -> System.Collections.Generic.HashSet<Reko.Analysis.SsaIdentifier!>!
Reko.Analysis.ConditionCodeEliminator.ClosureOfUsingStatements(Reko.Analysis.SsaIdentifier! sid, System.Collections.Generic.HashSet<Reko.Core.Statement!>! uses, System.Collections.Generic.HashSet<Reko.Core.Expressions.Identifier!>! aliases) -> System.Collections.Generic.HashSet<Reko.Core.Statement!>!
Reko.Analysis.ConditionCodeEliminator.ComparisonFromConditionCode(Reko.Core.Expressions.ConditionCode cc, Reko.Core.Expressions.BinaryExpression! bin, bool isNegated) -> Reko.Core.Expressions.Expression!
Reko.Analysis.ConditionCodeEliminator.ComparisonFromOverflow(Reko.Core.Expressions.BinaryExpression! bin, bool isNegated) -> Reko.Core.Expressions.Expression!
Reko.Analysis.ConditionCodeEliminator.ComparisonFromParity(Reko.Core.Expressions.BinaryExpression! bin, bool isNegated) -> Reko.Core.Expressions.Expression!
Reko.Analysis.ConditionCodeEliminator.ConditionCodeEliminator(Reko.Core.Program! program, Reko.Analysis.SsaState! ssa, Reko.Core.Services.DecompilerEventListener! listener) -> void
Reko.Analysis.ConditionCodeEliminator.OrderedComparison(Reko.Core.Expressions.BinaryExpression! bin, bool isNegated) -> Reko.Core.Expressions.Expression!
Reko.Analysis.ConditionCodeEliminator.Transform() -> void
Reko.Analysis.ConditionCodeEliminator.UseGrfConditionally(Reko.Analysis.SsaIdentifier! sid, Reko.Core.Expressions.ConditionCode cc, bool forceIdentifier) -> Reko.Core.Expressions.Expression!
Reko.Analysis.ConstDivisionImplementedByMultiplication
Reko.Analysis.ConstDivisionImplementedByMultiplication.ConstDivisionImplementedByMultiplication(Reko.Analysis.SsaState! ssa) -> void
Reko.Analysis.ConstDivisionImplementedByMultiplication.Match(Reko.Core.Code.Instruction! instr) -> bool
Reko.Analysis.ConstDivisionImplementedByMultiplication.Transform() -> void
Reko.Analysis.ConstDivisionImplementedByMultiplication.TransformInstruction() -> Reko.Core.Code.Assignment!
Reko.Analysis.DataFlow
Reko.Analysis.DataFlow.DataFlow() -> void
Reko.Analysis.DataFlow.EmitFlagGroup(Reko.Core.IProcessorArchitecture! arch, string! caption, System.Collections.Generic.Dictionary<Reko.Core.RegisterStorage!, uint>! flagRegs, System.IO.TextWriter! sb) -> void
Reko.Analysis.DataFlow.EmitFlagGroup(Reko.Core.IProcessorArchitecture! arch, string! caption, System.Collections.Generic.Dictionary<Reko.Core.RegisterStorage!, uint>! grfFlags) -> string!
Reko.Analysis.DataFlow.EmitRegisters(string! caption, System.Collections.Generic.HashSet<Reko.Core.Storage!>! regs) -> string!
Reko.Analysis.DataFlowAnalysis
Reko.Analysis.DataFlowAnalysis.AnalyzeProgram() -> void
Reko.Analysis.DataFlowAnalysis.BuildExpressionTrees() -> void
Reko.Analysis.DataFlowAnalysis.ClearTestFiles() -> void
Reko.Analysis.DataFlowAnalysis.ConvertToSsa(Reko.Core.Procedure! proc) -> Reko.Analysis.SsaTransform!
Reko.Analysis.DataFlowAnalysis.DataFlowAnalysis(Reko.Core.Program! program, Reko.Core.IDynamicLinker! dynamicLinker, System.IServiceProvider! services) -> void
Reko.Analysis.DataFlowAnalysis.DumpProgram() -> void
Reko.Analysis.DataFlowAnalysis.DumpWatchedProcedure(string! phase, string! caption, Reko.Analysis.SsaState! ssa) -> void
Reko.Analysis.DataFlowAnalysis.DumpWatchedProcedure(string! phase, string! caption, Reko.Core.Procedure! proc) -> void
Reko.Analysis.DataFlowAnalysis.DumpWatchedProcedure(string! phase, string! caption, System.Collections.Generic.IEnumerable<Reko.Analysis.SsaTransform!>! ssts) -> void
Reko.Analysis.DataFlowAnalysis.DumpWatchedProcedure(string! phase, string! caption, System.Collections.Generic.IEnumerable<Reko.Core.Procedure!>! procs) -> void
Reko.Analysis.DataFlowAnalysis.ProgramDataFlow.get -> Reko.Analysis.ProgramDataFlow!
Reko.Analysis.DataFlowAnalysis.RewriteProceduresToSsa() -> System.Collections.Generic.List<Reko.Analysis.SsaTransform!>!
Reko.Analysis.DataFlowAnalysis.UntangleProcedures() -> System.Collections.Generic.List<Reko.Analysis.SsaTransform!>!
Reko.Analysis.DeadCode
Reko.Analysis.DeadCode.AdjustApplicationsWithDeadReturnValues() -> void
Reko.Analysis.DeadCode.AdjustCallWithDeadDefinitions(Reko.Core.Code.CallInstruction! call) -> void
Reko.Analysis.DeclarationInserter
Reko.Analysis.DeclarationInserter.DeclarationInserter(Reko.Analysis.SsaIdentifierCollection! ssaIds, Reko.Core.Graphs.BlockDominatorGraph! doms) -> void
Reko.Analysis.DeclarationInserter.InsertDeclaration(Reko.Analysis.Web! web) -> void
Reko.Analysis.EscapedFrameIntervalsFinder
Reko.Analysis.EscapedFrameIntervalsFinder.EscapedFrameIntervalsFinder(Reko.Core.Program! program, Reko.Analysis.ProgramDataFlow! flow, Reko.Analysis.SsaState! ssa, Reko.Core.Services.DecompilerEventListener! eventListener) -> void
Reko.Analysis.EscapedFrameIntervalsFinder.Find() -> Reko.Core.Collections.IntervalTree<int, Reko.Core.Types.DataType!>!
Reko.Analysis.EscapedFrameIntervalsFinder.VisitAssignment(Reko.Core.Code.Assignment! ass) -> void
Reko.Analysis.EscapedFrameIntervalsFinder.VisitBranch(Reko.Core.Code.Branch! branch) -> void
Reko.Analysis.EscapedFrameIntervalsFinder.VisitCallInstruction(Reko.Core.Code.CallInstruction! ci) -> void
Reko.Analysis.EscapedFrameIntervalsFinder.VisitComment(Reko.Core.Code.CodeComment! code) -> void
Reko.Analysis.EscapedFrameIntervalsFinder.VisitDeclaration(Reko.Core.Code.Declaration! decl) -> void
Reko.Analysis.EscapedFrameIntervalsFinder.VisitDefInstruction(Reko.Core.Code.DefInstruction! def) -> void
Reko.Analysis.EscapedFrameIntervalsFinder.VisitGotoInstruction(Reko.Core.Code.GotoInstruction! gotoInstruction) -> void
Reko.Analysis.EscapedFrameIntervalsFinder.VisitPhiAssignment(Reko.Core.Code.PhiAssignment! phi) -> void
Reko.Analysis.EscapedFrameIntervalsFinder.VisitReturnInstruction(Reko.Core.Code.ReturnInstruction! ret) -> void
Reko.Analysis.EscapedFrameIntervalsFinder.VisitSideEffect(Reko.Core.Code.SideEffect! side) -> void
Reko.Analysis.EscapedFrameIntervalsFinder.VisitStore(Reko.Core.Code.Store! store) -> void
Reko.Analysis.EscapedFrameIntervalsFinder.VisitSwitchInstruction(Reko.Core.Code.SwitchInstruction! si) -> void
Reko.Analysis.EscapedFrameIntervalsFinder.VisitUseInstruction(Reko.Core.Code.UseInstruction! use) -> void
Reko.Analysis.ExpressionIdentifierUseFinder
Reko.Analysis.ExpressionIdentifierUseFinder.ExpressionIdentifierUseFinder(Reko.Analysis.SsaIdentifierCollection! ssaIds) -> void
Reko.Analysis.ExpressionUseRemover
Reko.Analysis.ExpressionUseRemover.ExpressionUseRemover(Reko.Core.Statement! user, Reko.Analysis.SsaIdentifierCollection! ssaIds) -> void
Reko.Analysis.FpuStackReturnGuesser
Reko.Analysis.FpuStackReturnGuesser.FpuStackReturnGuesser(Reko.Analysis.SsaState! ssa, Reko.Core.Services.DecompilerEventListener! listener) -> void
Reko.Analysis.FpuStackReturnGuesser.Transform() -> void
Reko.Analysis.GrfDefinitionFinder
Reko.Analysis.GrfDefinitionFinder.DefiningExpression.get -> Reko.Core.Expressions.Expression?
Reko.Analysis.GrfDefinitionFinder.FindDefiningExpression(Reko.Analysis.SsaIdentifier! sid) -> void
Reko.Analysis.GrfDefinitionFinder.GrfDefinitionFinder(Reko.Analysis.SsaIdentifierCollection! ssaIds) -> void
Reko.Analysis.GrfDefinitionFinder.IsNegated.get -> bool
Reko.Analysis.IdentifierReplacer
Reko.Analysis.IdentifierReplacer.IdentifierReplacer(Reko.Analysis.SsaIdentifierCollection! ssaIds, Reko.Core.Statement! use, Reko.Core.Expressions.Identifier! idOld, Reko.Core.Expressions.Expression! exprNew, bool replaceDefinitions) -> void
Reko.Analysis.IndirectCallRewriter
Reko.Analysis.IndirectCallRewriter.IndirectCallRewriter(Reko.Core.Program! program, Reko.Analysis.SsaState! ssa, Reko.Core.Services.DecompilerEventListener! eventListener) -> void
Reko.Analysis.IndirectCallRewriter.Rewrite() -> bool
Reko.Analysis.IndirectCallRewriter.RewriteCall(Reko.Core.Statement! stm, Reko.Core.Code.CallInstruction! call, Reko.Core.Types.FunctionType! ft) -> void
Reko.Analysis.InstructionUseAdder
Reko.Analysis.InstructionUseAdder.InstructionUseAdder(Reko.Core.Statement! user, Reko.Analysis.SsaIdentifierCollection! ssaIds) -> void
Reko.Analysis.InstructionUseCollector
Reko.Analysis.InstructionUseCollector.CollectUses(Reko.Core.Statement! stm) -> System.Collections.Generic.IDictionary<Reko.Core.Expressions.Identifier!, int>!
Reko.Analysis.InstructionUseCollector.InstructionUseCollector() -> void
Reko.Analysis.InstructionUseVisitorBase
Reko.Analysis.InstructionUseVisitorBase.InstructionUseVisitorBase() -> void
Reko.Analysis.Interference
Reko.Analysis.Interference.CompareTo(Reko.Analysis.Interference? i) -> int
Reko.Analysis.Interference.Identifier1.get -> Reko.Core.Expressions.Identifier!
Reko.Analysis.Interference.Identifier2.get -> Reko.Core.Expressions.Identifier!
Reko.Analysis.Interference.Interference(Reko.Core.Expressions.Identifier! id1, Reko.Core.Expressions.Identifier! id2) -> void
Reko.Analysis.InterferenceGraph
Reko.Analysis.InterferenceGraph.Add(Reko.Core.Expressions.Identifier! id1, Reko.Core.Expressions.Identifier! id2) -> void
Reko.Analysis.InterferenceGraph.Interfere(Reko.Core.Expressions.Identifier! id1, Reko.Core.Expressions.Identifier! id2) -> bool
Reko.Analysis.InterferenceGraph.InterferenceGraph() -> void
Reko.Analysis.InterferenceGraph.Write(System.IO.TextWriter! sb) -> void
Reko.Analysis.IntraBlockDeadRegisters
Reko.Analysis.IntraBlockDeadRegisters.Apply(Reko.Core.Block! block) -> void
Reko.Analysis.IntraBlockDeadRegisters.IntraBlockDeadRegisters() -> void
Reko.Analysis.IntraBlockDeadRegisters.VisitAssignment(Reko.Core.Code.Assignment! ass) -> bool
Reko.Analysis.IntraBlockDeadRegisters.VisitBranch(Reko.Core.Code.Branch! branch) -> bool
Reko.Analysis.IntraBlockDeadRegisters.VisitCallInstruction(Reko.Core.Code.CallInstruction! ci) -> bool
Reko.Analysis.IntraBlockDeadRegisters.VisitComment(Reko.Core.Code.CodeComment! comment) -> bool
Reko.Analysis.IntraBlockDeadRegisters.VisitDeclaration(Reko.Core.Code.Declaration! decl) -> bool
Reko.Analysis.IntraBlockDeadRegisters.VisitDefInstruction(Reko.Core.Code.DefInstruction! def) -> bool
Reko.Analysis.IntraBlockDeadRegisters.VisitFlagGroupStorage(Reko.Core.FlagGroupStorage! grf, bool defining) -> bool
Reko.Analysis.IntraBlockDeadRegisters.VisitFpuStackStorage(Reko.Core.FpuStackStorage! fpu, bool defining) -> bool
Reko.Analysis.IntraBlockDeadRegisters.VisitGotoInstruction(Reko.Core.Code.GotoInstruction! gotoInstruction) -> bool
Reko.Analysis.IntraBlockDeadRegisters.VisitMemoryStorage(Reko.Core.MemoryStorage! global, bool defining) -> bool
Reko.Analysis.IntraBlockDeadRegisters.VisitOutArgumentStorage(Reko.Core.OutArgumentStorage! arg, bool defining) -> bool
Reko.Analysis.IntraBlockDeadRegisters.VisitPhiAssignment(Reko.Core.Code.PhiAssignment! phi) -> bool
Reko.Analysis.IntraBlockDeadRegisters.VisitRegisterStorage(Reko.Core.RegisterStorage! reg, bool defining) -> bool
Reko.Analysis.IntraBlockDeadRegisters.VisitReturnInstruction(Reko.Core.Code.ReturnInstruction! ret) -> bool
Reko.Analysis.IntraBlockDeadRegisters.VisitSequenceStorage(Reko.Core.SequenceStorage! seq, bool defining) -> bool
Reko.Analysis.IntraBlockDeadRegisters.VisitSideEffect(Reko.Core.Code.SideEffect! side) -> bool
Reko.Analysis.IntraBlockDeadRegisters.VisitStackStorage(Reko.Core.StackStorage! stack, bool defining) -> bool
Reko.Analysis.IntraBlockDeadRegisters.VisitStore(Reko.Core.Code.Store! store) -> bool
Reko.Analysis.IntraBlockDeadRegisters.VisitSwitchInstruction(Reko.Core.Code.SwitchInstruction! si) -> bool
Reko.Analysis.IntraBlockDeadRegisters.VisitTemporaryStorage(Reko.Core.TemporaryStorage! temp, bool defining) -> bool
Reko.Analysis.IntraBlockDeadRegisters.VisitUseInstruction(Reko.Core.Code.UseInstruction! use) -> bool
Reko.Analysis.LinearInductionVariableContext
Reko.Analysis.LinearInductionVariableContext.CreateInductionVariable() -> Reko.Core.LinearInductionVariable!
Reko.Analysis.LinearInductionVariableContext.DeltaStatement.get -> Reko.Core.Statement?
Reko.Analysis.LinearInductionVariableContext.DeltaStatement.set -> void
Reko.Analysis.LinearInductionVariableContext.DeltaValue.get -> Reko.Core.Expressions.Constant?
Reko.Analysis.LinearInductionVariableContext.DeltaValue.set -> void
Reko.Analysis.LinearInductionVariableContext.InitialStatement.get -> Reko.Core.Statement?
Reko.Analysis.LinearInductionVariableContext.InitialStatement.set -> void
Reko.Analysis.LinearInductionVariableContext.InitialValue.get -> Reko.Core.Expressions.Constant?
Reko.Analysis.LinearInductionVariableContext.InitialValue.set -> void
Reko.Analysis.LinearInductionVariableContext.LinearInductionVariableContext() -> void
Reko.Analysis.LinearInductionVariableContext.PhiIdentifier.get -> Reko.Core.Expressions.Identifier?
Reko.Analysis.LinearInductionVariableContext.PhiIdentifier.set -> void
Reko.Analysis.LinearInductionVariableContext.PhiStatement.get -> Reko.Core.Statement?
Reko.Analysis.LinearInductionVariableContext.PhiStatement.set -> void
Reko.Analysis.LinearInductionVariableContext.TestOperator.get -> Reko.Core.Operators.Operator?
Reko.Analysis.LinearInductionVariableContext.TestOperator.set -> void
Reko.Analysis.LinearInductionVariableContext.TestStatement.get -> Reko.Core.Statement?
Reko.Analysis.LinearInductionVariableContext.TestStatement.set -> void
Reko.Analysis.LinearInductionVariableContext.TestValue.get -> Reko.Core.Expressions.Constant?
Reko.Analysis.LinearInductionVariableContext.TestValue.set -> void
Reko.Analysis.LinearInductionVariableFinder
Reko.Analysis.LinearInductionVariableFinder.AdjustTestValue(Reko.Core.Expressions.Constant? testValue) -> Reko.Core.Expressions.Constant?
Reko.Analysis.LinearInductionVariableFinder.Context.get -> Reko.Analysis.LinearInductionVariableContext!
Reko.Analysis.LinearInductionVariableFinder.Contexts.get -> System.Collections.Generic.Dictionary<Reko.Core.LinearInductionVariable!, Reko.Analysis.LinearInductionVariableContext!>!
Reko.Analysis.LinearInductionVariableFinder.CreateInductionVariable() -> Reko.Core.LinearInductionVariable?
Reko.Analysis.LinearInductionVariableFinder.DominatesAllUses(Reko.Core.Statement? stm, Reko.Core.Expressions.Identifier! id) -> bool
Reko.Analysis.LinearInductionVariableFinder.Find() -> void
Reko.Analysis.LinearInductionVariableFinder.FindFinalValue(System.Collections.Generic.ICollection<Reko.Analysis.SsaIdentifier!>! scc) -> Reko.Core.Expressions.Constant?
Reko.Analysis.LinearInductionVariableFinder.FindInitialValue(Reko.Core.Expressions.PhiFunction! phi) -> Reko.Core.Expressions.Constant?
Reko.Analysis.LinearInductionVariableFinder.FindLinearIncrement(System.Collections.Generic.ICollection<Reko.Analysis.SsaIdentifier!>! sids) -> Reko.Core.Expressions.Constant?
Reko.Analysis.LinearInductionVariableFinder.FindPhiFunction(System.Collections.Generic.ICollection<Reko.Analysis.SsaIdentifier!>! sids) -> Reko.Core.Expressions.PhiFunction?
Reko.Analysis.LinearInductionVariableFinder.GetSuccessors(Reko.Analysis.SsaIdentifier! sid) -> System.Collections.Generic.IEnumerable<Reko.Analysis.SsaIdentifier!>!
Reko.Analysis.LinearInductionVariableFinder.InductionVariables.get -> System.Collections.Generic.List<Reko.Core.LinearInductionVariable!>!
Reko.Analysis.LinearInductionVariableFinder.IsIdUsedOnlyBy(Reko.Core.Expressions.Identifier! id, Reko.Core.Statement? stm1, Reko.Core.Statement? stm2) -> bool
Reko.Analysis.LinearInductionVariableFinder.IsSccMember(Reko.Core.Expressions.Identifier! id, System.Collections.Generic.ICollection<Reko.Analysis.SsaIdentifier!>! sids) -> bool
Reko.Analysis.LinearInductionVariableFinder.IsSingleUsingStatement(Reko.Core.Statement! stm, Reko.Core.Expressions.Identifier! id) -> bool
Reko.Analysis.LinearInductionVariableFinder.LinearInductionVariableFinder(Reko.Analysis.SsaState! ssa, Reko.Core.Graphs.BlockDominatorGraph! doms) -> void
Reko.Analysis.LinearInductionVariableFinder.SsaGraph
Reko.Analysis.LinearInductionVariableFinder.SsaGraph.AddEdge(Reko.Analysis.SsaIdentifier! nodeFrom, Reko.Analysis.SsaIdentifier! nodeTo) -> void
Reko.Analysis.LinearInductionVariableFinder.SsaGraph.ContainsEdge(Reko.Analysis.SsaIdentifier! nodeFrom, Reko.Analysis.SsaIdentifier! nodeTo) -> bool
Reko.Analysis.LinearInductionVariableFinder.SsaGraph.Nodes.get -> System.Collections.Generic.ICollection<Reko.Analysis.SsaIdentifier!>!
Reko.Analysis.LinearInductionVariableFinder.SsaGraph.Predecessors(Reko.Analysis.SsaIdentifier! node) -> System.Collections.Generic.ICollection<Reko.Analysis.SsaIdentifier!>!
Reko.Analysis.LinearInductionVariableFinder.SsaGraph.RemoveEdge(Reko.Analysis.SsaIdentifier! nodeFrom, Reko.Analysis.SsaIdentifier! nodeTo) -> void
Reko.Analysis.LinearInductionVariableFinder.SsaGraph.SsaGraph(Reko.Analysis.SsaIdentifierCollection! ssaIds) -> void
Reko.Analysis.LinearInductionVariableFinder.SsaGraph.Successors(Reko.Analysis.SsaIdentifier! sid) -> System.Collections.Generic.ICollection<Reko.Analysis.SsaIdentifier!>!
Reko.Analysis.LiveCopyInserter
Reko.Analysis.LiveCopyInserter.DominatedUseRenamer
Reko.Analysis.LiveCopyInserter.DominatedUseRenamer.DominatedUseRenamer(Reko.Core.Graphs.BlockDominatorGraph! domGraph) -> void
Reko.Analysis.LiveCopyInserter.DominatedUseRenamer.Index(Reko.Core.Statement! stm) -> int
Reko.Analysis.LiveCopyInserter.DominatedUseRenamer.Transform(Reko.Analysis.SsaIdentifier! sidOld, Reko.Analysis.SsaIdentifier! sidNew) -> void
Reko.Analysis.LiveCopyInserter.IndexOfInsertedCopy(Reko.Core.Block! b) -> int
Reko.Analysis.LiveCopyInserter.InsertAssignment(Reko.Core.Expressions.Identifier! idDst, Reko.Core.Expressions.Identifier! idSrc, Reko.Core.Block! b, int i) -> Reko.Core.Expressions.Identifier!
Reko.Analysis.LiveCopyInserter.InsertAssignmentNewId(Reko.Core.Expressions.Identifier! idOld, Reko.Core.Block! b, int i) -> Reko.Core.Expressions.Identifier!
Reko.Analysis.LiveCopyInserter.IsLiveAtCopyPoint(Reko.Core.Expressions.Identifier! id, Reko.Core.Block! b) -> bool
Reko.Analysis.LiveCopyInserter.IsLiveOut(Reko.Core.Expressions.Identifier! id, Reko.Core.Statement! stm) -> bool
Reko.Analysis.LiveCopyInserter.LiveCopyInserter(Reko.Analysis.SsaState! ssa) -> void
Reko.Analysis.LiveCopyInserter.RenameDominatedIdentifiers(Reko.Analysis.SsaIdentifier! sidOld, Reko.Analysis.SsaIdentifier! sidNew) -> void
Reko.Analysis.LiveCopyInserter.Transform() -> void
Reko.Analysis.LiveCopyInserter.Transform(Reko.Core.Statement! stm, Reko.Core.Code.PhiAssignment! phi) -> void
Reko.Analysis.LocalTypeDescender
Reko.Analysis.LocalTypeDescender.BuildEquivalenceClasses(Reko.Analysis.SsaState! ssa) -> void
Reko.Analysis.LocalTypeDescender.LocalTypeDescender(Reko.Core.Program! program, Reko.Core.Types.TypeStore! store, Reko.Core.Types.TypeFactory! factory) -> void
Reko.Analysis.LocalTypeDescender.MergeDataTypes() -> void
Reko.Analysis.LocalTypeDescender.TypeVariables.get -> System.Collections.Generic.Dictionary<Reko.Core.Expressions.Expression!, Reko.Core.Types.TypeVariable!>!
Reko.Analysis.LocalTypeDescender.Visit(Reko.Core.Expressions.Expression! exp) -> void
Reko.Analysis.LongAddRewriter
Reko.Analysis.LongAddRewriter.CondMatch
Reko.Analysis.LongAddRewriter.CondMatch.CondMatch(Reko.Core.Expressions.Identifier! grf, Reko.Core.Expressions.Expression! src, Reko.Core.Statement! stm, int index) -> void
Reko.Analysis.LongAddRewriter.CreateLongInstruction(Reko.Analysis.AddSubCandidate! loCandidate, Reko.Analysis.AddSubCandidate! hiCandidate) -> void
Reko.Analysis.LongAddRewriter.FindConditionOf(System.Collections.Generic.List<Reko.Core.Statement!>! stms, int iStm, Reko.Core.Expressions.Expression! exp) -> Reko.Analysis.LongAddRewriter.CondMatch?
Reko.Analysis.LongAddRewriter.FindUsingInstruction(Reko.Core.Block! block, Reko.Core.Expressions.Identifier! cy, Reko.Analysis.AddSubCandidate! loInstr) -> Reko.Analysis.AddSubCandidate?
Reko.Analysis.LongAddRewriter.IsCarryFlag(Reko.Core.Expressions.Expression? exp) -> bool
Reko.Analysis.LongAddRewriter.LongAddRewriter(Reko.Analysis.SsaState! ssa, Reko.Core.Services.DecompilerEventListener! listener) -> void
Reko.Analysis.LongAddRewriter.MatchAdcSbc(Reko.Core.Statement! stm) -> Reko.Analysis.AddSubCandidate?
Reko.Analysis.LongAddRewriter.MatchAddSub(Reko.Core.Statement! stm) -> Reko.Analysis.AddSubCandidate?
Reko.Analysis.LongAddRewriter.MemoryOperandsAdjacent(Reko.Core.IProcessorArchitecture! arch, Reko.Core.Expressions.MemoryAccess! m1, Reko.Core.Expressions.MemoryAccess! m2) -> bool
Reko.Analysis.LongAddRewriter.ReplaceLongAdditions(Reko.Core.Block! block) -> void
Reko.Analysis.LongAddRewriter.Transform() -> void
Reko.Analysis.PhiGraph
Reko.Analysis.PhiGraph.AddEdge(Reko.Core.Code.PhiAssignment! nodeFrom, Reko.Core.Code.PhiAssignment! nodeTo) -> void
Reko.Analysis.PhiGraph.ContainsEdge(Reko.Core.Code.PhiAssignment! nodeFrom, Reko.Core.Code.PhiAssignment! nodeTo) -> bool
Reko.Analysis.PhiGraph.Nodes.get -> System.Collections.Generic.ICollection<Reko.Core.Code.PhiAssignment!>!
Reko.Analysis.PhiGraph.PhiGraph(Reko.Analysis.SsaState! ssa, System.Collections.Generic.IEnumerable<Reko.Core.Code.PhiAssignment!>! phis) -> void
Reko.Analysis.PhiGraph.Predecessors(Reko.Core.Code.PhiAssignment! node) -> System.Collections.Generic.ICollection<Reko.Core.Code.PhiAssignment!>!
Reko.Analysis.PhiGraph.RemoveEdge(Reko.Core.Code.PhiAssignment! nodeFrom, Reko.Core.Code.PhiAssignment! nodeTo) -> void
Reko.Analysis.PhiGraph.Successors(Reko.Core.Code.PhiAssignment! node) -> System.Collections.Generic.ICollection<Reko.Core.Code.PhiAssignment!>!
Reko.Analysis.ProcedureFlow
Reko.Analysis.ProcedureFlow.BitsLiveOut -> System.Collections.Generic.Dictionary<Reko.Core.Storage!, Reko.Core.BitRange>!
Reko.Analysis.ProcedureFlow.BitsUsed -> System.Collections.Generic.Dictionary<Reko.Core.Storage!, Reko.Core.BitRange>!
Reko.Analysis.ProcedureFlow.Constants -> System.Collections.Generic.Dictionary<Reko.Core.Storage!, Reko.Core.Expressions.Constant!>!
Reko.Analysis.ProcedureFlow.Dump(Reko.Core.IProcessorArchitecture! arch) -> void
Reko.Analysis.ProcedureFlow.GetFpuStackDelta(Reko.Core.IProcessorArchitecture! arch) -> int
Reko.Analysis.ProcedureFlow.grfLiveOut -> System.Collections.Generic.Dictionary<Reko.Core.RegisterStorage!, uint>!
Reko.Analysis.ProcedureFlow.grfPreserved -> System.Collections.Generic.Dictionary<Reko.Core.RegisterStorage!, uint>!
Reko.Analysis.ProcedureFlow.grfTrashed -> System.Collections.Generic.Dictionary<Reko.Core.RegisterStorage!, uint>!
Reko.Analysis.ProcedureFlow.IsLiveOut(Reko.Core.Expressions.Identifier! id) -> bool
Reko.Analysis.ProcedureFlow.LiveInDataTypes -> System.Collections.Generic.Dictionary<Reko.Core.Storage!, Reko.Core.Types.DataType!>!
Reko.Analysis.ProcedureFlow.Preserved -> System.Collections.Generic.HashSet<Reko.Core.Storage!>!
Reko.Analysis.ProcedureFlow.Procedure.get -> Reko.Core.Procedure!
Reko.Analysis.ProcedureFlow.ProcedureFlow(Reko.Core.Procedure! proc) -> void
Reko.Analysis.ProcedureFlow.Signature -> Reko.Core.Types.FunctionType?
Reko.Analysis.ProcedureFlow.TerminatesProcess -> bool
Reko.Analysis.ProcedureFlow.Trashed -> System.Collections.Generic.HashSet<Reko.Core.Storage!>!
Reko.Analysis.ProcedureGraph
Reko.Analysis.ProcedureGraph.AddEdge(Reko.Core.Procedure! nodeFrom, Reko.Core.Procedure! nodeTo) -> void
Reko.Analysis.ProcedureGraph.ContainsEdge(Reko.Core.Procedure! nodeFrom, Reko.Core.Procedure! nodeTo) -> bool
Reko.Analysis.ProcedureGraph.Nodes.get -> System.Collections.Generic.ICollection<Reko.Core.Procedure!>!
Reko.Analysis.ProcedureGraph.Predecessors(Reko.Core.Procedure! node) -> System.Collections.Generic.ICollection<Reko.Core.Procedure!>!
Reko.Analysis.ProcedureGraph.ProcedureGraph(Reko.Core.Program! program) -> void
Reko.Analysis.ProcedureGraph.RemoveEdge(Reko.Core.Procedure! nodeFrom, Reko.Core.Procedure! nodeTo) -> void
Reko.Analysis.ProcedureGraph.Successors(Reko.Core.Procedure! node) -> System.Collections.Generic.ICollection<Reko.Core.Procedure!>!
Reko.Analysis.ProgramDataFlow
Reko.Analysis.ProgramDataFlow.CreateFlowsFor(System.Collections.Generic.IEnumerable<Reko.Core.Procedure!>! procs) -> void
Reko.Analysis.ProgramDataFlow.ProcedureFlows.get -> System.Collections.Generic.IDictionary<Reko.Core.Procedure!, Reko.Analysis.ProcedureFlow!>!
Reko.Analysis.ProgramDataFlow.ProgramDataFlow() -> void
Reko.Analysis.ProgramDataFlow.ProgramDataFlow(Reko.Core.Program! program) -> void
Reko.Analysis.ProgramDataFlow.this[Reko.Core.Procedure! proc].get -> Reko.Analysis.ProcedureFlow!
Reko.Analysis.ProgramDataFlow.this[Reko.Core.Procedure! proc].set -> void
Reko.Analysis.ProjectionPropagator
Reko.Analysis.ProjectionPropagator.ProjectionPropagator(Reko.Analysis.SsaState! ssa, Reko.Analysis.SegmentedAccessClassifier! sac) -> void
Reko.Analysis.ProjectionPropagator.Transform() -> void
Reko.Analysis.SegmentedAccessClassifier
Reko.Analysis.SegmentedAccessClassifier.Associate(Reko.Core.Expressions.Identifier! basePtr, Reko.Core.Expressions.Constant! memberPtr) -> void
Reko.Analysis.SegmentedAccessClassifier.Associate(Reko.Core.Expressions.Identifier! basePtr, Reko.Core.Expressions.Identifier! membPtr) -> void
Reko.Analysis.SegmentedAccessClassifier.AssociatedIdentifier(Reko.Core.Expressions.Identifier! pointer) -> Reko.Core.Expressions.Identifier?
Reko.Analysis.SegmentedAccessClassifier.Classify() -> void
Reko.Analysis.SegmentedAccessClassifier.IsOnlyAssociatedWithConstants(Reko.Core.Expressions.Identifier! pointer) -> bool
Reko.Analysis.SegmentedAccessClassifier.SegmentedAccessClassifier(Reko.Analysis.SsaState! ssa) -> void
Reko.Analysis.SequenceIdentifierGenerator
Reko.Analysis.SequenceIdentifierGenerator.SequenceIdentifierGenerator(Reko.Analysis.SsaTransform! sst) -> void
Reko.Analysis.SequenceIdentifierGenerator.Transform() -> void
Reko.Analysis.SideEffectFinder
Reko.Analysis.SideEffectFinder.AreConstrained(Reko.Core.Statement! def, Reko.Core.Statement! use) -> bool
Reko.Analysis.SideEffectFinder.Conflict(Reko.Analysis.SideEffectFlags defFlags, Reko.Analysis.SideEffectFlags curFlags) -> bool
Reko.Analysis.SideEffectFinder.FindSideEffect(Reko.Core.Code.Instruction! instr) -> Reko.Analysis.SideEffectFlags
Reko.Analysis.SideEffectFinder.FindSideEffect(Reko.Core.Expressions.Expression! e) -> Reko.Analysis.SideEffectFlags
Reko.Analysis.SideEffectFinder.HasSideEffect(Reko.Core.Code.Instruction! instr) -> bool
Reko.Analysis.SideEffectFinder.HasSideEffect(Reko.Core.Expressions.Expression! e) -> bool
Reko.Analysis.SideEffectFinder.SideEffectFinder() -> void
Reko.Analysis.SideEffectFlags
Reko.Analysis.SideEffectFlags.Application = 4 -> Reko.Analysis.SideEffectFlags
Reko.Analysis.SideEffectFlags.Load = 1 -> Reko.Analysis.SideEffectFlags
Reko.Analysis.SideEffectFlags.None = 0 -> Reko.Analysis.SideEffectFlags
Reko.Analysis.SideEffectFlags.SideEffect = 8 -> Reko.Analysis.SideEffectFlags
Reko.Analysis.SideEffectFlags.Store = 2 -> Reko.Analysis.SideEffectFlags
Reko.Analysis.SparseValuePropagation
Reko.Analysis.SparseValuePropagation.SparseValuePropagation(Reko.Analysis.SsaState! ssa, Reko.Core.Program! program, Reko.Core.IDynamicLinker! resolver, Reko.Core.Services.DecompilerEventListener! listener) -> void
Reko.Analysis.SparseValuePropagation.Transform() -> void
Reko.Analysis.SparseValuePropagation.Write(System.IO.TextWriter! writer) -> void
Reko.Analysis.SsaDefinitionsCollector
Reko.Analysis.SsaDefinitionsCollector.CollectDefinitions(Reko.Core.Statement! stm) -> System.Collections.Generic.ICollection<Reko.Core.Expressions.Identifier!>!
Reko.Analysis.SsaDefinitionsCollector.SsaDefinitionsCollector() -> void
Reko.Analysis.SsaEvaluationContext
Reko.Analysis.SsaEvaluationContext.Endianness.get -> Reko.Core.EndianServices!
Reko.Analysis.SsaEvaluationContext.GetDefiningExpression(Reko.Core.Expressions.Identifier! id) -> Reko.Core.Expressions.Expression?
Reko.Analysis.SsaEvaluationContext.GetDefiningStatementClosure(Reko.Core.Expressions.Identifier! id) -> System.Collections.Generic.List<Reko.Core.Statement!>!
Reko.Analysis.SsaEvaluationContext.GetValue(Reko.Core.Expressions.Application! appl) -> Reko.Core.Expressions.Expression!
Reko.Analysis.SsaEvaluationContext.GetValue(Reko.Core.Expressions.Identifier! id) -> Reko.Core.Expressions.Expression?
Reko.Analysis.SsaEvaluationContext.GetValue(Reko.Core.Expressions.MemoryAccess! access, Reko.Core.SegmentMap! segmentMap) -> Reko.Core.Expressions.Expression!
Reko.Analysis.SsaEvaluationContext.GetValue(Reko.Core.Expressions.SegmentedAccess! access, Reko.Core.SegmentMap! segmentMap) -> Reko.Core.Expressions.Expression!
Reko.Analysis.SsaEvaluationContext.IsUsedInPhi(Reko.Core.Expressions.Identifier! id) -> bool
Reko.Analysis.SsaEvaluationContext.MakeSegmentedAddress(Reko.Core.Expressions.Constant! seg, Reko.Core.Expressions.Constant! off) -> Reko.Core.Expressions.Expression!
Reko.Analysis.SsaEvaluationContext.MemoryGranularity.get -> int
Reko.Analysis.SsaEvaluationContext.ReinterpretAsFloat(Reko.Core.Expressions.Constant! rawBits) -> Reko.Core.Expressions.Constant!
Reko.Analysis.SsaEvaluationContext.RemoveExpressionUse(Reko.Core.Expressions.Expression! exp) -> void
Reko.Analysis.SsaEvaluationContext.RemoveIdentifierUse(Reko.Core.Expressions.Identifier! id) -> void
Reko.Analysis.SsaEvaluationContext.SetValue(Reko.Core.Expressions.Identifier! id, Reko.Core.Expressions.Expression! value) -> void
Reko.Analysis.SsaEvaluationContext.SetValueEa(Reko.Core.Expressions.Expression! basePtr, Reko.Core.Expressions.Expression! ea, Reko.Core.Expressions.Expression! value) -> void
Reko.Analysis.SsaEvaluationContext.SetValueEa(Reko.Core.Expressions.Expression! ea, Reko.Core.Expressions.Expression! value) -> void
Reko.Analysis.SsaEvaluationContext.SsaEvaluationContext(Reko.Core.IProcessorArchitecture! arch, Reko.Analysis.SsaIdentifierCollection! ssaIds, Reko.Core.IDynamicLinker! dynamicLinker) -> void
Reko.Analysis.SsaEvaluationContext.Statement.get -> Reko.Core.Statement?
Reko.Analysis.SsaEvaluationContext.Statement.set -> void
Reko.Analysis.SsaEvaluationContext.UseExpression(Reko.Core.Expressions.Expression! exp) -> void
Reko.Analysis.SsaIdentifier
Reko.Analysis.SsaIdentifier.DefExpression.get -> Reko.Core.Expressions.Expression?
Reko.Analysis.SsaIdentifier.DefExpression.set -> void
Reko.Analysis.SsaIdentifier.DefStatement.get -> Reko.Core.Statement?
Reko.Analysis.SsaIdentifier.DefStatement.set -> void
Reko.Analysis.SsaIdentifier.Identifier.get -> Reko.Core.Expressions.Identifier!
Reko.Analysis.SsaIdentifier.InductionVariable.get -> Reko.Core.LinearInductionVariable?
Reko.Analysis.SsaIdentifier.InductionVariable.set -> void
Reko.Analysis.SsaIdentifier.IsOriginal.get -> bool
Reko.Analysis.SsaIdentifier.IsSideEffect.get -> bool
Reko.Analysis.SsaIdentifier.OriginalIdentifier.get -> Reko.Core.Expressions.Identifier!
Reko.Analysis.SsaIdentifier.SsaIdentifier(Reko.Core.Expressions.Identifier! id, Reko.Core.Expressions.Identifier! idOrig, Reko.Core.Statement? stmDef, Reko.Core.Expressions.Expression? exprDef, bool isSideEffect) -> void
Reko.Analysis.SsaIdentifier.Uses.get -> System.Collections.Generic.List<Reko.Core.Statement!>!
Reko.Analysis.SsaIdentifier.Write(System.IO.TextWriter! writer) -> void
Reko.Analysis.SsaIdentifierCollection
Reko.Analysis.SsaIdentifierCollection.Add(Reko.Core.Expressions.Identifier! id, Reko.Analysis.SsaIdentifier! sid) -> void
Reko.Analysis.SsaIdentifierCollection.Add(Reko.Core.Expressions.Identifier! idOld, Reko.Core.Statement? stmDef, Reko.Core.Expressions.Expression? exprDef, bool isSideEffect) -> Reko.Analysis.SsaIdentifier!
Reko.Analysis.SsaIdentifierCollection.Clear() -> void
Reko.Analysis.SsaIdentifierCollection.Contains(Reko.Core.Expressions.Identifier! id) -> bool
Reko.Analysis.SsaIdentifierCollection.Count.get -> int
Reko.Analysis.SsaIdentifierCollection.GetEnumerator() -> System.Collections.Generic.IEnumerator<Reko.Analysis.SsaIdentifier!>!
Reko.Analysis.SsaIdentifierCollection.IsReadOnly.get -> bool
Reko.Analysis.SsaIdentifierCollection.Remove(Reko.Analysis.SsaIdentifier! sid) -> bool
Reko.Analysis.SsaIdentifierCollection.SsaIdentifierCollection() -> void
Reko.Analysis.SsaIdentifierCollection.this[Reko.Core.Expressions.Identifier! id].get -> Reko.Analysis.SsaIdentifier!
Reko.Analysis.SsaIdentifierCollection.this[Reko.Core.Expressions.Identifier! id].set -> void
Reko.Analysis.SsaIdentifierCollection.TryGetValue(Reko.Core.Expressions.Identifier! id, out Reko.Analysis.SsaIdentifier! sid) -> bool
Reko.Analysis.SsaLivenessAnalysis
Reko.Analysis.SsaLivenessAnalysis.BuildDefinedMap(Reko.Analysis.SsaIdentifierCollection! ssaIds) -> void
Reko.Analysis.SsaLivenessAnalysis.BuildInterferenceGraph(Reko.Analysis.SsaIdentifierCollection! ssaIds) -> void
Reko.Analysis.SsaLivenessAnalysis.GetPhiFunction(Reko.Core.Statement! stm) -> Reko.Core.Expressions.PhiFunction?
Reko.Analysis.SsaLivenessAnalysis.IdentifiersDefinedAtStatement(Reko.Core.Statement! stm) -> System.Collections.Generic.List<Reko.Core.Expressions.Identifier!>!
Reko.Analysis.SsaLivenessAnalysis.IsDefinedAtStatement(Reko.Analysis.SsaIdentifier! v, Reko.Core.Statement? stm) -> bool
Reko.Analysis.SsaLivenessAnalysis.IsFirstStatementInBlock(Reko.Core.Statement! stm, Reko.Core.Block! block) -> bool
Reko.Analysis.SsaLivenessAnalysis.IsLiveIn(Reko.Core.Expressions.Identifier! id, Reko.Core.Statement! stm) -> bool
Reko.Analysis.SsaLivenessAnalysis.IsLiveOut(Reko.Core.Expressions.Identifier! id, Reko.Core.Block! b) -> bool
Reko.Analysis.SsaLivenessAnalysis.IsLiveOut(Reko.Core.Expressions.Identifier! id, Reko.Core.Statement! stm) -> bool
Reko.Analysis.SsaLivenessAnalysis.LiveInAtStatement(Reko.Core.Block! b, int i, Reko.Analysis.SsaIdentifier! v) -> void
Reko.Analysis.SsaLivenessAnalysis.LiveOutAtBlock(Reko.Core.Block! b, Reko.Analysis.SsaIdentifier! v) -> void
Reko.Analysis.SsaLivenessAnalysis.LiveOutAtStatement(Reko.Core.Statement! s, Reko.Analysis.SsaIdentifier! v) -> bool
Reko.Analysis.SsaLivenessAnalysis.SsaLivenessAnalysis(Reko.Analysis.SsaState! ssa) -> void
Reko.Analysis.SsaLivenessAnalysis.Write(Reko.Core.Procedure! proc, System.IO.TextWriter! writer) -> void
Reko.Analysis.SsaLivenessAnalysis2
Reko.Analysis.SsaLivenessAnalysis2.Analyze() -> void
Reko.Analysis.SsaLivenessAnalysis2.InterferenceGraph.get -> Reko.Analysis.InterferenceGraph!
Reko.Analysis.SsaLivenessAnalysis2.LiveOutAtStatement(Reko.Core.Block! block, int iStm, Reko.Analysis.SsaIdentifier! sid) -> void
Reko.Analysis.SsaLivenessAnalysis2.SsaLivenessAnalysis2(Reko.Analysis.SsaState! ssa) -> void
Reko.Analysis.SsaMutator
Reko.Analysis.SsaMutator.AdjustRegisterAfterCall(Reko.Core.Statement! stm, Reko.Core.Code.CallInstruction! call, Reko.Core.RegisterStorage! register, int delta) -> void
Reko.Analysis.SsaMutator.AdjustSsa(Reko.Core.Statement! stm, Reko.Core.Code.CallInstruction! call) -> void
Reko.Analysis.SsaMutator.DefineUninitializedIdentifiers(Reko.Core.Statement! stm, Reko.Core.Code.CallInstruction! call) -> void
Reko.Analysis.SsaMutator.InsertAssignmentAfter(Reko.Core.Expressions.Identifier! dst, Reko.Core.Expressions.Expression! src, Reko.Core.Statement! stmAfter) -> Reko.Analysis.SsaIdentifier!
Reko.Analysis.SsaMutator.InsertAssignmentBefore(Reko.Core.Expressions.Identifier! dst, Reko.Core.Expressions.Expression! src, Reko.Core.Statement! stmBefore) -> Reko.Analysis.SsaIdentifier!
Reko.Analysis.SsaMutator.InsertStatementAfter(Reko.Core.Code.Instruction! instr, Reko.Core.Statement! stmAfter) -> Reko.Core.Statement!
Reko.Analysis.SsaMutator.ReplaceAssigment(Reko.Analysis.SsaIdentifier! sid, Reko.Core.Code.Assignment! ass) -> void
Reko.Analysis.SsaMutator.SsaMutator(Reko.Analysis.SsaState! ssa) -> void
Reko.Analysis.SsaState
Reko.Analysis.SsaState.AddDefinitions(Reko.Core.Statement! stm) -> void
Reko.Analysis.SsaState.AddUses(Reko.Core.Statement! stm) -> void
Reko.Analysis.SsaState.AddUses(Reko.Core.Statement! stmUsing, Reko.Core.Expressions.Expression! e) -> void
Reko.Analysis.SsaState.ConvertBack(bool renameVariables) -> void
Reko.Analysis.SsaState.DeleteStatement(Reko.Core.Statement! stm) -> void
Reko.Analysis.SsaState.Dump(bool trace) -> void
Reko.Analysis.SsaState.EnsureDefInstruction(Reko.Core.Expressions.Identifier! id, Reko.Core.Block! b) -> Reko.Analysis.SsaIdentifier!
Reko.Analysis.SsaState.Identifiers.get -> Reko.Analysis.SsaIdentifierCollection!
Reko.Analysis.SsaState.InsertAfterDefinition(Reko.Core.Statement! stmBefore, Reko.Core.Code.AliasAssignment! ass) -> Reko.Analysis.SsaIdentifier!
Reko.Analysis.SsaState.PredecessorPhiIdentifiers(Reko.Core.Block! block) -> System.Collections.Generic.Dictionary<Reko.Core.Block!, Reko.Core.Code.CallBinding![]!>!
Reko.Analysis.SsaState.Procedure.get -> Reko.Core.Procedure!
Reko.Analysis.SsaState.RemoveUses(Reko.Core.Statement? stm) -> void
Reko.Analysis.SsaState.RemoveUses(Reko.Core.Statement! stmUsing, Reko.Core.Expressions.Expression! e) -> void
Reko.Analysis.SsaState.ReplaceDefinitions(Reko.Core.Statement! stmOld, Reko.Core.Statement? stmNew) -> void
Reko.Analysis.SsaState.SsaState(Reko.Core.Procedure! proc) -> void
Reko.Analysis.SsaState.Validate(System.Action<string!>! error) -> void
Reko.Analysis.SsaState.ValidateDefinitions(System.Action<string!>! error) -> void
Reko.Analysis.SsaState.ValidateUses() -> void
Reko.Analysis.SsaState.ValidateUses(System.Action<string!>! error) -> void
Reko.Analysis.SsaState.Write(System.IO.TextWriter! writer) -> void
Reko.Analysis.SsaTransform
Reko.Analysis.SsaTransform.AddUsesToExitBlock() -> void
Reko.Analysis.SsaTransform.Alias
Reko.Analysis.SsaTransform.Alias.Alias(Reko.Analysis.SsaIdentifier! sid) -> void
Reko.Analysis.SsaTransform.Alias.SsaId.get -> Reko.Analysis.SsaIdentifier!
Reko.Analysis.SsaTransform.Alias.SsaId.set -> void
Reko.Analysis.SsaTransform.AliasState
Reko.Analysis.SsaTransform.AliasState.AliasState() -> void
Reko.Analysis.SsaTransform.AliasState.Definitions -> System.Collections.Generic.List<(Reko.Analysis.SsaIdentifier!, Reko.Core.BitRange, int)>!
Reko.Analysis.SsaTransform.AliasState.ExactAliases -> System.Collections.Generic.Dictionary<Reko.Core.Storage!, Reko.Analysis.SsaIdentifier!>!
Reko.Analysis.SsaTransform.CollectFlagGroups(System.Collections.Generic.IEnumerable<Reko.Core.Expressions.Identifier!>! ids, Reko.Core.IStorageBinder! binder, Reko.Core.IProcessorArchitecture! arch) -> System.Collections.Generic.IEnumerable<Reko.Core.Expressions.Identifier!>!
Reko.Analysis.SsaTransform.ExpandFlagGroups(System.Collections.Generic.IEnumerable<Reko.Core.Expressions.Identifier!>! ids) -> System.Collections.Generic.IEnumerable<Reko.Core.Expressions.Identifier!>!
Reko.Analysis.SsaTransform.FlagAliasState
Reko.Analysis.SsaTransform.FlagAliasState.Definitions -> System.Collections.Generic.List<(Reko.Analysis.SsaIdentifier!, uint)>!
Reko.Analysis.SsaTransform.FlagAliasState.ExactAliases -> System.Collections.Generic.Dictionary<Reko.Core.Expressions.Identifier!, Reko.Analysis.SsaIdentifier!>!
Reko.Analysis.SsaTransform.FlagAliasState.FlagAliasState() -> void
Reko.Analysis.SsaTransform.FlagGroupTransformer
Reko.Analysis.SsaTransform.FlagGroupTransformer.FlagGroupTransformer(Reko.Core.Expressions.Identifier! id, Reko.Core.FlagGroupStorage! flagGroup, Reko.Core.Statement! stm, Reko.Analysis.SsaTransform! outer) -> void
Reko.Analysis.SsaTransform.FlagGroupTransformer.FlagGroupTransformer(Reko.Core.Expressions.Identifier! id, Reko.Core.FlagGroupStorage! flagGroup, Reko.Core.Statement! stm, Reko.Analysis.SsaTransform! outer, uint flagMask) -> void
Reko.Analysis.SsaTransform.FlagGroupTransformer.MaybeGenerateAliasStatement(Reko.Analysis.SsaIdentifier! sidFrom, Reko.Core.FlagGroupStorage! stgUse) -> Reko.Analysis.SsaIdentifier!
Reko.Analysis.SsaTransform.GuessParameterIdentifiers(Reko.Core.Code.CallInstruction! call, Reko.Core.Statement! stmCall) -> System.Collections.Generic.IEnumerable<Reko.Core.Expressions.Identifier!>!
Reko.Analysis.SsaTransform.IdentifierTransformer
Reko.Analysis.SsaTransform.IdentifierTransformer.AddPhiOperands(Reko.Analysis.SsaIdentifier! phi) -> Reko.Analysis.SsaIdentifier!
Reko.Analysis.SsaTransform.IdentifierTransformer.CreateBitInterval(int unitStackOffset, Reko.Core.Types.DataType! dt) -> Reko.Core.Collections.Interval<int>
Reko.Analysis.SsaTransform.IdentifierTransformer.id -> Reko.Core.Expressions.Identifier!
Reko.Analysis.SsaTransform.IdentifierTransformer.IdentifierTransformer(Reko.Core.Expressions.Identifier! id, Reko.Core.Statement! stm, Reko.Analysis.SsaTransform! outer) -> void
Reko.Analysis.SsaTransform.IdentifierTransformer.InsertBeforeStatement(Reko.Core.Block! block, Reko.Core.Statement! stm, Reko.Core.Code.Assignment! ass) -> Reko.Analysis.SsaIdentifier!
Reko.Analysis.SsaTransform.IdentifierTransformer.MeasureBitSize(Reko.Core.Types.DataType! dt) -> int
Reko.Analysis.SsaTransform.IdentifierTransformer.NewDefInstruction(Reko.Core.Expressions.Identifier! id, Reko.Core.Block! b) -> Reko.Analysis.SsaIdentifier!
Reko.Analysis.SsaTransform.IdentifierTransformer.Offset.get -> int
Reko.Analysis.SsaTransform.IdentifierTransformer.ReadVariableRecursive(Reko.Analysis.SsaTransform.SsaBlockState! bs) -> Reko.Analysis.SsaIdentifier?
Reko.Analysis.SsaTransform.NewDef(Reko.Core.Expressions.Identifier! idOld, Reko.Core.Expressions.Expression! src, bool isSideEffect) -> Reko.Core.Expressions.Identifier!
Reko.Analysis.SsaTransform.RegisterTransformer
Reko.Analysis.SsaTransform.RegisterTransformer.FindIntersectingRegister(System.Collections.Generic.List<(Reko.Analysis.SsaIdentifier!, Reko.Core.BitRange, int)>! definitions, Reko.Core.BitRange useRange) -> (Reko.Analysis.SsaIdentifier?, Reko.Core.BitRange, Reko.Core.BitRange)
Reko.Analysis.SsaTransform.RegisterTransformer.liveBits -> Reko.Core.BitRange
Reko.Analysis.SsaTransform.RegisterTransformer.RegisterTransformer(Reko.Core.Expressions.Identifier! id, Reko.Core.Statement! stm, Reko.Analysis.SsaTransform! outer) -> void
Reko.Analysis.SsaTransform.RemoveDeadSsaIdentifiers() -> void
Reko.Analysis.SsaTransform.RemoveOrphanedBasicBlocks() -> void
Reko.Analysis.SsaTransform.RenameFrameAccesses.get -> bool
Reko.Analysis.SsaTransform.RenameFrameAccesses.set -> void
Reko.Analysis.SsaTransform.SeparateSequences(System.Collections.Generic.IEnumerable<Reko.Core.Expressions.Identifier!>! ids) -> System.Collections.Generic.IEnumerable<Reko.Core.Expressions.Identifier!>!
Reko.Analysis.SsaTransform.SequenceTransformer
Reko.Analysis.SsaTransform.SequenceTransformer.Fuse(Reko.Analysis.SsaIdentifier![]! sids) -> Reko.Analysis.SsaIdentifier!
Reko.Analysis.SsaTransform.SequenceTransformer.SequenceTransformer(Reko.Core.Expressions.Identifier! id, Reko.Core.SequenceStorage! seq, Reko.Core.Statement! stm, Reko.Analysis.SsaTransform! outer) -> void
Reko.Analysis.SsaTransform.SimpleTransformer
Reko.Analysis.SsaTransform.SimpleTransformer.SimpleTransformer(Reko.Core.Expressions.Identifier! id, Reko.Core.Storage! stg, Reko.Core.Statement! stm, Reko.Analysis.SsaTransform! outer) -> void
Reko.Analysis.SsaTransform.SsaBlockState
Reko.Analysis.SsaTransform.SsaBlockState.SsaBlockState(Reko.Core.Block! block) -> void
Reko.Analysis.SsaTransform.SsaBlockState.Terminates -> bool
Reko.Analysis.SsaTransform.SsaBlockState.Visited -> bool
Reko.Analysis.SsaTransform.SsaState.get -> Reko.Analysis.SsaState!
Reko.Analysis.SsaTransform.SsaTransform(Reko.Core.Program! program, Reko.Core.Procedure! proc, System.Collections.Generic.HashSet<Reko.Core.Procedure!>! sccProcs, Reko.Core.IDynamicLinker! dynamicLinker, Reko.Analysis.ProgramDataFlow! programFlow) -> void
Reko.Analysis.SsaTransform.StackTransformer
Reko.Analysis.SsaTransform.StackTransformer.StackTransformer(Reko.Core.Expressions.Identifier! id, int stackOffset, Reko.Core.Statement! stm, Reko.Analysis.SsaTransform! outer) -> void
Reko.Analysis.SsaTransform.Transform() -> Reko.Analysis.SsaState!
Reko.Analysis.SsaTransform.TransformerFactory
Reko.Analysis.SsaTransform.TransformerFactory.Create(Reko.Core.Expressions.Identifier! id, Reko.Core.Statement! stm) -> Reko.Analysis.SsaTransform.IdentifierTransformer!
Reko.Analysis.SsaTransform.TransformerFactory.TransformerFactory(Reko.Analysis.SsaTransform! transform) -> void
Reko.Analysis.SsaTransform.TransformerFactory.VisitFlagGroupStorage(Reko.Core.FlagGroupStorage! grf) -> Reko.Analysis.SsaTransform.IdentifierTransformer!
Reko.Analysis.SsaTransform.TransformerFactory.VisitFpuStackStorage(Reko.Core.FpuStackStorage! fpu) -> Reko.Analysis.SsaTransform.IdentifierTransformer!
Reko.Analysis.SsaTransform.TransformerFactory.VisitMemoryStorage(Reko.Core.MemoryStorage! global) -> Reko.Analysis.SsaTransform.IdentifierTransformer!
Reko.Analysis.SsaTransform.TransformerFactory.VisitOutArgumentStorage(Reko.Core.OutArgumentStorage! arg) -> Reko.Analysis.SsaTransform.IdentifierTransformer!
Reko.Analysis.SsaTransform.TransformerFactory.VisitRegisterStorage(Reko.Core.RegisterStorage! reg) -> Reko.Analysis.SsaTransform.IdentifierTransformer!
Reko.Analysis.SsaTransform.TransformerFactory.VisitSequenceStorage(Reko.Core.SequenceStorage! seq) -> Reko.Analysis.SsaTransform.IdentifierTransformer!
Reko.Analysis.SsaTransform.TransformerFactory.VisitStackStorage(Reko.Core.StackStorage! local) -> Reko.Analysis.SsaTransform.IdentifierTransformer!
Reko.Analysis.SsaTransform.TransformerFactory.VisitTemporaryStorage(Reko.Core.TemporaryStorage! temp) -> Reko.Analysis.SsaTransform.IdentifierTransformer!
Reko.Analysis.StackPointerBackpropagator
Reko.Analysis.StackPointerBackpropagator.BackpropagateStackPointer() -> void
Reko.Analysis.StackPointerBackpropagator.StackPointerBackpropagator(Reko.Analysis.SsaState! ssa, Reko.Core.Services.DecompilerEventListener! listener) -> void
Reko.Analysis.StoreFuser
Reko.Analysis.StoreFuser.StoreFuser(Reko.Analysis.SsaState! ssa) -> void
Reko.Analysis.StoreFuser.Transform() -> void
Reko.Analysis.StrengthReduction
Reko.Analysis.StrengthReduction.ClassifyUses() -> void
Reko.Analysis.StrengthReduction.IncrementedUse
Reko.Analysis.StrengthReduction.IncrementedUse.Expression.get -> Reko.Core.Expressions.BinaryExpression?
Reko.Analysis.StrengthReduction.IncrementedUse.Increment.get -> Reko.Core.Expressions.Constant?
Reko.Analysis.StrengthReduction.IncrementedUse.IncrementedUse(Reko.Core.Statement! stm, Reko.Core.Expressions.BinaryExpression? exp, Reko.Core.Expressions.Constant? inc) -> void
Reko.Analysis.StrengthReduction.IncrementedUse.Statement.get -> Reko.Core.Statement!
Reko.Analysis.StrengthReduction.IncrementedUseFinder
Reko.Analysis.StrengthReduction.IncrementedUseFinder.IncrementedUseFinder(System.Collections.Generic.List<Reko.Analysis.StrengthReduction.IncrementedUse!>! uses) -> void
Reko.Analysis.StrengthReduction.IncrementedUseFinder.Match(Reko.Core.Expressions.Identifier! id, Reko.Core.Statement! stm) -> void
Reko.Analysis.StrengthReduction.IncrementedUses.get -> System.Collections.Generic.List<Reko.Analysis.StrengthReduction.IncrementedUse!>!
Reko.Analysis.StrengthReduction.ModifyUses() -> void
Reko.Analysis.StrengthReduction.StrengthReduction(Reko.Analysis.SsaState! ssa, Reko.Core.LinearInductionVariable! liv, Reko.Analysis.LinearInductionVariableContext! ctx) -> void
Reko.Analysis.TrashedRegisterFinder
Reko.Analysis.TrashedRegisterFinder.Compute() -> void
Reko.Analysis.TrashedRegisterFinder.Context
Reko.Analysis.TrashedRegisterFinder.Context.Clone() -> Reko.Analysis.TrashedRegisterFinder.Context!
Reko.Analysis.TrashedRegisterFinder.Context.Context(Reko.Analysis.SsaState! ssa, Reko.Core.Expressions.Identifier! fp, System.Collections.Generic.Dictionary<Reko.Core.Expressions.Identifier!, (Reko.Core.Expressions.Expression!, Reko.Core.BitRange)>! idState, Reko.Analysis.ProcedureFlow! procFlow) -> void
Reko.Analysis.TrashedRegisterFinder.Context.Endianness.get -> Reko.Core.EndianServices!
Reko.Analysis.TrashedRegisterFinder.Context.GetBitRange(Reko.Core.Expressions.Identifier! id) -> Reko.Core.BitRange
Reko.Analysis.TrashedRegisterFinder.Context.GetDefiningExpression(Reko.Core.Expressions.Identifier! id) -> Reko.Core.Expressions.Expression?
Reko.Analysis.TrashedRegisterFinder.Context.GetDefiningStatementClosure(Reko.Core.Expressions.Identifier! id) -> System.Collections.Generic.List<Reko.Core.Statement!>!
Reko.Analysis.TrashedRegisterFinder.Context.GetValue(Reko.Core.Expressions.Application! appl) -> Reko.Core.Expressions.Expression!
Reko.Analysis.TrashedRegisterFinder.Context.GetValue(Reko.Core.Expressions.Identifier! id) -> Reko.Core.Expressions.Expression?
Reko.Analysis.TrashedRegisterFinder.Context.GetValue(Reko.Core.Expressions.MemoryAccess! access, Reko.Core.SegmentMap! segmentMap) -> Reko.Core.Expressions.Expression!
Reko.Analysis.TrashedRegisterFinder.Context.GetValue(Reko.Core.Expressions.SegmentedAccess! access, Reko.Core.SegmentMap! segmentMap) -> Reko.Core.Expressions.Expression!
Reko.Analysis.TrashedRegisterFinder.Context.IsDirty.get -> bool
Reko.Analysis.TrashedRegisterFinder.Context.IsDirty.set -> void
Reko.Analysis.TrashedRegisterFinder.Context.IsUsedInPhi(Reko.Core.Expressions.Identifier! id) -> bool
Reko.Analysis.TrashedRegisterFinder.Context.MakeSegmentedAddress(Reko.Core.Expressions.Constant! c1, Reko.Core.Expressions.Constant! c2) -> Reko.Core.Expressions.Expression!
Reko.Analysis.TrashedRegisterFinder.Context.MemoryGranularity.get -> int
Reko.Analysis.TrashedRegisterFinder.Context.MergeWith(Reko.Analysis.TrashedRegisterFinder.Context! ctxOther) -> bool
Reko.Analysis.TrashedRegisterFinder.Context.ProcFlow -> Reko.Analysis.ProcedureFlow!
Reko.Analysis.TrashedRegisterFinder.Context.ReinterpretAsFloat(Reko.Core.Expressions.Constant! rawBits) -> Reko.Core.Expressions.Constant!
Reko.Analysis.TrashedRegisterFinder.Context.RemoveExpressionUse(Reko.Core.Expressions.Expression! expr) -> void
Reko.Analysis.TrashedRegisterFinder.Context.RemoveIdentifierUse(Reko.Core.Expressions.Identifier! id) -> void
Reko.Analysis.TrashedRegisterFinder.Context.SetValue(Reko.Core.Expressions.Identifier! id, Reko.Core.Expressions.Expression! value) -> void
Reko.Analysis.TrashedRegisterFinder.Context.SetValue(Reko.Core.Expressions.Identifier! id, Reko.Core.Expressions.Expression! value, Reko.Core.BitRange range) -> void
Reko.Analysis.TrashedRegisterFinder.Context.SetValueEa(Reko.Core.Expressions.Expression! basePointer, Reko.Core.Expressions.Expression! ea, Reko.Core.Expressions.Expression! value) -> void
Reko.Analysis.TrashedRegisterFinder.Context.SetValueEa(Reko.Core.Expressions.Expression! effectiveAddress, Reko.Core.Expressions.Expression! value) -> void
Reko.Analysis.TrashedRegisterFinder.Context.UseExpression(Reko.Core.Expressions.Expression! expr) -> void
Reko.Analysis.TrashedRegisterFinder.Dump(Reko.Core.Block! block) -> void
Reko.Analysis.TrashedRegisterFinder.TrashedRegisterFinder(Reko.Core.Program! program, Reko.Analysis.ProgramDataFlow! flow, System.Collections.Generic.IEnumerable<Reko.Analysis.SsaTransform!>! sccGroup, Reko.Core.Services.DecompilerEventListener! listener) -> void
Reko.Analysis.TrashedRegisterFinder.VisitAssignment(Reko.Core.Code.Assignment! ass) -> bool
Reko.Analysis.TrashedRegisterFinder.VisitBranch(Reko.Core.Code.Branch! branch) -> bool
Reko.Analysis.TrashedRegisterFinder.VisitCallInstruction(Reko.Core.Code.CallInstruction! ci) -> bool
Reko.Analysis.TrashedRegisterFinder.VisitComment(Reko.Core.Code.CodeComment! comment) -> bool
Reko.Analysis.TrashedRegisterFinder.VisitDeclaration(Reko.Core.Code.Declaration! decl) -> bool
Reko.Analysis.TrashedRegisterFinder.VisitDefInstruction(Reko.Core.Code.DefInstruction! def) -> bool
Reko.Analysis.TrashedRegisterFinder.VisitGotoInstruction(Reko.Core.Code.GotoInstruction! g) -> bool
Reko.Analysis.TrashedRegisterFinder.VisitPhiAssignment(Reko.Core.Code.PhiAssignment! phi) -> bool
Reko.Analysis.TrashedRegisterFinder.VisitReturnInstruction(Reko.Core.Code.ReturnInstruction! ret) -> bool
Reko.Analysis.TrashedRegisterFinder.VisitSideEffect(Reko.Core.Code.SideEffect! side) -> bool
Reko.Analysis.TrashedRegisterFinder.VisitStore(Reko.Core.Code.Store! store) -> bool
Reko.Analysis.TrashedRegisterFinder.VisitSwitchInstruction(Reko.Core.Code.SwitchInstruction! si) -> bool
Reko.Analysis.TrashedRegisterFinder.VisitUseInstruction(Reko.Core.Code.UseInstruction! use) -> bool
Reko.Analysis.UnalignedMemoryAccessFuser
Reko.Analysis.UnalignedMemoryAccessFuser.FuseUnalignedLoads(Reko.Core.Code.Assignment! assR) -> void
Reko.Analysis.UnalignedMemoryAccessFuser.Transform() -> void
Reko.Analysis.UnalignedMemoryAccessFuser.UnalignedAccess
Reko.Analysis.UnalignedMemoryAccessFuser.UnalignedAccess.isLeft -> bool
Reko.Analysis.UnalignedMemoryAccessFuser.UnalignedAccess.mem -> Reko.Core.Expressions.Expression?
Reko.Analysis.UnalignedMemoryAccessFuser.UnalignedAccess.offset -> int
Reko.Analysis.UnalignedMemoryAccessFuser.UnalignedAccess.reg -> Reko.Core.Expressions.Identifier?
Reko.Analysis.UnalignedMemoryAccessFuser.UnalignedAccess.stm -> Reko.Core.Statement?
Reko.Analysis.UnalignedMemoryAccessFuser.UnalignedAccess.UnalignedAccess() -> void
Reko.Analysis.UnalignedMemoryAccessFuser.UnalignedAccess.value -> Reko.Core.Expressions.Expression?
Reko.Analysis.UnalignedMemoryAccessFuser.UnalignedMemoryAccessFuser(Reko.Analysis.SsaState! ssa) -> void
Reko.Analysis.UnreachableBlockRemover
Reko.Analysis.UnreachableBlockRemover.Transform() -> void
Reko.Analysis.UnreachableBlockRemover.UnreachableBlockRemover(Reko.Analysis.SsaState! ssa, Reko.Core.Services.DecompilerEventListener! listener) -> void
Reko.Analysis.UnusedOutValuesRemover
Reko.Analysis.UnusedOutValuesRemover.DumpLiveOut() -> void
Reko.Analysis.UnusedOutValuesRemover.RemoveUnusedDefinedValues(Reko.Analysis.SsaState! ssa, Reko.Core.WorkList<Reko.Analysis.SsaState!>! wl) -> bool
Reko.Analysis.UnusedOutValuesRemover.Transform() -> void
Reko.Analysis.UnusedOutValuesRemover.UnusedOutValuesRemover(Reko.Core.Program! program, System.Collections.Generic.IEnumerable<Reko.Analysis.SsaState!>! ssaStates, Reko.Analysis.ProgramDataFlow! dataFlow, Reko.Core.IDynamicLinker! dynamicLinker, Reko.Core.Services.DecompilerEventListener! eventListener) -> void
Reko.Analysis.UsedRegisterFinder
Reko.Analysis.UsedRegisterFinder.Classify(Reko.Analysis.SsaIdentifier! sid) -> Reko.Core.BitRange
Reko.Analysis.UsedRegisterFinder.Classify(Reko.Analysis.SsaState! ssa, Reko.Analysis.SsaIdentifier! sid, Reko.Core.Storage! storage, bool ignoreUseInstructions) -> Reko.Core.BitRange
Reko.Analysis.UsedRegisterFinder.ComputeLiveIn(Reko.Analysis.SsaState! ssaState, bool ignoreUse) -> Reko.Analysis.ProcedureFlow!
Reko.Analysis.UsedRegisterFinder.UsedRegisterFinder(Reko.Core.Program! program, Reko.Analysis.ProgramDataFlow! flow, System.Collections.Generic.IEnumerable<Reko.Core.Procedure!>! scc, Reko.Core.Services.DecompilerEventListener! eventListener) -> void
Reko.Analysis.UsedRegisterFinder.VisitAddress(Reko.Core.Address! addr) -> Reko.Core.BitRange
Reko.Analysis.UsedRegisterFinder.VisitApplication(Reko.Core.Expressions.Application! appl) -> Reko.Core.BitRange
Reko.Analysis.UsedRegisterFinder.VisitArrayAccess(Reko.Core.Expressions.ArrayAccess! acc) -> Reko.Core.BitRange
Reko.Analysis.UsedRegisterFinder.VisitAssignment(Reko.Core.Code.Assignment! ass) -> Reko.Core.BitRange
Reko.Analysis.UsedRegisterFinder.VisitBinaryExpression(Reko.Core.Expressions.BinaryExpression! binExp) -> Reko.Core.BitRange
Reko.Analysis.UsedRegisterFinder.VisitBranch(Reko.Core.Code.Branch! branch) -> Reko.Core.BitRange
Reko.Analysis.UsedRegisterFinder.VisitCallInstruction(Reko.Core.Code.CallInstruction! ci) -> Reko.Core.BitRange
Reko.Analysis.UsedRegisterFinder.VisitCast(Reko.Core.Expressions.Cast! cast) -> Reko.Core.BitRange
Reko.Analysis.UsedRegisterFinder.VisitComment(Reko.Core.Code.CodeComment! comment) -> Reko.Core.BitRange
Reko.Analysis.UsedRegisterFinder.VisitConditionalExpression(Reko.Core.Expressions.ConditionalExpression! c) -> Reko.Core.BitRange
Reko.Analysis.UsedRegisterFinder.VisitConditionOf(Reko.Core.Expressions.ConditionOf! cof) -> Reko.Core.BitRange
Reko.Analysis.UsedRegisterFinder.VisitConstant(Reko.Core.Expressions.Constant! c) -> Reko.Core.BitRange
Reko.Analysis.UsedRegisterFinder.VisitConversion(Reko.Core.Expressions.Conversion! conversion) -> Reko.Core.BitRange
Reko.Analysis.UsedRegisterFinder.VisitDeclaration(Reko.Core.Code.Declaration! decl) -> Reko.Core.BitRange
Reko.Analysis.UsedRegisterFinder.VisitDefInstruction(Reko.Core.Code.DefInstruction! def) -> Reko.Core.BitRange
Reko.Analysis.UsedRegisterFinder.VisitDereference(Reko.Core.Expressions.Dereference! deref) -> Reko.Core.BitRange
Reko.Analysis.UsedRegisterFinder.VisitFieldAccess(Reko.Core.Expressions.FieldAccess! acc) -> Reko.Core.BitRange
Reko.Analysis.UsedRegisterFinder.VisitGotoInstruction(Reko.Core.Code.GotoInstruction! gotoInstruction) -> Reko.Core.BitRange
Reko.Analysis.UsedRegisterFinder.VisitIdentifier(Reko.Core.Expressions.Identifier! id) -> Reko.Core.BitRange
Reko.Analysis.UsedRegisterFinder.VisitMemberPointerSelector(Reko.Core.Expressions.MemberPointerSelector! mps) -> Reko.Core.BitRange
Reko.Analysis.UsedRegisterFinder.VisitMemoryAccess(Reko.Core.Expressions.MemoryAccess! access) -> Reko.Core.BitRange
Reko.Analysis.UsedRegisterFinder.VisitMkSequence(Reko.Core.Expressions.MkSequence! seq) -> Reko.Core.BitRange
Reko.Analysis.UsedRegisterFinder.VisitOutArgument(Reko.Core.Expressions.OutArgument! outArgument) -> Reko.Core.BitRange
Reko.Analysis.UsedRegisterFinder.VisitPhiAssignment(Reko.Core.Code.PhiAssignment! phi) -> Reko.Core.BitRange
Reko.Analysis.UsedRegisterFinder.VisitPhiFunction(Reko.Core.Expressions.PhiFunction! phi) -> Reko.Core.BitRange
Reko.Analysis.UsedRegisterFinder.VisitPointerAddition(Reko.Core.Expressions.PointerAddition! pa) -> Reko.Core.BitRange
Reko.Analysis.UsedRegisterFinder.VisitProcedureConstant(Reko.Core.Expressions.ProcedureConstant! pc) -> Reko.Core.BitRange
Reko.Analysis.UsedRegisterFinder.VisitReturnInstruction(Reko.Core.Code.ReturnInstruction! ret) -> Reko.Core.BitRange
Reko.Analysis.UsedRegisterFinder.VisitScopeResolution(Reko.Core.Expressions.ScopeResolution! scopeResolution) -> Reko.Core.BitRange
Reko.Analysis.UsedRegisterFinder.VisitSegmentedAccess(Reko.Core.Expressions.SegmentedAccess! access) -> Reko.Core.BitRange
Reko.Analysis.UsedRegisterFinder.VisitSideEffect(Reko.Core.Code.SideEffect! side) -> Reko.Core.BitRange
Reko.Analysis.UsedRegisterFinder.VisitSlice(Reko.Core.Expressions.Slice! slice) -> Reko.Core.BitRange
Reko.Analysis.UsedRegisterFinder.VisitStore(Reko.Core.Code.Store! store) -> Reko.Core.BitRange
Reko.Analysis.UsedRegisterFinder.VisitSwitchInstruction(Reko.Core.Code.SwitchInstruction! si) -> Reko.Core.BitRange
Reko.Analysis.UsedRegisterFinder.VisitTestCondition(Reko.Core.Expressions.TestCondition! tc) -> Reko.Core.BitRange
Reko.Analysis.UsedRegisterFinder.VisitUnaryExpression(Reko.Core.Expressions.UnaryExpression! unary) -> Reko.Core.BitRange
Reko.Analysis.UsedRegisterFinder.VisitUseInstruction(Reko.Core.Code.UseInstruction! use) -> Reko.Core.BitRange
Reko.Analysis.ValuePropagator
Reko.Analysis.ValuePropagator.Transform() -> void
Reko.Analysis.ValuePropagator.Transform(Reko.Core.Statement! stm) -> bool
Reko.Analysis.ValuePropagator.ValuePropagator(Reko.Core.SegmentMap! segmentMap, Reko.Analysis.SsaState! ssa, Reko.Core.CallGraph! callGraph, Reko.Core.IDynamicLinker! dynamicLinker, Reko.Core.Services.DecompilerEventListener! eventListener) -> void
Reko.Analysis.ValuePropagator.VisitAssignment(Reko.Core.Code.Assignment! a) -> (Reko.Core.Code.Instruction!, bool)
Reko.Analysis.ValuePropagator.VisitBranch(Reko.Core.Code.Branch! b) -> (Reko.Core.Code.Instruction!, bool)
Reko.Analysis.ValuePropagator.VisitCallInstruction(Reko.Core.Code.CallInstruction! ci) -> (Reko.Core.Code.Instruction!, bool)
Reko.Analysis.ValuePropagator.VisitComment(Reko.Core.Code.CodeComment! comment) -> (Reko.Core.Code.Instruction!, bool)
Reko.Analysis.ValuePropagator.VisitDeclaration(Reko.Core.Code.Declaration! decl) -> (Reko.Core.Code.Instruction!, bool)
Reko.Analysis.ValuePropagator.VisitDefInstruction(Reko.Core.Code.DefInstruction! def) -> (Reko.Core.Code.Instruction!, bool)
Reko.Analysis.ValuePropagator.VisitGotoInstruction(Reko.Core.Code.GotoInstruction! gotoInstruction) -> (Reko.Core.Code.Instruction!, bool)
Reko.Analysis.ValuePropagator.VisitPhiAssignment(Reko.Core.Code.PhiAssignment! phi) -> (Reko.Core.Code.Instruction!, bool)
Reko.Analysis.ValuePropagator.VisitReturnInstruction(Reko.Core.Code.ReturnInstruction! ret) -> (Reko.Core.Code.Instruction!, bool)
Reko.Analysis.ValuePropagator.VisitSideEffect(Reko.Core.Code.SideEffect! side) -> (Reko.Core.Code.Instruction!, bool)
Reko.Analysis.ValuePropagator.VisitStore(Reko.Core.Code.Store! store) -> (Reko.Core.Code.Instruction!, bool)
Reko.Analysis.ValuePropagator.VisitSwitchInstruction(Reko.Core.Code.SwitchInstruction! si) -> (Reko.Core.Code.Instruction!, bool)
Reko.Analysis.ValuePropagator.VisitUseInstruction(Reko.Core.Code.UseInstruction! u) -> (Reko.Core.Code.Instruction!, bool)
Reko.Analysis.Web
Reko.Analysis.Web.Add(Reko.Analysis.SsaIdentifier! sid) -> void
Reko.Analysis.Web.DefExprs.get -> System.Collections.Generic.List<Reko.Core.Expressions.Expression!>!
Reko.Analysis.Web.Definitions.get -> System.Collections.Generic.HashSet<Reko.Core.Statement!>!
Reko.Analysis.Web.Identifier.get -> Reko.Core.Expressions.Identifier?
Reko.Analysis.Web.InductionVariable.get -> Reko.Core.LinearInductionVariable?
Reko.Analysis.Web.Members.get -> System.Collections.Generic.HashSet<Reko.Analysis.SsaIdentifier!>!
Reko.Analysis.Web.Uses.get -> System.Collections.Generic.HashSet<Reko.Core.Statement!>!
Reko.Analysis.Web.Web() -> void
Reko.Analysis.Web.Write(System.IO.TextWriter! writer) -> void
Reko.Analysis.WebBuilder
Reko.Analysis.WebBuilder.InsertDeclarations() -> void
Reko.Analysis.WebBuilder.OutDefinitionFinder
Reko.Analysis.WebBuilder.OutDefinitionFinder.OutDefinitionFinder(Reko.Core.Expressions.Identifier! id) -> void
Reko.Analysis.WebBuilder.Transform() -> void
Reko.Analysis.WebBuilder.VisitPhiAssignment(Reko.Core.Code.PhiAssignment! p) -> void
Reko.Analysis.WebBuilder.VisitStatement(Reko.Core.Statement! stm) -> void
Reko.Analysis.WebBuilder.WebBuilder(Reko.Core.Program! program, Reko.Analysis.SsaState! ssa, System.Collections.Generic.Dictionary<Reko.Core.Expressions.Identifier!, Reko.Core.LinearInductionVariable!>! ivs, Reko.Core.Services.DecompilerEventListener! listener) -> void
Reko.Analysis.WebBuilder.WebOf(Reko.Core.Expressions.Identifier! id) -> Reko.Analysis.Web!
Reko.Analysis.WebBuilder.Write(System.IO.TextWriter! writer) -> void
Reko.DecompiledFileService
Reko.DecompiledFileService.CreateTextWriter(string! filename) -> System.IO.TextWriter!
Reko.DecompiledFileService.DecompiledFileService(System.IServiceProvider! services, Reko.Core.Services.IFileSystemService! fsSvc, Reko.Core.Services.DecompilerEventListener! listener) -> void
Reko.DecompiledFileService.WriteDecompiledCode(Reko.Core.Program! program, System.Action<string!, System.Collections.Generic.IEnumerable<Reko.Core.IAddressable!>!, System.IO.TextWriter!>! writer) -> void
Reko.DecompiledFileService.WriteDisassembly(Reko.Core.Program! program, System.Action<string!, System.Collections.Generic.Dictionary<Reko.Core.ImageSegment!, System.Collections.Generic.List<Reko.Core.ImageMapItem!>!>!, Reko.Core.Output.Formatter!>! writer) -> void
Reko.DecompiledFileService.WriteGlobals(Reko.Core.Program! program, System.Action<string!, System.IO.TextWriter!>! writer) -> void
Reko.DecompiledFileService.WriteIntermediateCode(Reko.Core.Program! program, System.Action<string!, System.Collections.Generic.IEnumerable<Reko.Core.IAddressable!>!, System.IO.TextWriter!>! writer) -> void
Reko.DecompiledFileService.WriteTypes(Reko.Core.Program! program, System.Action<string!, System.IO.TextWriter!>! writer) -> void
Reko.Decompiler
Reko.Decompiler.Decompile() -> void
Reko.Decompiler.Decompiler(Reko.Core.Project! project, System.IServiceProvider! services) -> void
Reko.Decompiler.DumpAssembler(Reko.Core.Program! program, string! filename, System.Collections.Generic.Dictionary<Reko.Core.ImageSegment!, System.Collections.Generic.List<Reko.Core.ImageMapItem!>!>! segmentItems, Reko.Core.Output.Formatter! wr) -> void
Reko.Decompiler.ExtractResources() -> void
Reko.Decompiler.ExtractResources(Reko.Core.Program! program) -> void
Reko.Decompiler.LoadCallSignatures(Reko.Core.Program! program, System.Collections.Generic.ICollection<Reko.Core.Serialization.SerializedCall_v1!>! userCalls) -> System.Collections.Generic.IDictionary<Reko.Core.Address!, Reko.Core.Types.FunctionType!>!
Reko.Decompiler.Project.get -> Reko.Core.Project!
Reko.Decompiler.Project.set -> void
Reko.Decompiler.ProjectChanged -> System.EventHandler?
Reko.Decompiler.ReconstructTypes() -> void
Reko.Decompiler.ScanProcedure(Reko.Core.ProgramAddress! paddr, Reko.Core.IProcessorArchitecture! arch) -> Reko.Core.ProcedureBase!
Reko.Decompiler.ScanPrograms() -> void
Reko.Decompiler.StructureProgram() -> void
Reko.Decompiler.WriteDecompiledObjects(Reko.Core.Program! program, string! filename, System.Collections.Generic.IEnumerable<Reko.Core.IAddressable!>! objects, System.IO.TextWriter! w) -> void
Reko.Decompiler.WriteDecompiledTypes(Reko.Core.Program! program, string! headerFilename, System.IO.TextWriter! w) -> void
Reko.Decompiler.WriteDecompilerProducts() -> void
Reko.Decompiler.WriteGlobals(Reko.Core.Program! program, string! filename, System.IO.TextWriter! w) -> void
Reko.Decompiler.WriteHeaderComment(string! filename, Reko.Core.Program! program, System.IO.TextWriter! w) -> void
Reko.Decompiler.WriteSccs(Reko.Core.Program! program) -> void
Reko.Evaluation.AddTwoIdsRule
Reko.Evaluation.AddTwoIdsRule.AddTwoIdsRule(Reko.Core.EvaluationContext! ctx) -> void
Reko.Evaluation.AddTwoIdsRule.Match(Reko.Core.Expressions.BinaryExpression! binExp) -> bool
Reko.Evaluation.AddTwoIdsRule.Transform() -> Reko.Core.Expressions.Expression!
Reko.Evaluation.Add_e_c_cRule
Reko.Evaluation.Add_e_c_cRule.Add_e_c_cRule(Reko.Core.EvaluationContext! ctx) -> void
Reko.Evaluation.Add_e_c_cRule.Match(Reko.Core.Expressions.BinaryExpression! binExp, Reko.Core.Expressions.Expression! left, Reko.Core.Expressions.Expression! right) -> bool
Reko.Evaluation.Add_e_c_cRule.Transform(Reko.Core.Statement! stm) -> Reko.Core.Expressions.Expression!
Reko.Evaluation.Add_mul_id_c_id_Rule
Reko.Evaluation.Add_mul_id_c_id_Rule.Add_mul_id_c_id_Rule(Reko.Core.EvaluationContext! ctx) -> void
Reko.Evaluation.Add_mul_id_c_id_Rule.Match(Reko.Core.Expressions.BinaryExpression! exp) -> bool
Reko.Evaluation.Add_mul_id_c_id_Rule.Transform() -> Reko.Core.Expressions.Expression!
Reko.Evaluation.BinOpWithSelf_Rule
Reko.Evaluation.BinOpWithSelf_Rule.BinOpWithSelf_Rule() -> void
Reko.Evaluation.BinOpWithSelf_Rule.Match(Reko.Core.Expressions.BinaryExpression! binExp) -> bool
Reko.Evaluation.BinOpWithSelf_Rule.Transform(Reko.Core.EvaluationContext! ctx) -> Reko.Core.Expressions.Expression!
Reko.Evaluation.ComparisonConstOnLeft
Reko.Evaluation.ComparisonConstOnLeft.ComparisonConstOnLeft() -> void
Reko.Evaluation.ComparisonConstOnLeft.Match(Reko.Core.Expressions.BinaryExpression! bin) -> bool
Reko.Evaluation.ComparisonConstOnLeft.Transform() -> Reko.Core.Expressions.Expression!
Reko.Evaluation.ConstConstBin_Rule
Reko.Evaluation.ConstConstBin_Rule.ConstConstBin_Rule() -> void
Reko.Evaluation.ConstConstBin_Rule.Match(Reko.Core.Expressions.BinaryExpression! binExp) -> bool
Reko.Evaluation.ConstConstBin_Rule.Transform() -> Reko.Core.Expressions.Expression!
Reko.Evaluation.ConvertConvertRule
Reko.Evaluation.ConvertConvertRule.ConvertConvertRule(Reko.Core.EvaluationContext! ctx) -> void
Reko.Evaluation.ConvertConvertRule.Match(Reko.Core.Expressions.Conversion! c) -> bool
Reko.Evaluation.ConvertConvertRule.Transform() -> Reko.Core.Expressions.Expression!
Reko.Evaluation.DistributedCastRule
Reko.Evaluation.DistributedCastRule.DistributedCastRule() -> void
Reko.Evaluation.DistributedCastRule.Match(Reko.Core.Expressions.BinaryExpression! binExp) -> bool
Reko.Evaluation.DistributedCastRule.Transform(Reko.Core.EvaluationContext! ctx) -> Reko.Core.Expressions.Expression!
Reko.Evaluation.DistributedConversionRule
Reko.Evaluation.DistributedConversionRule.DistributedConversionRule() -> void
Reko.Evaluation.DistributedConversionRule.Match(Reko.Core.Expressions.BinaryExpression! binExp) -> bool
Reko.Evaluation.DistributedConversionRule.Transform(Reko.Core.EvaluationContext! ctx) -> Reko.Core.Expressions.Expression!
Reko.Evaluation.DistributedSliceRule
Reko.Evaluation.DistributedSliceRule.DistributedSliceRule() -> void
Reko.Evaluation.DistributedSliceRule.Match(Reko.Core.Expressions.BinaryExpression! binExp) -> bool
Reko.Evaluation.DistributedSliceRule.Transform(Reko.Core.EvaluationContext! ctx) -> Reko.Core.Expressions.Expression!
Reko.Evaluation.ExpressionSimplifier
Reko.Evaluation.ExpressionSimplifier.ExpressionSimplifier(Reko.Core.SegmentMap! segmentMap, Reko.Core.EvaluationContext! ctx, Reko.Core.Services.DecompilerEventListener! listener) -> void
Reko.Evaluation.ExpressionSimplifier.FuseLogicalOperations(Reko.Core.Types.DataType! dt, Reko.Core.Expressions.Expression![]! exps) -> Reko.Core.Expressions.Expression?
Reko.Evaluation.IdBinIdc_Rule
Reko.Evaluation.IdBinIdc_Rule.IdBinIdc_Rule(Reko.Core.EvaluationContext! ctx) -> void
Reko.Evaluation.IdBinIdc_Rule.Match(Reko.Core.Expressions.Identifier! id) -> bool
Reko.Evaluation.IdBinIdc_Rule.Transform() -> Reko.Core.Expressions.Expression!
Reko.Evaluation.IdConstant
Reko.Evaluation.IdConstant.IdConstant(Reko.Core.EvaluationContext! ctx, Reko.Core.Types.Unifier! u, Reko.Core.Services.DecompilerEventListener! listener) -> void
Reko.Evaluation.IdConstant.Match(Reko.Core.Expressions.Identifier! id) -> bool
Reko.Evaluation.IdConstant.Transform() -> Reko.Core.Expressions.Expression!
Reko.Evaluation.IdCopyPropagationRule
Reko.Evaluation.IdCopyPropagationRule.IdCopyPropagationRule(Reko.Core.EvaluationContext! ctx) -> void
Reko.Evaluation.IdCopyPropagationRule.Match(Reko.Core.Expressions.Identifier! id) -> bool
Reko.Evaluation.IdCopyPropagationRule.Transform() -> Reko.Core.Expressions.Expression!
Reko.Evaluation.IdProcConstRule
Reko.Evaluation.IdProcConstRule.IdProcConstRule(Reko.Core.EvaluationContext! ctx) -> void
Reko.Evaluation.IdProcConstRule.Match(Reko.Core.Expressions.Identifier! id) -> bool
Reko.Evaluation.IdProcConstRule.Transform() -> Reko.Core.Expressions.ProcedureConstant!
Reko.Evaluation.InstructionMatcher
Reko.Evaluation.InstructionMatcher.CapturedExpressions(string! label) -> Reko.Core.Expressions.Expression?
Reko.Evaluation.InstructionMatcher.CapturedOperators(string! label) -> Reko.Core.Operators.Operator?
Reko.Evaluation.InstructionMatcher.InstructionMatcher(Reko.Core.Code.Instruction! pattern) -> void
Reko.Evaluation.InstructionMatcher.Match(Reko.Core.Code.Instruction! instr) -> bool
Reko.Evaluation.InstructionMatcher.VisitAssignment(Reko.Core.Code.Assignment! ass) -> bool
Reko.Evaluation.InstructionMatcher.VisitBranch(Reko.Core.Code.Branch! branch) -> bool
Reko.Evaluation.InstructionMatcher.VisitCallInstruction(Reko.Core.Code.CallInstruction! ci) -> bool
Reko.Evaluation.InstructionMatcher.VisitComment(Reko.Core.Code.CodeComment! comment) -> bool
Reko.Evaluation.InstructionMatcher.VisitDeclaration(Reko.Core.Code.Declaration! decl) -> bool
Reko.Evaluation.InstructionMatcher.VisitDefInstruction(Reko.Core.Code.DefInstruction! def) -> bool
Reko.Evaluation.InstructionMatcher.VisitGotoInstruction(Reko.Core.Code.GotoInstruction! gotoInstruction) -> bool
Reko.Evaluation.InstructionMatcher.VisitPhiAssignment(Reko.Core.Code.PhiAssignment! phi) -> bool
Reko.Evaluation.InstructionMatcher.VisitReturnInstruction(Reko.Core.Code.ReturnInstruction! ret) -> bool
Reko.Evaluation.InstructionMatcher.VisitSideEffect(Reko.Core.Code.SideEffect! side) -> bool
Reko.Evaluation.InstructionMatcher.VisitStore(Reko.Core.Code.Store! store) -> bool
Reko.Evaluation.InstructionMatcher.VisitSwitchInstruction(Reko.Core.Code.SwitchInstruction! si) -> bool
Reko.Evaluation.InstructionMatcher.VisitUseInstruction(Reko.Core.Code.UseInstruction! u) -> bool
Reko.Evaluation.LogicalNotFromArithmeticSequenceRule
Reko.Evaluation.LogicalNotFromArithmeticSequenceRule.LogicalNotFromArithmeticSequenceRule() -> void
Reko.Evaluation.LogicalNotFromArithmeticSequenceRule.Match(Reko.Core.Expressions.BinaryExpression! binExp) -> bool
Reko.Evaluation.LogicalNotFromArithmeticSequenceRule.Transform() -> Reko.Core.Expressions.Expression!
Reko.Evaluation.MkSeqFromSlices_Rule
Reko.Evaluation.MkSeqFromSlices_Rule.Match(Reko.Core.Expressions.MkSequence! seq) -> bool
Reko.Evaluation.MkSeqFromSlices_Rule.MkSeqFromSlices_Rule(Reko.Core.EvaluationContext! ctx) -> void
Reko.Evaluation.MkSeqFromSlices_Rule.Transform() -> Reko.Core.Expressions.Expression!
Reko.Evaluation.Mps_Constant_Rule
Reko.Evaluation.Mps_Constant_Rule.Match(Reko.Core.Expressions.MemberPointerSelector! mps) -> bool
Reko.Evaluation.Mps_Constant_Rule.Mps_Constant_Rule(Reko.Core.EvaluationContext! ctx) -> void
Reko.Evaluation.Mps_Constant_Rule.Transform() -> Reko.Core.Expressions.Expression!
Reko.Evaluation.NegSub_Rule
Reko.Evaluation.NegSub_Rule.Match(Reko.Core.Expressions.UnaryExpression! unary) -> bool
Reko.Evaluation.NegSub_Rule.NegSub_Rule() -> void
Reko.Evaluation.NegSub_Rule.Transform() -> Reko.Core.Expressions.Expression!
Reko.Evaluation.ScaledIndexRule
Reko.Evaluation.ScaledIndexRule.Match(Reko.Core.Expressions.Expression! ea) -> bool
Reko.Evaluation.ScaledIndexRule.ScaledIndexRule(Reko.Core.EvaluationContext! ctx) -> void
Reko.Evaluation.ScaledIndexRule.Transform() -> Reko.Core.Expressions.Expression!
Reko.Evaluation.ShiftShift_c_c_Rule
Reko.Evaluation.ShiftShift_c_c_Rule.Match(Reko.Core.Expressions.BinaryExpression! b) -> bool
Reko.Evaluation.ShiftShift_c_c_Rule.ShiftShift_c_c_Rule(Reko.Core.EvaluationContext! ctx) -> void
Reko.Evaluation.ShiftShift_c_c_Rule.Transform() -> Reko.Core.Expressions.Expression!
Reko.Evaluation.Shl_add_Rule
Reko.Evaluation.Shl_add_Rule.Match(Reko.Core.Expressions.BinaryExpression! b) -> bool
Reko.Evaluation.Shl_add_Rule.Shl_add_Rule(Reko.Core.EvaluationContext! ctx) -> void
Reko.Evaluation.Shl_add_Rule.Transform() -> Reko.Core.Expressions.Expression!
Reko.Evaluation.Shl_mul_e_Rule
Reko.Evaluation.Shl_mul_e_Rule.Match(Reko.Core.Expressions.BinaryExpression! b) -> bool
Reko.Evaluation.Shl_mul_e_Rule.Shl_mul_e_Rule(Reko.Core.EvaluationContext! ctx) -> void
Reko.Evaluation.Shl_mul_e_Rule.Transform() -> Reko.Core.Expressions.Expression!
Reko.Evaluation.SliceConstant_Rule
Reko.Evaluation.SliceConstant_Rule.Match(Reko.Core.Expressions.Slice! slice) -> bool
Reko.Evaluation.SliceConstant_Rule.SliceConstant_Rule() -> void
Reko.Evaluation.SliceConstant_Rule.Transform() -> Reko.Core.Expressions.Expression!
Reko.Evaluation.SliceConvert
Reko.Evaluation.SliceConvert.Match(Reko.Core.Expressions.Slice! slice) -> bool
Reko.Evaluation.SliceConvert.SliceConvert() -> void
Reko.Evaluation.SliceConvert.Transform() -> Reko.Core.Expressions.Expression!
Reko.Evaluation.SliceMem_Rule
Reko.Evaluation.SliceMem_Rule.Match(Reko.Core.Expressions.Slice! slice) -> bool
Reko.Evaluation.SliceMem_Rule.SliceMem_Rule(Reko.Core.EvaluationContext! ctx) -> void
Reko.Evaluation.SliceMem_Rule.Transform() -> Reko.Core.Expressions.Expression!
Reko.Evaluation.SliceSegmentedPointer_Rule
Reko.Evaluation.SliceSegmentedPointer_Rule.Match(Reko.Core.Expressions.SegmentedAccess! segMem) -> bool
Reko.Evaluation.SliceSegmentedPointer_Rule.SliceSegmentedPointer_Rule(Reko.Core.EvaluationContext! ctx) -> void
Reko.Evaluation.SliceSegmentedPointer_Rule.Transform() -> Reko.Core.Expressions.Expression!
Reko.Evaluation.SliceShift
Reko.Evaluation.SliceShift.Match(Reko.Core.Expressions.Slice! slice) -> bool
Reko.Evaluation.SliceShift.SliceShift(Reko.Core.EvaluationContext! ctx) -> void
Reko.Evaluation.SliceShift.Transform() -> Reko.Core.Expressions.Expression!
Reko.Evaluation.Substitutor
Reko.Evaluation.Substitutor.Substitutor(Reko.Core.EvaluationContext! ctx) -> void
Reko.Evaluation.Substitutor.VisitAddress(Reko.Core.Address! addr) -> Reko.Core.Expressions.Expression!
Reko.Evaluation.Substitutor.VisitApplication(Reko.Core.Expressions.Application! appl) -> Reko.Core.Expressions.Expression!
Reko.Evaluation.Substitutor.VisitArrayAccess(Reko.Core.Expressions.ArrayAccess! acc) -> Reko.Core.Expressions.Expression!
Reko.Evaluation.Substitutor.VisitBinaryExpression(Reko.Core.Expressions.BinaryExpression! binExp) -> Reko.Core.Expressions.Expression!
Reko.Evaluation.Substitutor.VisitCast(Reko.Core.Expressions.Cast! cast) -> Reko.Core.Expressions.Expression!
Reko.Evaluation.Substitutor.VisitConditionalExpression(Reko.Core.Expressions.ConditionalExpression! c) -> Reko.Core.Expressions.Expression!
Reko.Evaluation.Substitutor.VisitConditionOf(Reko.Core.Expressions.ConditionOf! cof) -> Reko.Core.Expressions.Expression!
Reko.Evaluation.Substitutor.VisitConstant(Reko.Core.Expressions.Constant! c) -> Reko.Core.Expressions.Expression!
Reko.Evaluation.Substitutor.VisitConversion(Reko.Core.Expressions.Conversion! conversion) -> Reko.Core.Expressions.Expression!
Reko.Evaluation.Substitutor.VisitDereference(Reko.Core.Expressions.Dereference! deref) -> Reko.Core.Expressions.Expression!
Reko.Evaluation.Substitutor.VisitFieldAccess(Reko.Core.Expressions.FieldAccess! acc) -> Reko.Core.Expressions.Expression!
Reko.Evaluation.Substitutor.VisitIdentifier(Reko.Core.Expressions.Identifier! id) -> Reko.Core.Expressions.Expression!
Reko.Evaluation.Substitutor.VisitMemberPointerSelector(Reko.Core.Expressions.MemberPointerSelector! mps) -> Reko.Core.Expressions.Expression!
Reko.Evaluation.Substitutor.VisitMemoryAccess(Reko.Core.Expressions.MemoryAccess! access) -> Reko.Core.Expressions.Expression!
Reko.Evaluation.Substitutor.VisitMkSequence(Reko.Core.Expressions.MkSequence! seq) -> Reko.Core.Expressions.Expression!
Reko.Evaluation.Substitutor.VisitOutArgument(Reko.Core.Expressions.OutArgument! outArg) -> Reko.Core.Expressions.Expression!
Reko.Evaluation.Substitutor.VisitPhiFunction(Reko.Core.Expressions.PhiFunction! phi) -> Reko.Core.Expressions.Expression!
Reko.Evaluation.Substitutor.VisitPointerAddition(Reko.Core.Expressions.PointerAddition! pa) -> Reko.Core.Expressions.Expression!
Reko.Evaluation.Substitutor.VisitProcedureConstant(Reko.Core.Expressions.ProcedureConstant! pc) -> Reko.Core.Expressions.Expression!
Reko.Evaluation.Substitutor.VisitScopeResolution(Reko.Core.Expressions.ScopeResolution! scopeResolution) -> Reko.Core.Expressions.Expression!
Reko.Evaluation.Substitutor.VisitSegmentedAccess(Reko.Core.Expressions.SegmentedAccess! access) -> Reko.Core.Expressions.Expression!
Reko.Evaluation.Substitutor.VisitSlice(Reko.Core.Expressions.Slice! slice) -> Reko.Core.Expressions.Expression!
Reko.Evaluation.Substitutor.VisitTestCondition(Reko.Core.Expressions.TestCondition! tc) -> Reko.Core.Expressions.Expression!
Reko.Evaluation.Substitutor.VisitUnaryExpression(Reko.Core.Expressions.UnaryExpression! unary) -> Reko.Core.Expressions.Expression!
Reko.Evaluation.UnaryNegEqZeroRule
Reko.Evaluation.UnaryNegEqZeroRule.Match(Reko.Core.Expressions.BinaryExpression! binExp) -> bool
Reko.Evaluation.UnaryNegEqZeroRule.Transform() -> Reko.Core.Expressions.Expression!
Reko.Evaluation.UnaryNegEqZeroRule.UnaryNegEqZeroRule() -> void
Reko.IDecompiledFileService
Reko.IDecompiledFileService.CreateTextWriter(string! filename) -> System.IO.TextWriter!
Reko.IDecompiledFileService.WriteDecompiledCode(Reko.Core.Program! program, System.Action<string!, System.Collections.Generic.IEnumerable<Reko.Core.IAddressable!>!, System.IO.TextWriter!>! writer) -> void
Reko.IDecompiledFileService.WriteDisassembly(Reko.Core.Program! program, System.Action<string!, System.Collections.Generic.Dictionary<Reko.Core.ImageSegment!, System.Collections.Generic.List<Reko.Core.ImageMapItem!>!>!, Reko.Core.Output.Formatter!>! writer) -> void
Reko.IDecompiledFileService.WriteGlobals(Reko.Core.Program! program, System.Action<string!, System.IO.TextWriter!>! writer) -> void
Reko.IDecompiledFileService.WriteIntermediateCode(Reko.Core.Program! program, System.Action<string!, System.Collections.Generic.IEnumerable<Reko.Core.IAddressable!>!, System.IO.TextWriter!>! writer) -> void
Reko.IDecompiledFileService.WriteTypes(Reko.Core.Program! program, System.Action<string!, System.IO.TextWriter!>! writer) -> void
Reko.IDecompiler
Reko.IDecompiler.AnalyzeDataFlow() -> void
Reko.IDecompiler.ExtractResources() -> void
Reko.IDecompiler.Project.get -> Reko.Core.Project!
Reko.IDecompiler.ProjectChanged -> System.EventHandler?
Reko.IDecompiler.ReconstructTypes() -> void
Reko.IDecompiler.ScanProcedure(Reko.Core.ProgramAddress! paddr, Reko.Core.IProcessorArchitecture! arch) -> Reko.Core.ProcedureBase!
Reko.IDecompiler.ScanPrograms() -> void
Reko.IDecompiler.StructureProgram() -> void
Reko.IDecompiler.WriteDecompilerProducts() -> void
Reko.Loading.DccSignatureLoader
Reko.Loading.DccSignatureLoader.DccSignatureLoader(Reko.Core.Program! program) -> void
Reko.Loading.DccSignatureLoader.hlType
Reko.Loading.DccSignatureLoader.hlType.TYPE_BYTE_SIGN = 1 -> Reko.Loading.DccSignatureLoader.hlType
Reko.Loading.DccSignatureLoader.hlType.TYPE_BYTE_UNSIGN = 2 -> Reko.Loading.DccSignatureLoader.hlType
Reko.Loading.DccSignatureLoader.hlType.TYPE_CONST = 10 -> Reko.Loading.DccSignatureLoader.hlType
Reko.Loading.DccSignatureLoader.hlType.TYPE_DOUBLE = 12 -> Reko.Loading.DccSignatureLoader.hlType
Reko.Loading.DccSignatureLoader.hlType.TYPE_FLOAT = 11 -> Reko.Loading.DccSignatureLoader.hlType
Reko.Loading.DccSignatureLoader.hlType.TYPE_LONG_SIGN = 5 -> Reko.Loading.DccSignatureLoader.hlType
Reko.Loading.DccSignatureLoader.hlType.TYPE_LONG_UNSIGN = 6 -> Reko.Loading.DccSignatureLoader.hlType
Reko.Loading.DccSignatureLoader.hlType.TYPE_PTR = 8 -> Reko.Loading.DccSignatureLoader.hlType
Reko.Loading.DccSignatureLoader.hlType.TYPE_RECORD = 7 -> Reko.Loading.DccSignatureLoader.hlType
Reko.Loading.DccSignatureLoader.hlType.TYPE_STR = 9 -> Reko.Loading.DccSignatureLoader.hlType
Reko.Loading.DccSignatureLoader.hlType.TYPE_UNKNOWN = 0 -> Reko.Loading.DccSignatureLoader.hlType
Reko.Loading.DccSignatureLoader.hlType.TYPE_WORD_SIGN = 3 -> Reko.Loading.DccSignatureLoader.hlType
Reko.Loading.DccSignatureLoader.hlType.TYPE_WORD_UNSIGN = 4 -> Reko.Loading.DccSignatureLoader.hlType
Reko.Loading.DccSignatureLoader.HT
Reko.Loading.DccSignatureLoader.HT.HT() -> void
Reko.Loading.DccSignatureLoader.HT.htPat -> byte[]?
Reko.Loading.DccSignatureLoader.HT.htSym -> string?
Reko.Loading.DccSignatureLoader.LibCheck(System.IServiceProvider! services, Reko.Core.Procedure! proc, Reko.Core.Address! addr) -> bool
Reko.Loading.DccSignatureLoader.PH_FUNC_STRUCT
Reko.Loading.DccSignatureLoader.PH_FUNC_STRUCT.bVararg -> bool
Reko.Loading.DccSignatureLoader.PH_FUNC_STRUCT.firstArg -> int
Reko.Loading.DccSignatureLoader.PH_FUNC_STRUCT.name -> string?
Reko.Loading.DccSignatureLoader.PH_FUNC_STRUCT.numArg -> int
Reko.Loading.DccSignatureLoader.PH_FUNC_STRUCT.PH_FUNC_STRUCT() -> void
Reko.Loading.DccSignatureLoader.PH_FUNC_STRUCT.typ -> Reko.Loading.DccSignatureLoader.hlType
Reko.Loading.DccSignatureLoader.SetupLibCheck(System.IServiceProvider! services) -> bool
Reko.Loading.DccSignatureLoader.SetupLibCheck(System.IServiceProvider! services, string! fpath, byte[]! bytes) -> bool
Reko.Loading.FlirtoidSignatureLoader
Reko.Loading.FlirtoidSignatureLoader.FlirtoidSignatureLoader() -> void
Reko.Loading.ImageSignature
Reko.Loading.ImageSignature.Comments -> string?
Reko.Loading.ImageSignature.EntryPointPattern -> string?
Reko.Loading.ImageSignature.ImagePattern -> string?
Reko.Loading.ImageSignature.ImageSignature() -> void
Reko.Loading.ImageSignature.Name -> string?
Reko.Loading.Loader
Reko.Loading.Loader.AssembleExecutable(Reko.Core.ImageLocation! asmFileLocation, byte[]! image, Reko.Core.Assemblers.IAssembler! asm, Reko.Core.IPlatform! platform, Reko.Core.Address! addrLoad) -> Reko.Core.Program!
Reko.Loading.Loader.AssembleExecutable(Reko.Core.ImageLocation! asmFileLocation, Reko.Core.Assemblers.IAssembler! asm, Reko.Core.IPlatform! platform, Reko.Core.Address! addrLoad) -> Reko.Core.Program!
Reko.Loading.Loader.CopyImportReferences(System.Collections.Generic.Dictionary<Reko.Core.Address!, Reko.Core.ImportReference!>! importReference, Reko.Core.Program! program) -> void
Reko.Loading.Loader.CreateDefaultImageLoader(Reko.Core.ImageLocation! imageLocation, byte[]! image) -> Reko.Core.Loading.ImageLoader?
Reko.Loading.Loader.DefaultToFormat.get -> string?
Reko.Loading.Loader.DefaultToFormat.set -> void
Reko.Loading.Loader.FindImageLoader<T>(Reko.Core.ImageLocation! imageLocation, byte[]! rawBytes) -> T?
Reko.Loading.Loader.ImageHasMagicNumber(byte[]! image, string! magicNumber, long offset) -> bool
Reko.Loading.Loader.Load(Reko.Core.ImageLocation! imageLocation, string? loaderName = null, Reko.Core.Address? addrLoad = null) -> Reko.Core.Loading.ILoadedImage!
Reko.Loading.Loader.LoadBinaryImage(Reko.Core.ImageLocation! imageLocation, byte[]! image, string? loader, Reko.Core.Address? addrLoad) -> Reko.Core.Loading.ILoadedImage!
Reko.Loading.Loader.Loader(System.IServiceProvider! services) -> void
Reko.Loading.Loader.LoadMetadata(Reko.Core.ImageLocation! metadataLocation, Reko.Core.IPlatform! platform, Reko.Core.TypeLibrary! typeLib) -> Reko.Core.TypeLibrary?
Reko.Loading.Loader.LoadRawImage(byte[]! image, Reko.Core.Loading.LoadDetails! raw) -> Reko.Core.Program!
Reko.Loading.Loader.LoadRawImage(Reko.Core.ImageLocation! imageLocation, byte[]! image, Reko.Core.Address? addrLoad, Reko.Core.Loading.LoadDetails! details) -> Reko.Core.Program!
Reko.Loading.Loader.LoadRawImage(Reko.Core.ImageLocation! location, Reko.Core.Loading.LoadDetails! raw) -> Reko.Core.Program!
Reko.Loading.Loader.LoadScript(Reko.Core.ImageLocation! scriptLocation) -> Reko.Core.Scripts.ScriptFile?
Reko.Loading.Loader.RunScriptOnProgramImage(Reko.Core.Program! program, Reko.Core.Serialization.Script_v2? script) -> void
Reko.Loading.Loader.Services.get -> System.IServiceProvider!
Reko.Loading.NullImageLoader
Reko.Loading.NullImageLoader.Architecture.get -> Reko.Core.IProcessorArchitecture?
Reko.Loading.NullImageLoader.Architecture.set -> void
Reko.Loading.NullImageLoader.CreatePlatformSegmentMap(Reko.Core.IPlatform! platform, Reko.Core.Address! loadAddr, byte[]! rawBytes) -> Reko.Core.SegmentMap!
Reko.Loading.NullImageLoader.EntryPoints.get -> System.Collections.Generic.List<Reko.Core.ImageSymbol!>!
Reko.Loading.NullImageLoader.NullImageLoader(System.IServiceProvider! services, Reko.Core.ImageLocation! imageLocation, byte[]! image) -> void
Reko.Loading.NullImageLoader.Platform.get -> Reko.Core.IPlatform?
Reko.Loading.NullImageLoader.Platform.set -> void
Reko.Loading.SignatureLoader
Reko.Loading.SignatureLoader.SignatureLoader() -> void
Reko.Loading.SymbolLoadingService
Reko.Loading.SymbolLoadingService.GetSymbolSource(string! filename) -> Reko.Core.Loading.ISymbolSource?
Reko.Loading.SymbolLoadingService.GetSymbolSources() -> System.Collections.Generic.List<Reko.Core.Configuration.SymbolSourceDefinition!>!
Reko.Loading.SymbolLoadingService.LoadSymbolSource(Reko.Core.Configuration.SymbolSourceDefinition! symSrcDef, byte[]! bytes, string! filename) -> Reko.Core.Loading.ISymbolSource?
Reko.Loading.SymbolLoadingService.SymbolLoadingService(System.IServiceProvider! services) -> void
Reko.Loading.UnpackerSignatureLoader
Reko.Loading.UnpackerSignatureLoader.UnpackerSignatureLoader() -> void
Reko.Loading.UnpackingService
Reko.Loading.UnpackingService.FindUnpackerBySignature(Reko.Core.Loading.ProgramImageLoader! loader, uint entryPointOffset) -> Reko.Core.Loading.ProgramImageLoader!
Reko.Loading.UnpackingService.LoadSignatureFiles() -> void
Reko.Loading.UnpackingService.Matches(Reko.Loading.ImageSignature! sig, byte[]! image, uint entryPointOffset) -> bool
Reko.Loading.UnpackingService.Services.get -> System.IServiceProvider!
Reko.Loading.UnpackingService.Signatures.get -> System.Collections.Generic.List<Reko.Loading.ImageSignature!>!
Reko.Loading.UnpackingService.UnpackingService(System.IServiceProvider! services) -> void
Reko.NullDecompiledFileService
Reko.NullDecompiledFileService.CreateTextWriter(string! path) -> System.IO.TextWriter!
Reko.NullDecompiledFileService.NullDecompiledFileService() -> void
Reko.NullDecompiledFileService.WriteDecompiledCode(Reko.Core.Program! program, System.Action<string!, System.Collections.Generic.IEnumerable<Reko.Core.IAddressable!>!, System.IO.TextWriter!>! writer) -> void
Reko.NullDecompiledFileService.WriteDisassembly(Reko.Core.Program! program, System.Action<string!, System.Collections.Generic.Dictionary<Reko.Core.ImageSegment!, System.Collections.Generic.List<Reko.Core.ImageMapItem!>!>!, Reko.Core.Output.Formatter!>! writer) -> void
Reko.NullDecompiledFileService.WriteGlobals(Reko.Core.Program! program, System.Action<string!, System.IO.TextWriter!>! writer) -> void
Reko.NullDecompiledFileService.WriteIntermediateCode(Reko.Core.Program! program, System.Action<string!, System.Collections.Generic.IEnumerable<Reko.Core.IAddressable!>!, System.IO.TextWriter!>! writer) -> void
Reko.NullDecompiledFileService.WriteTypes(Reko.Core.Program! program, System.Action<string!, System.IO.TextWriter!>! writer) -> void
Reko.Scanning.AhoCorasick
~Reko.Scanning.AhoCorasick.addString(string s) -> void
Reko.Scanning.AhoCorasick.AhoCorasick(int maxNodes) -> void
Reko.Scanning.AhoCorasick.suffLink(int nodeIndex) -> int
Reko.Scanning.AhoCorasick.transition(int nodeIndex, char ch) -> int
~Reko.Scanning.AhoCorasickSearch2<TSymbol>
~Reko.Scanning.AhoCorasickSearch2<TSymbol>.AhoCorasickSearch2(TSymbol[][] keywords, bool scannedMemory, bool unscannedMemory) -> void
~Reko.Scanning.AhoCorasickSearch2<TSymbol>.ContainsAny(TSymbol[] text) -> bool
~Reko.Scanning.AhoCorasickSearch2<TSymbol>.FindAll(TSymbol[] text) -> Reko.Scanning.StringSearchResult<TSymbol>[]
~Reko.Scanning.AhoCorasickSearch2<TSymbol>.FindFirst(TSymbol[] text) -> Reko.Scanning.StringSearchResult<TSymbol>
~Reko.Scanning.AhoCorasickSearch2<TSymbol>.Keywords.get -> TSymbol[][]
~Reko.Scanning.AhoCorasickSearch2<TSymbol>.Keywords.set -> void
~Reko.Scanning.AhoCorasickSearch<TSymbol>
Reko.Scanning.AhoCorasickSearch<TSymbol>.AhoCorasickSearch() -> void
~Reko.Scanning.AhoCorasickSearch<TSymbol>.AhoCorasickSearch(TSymbol[][] keywords, bool scannedMemory, bool unscannedMemory) -> void
~Reko.Scanning.AhoCorasickSearch<TSymbol>.Keywords.get -> TSymbol[][]
~Reko.Scanning.AhoCorasickSearch<TSymbol>.Keywords.set -> void
Reko.Scanning.ArrayEx
Reko.Scanning.BackwalkBranch
Reko.Scanning.BackwalkBranch.BackwalkBranch(Reko.Core.Expressions.ConditionCode cc) -> void
Reko.Scanning.BackwalkDereference
Reko.Scanning.BackwalkDereference.BackwalkDereference(int tableOffset, int tableEntrySize) -> void
Reko.Scanning.BackwalkDereference.TableOffset.get -> int
Reko.Scanning.Backwalker<TBlock, TInstr>
Reko.Scanning.Backwalker<TBlock, TInstr>.BackWalk(TBlock! block) -> System.Collections.Generic.List<Reko.Scanning.BackwalkOperation!>?
Reko.Scanning.Backwalker<TBlock, TInstr>.Backwalker(Reko.Core.IBackWalkHost<TBlock!, TInstr!>! host, Reko.Core.Rtl.RtlTransfer! xfer, Reko.Evaluation.ExpressionSimplifier! eval) -> void
Reko.Scanning.Backwalker<TBlock, TInstr>.BackwalkInstruction(TInstr! instr) -> bool
Reko.Scanning.Backwalker<TBlock, TInstr>.BackwalkInstructions(Reko.Core.RegisterStorage? regIdx, System.Collections.Generic.IEnumerable<TInstr!>! backwardStatementSequence) -> bool
Reko.Scanning.Backwalker<TBlock, TInstr>.BackwalkInstructions(Reko.Core.RegisterStorage? regIdx, TBlock! block) -> bool
Reko.Scanning.Backwalker<TBlock, TInstr>.CanBackwalk() -> bool
Reko.Scanning.Backwalker<TBlock, TInstr>.DetermineIndexRegister(Reko.Core.Expressions.MemoryAccess! mem) -> Reko.Core.RegisterStorage?
Reko.Scanning.Backwalker<TBlock, TInstr>.DumpBlock(Reko.Core.RegisterStorage! regIdx, Reko.Core.Block! block) -> void
Reko.Scanning.Backwalker<TBlock, TInstr>.Index.get -> Reko.Core.RegisterStorage?
Reko.Scanning.Backwalker<TBlock, TInstr>.IndexExpression.get -> Reko.Core.Expressions.Expression?
Reko.Scanning.Backwalker<TBlock, TInstr>.IndexExpression.set -> void
Reko.Scanning.Backwalker<TBlock, TInstr>.JumpSize.get -> int
Reko.Scanning.Backwalker<TBlock, TInstr>.JumpSize.set -> void
Reko.Scanning.Backwalker<TBlock, TInstr>.Operations.get -> System.Collections.Generic.List<Reko.Scanning.BackwalkOperation!>!
Reko.Scanning.Backwalker<TBlock, TInstr>.Stride.get -> int
Reko.Scanning.Backwalker<TBlock, TInstr>.UsedFlagIdentifier.get -> Reko.Core.Expressions.Identifier?
Reko.Scanning.Backwalker<TBlock, TInstr>.UsedFlagIdentifier.set -> void
Reko.Scanning.Backwalker<TBlock, TInstr>.VectorAddress.get -> Reko.Core.Address?
Reko.Scanning.BackwalkError
Reko.Scanning.BackwalkError.BackwalkError(string! errorMsg) -> void
Reko.Scanning.BackwalkError.ErrorMessage.get -> string!
Reko.Scanning.BackwalkOperation
Reko.Scanning.BackwalkOperation.BackwalkOperation(Reko.Scanning.BackwalkOperator op, int operand) -> void
Reko.Scanning.BackwalkOperation.operand -> int
Reko.Scanning.BackwalkOperator
Reko.Scanning.BackwalkOperator.add = 0 -> Reko.Scanning.BackwalkOperator
Reko.Scanning.BackwalkOperator.and = 3 -> Reko.Scanning.BackwalkOperator
Reko.Scanning.BackwalkOperator.branch = 7 -> Reko.Scanning.BackwalkOperator
Reko.Scanning.BackwalkOperator.cmp = 4 -> Reko.Scanning.BackwalkOperator
Reko.Scanning.BackwalkOperator.deref = 5 -> Reko.Scanning.BackwalkOperator
Reko.Scanning.BackwalkOperator.err = 6 -> Reko.Scanning.BackwalkOperator
Reko.Scanning.BackwalkOperator.mul = 1 -> Reko.Scanning.BackwalkOperator
Reko.Scanning.BackwalkOperator.sub = 2 -> Reko.Scanning.BackwalkOperator
Reko.Scanning.BackwardSlicer
Reko.Scanning.BackwardSlicer.BackwardSlicer(Reko.Core.IBackWalkHost<Reko.Scanning.RtlBlock!, Reko.Core.Rtl.RtlInstruction!>! host, Reko.Scanning.RtlBlock! rtlBlock, Reko.Core.ProcessorState! state) -> void
Reko.Scanning.BackwardSlicer.DiscoverTableExtent(Reko.Core.Address! addrSwitch, Reko.Core.Rtl.RtlTransfer! xfer, Reko.Core.Services.DecompilerEventListener! listener) -> Reko.Scanning.TableExtent?
Reko.Scanning.BackwardSlicer.FindIndexWithPatternMatch(Reko.Core.Expressions.Expression? jumpTableFormat) -> Reko.Core.Expressions.Expression?
Reko.Scanning.BackwardSlicer.JumpTableFormat.get -> Reko.Core.Expressions.Expression?
Reko.Scanning.BackwardSlicer.JumpTableIndex.get -> Reko.Core.Expressions.Expression?
Reko.Scanning.BackwardSlicer.JumpTableIndexInterval.get -> Reko.Core.StridedInterval
Reko.Scanning.BackwardSlicer.JumpTableIndexToUse.get -> Reko.Core.Expressions.Expression?
Reko.Scanning.BackwardSlicer.Live.get -> System.Collections.Generic.Dictionary<Reko.Core.Expressions.Expression!, Reko.Scanning.BackwardSlicerContext!>!
Reko.Scanning.BackwardSlicer.Start(Reko.Scanning.RtlBlock! block, int iInstr, Reko.Core.Expressions.Expression! indirectJump) -> bool
Reko.Scanning.BackwardSlicer.Step() -> bool
Reko.Scanning.BackwardSlicerContext
Reko.Scanning.BackwardSlicerContext.BackwardSlicerContext(Reko.Scanning.ContextType type, Reko.Core.BitRange range) -> void
Reko.Scanning.BackwardSlicerContext.BitRange -> Reko.Core.BitRange
Reko.Scanning.BackwardSlicerContext.CompareTo(Reko.Scanning.BackwardSlicerContext? that) -> int
Reko.Scanning.BackwardSlicerContext.Merge(Reko.Scanning.BackwardSlicerContext! that) -> Reko.Scanning.BackwardSlicerContext!
Reko.Scanning.BackwardSlicerContext.Type -> Reko.Scanning.ContextType
Reko.Scanning.BackwardSlicerHost
Reko.Scanning.BackwardSlicerHost.Architecture.get -> Reko.Core.IProcessorArchitecture!
Reko.Scanning.BackwardSlicerHost.AsAssignment(Reko.Core.Rtl.RtlInstruction! instr) -> (Reko.Core.Expressions.Expression?, Reko.Core.Expressions.Expression?)
Reko.Scanning.BackwardSlicerHost.AsBranch(Reko.Core.Rtl.RtlInstruction! instr) -> Reko.Core.Expressions.Expression?
Reko.Scanning.BackwardSlicerHost.BackwardSlicerHost(Reko.Core.Program! program, Reko.Core.IProcessorArchitecture! arch) -> void
Reko.Scanning.BackwardSlicerHost.BlockInstructionCount(Reko.Scanning.RtlBlock! rtlBlock) -> int
Reko.Scanning.BackwardSlicerHost.GetBlockInstructions(Reko.Scanning.RtlBlock! rtlBlock) -> System.Collections.Generic.IEnumerable<Reko.Core.Rtl.RtlInstruction?>!
Reko.Scanning.BackwardSlicerHost.GetPredecessors(Reko.Scanning.RtlBlock! block) -> System.Collections.Generic.List<Reko.Scanning.RtlBlock!>!
Reko.Scanning.BackwardSlicerHost.GetRtlBlock(Reko.Core.Block! block) -> Reko.Scanning.RtlBlock!
Reko.Scanning.BackwardSlicerHost.GetSinglePredecessor(Reko.Scanning.RtlBlock! block) -> Reko.Scanning.RtlBlock!
Reko.Scanning.BackwardSlicerHost.GetSubregister(Reko.Core.RegisterStorage! reg, Reko.Core.BitRange range) -> Reko.Core.RegisterStorage!
Reko.Scanning.BackwardSlicerHost.IsFallthrough(Reko.Core.Rtl.RtlInstruction! instr, Reko.Scanning.RtlBlock! block) -> bool
Reko.Scanning.BackwardSlicerHost.IsStackRegister(Reko.Core.Storage! storage) -> bool
Reko.Scanning.BackwardSlicerHost.IsValidAddress(Reko.Core.Address! addr) -> bool
Reko.Scanning.BackwardSlicerHost.MakeAddressFromConstant(Reko.Core.Expressions.Constant! c) -> Reko.Core.Address!
Reko.Scanning.BackwardSlicerHost.MakeSegmentedAddress(Reko.Core.Expressions.Constant! selector, Reko.Core.Expressions.Constant! offset) -> Reko.Core.Address!
Reko.Scanning.BackwardSlicerHost.Program.get -> Reko.Core.Program!
Reko.Scanning.BackwardSlicerHost.SegmentMap.get -> Reko.Core.SegmentMap!
Reko.Scanning.BlockCloner
Reko.Scanning.BlockCloner.BlockCloner(Reko.Core.Block! blockToClone, Reko.Core.Procedure! procCalling, Reko.Core.CallGraph! callGraph) -> void
Reko.Scanning.BlockCloner.CloneBlock(Reko.Core.Block! blockOrig) -> Reko.Core.Block?
Reko.Scanning.BlockCloner.Execute() -> Reko.Core.Block?
Reko.Scanning.BlockCloner.Identifier.get -> Reko.Core.Expressions.Identifier?
Reko.Scanning.BlockCloner.Identifier.set -> void
Reko.Scanning.BlockCloner.Statement.get -> Reko.Core.Statement?
Reko.Scanning.BlockCloner.Statement.set -> void
Reko.Scanning.BlockCloner.StatementNew.get -> Reko.Core.Statement?
Reko.Scanning.BlockCloner.StatementNew.set -> void
Reko.Scanning.BlockCloner.VisitAddress(Reko.Core.Address! addr) -> Reko.Core.Expressions.Expression!
Reko.Scanning.BlockCloner.VisitApplication(Reko.Core.Expressions.Application! appl) -> Reko.Core.Expressions.Expression!
Reko.Scanning.BlockCloner.VisitArrayAccess(Reko.Core.Expressions.ArrayAccess! acc) -> Reko.Core.Expressions.Expression!
Reko.Scanning.BlockCloner.VisitAssignment(Reko.Core.Code.Assignment! ass) -> Reko.Core.Code.Instruction!
Reko.Scanning.BlockCloner.VisitBinaryExpression(Reko.Core.Expressions.BinaryExpression! binExp) -> Reko.Core.Expressions.Expression!
Reko.Scanning.BlockCloner.VisitBranch(Reko.Core.Code.Branch! branch) -> Reko.Core.Code.Instruction!
Reko.Scanning.BlockCloner.VisitCallInstruction(Reko.Core.Code.CallInstruction! ci) -> Reko.Core.Code.Instruction!
Reko.Scanning.BlockCloner.VisitCast(Reko.Core.Expressions.Cast! cast) -> Reko.Core.Expressions.Expression!
Reko.Scanning.BlockCloner.VisitComment(Reko.Core.Code.CodeComment! comment) -> Reko.Core.Code.Instruction!
Reko.Scanning.BlockCloner.VisitConditionalExpression(Reko.Core.Expressions.ConditionalExpression! c) -> Reko.Core.Expressions.Expression!
Reko.Scanning.BlockCloner.VisitConditionOf(Reko.Core.Expressions.ConditionOf! cof) -> Reko.Core.Expressions.Expression!
Reko.Scanning.BlockCloner.VisitConstant(Reko.Core.Expressions.Constant! c) -> Reko.Core.Expressions.Expression!
Reko.Scanning.BlockCloner.VisitConversion(Reko.Core.Expressions.Conversion! conversion) -> Reko.Core.Expressions.Expression!
Reko.Scanning.BlockCloner.VisitDeclaration(Reko.Core.Code.Declaration! decl) -> Reko.Core.Code.Instruction!
Reko.Scanning.BlockCloner.VisitDefInstruction(Reko.Core.Code.DefInstruction! def) -> Reko.Core.Code.Instruction!
Reko.Scanning.BlockCloner.VisitDereference(Reko.Core.Expressions.Dereference! deref) -> Reko.Core.Expressions.Expression!
Reko.Scanning.BlockCloner.VisitFieldAccess(Reko.Core.Expressions.FieldAccess! acc) -> Reko.Core.Expressions.Expression!
Reko.Scanning.BlockCloner.VisitFlagGroupStorage(Reko.Core.FlagGroupStorage! grf) -> Reko.Core.Expressions.Identifier!
Reko.Scanning.BlockCloner.VisitFpuStackStorage(Reko.Core.FpuStackStorage! fpu) -> Reko.Core.Expressions.Identifier!
Reko.Scanning.BlockCloner.VisitGotoInstruction(Reko.Core.Code.GotoInstruction! gotoInstruction) -> Reko.Core.Code.Instruction!
Reko.Scanning.BlockCloner.VisitIdentifier(Reko.Core.Expressions.Identifier! id) -> Reko.Core.Expressions.Expression!
Reko.Scanning.BlockCloner.VisitMemberPointerSelector(Reko.Core.Expressions.MemberPointerSelector! mps) -> Reko.Core.Expressions.Expression!
Reko.Scanning.BlockCloner.VisitMemoryAccess(Reko.Core.Expressions.MemoryAccess! access) -> Reko.Core.Expressions.Expression!
Reko.Scanning.BlockCloner.VisitMemoryStorage(Reko.Core.MemoryStorage! global) -> Reko.Core.Expressions.Identifier!
Reko.Scanning.BlockCloner.VisitMkSequence(Reko.Core.Expressions.MkSequence! seq) -> Reko.Core.Expressions.Expression!
Reko.Scanning.BlockCloner.VisitOutArgument(Reko.Core.Expressions.OutArgument! outArg) -> Reko.Core.Expressions.Expression!
Reko.Scanning.BlockCloner.VisitOutArgumentStorage(Reko.Core.OutArgumentStorage! arg) -> Reko.Core.Expressions.Identifier!
Reko.Scanning.BlockCloner.VisitPhiAssignment(Reko.Core.Code.PhiAssignment! phi) -> Reko.Core.Code.Instruction!
Reko.Scanning.BlockCloner.VisitPhiFunction(Reko.Core.Expressions.PhiFunction! phi) -> Reko.Core.Expressions.Expression!
Reko.Scanning.BlockCloner.VisitPointerAddition(Reko.Core.Expressions.PointerAddition! pa) -> Reko.Core.Expressions.Expression!
Reko.Scanning.BlockCloner.VisitProcedureConstant(Reko.Core.Expressions.ProcedureConstant! pc) -> Reko.Core.Expressions.Expression!
Reko.Scanning.BlockCloner.VisitRegisterStorage(Reko.Core.RegisterStorage! reg) -> Reko.Core.Expressions.Identifier!
Reko.Scanning.BlockCloner.VisitReturnInstruction(Reko.Core.Code.ReturnInstruction! ret) -> Reko.Core.Code.Instruction!
Reko.Scanning.BlockCloner.VisitScopeResolution(Reko.Core.Expressions.ScopeResolution! scopeResolution) -> Reko.Core.Expressions.Expression!
Reko.Scanning.BlockCloner.VisitSegmentedAccess(Reko.Core.Expressions.SegmentedAccess! access) -> Reko.Core.Expressions.Expression!
Reko.Scanning.BlockCloner.VisitSequenceStorage(Reko.Core.SequenceStorage! seq) -> Reko.Core.Expressions.Identifier!
Reko.Scanning.BlockCloner.VisitSideEffect(Reko.Core.Code.SideEffect! side) -> Reko.Core.Code.Instruction!
Reko.Scanning.BlockCloner.VisitSlice(Reko.Core.Expressions.Slice! slice) -> Reko.Core.Expressions.Expression!
Reko.Scanning.BlockCloner.VisitStackStorage(Reko.Core.StackStorage! stack) -> Reko.Core.Expressions.Identifier!
Reko.Scanning.BlockCloner.VisitStore(Reko.Core.Code.Store! store) -> Reko.Core.Code.Instruction!
Reko.Scanning.BlockCloner.VisitSwitchInstruction(Reko.Core.Code.SwitchInstruction! si) -> Reko.Core.Code.Instruction!
Reko.Scanning.BlockCloner.VisitTemporaryStorage(Reko.Core.TemporaryStorage! temp) -> Reko.Core.Expressions.Identifier!
Reko.Scanning.BlockCloner.VisitTestCondition(Reko.Core.Expressions.TestCondition! tc) -> Reko.Core.Expressions.Expression!
Reko.Scanning.BlockCloner.VisitUnaryExpression(Reko.Core.Expressions.UnaryExpression! unary) -> Reko.Core.Expressions.Expression!
Reko.Scanning.BlockCloner.VisitUseInstruction(Reko.Core.Code.UseInstruction! use) -> Reko.Core.Code.Instruction!
Reko.Scanning.BlockConflictResolver
Reko.Scanning.BlockConflictResolver.BlockConflictResolver(Reko.Core.Program! program, Reko.Scanning.ScanResults! sr, System.Func<Reko.Core.Address!, bool>! isAddressValid, Reko.Core.IRewriterHost! host) -> void
Reko.Scanning.BlockConflictResolver.GapResolution() -> void
Reko.Scanning.BlockConflictResolver.GetAncestors(Reko.Scanning.RtlBlock! n) -> System.Collections.Generic.ISet<Reko.Scanning.RtlBlock!>!
Reko.Scanning.BlockConflictResolver.ResolveBlockConflicts(System.Collections.Generic.IEnumerable<Reko.Core.Address!>! procedureStarts) -> void
Reko.Scanning.BlockWorkitem
Reko.Scanning.BlockWorkitem.BlockWorkitem(Reko.Scanning.IScanner! scanner, Reko.Core.Program! program, Reko.Core.IProcessorArchitecture! arch, Reko.Core.ProcessorState! state, Reko.Core.Address! addr) -> void
Reko.Scanning.BlockWorkitem.GetValue(Reko.Core.Expressions.Expression! op) -> Reko.Core.Expressions.Expression!
Reko.Scanning.BlockWorkitem.ImportedProcedureName(Reko.Core.Expressions.Expression! callTarget) -> Reko.Core.ExternalProcedure?
Reko.Scanning.BlockWorkitem.ProcessAlloca(Reko.Core.Code.CallSite! site, Reko.Core.ProcedureBase! impProc, Reko.Core.Serialization.ProcedureCharacteristics! chr) -> bool
Reko.Scanning.BlockWorkitem.ProcessIndirectControlTransfer(Reko.Core.Address! addrSwitch, Reko.Core.Rtl.RtlTransfer! xfer) -> bool
Reko.Scanning.BlockWorkitem.SetAssumedRegisterValues(Reko.Core.Address! addr) -> void
Reko.Scanning.BlockWorkitem.SetValue(Reko.Core.Expressions.Expression! dst, Reko.Core.Expressions.Expression! value) -> void
Reko.Scanning.BlockWorkitem.TrashVariable(Reko.Core.Storage! stg) -> void
Reko.Scanning.BlockWorkitem.VisitAssignment(Reko.Core.Rtl.RtlAssignment! a) -> bool
Reko.Scanning.BlockWorkitem.VisitBranch(Reko.Core.Rtl.RtlBranch! b) -> bool
Reko.Scanning.BlockWorkitem.VisitCall(Reko.Core.Rtl.RtlCall! call) -> bool
Reko.Scanning.BlockWorkitem.VisitGoto(Reko.Core.Rtl.RtlGoto! g) -> bool
Reko.Scanning.BlockWorkitem.VisitIf(Reko.Core.Rtl.RtlIf! rtlIf) -> bool
Reko.Scanning.BlockWorkitem.VisitInvalid(Reko.Core.Rtl.RtlInvalid! invalid) -> bool
Reko.Scanning.BlockWorkitem.VisitMicroGoto(Reko.Core.Rtl.RtlMicroGoto! uGoto) -> bool
Reko.Scanning.BlockWorkitem.VisitMicroLabel(Reko.Core.Rtl.RtlMicroLabel! uLabel) -> bool
Reko.Scanning.BlockWorkitem.VisitNop(Reko.Core.Rtl.RtlNop! nop) -> bool
Reko.Scanning.BlockWorkitem.VisitReturn(Reko.Core.Rtl.RtlReturn! ret) -> bool
Reko.Scanning.BlockWorkitem.VisitSideEffect(Reko.Core.Rtl.RtlSideEffect! side) -> bool
Reko.Scanning.BlockWorkitem.VisitSwitch(Reko.Core.Rtl.RtlSwitch! rtlSwitch) -> bool
Reko.Scanning.CommentInjector
Reko.Scanning.CommentInjector.CommentInjector(System.Collections.Generic.IEnumerable<Reko.Core.Annotation!>! annotations) -> void
Reko.Scanning.CommentInjector.InjectComments(Reko.Core.Procedure! proc) -> void
Reko.Scanning.CommonPatternFinder
Reko.Scanning.CommonPatternFinder.CommonPatternFinder() -> void
Reko.Scanning.ConcreteValueSet
Reko.Scanning.ConcreteValueSet.ConcreteValueSet(Reko.Core.Types.DataType! dt, params Reko.Core.Expressions.Expression![]! values) -> void
Reko.Scanning.ContextType
Reko.Scanning.ContextType.Condition = 2 -> Reko.Scanning.ContextType
Reko.Scanning.ContextType.Jumptable = 1 -> Reko.Scanning.ContextType
Reko.Scanning.ContextType.None = 0 -> Reko.Scanning.ContextType
Reko.Scanning.DataScanner
Reko.Scanning.DataScanner.DataScanner(Reko.Core.Program! program, Reko.Scanning.ScanResults! sr, Reko.Core.Services.DecompilerEventListener! listener) -> void
Reko.Scanning.DataScanner.EnqueueImageSymbol(Reko.Core.ImageSymbol! sym, bool isEntryPoint) -> void
Reko.Scanning.DataScanner.EnqueueProcedure(Reko.Core.IProcessorArchitecture! arch, Reko.Core.Address! addr) -> void
Reko.Scanning.DataScanner.EnqueueUserGlobalData(Reko.Core.Address! addr, Reko.Core.Types.DataType! dt, string? name) -> void
Reko.Scanning.DataScanner.EnqueueUserProcedure(Reko.Core.IProcessorArchitecture! arch, Reko.Core.Address! addr, Reko.Core.Types.FunctionType! sig, string? name) -> void
Reko.Scanning.DataScanner.Procedures.get -> System.Collections.Generic.Dictionary<Reko.Core.Address!, Reko.Core.ImageSymbol!>!
Reko.Scanning.DataScanner.ProcessQueue() -> void
Reko.Scanning.EscapedAccessRewriter
Reko.Scanning.EscapedAccessRewriter.EscapedAccessRewriter(Reko.Core.Procedure! proc) -> void
Reko.Scanning.EscapedAccessRewriter.InsertFramePointerAssignment(Reko.Core.IProcessorArchitecture! arch) -> void
Reko.Scanning.EscapedAccessRewriter.Transform() -> void
Reko.Scanning.GlobalDataWorkItem
Reko.Scanning.GlobalDataWorkItem.GlobalDataWorkItem(Reko.Scanning.IScannerQueue! scanner, Reko.Core.Program! program, Reko.Core.Address! addr, Reko.Core.Types.DataType! dt, string? name) -> void
Reko.Scanning.GlobalDataWorkItem.VisitArray(Reko.Core.Types.ArrayType! at) -> void
Reko.Scanning.GlobalDataWorkItem.VisitClass(Reko.Core.Types.ClassType! ct) -> void
Reko.Scanning.GlobalDataWorkItem.VisitCode(Reko.Core.Types.CodeType! c) -> void
Reko.Scanning.GlobalDataWorkItem.VisitEnum(Reko.Core.Types.EnumType! e) -> void
Reko.Scanning.GlobalDataWorkItem.VisitEquivalenceClass(Reko.Core.Types.EquivalenceClass! eq) -> void
Reko.Scanning.GlobalDataWorkItem.VisitFunctionType(Reko.Core.Types.FunctionType! ft) -> void
Reko.Scanning.GlobalDataWorkItem.VisitMemberPointer(Reko.Core.Types.MemberPointer! memptr) -> void
Reko.Scanning.GlobalDataWorkItem.VisitPointer(Reko.Core.Types.Pointer! ptr) -> void
Reko.Scanning.GlobalDataWorkItem.VisitPrimitive(Reko.Core.Types.PrimitiveType! pt) -> void
Reko.Scanning.GlobalDataWorkItem.VisitReference(Reko.Core.Types.ReferenceTo! refTo) -> void
Reko.Scanning.GlobalDataWorkItem.VisitString(Reko.Core.Types.StringType! str) -> void
Reko.Scanning.GlobalDataWorkItem.VisitStructure(Reko.Core.Types.StructureType! str) -> void
Reko.Scanning.GlobalDataWorkItem.VisitTypeReference(Reko.Core.Types.TypeReference! typeref) -> void
Reko.Scanning.GlobalDataWorkItem.VisitTypeVariable(Reko.Core.Types.TypeVariable! tv) -> void
Reko.Scanning.GlobalDataWorkItem.VisitUnion(Reko.Core.Types.UnionType! ut) -> void
Reko.Scanning.GlobalDataWorkItem.VisitUnknownType(Reko.Core.Types.UnknownType! ut) -> void
Reko.Scanning.GlobalDataWorkItem.VisitVoidType(Reko.Core.Types.VoidType! voidType) -> void
Reko.Scanning.HeuristicDisassembler
Reko.Scanning.HeuristicDisassembler.Disassemble(Reko.Core.Address! addr) -> Reko.Scanning.RtlBlock!
Reko.Scanning.HeuristicDisassembler.HeuristicDisassembler(Reko.Core.Program! program, Reko.Core.IStorageBinder! binder, Reko.Scanning.ScanResults! sr, System.Func<Reko.Core.Address!, bool>! isAddrValid, bool assumeCallsDiverge, Reko.Core.IRewriterHost! host) -> void
Reko.Scanning.HeuristicProcedure
Reko.Scanning.HeuristicProcedure.BeginAddress -> Reko.Core.Address!
Reko.Scanning.HeuristicProcedure.Cfg -> Reko.Core.Graphs.DiGraph<Reko.Scanning.RtlBlock!>!
Reko.Scanning.HeuristicProcedure.EndAddress -> Reko.Core.Address!
Reko.Scanning.HeuristicProcedure.Frame -> Reko.Core.Frame!
Reko.Scanning.HeuristicProcedure.HeuristicProcedure(Reko.Core.Address! addrBegin, Reko.Core.Address! addrEnd, Reko.Core.Frame! frame) -> void
Reko.Scanning.HeuristicProcedure.IsValidAddress(Reko.Core.Address! addr) -> bool
Reko.Scanning.HeuristicScanner
Reko.Scanning.HeuristicScanner.DisassembleProcedure(Reko.Core.Address! addrStart, Reko.Core.Address! addrEnd) -> Reko.Scanning.HeuristicProcedure!
Reko.Scanning.HeuristicScanner.FindCallOpcodes(Reko.Core.Memory.ByteMemoryArea! mem, System.Collections.Generic.IEnumerable<Reko.Core.Address!>! knownProcedureAddresses) -> System.Collections.Generic.IEnumerable<Reko.Core.Address!>!
Reko.Scanning.HeuristicScanner.FindPossibleFunctions(System.Collections.Generic.IEnumerable<System.Tuple<Reko.Core.Memory.ByteMemoryArea!, Reko.Core.Address!, Reko.Core.Address!>!>! ranges) -> System.Collections.Generic.IEnumerable<System.Tuple<Reko.Core.Address!, Reko.Core.Address!>!>!
Reko.Scanning.HeuristicScanner.FindPossibleProcedureEntries(Reko.Core.Memory.ByteMemoryArea! mem, Reko.Core.Address! addrBegin, Reko.Core.Address! addrEnd) -> System.Collections.Generic.IEnumerable<Reko.Core.Address!>!
Reko.Scanning.HeuristicScanner.FindUnscannedRanges() -> System.Collections.Generic.IEnumerable<(Reko.Core.Memory.MemoryArea!, Reko.Core.Address!, uint)>!
Reko.Scanning.HeuristicScanner.HeuristicScanner(System.IServiceProvider! services, Reko.Core.Program! program, Reko.Core.IRewriterHost! host, Reko.Core.Services.DecompilerEventListener! eventListener) -> void
Reko.Scanning.HeuristicScanner.ScanImage(Reko.Scanning.ScanResults! sr) -> Reko.Scanning.ScanResults?
Reko.Scanning.HeuristicScanner.Services.get -> System.IServiceProvider!
Reko.Scanning.IcfgBuilder
Reko.Scanning.IcfgBuilder.AddrToBlock -> System.Collections.Generic.Dictionary<Reko.Core.Address!, Reko.Scanning.RtlBlock!>!
Reko.Scanning.IcfgBuilder.Blocks -> Reko.Core.Graphs.DiGraph<Reko.Scanning.RtlBlock!>!
Reko.Scanning.IcfgBuilder.Edges -> System.Collections.Generic.List<(Reko.Scanning.RtlBlock!, Reko.Core.Address!)>!
Reko.Scanning.IcfgBuilder.IcfgBuilder(System.Collections.Generic.List<(Reko.Scanning.RtlBlock!, Reko.Core.Address!)>! edges, System.Collections.Generic.Dictionary<Reko.Core.Address!, Reko.Scanning.RtlBlock!>! mpBlocks, Reko.Core.Graphs.DiGraph<Reko.Scanning.RtlBlock!>! allBlocks) -> void
Reko.Scanning.IdentifierRelocator
Reko.Scanning.IdentifierRelocator.IdentifierRelocator(Reko.Core.Frame! frameOld, Reko.Core.Frame! frameNew) -> void
Reko.Scanning.IdentifierRelocator.ReplaceIdentifiers(Reko.Core.Code.Instruction! instr) -> Reko.Core.Code.Instruction!
Reko.Scanning.IdentifierRelocator.VisitFlagGroupStorage(Reko.Core.FlagGroupStorage! flags) -> Reko.Core.Expressions.Identifier!
Reko.Scanning.IdentifierRelocator.VisitFpuStackStorage(Reko.Core.FpuStackStorage! fpu) -> Reko.Core.Expressions.Identifier!
Reko.Scanning.IdentifierRelocator.VisitMemoryStorage(Reko.Core.MemoryStorage! mem) -> Reko.Core.Expressions.Identifier!
Reko.Scanning.IdentifierRelocator.VisitOutArgumentStorage(Reko.Core.OutArgumentStorage! ost) -> Reko.Core.Expressions.Identifier!
Reko.Scanning.IdentifierRelocator.VisitRegisterStorage(Reko.Core.RegisterStorage! reg) -> Reko.Core.Expressions.Identifier!
Reko.Scanning.IdentifierRelocator.VisitSequenceStorage(Reko.Core.SequenceStorage! seq) -> Reko.Core.Expressions.Identifier!
Reko.Scanning.IdentifierRelocator.VisitStackStorage(Reko.Core.StackStorage! arg) -> Reko.Core.Expressions.Identifier!
Reko.Scanning.IdentifierRelocator.VisitTemporaryStorage(Reko.Core.TemporaryStorage! tmp) -> Reko.Core.Expressions.Identifier!
Reko.Scanning.ImageSymbolWorkItem
Reko.Scanning.ImageSymbolWorkItem.ImageSymbolWorkItem(Reko.Scanning.IScanner! scanner, Reko.Core.Program! program, Reko.Core.ImageSymbol! sym, bool isEntryPoint) -> void
Reko.Scanning.IntervalValueSet
Reko.Scanning.IntervalValueSet.IntervalValueSet(Reko.Core.Types.DataType! dt, Reko.Core.StridedInterval si) -> void
Reko.Scanning.IntervalValueSet.SI -> Reko.Core.StridedInterval
Reko.Scanning.IScanner
Reko.Scanning.IScanner.CreateCallRetThunk(Reko.Core.Address! addrFrom, Reko.Core.Procedure! procOld, Reko.Core.Procedure! procNew) -> Reko.Core.Block!
Reko.Scanning.IScanner.EnqueueJumpTarget(Reko.Core.Address! addrSrc, Reko.Core.Address! addrDst, Reko.Core.Procedure! proc, Reko.Core.ProcessorState! state) -> Reko.Core.Block?
Reko.Scanning.IScanner.EnqueueUserProcedure(Reko.Core.IProcessorArchitecture! arch, Reko.Core.UserProcedure! sp) -> Reko.Core.Address?
Reko.Scanning.IScanner.FindContainingBlock(Reko.Core.Address! addr) -> Reko.Core.Block?
Reko.Scanning.IScanner.FindExactBlock(Reko.Core.Address! addr) -> Reko.Core.Block?
Reko.Scanning.IScanner.GetImportedProcedure(Reko.Core.IProcessorArchitecture! arch, Reko.Core.Address! addrImportThunk, Reko.Core.Address! addrInstruction) -> Reko.Core.ExternalProcedure?
Reko.Scanning.IScanner.GetTrace(Reko.Core.IProcessorArchitecture! arch, Reko.Core.Address! addrStart, Reko.Core.ProcessorState! state, Reko.Core.IStorageBinder! binder) -> System.Collections.Generic.IEnumerable<Reko.Core.Rtl.RtlInstructionCluster!>!
Reko.Scanning.IScanner.GetTrampoline(Reko.Core.IProcessorArchitecture! arch, Reko.Core.Address! addr) -> Reko.Core.ProcedureBase?
Reko.Scanning.IScanner.ScanImage() -> void
Reko.Scanning.IScanner.ScanImageSymbol(Reko.Core.ImageSymbol! sym, bool isEntryPoint) -> void
Reko.Scanning.IScanner.ScanProcedure(Reko.Core.IProcessorArchitecture! arch, Reko.Core.Address! addr, string? procedureName, Reko.Core.ProcessorState! state) -> Reko.Core.ProcedureBase!
Reko.Scanning.IScanner.Services.get -> System.IServiceProvider!
Reko.Scanning.IScanner.SetProcedureReturnAddressBytes(Reko.Core.Procedure! proc, int returnAddressBytes, Reko.Core.Address! address) -> void
Reko.Scanning.IScanner.SetProcedureStackDelta(Reko.Core.Procedure! proc, int stackDelta, Reko.Core.Address! address) -> void
Reko.Scanning.IScanner.SplitBlock(Reko.Core.Block! block, Reko.Core.Address! addr) -> Reko.Core.Block!
Reko.Scanning.IScanner.TerminateBlock(Reko.Core.Block! block, Reko.Core.Address! addrEnd) -> void
Reko.Scanning.IScannerQueue
Reko.Scanning.IScannerQueue.EnqueueImageSymbol(Reko.Core.ImageSymbol! sym, bool isEntryPoint) -> void
Reko.Scanning.IScannerQueue.EnqueueProcedure(Reko.Core.IProcessorArchitecture! arch, Reko.Core.Address! addr) -> void
Reko.Scanning.IScannerQueue.EnqueueUserGlobalData(Reko.Core.Address! addr, Reko.Core.Types.DataType! dt, string? name) -> void
Reko.Scanning.IScannerQueue.EnqueueUserProcedure(Reko.Core.IProcessorArchitecture! arch, Reko.Core.Address! addr, Reko.Core.Types.FunctionType! sig, string? name) -> void
Reko.Scanning.IScannerQueue.Error(Reko.Core.Address! addr, string! message, params object![]! args) -> void
Reko.Scanning.IScannerQueue.Warn(Reko.Core.Address! addr, string! message) -> void
Reko.Scanning.IScannerQueue.Warn(Reko.Core.Address! addr, string! message, params object![]! args) -> void
Reko.Scanning.IStringSearchAlgorithm<TSymbol>
~Reko.Scanning.IStringSearchAlgorithm<TSymbol>.ContainsAny(string text) -> bool
~Reko.Scanning.IStringSearchAlgorithm<TSymbol>.FindAll(string text) -> Reko.Scanning.StringSearchResult<TSymbol>[]
~Reko.Scanning.IStringSearchAlgorithm<TSymbol>.FindFirst(string text) -> Reko.Scanning.StringSearchResult<TSymbol>
~Reko.Scanning.IStringSearchAlgorithm<TSymbol>.Keywords.get -> TSymbol[][]
~Reko.Scanning.IStringSearchAlgorithm<TSymbol>.Keywords.set -> void
Reko.Scanning.KmpStringSearch<C>
Reko.Scanning.KmpStringSearch<C>.KmpStringSearch(C[]! W, bool scannedMemory, bool unscannedMemory) -> void
Reko.Scanning.LinearScanner
Reko.Scanning.LinearScanner.LinearScanner(Reko.Core.Program! program, System.Collections.Generic.ISet<Reko.Core.Address!>! symbols) -> void
Reko.Scanning.LinearScanner.Scan() -> void
Reko.Scanning.ProcedureDetector
Reko.Scanning.ProcedureDetector.Cluster
Reko.Scanning.ProcedureDetector.Cluster.Cluster() -> void
Reko.Scanning.ProcedureDetector.Cluster.Cluster(System.Collections.Generic.IEnumerable<Reko.Scanning.RtlBlock!>! entries, System.Collections.Generic.IEnumerable<Reko.Scanning.RtlBlock!>! blocks) -> void
Reko.Scanning.ProcedureDetector.Cluster.Dump(Reko.Core.Graphs.DirectedGraph<Reko.Scanning.RtlBlock!>! icfg) -> void
Reko.Scanning.ProcedureDetector.DetectProcedures() -> System.Collections.Generic.List<Reko.Scanning.RtlProcedure!>!
Reko.Scanning.ProcedureDetector.DumpDuplicates(System.Collections.Generic.IEnumerable<Reko.Scanning.RtlBlock!>! blocks) -> void
Reko.Scanning.ProcedureDetector.FindClusterEntries(Reko.Scanning.ProcedureDetector.Cluster! cluster) -> bool
Reko.Scanning.ProcedureDetector.FindClusters() -> System.Collections.Generic.List<Reko.Scanning.ProcedureDetector.Cluster!>!
Reko.Scanning.ProcedureDetector.FuseLinearBlocks(Reko.Scanning.ProcedureDetector.Cluster! cluster) -> void
Reko.Scanning.ProcedureDetector.PartitionIntoSubclusters(Reko.Scanning.ProcedureDetector.Cluster! cluster) -> System.Collections.Generic.List<Reko.Scanning.RtlProcedure!>!
Reko.Scanning.ProcedureDetector.PostProcessCluster(Reko.Scanning.ProcedureDetector.Cluster! cluster) -> System.Collections.Generic.List<Reko.Scanning.RtlProcedure!>!
Reko.Scanning.ProcedureDetector.ProcedureDetector(Reko.Core.Program! program, Reko.Scanning.ScanResults! sr, Reko.Core.Services.DecompilerEventListener! listener) -> void
Reko.Scanning.ProcedureDetector.RemoveJumpsToKnownProcedures() -> void
Reko.Scanning.ProcedurePaddingFinder
Reko.Scanning.ProcedurePaddingFinder.FindPaddingBlocks() -> System.Collections.Generic.List<Reko.Scanning.RtlBlock!>!
Reko.Scanning.ProcedurePaddingFinder.ProcedurePaddingFinder(Reko.Scanning.ScanResults! sr) -> void
Reko.Scanning.ProcedurePaddingFinder.Remove(System.Collections.Generic.List<Reko.Scanning.RtlBlock!>! paddingBlocks) -> void
Reko.Scanning.ProcedureWorkItem
Reko.Scanning.ProcedureWorkItem.ProcedureWorkItem(Reko.Scanning.IScanner! scanner, Reko.Core.IProcessorArchitecture! arch, Reko.Core.Address! addr, string? name) -> void
Reko.Scanning.PromoteBlockWorkItem
Reko.Scanning.PromoteBlockWorkItem.Block -> Reko.Core.Block!
Reko.Scanning.PromoteBlockWorkItem.FixInboundEdges(Reko.Core.Block! blockToPromote) -> void
Reko.Scanning.PromoteBlockWorkItem.FixOutboundEdges(Reko.Core.Block! block) -> void
Reko.Scanning.PromoteBlockWorkItem.ProcNew -> Reko.Core.Procedure!
Reko.Scanning.PromoteBlockWorkItem.Program -> Reko.Core.Program!
Reko.Scanning.PromoteBlockWorkItem.PromoteBlockWorkItem(Reko.Core.Address! addr, Reko.Scanning.IScanner! scanner, Reko.Core.Program! program, Reko.Core.Block! block, Reko.Core.Procedure! procNew) -> void
Reko.Scanning.PromoteBlockWorkItem.Scanner -> Reko.Scanning.IScanner!
Reko.Scanning.Regexp
~Reko.Scanning.Regexp.Match(byte[] arr, int position) -> bool
Reko.Scanning.Regexp.Position.get -> int
Reko.Scanning.RobustRewriter
Reko.Scanning.RobustRewriter.GetEnumerator() -> System.Collections.Generic.IEnumerator<Reko.Core.Rtl.RtlInstructionCluster!>!
Reko.Scanning.RobustRewriter.RobustRewriter(System.Collections.Generic.IEnumerable<Reko.Core.Rtl.RtlInstructionCluster!>! inner, int granularity) -> void
Reko.Scanning.RtlBlock
Reko.Scanning.RtlBlock.Address.get -> Reko.Core.Address!
Reko.Scanning.RtlBlock.Architecture.get -> Reko.Core.IProcessorArchitecture!
Reko.Scanning.RtlBlock.FallThrough.get -> Reko.Core.Address!
Reko.Scanning.RtlBlock.FallThrough.set -> void
Reko.Scanning.RtlBlock.GetEndAddress() -> Reko.Core.Address!
Reko.Scanning.RtlBlock.Instructions.get -> System.Collections.Generic.List<Reko.Core.Rtl.RtlInstructionCluster!>!
Reko.Scanning.RtlBlock.Instructions.init -> void
Reko.Scanning.RtlBlock.IsSharedExitBlock.get -> bool
Reko.Scanning.RtlBlock.IsSharedExitBlock.set -> void
Reko.Scanning.RtlBlock.IsValid.get -> bool
Reko.Scanning.RtlBlock.IsValid.set -> void
Reko.Scanning.RtlBlock.Length.get -> int
Reko.Scanning.RtlBlock.Length.set -> void
Reko.Scanning.RtlBlock.Name.get -> string!
Reko.Scanning.RtlBlock.RtlBlock(Reko.Core.Address! addr, string! id) -> void
Reko.Scanning.RtlBlock.RtlBlock(Reko.Core.IProcessorArchitecture! arch, Reko.Core.Address! addr, string! id, int length, Reko.Core.Address! addrFallThrough, System.Collections.Generic.List<Reko.Core.Rtl.RtlInstructionCluster!>! instructions) -> void
Reko.Scanning.RtlProcedure
Reko.Scanning.RtlProcedure.RtlProcedure(Reko.Scanning.RtlBlock! entry, System.Collections.Generic.ISet<Reko.Scanning.RtlBlock!>! blocks) -> void
Reko.Scanning.Scanner
Reko.Scanning.Scanner.AddBlock(Reko.Core.Address! addr, Reko.Core.Procedure! proc, string! blockName) -> Reko.Core.Block!
Reko.Scanning.Scanner.CreateCallRetThunk(Reko.Core.Address! addrFrom, Reko.Core.Procedure! procOld, Reko.Core.Procedure! procNew) -> Reko.Core.Block!
Reko.Scanning.Scanner.CreatePromoteWorkItem(Reko.Core.Address! addrStart, Reko.Core.Block! block, Reko.Core.Procedure! procNew) -> Reko.Scanning.PromoteBlockWorkItem!
Reko.Scanning.Scanner.EnqueueImageSymbol(Reko.Core.ImageSymbol! sym, bool isEntryPoint) -> void
Reko.Scanning.Scanner.EnqueueJumpTarget(Reko.Core.Address! addrSrc, Reko.Core.Address! addrDest, Reko.Core.Procedure! proc, Reko.Core.ProcessorState! state) -> Reko.Core.Block?
Reko.Scanning.Scanner.EnqueueProcedure(Reko.Core.IProcessorArchitecture! arch, Reko.Core.Address! addr) -> void
Reko.Scanning.Scanner.EnqueueUserGlobalData(Reko.Core.Address! addr, Reko.Core.Types.DataType! dt, string? name) -> void
Reko.Scanning.Scanner.EnqueueUserProcedure(Reko.Core.IProcessorArchitecture! arch, Reko.Core.Address! addr, Reko.Core.Types.FunctionType! sig, string? name) -> void
Reko.Scanning.Scanner.EnqueueUserProcedure(Reko.Core.IProcessorArchitecture! arch, Reko.Core.UserProcedure! sp) -> Reko.Core.Address?
Reko.Scanning.Scanner.EnsureEntryPoint(Reko.Core.ImageSymbol! sym) -> void
Reko.Scanning.Scanner.EnsureIntrinsic(string! name, bool hasSideEffect, Reko.Core.Types.DataType! returnType, int arity) -> Reko.Core.IntrinsicProcedure!
Reko.Scanning.Scanner.EnsureProcedure(Reko.Core.IProcessorArchitecture! arch, Reko.Core.Address! addr, string! name, Reko.Core.Types.FunctionType! signature) -> Reko.Core.Procedure?
Reko.Scanning.Scanner.EnsureUserProcedure(Reko.Core.IProcessorArchitecture! arch, Reko.Core.UserProcedure! sp) -> System.Collections.Generic.KeyValuePair<Reko.Core.Address!, Reko.Core.Procedure!>?
Reko.Scanning.Scanner.eventListener -> Reko.Core.Services.DecompilerEventListener!
Reko.Scanning.Scanner.FilterRtlProcedure(Reko.Scanning.RtlProcedure! rtlProc) -> bool
Reko.Scanning.Scanner.FindContainingBlock(Reko.Core.Address! address) -> Reko.Core.Block?
Reko.Scanning.Scanner.FindExactBlock(Reko.Core.Address! address) -> Reko.Core.Block?
Reko.Scanning.Scanner.GetArchitecture(string! archMoniker) -> Reko.Core.IProcessorArchitecture!
Reko.Scanning.Scanner.GetImport(Reko.Core.Address! addrImportThunk, Reko.Core.Address! addrInstruction) -> Reko.Core.Expressions.Expression?
Reko.Scanning.Scanner.GetImportedProcedure(Reko.Core.IProcessorArchitecture! arch, Reko.Core.Address! addrImportThunk, Reko.Core.Address! addrInstruction) -> Reko.Core.ExternalProcedure?
Reko.Scanning.Scanner.GetInterceptedCall(Reko.Core.IProcessorArchitecture! arch, Reko.Core.Address! addrImportThunk) -> Reko.Core.ExternalProcedure?
Reko.Scanning.Scanner.GetTrace(Reko.Core.IProcessorArchitecture! arch, Reko.Core.Address! addrStart, Reko.Core.ProcessorState! state, Reko.Core.IStorageBinder! binder) -> System.Collections.Generic.IEnumerable<Reko.Core.Rtl.RtlInstructionCluster!>!
Reko.Scanning.Scanner.GetTrampoline(Reko.Core.IProcessorArchitecture! arch, Reko.Core.Address! addr) -> Reko.Core.ProcedureBase?
Reko.Scanning.Scanner.InjectProcedureEntryInstructions(Reko.Core.Address! addr, Reko.Core.Procedure! proc) -> void
Reko.Scanning.Scanner.Intrinsic(string! name, bool hasSideEffect, Reko.Core.Types.DataType! returnType, params Reko.Core.Expressions.Expression![]! args) -> Reko.Core.Expressions.Expression!
Reko.Scanning.Scanner.IsBlockLinearProcedureExit(Reko.Core.Block! block) -> bool
Reko.Scanning.Scanner.IsLinearReturning(Reko.Core.Block! block) -> bool
Reko.Scanning.Scanner.ProcessQueue() -> void
Reko.Scanning.Scanner.ScanDataItems() -> Reko.Scanning.ScanResults!
Reko.Scanning.Scanner.ScanImageSymbol(Reko.Core.ImageSymbol! sym, bool isEntryPoint) -> void
Reko.Scanning.Scanner.Scanner(Reko.Core.Program! program, Reko.Core.TypeLibrary! metadata, Reko.Core.IDynamicLinker! dynamicLinker, System.IServiceProvider! services) -> void
Reko.Scanning.Scanner.ScanProcedure(Reko.Core.IProcessorArchitecture! arch, Reko.Core.Address! addr, string? procedureName, Reko.Core.ProcessorState! state) -> Reko.Core.ProcedureBase!
Reko.Scanning.Scanner.ScanProceduresRecursively() -> void
Reko.Scanning.Scanner.Services.get -> System.IServiceProvider!
Reko.Scanning.Scanner.SetAssumedRegisterValues(Reko.Core.Address! addr, Reko.Core.ProcessorState! st) -> void
Reko.Scanning.Scanner.SetProcedureReturnAddressBytes(Reko.Core.Procedure! proc, int returnAddressBytes, Reko.Core.Address! address) -> void
Reko.Scanning.Scanner.SetProcedureStackDelta(Reko.Core.Procedure! proc, int stackDelta, Reko.Core.Address! address) -> void
Reko.Scanning.Scanner.ShingleScanProcedures() -> void
Reko.Scanning.Scanner.SplitBlock(Reko.Core.Block! blockToSplit, Reko.Core.Address! addr) -> Reko.Core.Block!
Reko.Scanning.Scanner.TerminateAnyBlockAt(Reko.Core.Address! addr) -> void
Reko.Scanning.Scanner.TerminateBlock(Reko.Core.Block! block, Reko.Core.Address! addr) -> void
Reko.Scanning.Scanner.TryRead(Reko.Core.IProcessorArchitecture! arch, Reko.Core.Address! addr, Reko.Core.Types.PrimitiveType! dt, out Reko.Core.Expressions.Constant! value) -> bool
Reko.Scanning.ScannerBase
Reko.Scanning.ScannerBase.Error(Reko.Core.Address! addr, string! message, params object![]! args) -> void
Reko.Scanning.ScannerBase.IsNoDecompiledProcedure(Reko.Core.Address! addr) -> bool
Reko.Scanning.ScannerBase.Program.get -> Reko.Core.Program!
Reko.Scanning.ScannerBase.ScannerBase(Reko.Core.Program! program, Reko.Core.Services.DecompilerEventListener! eventListener) -> void
Reko.Scanning.ScannerBase.TryGetNoDecompiledProcedure(Reko.Core.Address! addr, out Reko.Core.ExternalProcedure? ep) -> bool
Reko.Scanning.ScannerBase.Warn(Reko.Core.Address! addr, string! message) -> void
Reko.Scanning.ScannerBase.Warn(Reko.Core.Address! addr, string! message, params object![]! args) -> void
Reko.Scanning.ScannerInLinq
Reko.Scanning.ScannerInLinq.DumpBlocks(Reko.Scanning.ScanResults! sr, System.Collections.Generic.Dictionary<Reko.Core.Address!, Reko.Scanning.ScanResults.block!>! blocks, System.Action<string!>! writeLine) -> void
Reko.Scanning.ScannerInLinq.FindUnscannedRanges() -> System.Collections.Generic.IEnumerable<(Reko.Core.IProcessorArchitecture!, Reko.Core.Memory.MemoryArea!, Reko.Core.Address!, uint)>!
Reko.Scanning.ScannerInLinq.Probe(Reko.Scanning.ScanResults! sr) -> void
Reko.Scanning.ScannerInLinq.ScanImage(Reko.Scanning.ScanResults! sr) -> Reko.Scanning.ScanResults!
Reko.Scanning.ScannerInLinq.ScanInstructions(Reko.Scanning.ScanResults! sr) -> Reko.Scanning.ScanResults?
Reko.Scanning.ScannerInLinq.ScannerInLinq(System.IServiceProvider! services, Reko.Core.Program! program, Reko.Core.IRewriterHost! host, Reko.Core.Services.DecompilerEventListener! eventListener) -> void
Reko.Scanning.ScanResults
Reko.Scanning.ScanResults.block
Reko.Scanning.ScanResults.block.block() -> void
~Reko.Scanning.ScanResults.block.component_id -> Reko.Core.Address
~Reko.Scanning.ScanResults.block.id -> Reko.Core.Address
~Reko.Scanning.ScanResults.block.instrs -> Reko.Scanning.ScanResults.instr[]
~Reko.Scanning.ScanResults.BreakOnWatchedAddress(System.Collections.Generic.IEnumerable<Reko.Core.Address> enumerable) -> void
~Reko.Scanning.ScanResults.DirectlyCalledAddresses -> System.Collections.Generic.Dictionary<Reko.Core.Address, int>
~Reko.Scanning.ScanResults.Dump(string caption = "Dump") -> void
~Reko.Scanning.ScanResults.FlatEdges.get -> System.Collections.Generic.List<Reko.Scanning.ScanResults.link>
~Reko.Scanning.ScanResults.FlatEdges.set -> void
~Reko.Scanning.ScanResults.FlatInstructions.get -> System.Collections.Generic.Dictionary<ulong, Reko.Scanning.ScanResults.instr>
~Reko.Scanning.ScanResults.FlatInstructions.set -> void
~Reko.Scanning.ScanResults.ICFG -> Reko.Core.Graphs.DiGraph<Reko.Scanning.RtlBlock>
~Reko.Scanning.ScanResults.IndirectCalls -> System.Collections.Generic.HashSet<Reko.Core.Address>
~Reko.Scanning.ScanResults.IndirectJumps -> System.Collections.Generic.HashSet<Reko.Core.Address>
Reko.Scanning.ScanResults.instr
~Reko.Scanning.ScanResults.instr.addr -> Reko.Core.Address
~Reko.Scanning.ScanResults.instr.block_id -> Reko.Core.Address
Reko.Scanning.ScanResults.instr.instr() -> void
Reko.Scanning.ScanResults.instr.pred -> int
~Reko.Scanning.ScanResults.instr.rtl -> Reko.Core.Rtl.RtlInstructionCluster
Reko.Scanning.ScanResults.instr.size -> int
Reko.Scanning.ScanResults.instr.succ -> int
Reko.Scanning.ScanResults.instr.type -> ushort
~Reko.Scanning.ScanResults.Instructions -> System.Collections.Generic.Dictionary<Reko.Core.Address, Reko.Core.Rtl.RtlInstructionCluster>
~Reko.Scanning.ScanResults.Invalid -> System.Collections.Generic.HashSet<Reko.Core.Address>
~Reko.Scanning.ScanResults.KnownAddresses -> System.Collections.Generic.Dictionary<Reko.Core.Address, Reko.Core.ImageSymbol>
~Reko.Scanning.ScanResults.KnownProcedures.get -> System.Collections.Generic.HashSet<Reko.Core.Address>
~Reko.Scanning.ScanResults.KnownProcedures.set -> void
Reko.Scanning.ScanResults.link
~Reko.Scanning.ScanResults.link.first -> Reko.Core.Address
Reko.Scanning.ScanResults.link.link() -> void
~Reko.Scanning.ScanResults.link.second -> Reko.Core.Address
~Reko.Scanning.ScanResults.PossibleAddresses -> System.Collections.Generic.Dictionary<Reko.Core.Address, int>
~Reko.Scanning.ScanResults.Procedures.get -> System.Collections.Generic.List<Reko.Scanning.RtlProcedure>
~Reko.Scanning.ScanResults.Procedures.set -> void
~Reko.Scanning.ScanResults.RemovedPadding.get -> System.Collections.Generic.List<Reko.Scanning.RtlBlock>
~Reko.Scanning.ScanResults.RemovedPadding.set -> void
Reko.Scanning.ScanResults.ScanResults() -> void
~Reko.Scanning.ScanResults.TransferTargets -> System.Collections.Generic.HashSet<Reko.Core.Address>
~Reko.Scanning.ScanResults.WatchedAddresses -> System.Collections.Generic.HashSet<Reko.Core.Address>
Reko.Scanning.ShingledScanner
Reko.Scanning.ShingledScanner.AddEdge(Reko.Core.Address! from, Reko.Core.Address! to) -> void
Reko.Scanning.ShingledScanner.BuildBlocks(Reko.Core.Graphs.DiGraph<Reko.Core.Address!>! graph) -> Reko.Scanning.IcfgBuilder!
Reko.Scanning.ShingledScanner.BuildIcfg(System.Collections.Generic.HashSet<Reko.Core.Address!>! deadNodes) -> Reko.Core.Graphs.DiGraph<Reko.Scanning.RtlBlock!>!
Reko.Scanning.ShingledScanner.Dump(string! caption) -> void
Reko.Scanning.ShingledScanner.GetPossiblePointers(Reko.Core.ImageSegment! seg) -> System.Collections.Generic.IEnumerable<Reko.Core.Address!>!
Reko.Scanning.ShingledScanner.GetPossiblePointerTargets() -> System.Collections.Generic.Dictionary<Reko.Core.ImageSegment!, int[]!>!
Reko.Scanning.ShingledScanner.RemoveBadInstructionsFromGraph() -> System.Collections.Generic.HashSet<Reko.Core.Address!>!
Reko.Scanning.ShingledScanner.Scan() -> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<Reko.Core.Address!, int>>!
Reko.Scanning.ShingledScanner.ScanExecutableSegments() -> System.Collections.Generic.Dictionary<Reko.Core.ImageSegment!, byte[]!>!
Reko.Scanning.ShingledScanner.ScanNew() -> Reko.Scanning.ScanResults!
Reko.Scanning.ShingledScanner.ScanRange(Reko.Core.IProcessorArchitecture! arch, Reko.Core.Memory.MemoryArea! mem, Reko.Core.Address! addrStart, uint cbAlloc, ulong workToDo) -> byte[]!
Reko.Scanning.ShingledScanner.ShingledScanner(Reko.Core.Program! program, Reko.Core.IRewriterHost! host, Reko.Core.IStorageBinder! storageBinder, Reko.Scanning.ScanResults! sr, Reko.Core.Services.DecompilerEventListener! eventListener) -> void
Reko.Scanning.ShingledScanner.SpeculateCallDests(System.Collections.Generic.IDictionary<Reko.Core.ImageSegment!, byte[]!>! map) -> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<Reko.Core.Address!, int>>!
Reko.Scanning.SlicerResult
Reko.Scanning.SlicerResult.LiveExprs -> System.Collections.Generic.Dictionary<Reko.Core.Expressions.Expression!, Reko.Scanning.BackwardSlicerContext!>!
Reko.Scanning.SlicerResult.SlicerResult() -> void
Reko.Scanning.SlicerResult.SrcExpr -> Reko.Core.Expressions.Expression?
Reko.Scanning.SlicerResult.Stop -> bool
Reko.Scanning.SliceState
Reko.Scanning.SliceState.addrSucc -> Reko.Core.Address?
Reko.Scanning.SliceState.assignLhs -> Reko.Core.Expressions.Expression?
Reko.Scanning.SliceState.block -> Reko.Scanning.RtlBlock!
Reko.Scanning.SliceState.ccNext -> Reko.Core.Expressions.ConditionCode
Reko.Scanning.SliceState.CreateNew(Reko.Scanning.RtlBlock! block, Reko.Core.Address! addrSucc) -> Reko.Scanning.SliceState!
Reko.Scanning.SliceState.iInstr -> int
Reko.Scanning.SliceState.instrs -> Reko.Core.Rtl.RtlInstruction![]!
Reko.Scanning.SliceState.invertCondition -> bool
Reko.Scanning.SliceState.IsInBeginningOfBlock() -> bool
Reko.Scanning.SliceState.JumpTableFormat.get -> Reko.Core.Expressions.Expression?
Reko.Scanning.SliceState.JumpTableIndex.get -> Reko.Core.Expressions.Expression?
Reko.Scanning.SliceState.JumpTableIndexInterval.get -> Reko.Core.StridedInterval
Reko.Scanning.SliceState.JumpTableIndexToUse.get -> Reko.Core.Expressions.Expression?
Reko.Scanning.SliceState.Live -> System.Collections.Generic.Dictionary<Reko.Core.Expressions.Expression!, Reko.Scanning.BackwardSlicerContext!>!
Reko.Scanning.SliceState.SliceState(Reko.Scanning.BackwardSlicer! slicer, Reko.Scanning.RtlBlock! block, int iInstr) -> void
Reko.Scanning.SliceState.Start(Reko.Core.Expressions.Expression! indirectJump) -> bool
Reko.Scanning.SliceState.Step() -> bool
Reko.Scanning.SliceState.VisitAddress(Reko.Core.Address! addr, Reko.Scanning.BackwardSlicerContext! ctx) -> Reko.Scanning.SlicerResult!
Reko.Scanning.SliceState.VisitApplication(Reko.Core.Expressions.Application! appl, Reko.Scanning.BackwardSlicerContext! ctx) -> Reko.Scanning.SlicerResult!
Reko.Scanning.SliceState.VisitArrayAccess(Reko.Core.Expressions.ArrayAccess! acc, Reko.Scanning.BackwardSlicerContext! ctx) -> Reko.Scanning.SlicerResult!
Reko.Scanning.SliceState.VisitAssignment(Reko.Core.Rtl.RtlAssignment! ass) -> Reko.Scanning.SlicerResult?
Reko.Scanning.SliceState.VisitBinaryExpression(Reko.Core.Expressions.BinaryExpression! binExp, Reko.Scanning.BackwardSlicerContext! ctx) -> Reko.Scanning.SlicerResult?
Reko.Scanning.SliceState.VisitBranch(Reko.Core.Rtl.RtlBranch! branch) -> Reko.Scanning.SlicerResult?
Reko.Scanning.SliceState.VisitCall(Reko.Core.Rtl.RtlCall! call) -> Reko.Scanning.SlicerResult!
Reko.Scanning.SliceState.VisitCast(Reko.Core.Expressions.Cast! cast, Reko.Scanning.BackwardSlicerContext! ctx) -> Reko.Scanning.SlicerResult?
Reko.Scanning.SliceState.VisitConditionalExpression(Reko.Core.Expressions.ConditionalExpression! c, Reko.Scanning.BackwardSlicerContext! ctx) -> Reko.Scanning.SlicerResult?
Reko.Scanning.SliceState.VisitConditionOf(Reko.Core.Expressions.ConditionOf! cof, Reko.Scanning.BackwardSlicerContext! ctx) -> Reko.Scanning.SlicerResult?
Reko.Scanning.SliceState.VisitConstant(Reko.Core.Expressions.Constant! c, Reko.Scanning.BackwardSlicerContext! ctx) -> Reko.Scanning.SlicerResult!
Reko.Scanning.SliceState.VisitConversion(Reko.Core.Expressions.Conversion! conversion, Reko.Scanning.BackwardSlicerContext! ctx) -> Reko.Scanning.SlicerResult?
Reko.Scanning.SliceState.VisitDereference(Reko.Core.Expressions.Dereference! deref, Reko.Scanning.BackwardSlicerContext! ctx) -> Reko.Scanning.SlicerResult!
Reko.Scanning.SliceState.VisitFieldAccess(Reko.Core.Expressions.FieldAccess! acc, Reko.Scanning.BackwardSlicerContext! ctx) -> Reko.Scanning.SlicerResult!
Reko.Scanning.SliceState.VisitGoto(Reko.Core.Rtl.RtlGoto! go) -> Reko.Scanning.SlicerResult?
Reko.Scanning.SliceState.VisitIdentifier(Reko.Core.Expressions.Identifier! id, Reko.Scanning.BackwardSlicerContext! ctx) -> Reko.Scanning.SlicerResult!
Reko.Scanning.SliceState.VisitIf(Reko.Core.Rtl.RtlIf! rtlIf) -> Reko.Scanning.SlicerResult!
Reko.Scanning.SliceState.VisitInvalid(Reko.Core.Rtl.RtlInvalid! invalid) -> Reko.Scanning.SlicerResult!
Reko.Scanning.SliceState.VisitMemberPointerSelector(Reko.Core.Expressions.MemberPointerSelector! mps, Reko.Scanning.BackwardSlicerContext! ctx) -> Reko.Scanning.SlicerResult!
Reko.Scanning.SliceState.VisitMemoryAccess(Reko.Core.Expressions.MemoryAccess! access, Reko.Scanning.BackwardSlicerContext! ctx) -> Reko.Scanning.SlicerResult!
Reko.Scanning.SliceState.VisitMicroGoto(Reko.Core.Rtl.RtlMicroGoto! uGoto) -> Reko.Scanning.SlicerResult!
Reko.Scanning.SliceState.VisitMicroLabel(Reko.Core.Rtl.RtlMicroLabel! uLabel) -> Reko.Scanning.SlicerResult!
Reko.Scanning.SliceState.VisitMkSequence(Reko.Core.Expressions.MkSequence! seq, Reko.Scanning.BackwardSlicerContext! ctx) -> Reko.Scanning.SlicerResult!
Reko.Scanning.SliceState.VisitNop(Reko.Core.Rtl.RtlNop! rtlNop) -> Reko.Scanning.SlicerResult?
Reko.Scanning.SliceState.VisitOutArgument(Reko.Core.Expressions.OutArgument! outArgument, Reko.Scanning.BackwardSlicerContext! ctx) -> Reko.Scanning.SlicerResult!
Reko.Scanning.SliceState.VisitPhiFunction(Reko.Core.Expressions.PhiFunction! phi, Reko.Scanning.BackwardSlicerContext! ctx) -> Reko.Scanning.SlicerResult!
Reko.Scanning.SliceState.VisitPointerAddition(Reko.Core.Expressions.PointerAddition! pa, Reko.Scanning.BackwardSlicerContext! ctx) -> Reko.Scanning.SlicerResult!
Reko.Scanning.SliceState.VisitProcedureConstant(Reko.Core.Expressions.ProcedureConstant! pc, Reko.Scanning.BackwardSlicerContext! ctx) -> Reko.Scanning.SlicerResult!
Reko.Scanning.SliceState.VisitReturn(Reko.Core.Rtl.RtlReturn! ret) -> Reko.Scanning.SlicerResult!
Reko.Scanning.SliceState.VisitScopeResolution(Reko.Core.Expressions.ScopeResolution! scopeResolution, Reko.Scanning.BackwardSlicerContext! ctx) -> Reko.Scanning.SlicerResult!
Reko.Scanning.SliceState.VisitSegmentedAccess(Reko.Core.Expressions.SegmentedAccess! access, Reko.Scanning.BackwardSlicerContext! ctx) -> Reko.Scanning.SlicerResult?
Reko.Scanning.SliceState.VisitSideEffect(Reko.Core.Rtl.RtlSideEffect! side) -> Reko.Scanning.SlicerResult!
Reko.Scanning.SliceState.VisitSlice(Reko.Core.Expressions.Slice! slice, Reko.Scanning.BackwardSlicerContext! ctx) -> Reko.Scanning.SlicerResult?
Reko.Scanning.SliceState.VisitSwitch(Reko.Core.Rtl.RtlSwitch! rtlSwitch) -> Reko.Scanning.SlicerResult?
Reko.Scanning.SliceState.VisitTestCondition(Reko.Core.Expressions.TestCondition! tc, Reko.Scanning.BackwardSlicerContext! ctx) -> Reko.Scanning.SlicerResult?
Reko.Scanning.SliceState.VisitUnaryExpression(Reko.Core.Expressions.UnaryExpression! unary, Reko.Scanning.BackwardSlicerContext! ctx) -> Reko.Scanning.SlicerResult?
Reko.Scanning.StringFinder
Reko.Scanning.StringFinder.FindStrings(Reko.Scanning.StringFinderCriteria! criteria) -> System.Collections.Generic.IEnumerable<Reko.Core.AddressSearchHit!>!
Reko.Scanning.StringFinder.IsValid(char ch) -> bool
Reko.Scanning.StringFinder.StringFinder(Reko.Core.Program! program) -> void
Reko.Scanning.StringFinderCriteria
~Reko.Scanning.StringFinderCriteria.CreateReader -> System.Func<Reko.Core.Memory.ByteMemoryArea, Reko.Core.Address, Reko.Core.Address, Reko.Core.Memory.EndianImageReader>
~Reko.Scanning.StringFinderCriteria.Encoding -> System.Text.Encoding
Reko.Scanning.StringFinderCriteria.MinimumLength -> int
Reko.Scanning.StringFinderCriteria.StringFinderCriteria() -> void
~Reko.Scanning.StringFinderCriteria.StringType -> Reko.Core.Types.StringType
Reko.Scanning.StringSearch<TSymbol>
Reko.Scanning.StringSearch<TSymbol>.Pattern.get -> TSymbol[]!
Reko.Scanning.StringSearch<TSymbol>.ScannedMemory.get -> bool
Reko.Scanning.StringSearch<TSymbol>.StringSearch(TSymbol[]! pattern, bool scannedMemory, bool unscannedMemory) -> void
Reko.Scanning.StringSearch<TSymbol>.UnscannedMemory.get -> bool
Reko.Scanning.StringSearchResult<TSymbol>
Reko.Scanning.StringSearchResult<TSymbol>.Index.get -> int
~Reko.Scanning.StringSearchResult<TSymbol>.Keyword.get -> TSymbol[]
Reko.Scanning.StringSearchResult<TSymbol>.StringSearchResult() -> void
~Reko.Scanning.StringSearchResult<TSymbol>.StringSearchResult(int index, TSymbol[] keyword) -> void
Reko.Scanning.TableExtent
Reko.Scanning.TableExtent.Accesses -> System.Collections.Generic.Dictionary<Reko.Core.Address!, Reko.Core.Types.DataType!>?
Reko.Scanning.TableExtent.Index -> Reko.Core.Expressions.Expression?
Reko.Scanning.TableExtent.TableExtent() -> void
Reko.Scanning.TableExtent.Targets -> System.Collections.Generic.List<Reko.Core.Address!>?
Reko.Scanning.Trie<T>
Reko.Scanning.Trie<T>.Add(T[]! instrs) -> void
Reko.Scanning.Trie<T>.Count.get -> int
Reko.Scanning.Trie<T>.Dump() -> void
Reko.Scanning.Trie<T>.ScoreInstructions(T[]! instrs) -> long
Reko.Scanning.Trie<T>.Trie(System.Collections.Generic.IEqualityComparer<T>! hasher) -> void
Reko.Scanning.ValueSet
Reko.Scanning.ValueSet.DataType.get -> Reko.Core.Types.DataType!
Reko.Scanning.ValueSet.ValueSet(Reko.Core.Types.DataType! dt) -> void
Reko.Scanning.ValueSetEvaluator
Reko.Scanning.ValueSetEvaluator.Evaluate(Reko.Core.Expressions.Expression! expr) -> (Reko.Scanning.ValueSet!, System.Collections.Generic.Dictionary<Reko.Core.Address!, Reko.Core.Types.DataType!>!)
Reko.Scanning.ValueSetEvaluator.ValueSetEvaluator(Reko.Core.IProcessorArchitecture! arch, Reko.Core.SegmentMap! segmentMap, System.Collections.Generic.Dictionary<Reko.Core.Expressions.Expression!, Reko.Scanning.ValueSet!>! context, Reko.Core.ProcessorState? state = null) -> void
Reko.Scanning.ValueSetEvaluator.VisitAddress(Reko.Core.Address! addr, Reko.Core.BitRange bitRange) -> Reko.Scanning.ValueSet!
Reko.Scanning.ValueSetEvaluator.VisitApplication(Reko.Core.Expressions.Application! appl, Reko.Core.BitRange bitRange) -> Reko.Scanning.ValueSet!
Reko.Scanning.ValueSetEvaluator.VisitArrayAccess(Reko.Core.Expressions.ArrayAccess! acc, Reko.Core.BitRange bitRange) -> Reko.Scanning.ValueSet!
Reko.Scanning.ValueSetEvaluator.VisitBinaryExpression(Reko.Core.Expressions.BinaryExpression! binExp, Reko.Core.BitRange bitRange) -> Reko.Scanning.ValueSet!
Reko.Scanning.ValueSetEvaluator.VisitCast(Reko.Core.Expressions.Cast! cast, Reko.Core.BitRange bitRange) -> Reko.Scanning.ValueSet!
Reko.Scanning.ValueSetEvaluator.VisitConditionalExpression(Reko.Core.Expressions.ConditionalExpression! cond, Reko.Core.BitRange bitRange) -> Reko.Scanning.ValueSet!
Reko.Scanning.ValueSetEvaluator.VisitConditionOf(Reko.Core.Expressions.ConditionOf! cof, Reko.Core.BitRange bitRange) -> Reko.Scanning.ValueSet!
Reko.Scanning.ValueSetEvaluator.VisitConstant(Reko.Core.Expressions.Constant! c, Reko.Core.BitRange bitRange) -> Reko.Scanning.ValueSet!
Reko.Scanning.ValueSetEvaluator.VisitConversion(Reko.Core.Expressions.Conversion! conversion, Reko.Core.BitRange bitRange) -> Reko.Scanning.ValueSet!
Reko.Scanning.ValueSetEvaluator.VisitDereference(Reko.Core.Expressions.Dereference! deref, Reko.Core.BitRange bitRange) -> Reko.Scanning.ValueSet!
Reko.Scanning.ValueSetEvaluator.VisitFieldAccess(Reko.Core.Expressions.FieldAccess! acc, Reko.Core.BitRange bitRange) -> Reko.Scanning.ValueSet!
Reko.Scanning.ValueSetEvaluator.VisitIdentifier(Reko.Core.Expressions.Identifier! id, Reko.Core.BitRange bitRange) -> Reko.Scanning.ValueSet!
Reko.Scanning.ValueSetEvaluator.VisitMemberPointerSelector(Reko.Core.Expressions.MemberPointerSelector! mps, Reko.Core.BitRange bitRange) -> Reko.Scanning.ValueSet!
Reko.Scanning.ValueSetEvaluator.VisitMemoryAccess(Reko.Core.Expressions.MemoryAccess! access, Reko.Core.BitRange bitRange) -> Reko.Scanning.ValueSet!
Reko.Scanning.ValueSetEvaluator.VisitMkSequence(Reko.Core.Expressions.MkSequence! seq, Reko.Core.BitRange bitRange) -> Reko.Scanning.ValueSet!
Reko.Scanning.ValueSetEvaluator.VisitOutArgument(Reko.Core.Expressions.OutArgument! outArgument, Reko.Core.BitRange bitRange) -> Reko.Scanning.ValueSet!
Reko.Scanning.ValueSetEvaluator.VisitPhiFunction(Reko.Core.Expressions.PhiFunction! phi, Reko.Core.BitRange bitRange) -> Reko.Scanning.ValueSet!
Reko.Scanning.ValueSetEvaluator.VisitPointerAddition(Reko.Core.Expressions.PointerAddition! pa, Reko.Core.BitRange bitRange) -> Reko.Scanning.ValueSet!
Reko.Scanning.ValueSetEvaluator.VisitProcedureConstant(Reko.Core.Expressions.ProcedureConstant! pc, Reko.Core.BitRange bitRange) -> Reko.Scanning.ValueSet!
Reko.Scanning.ValueSetEvaluator.VisitScopeResolution(Reko.Core.Expressions.ScopeResolution! scopeResolution, Reko.Core.BitRange bitRange) -> Reko.Scanning.ValueSet!
Reko.Scanning.ValueSetEvaluator.VisitSegmentedAccess(Reko.Core.Expressions.SegmentedAccess! access, Reko.Core.BitRange bitRange) -> Reko.Scanning.ValueSet!
Reko.Scanning.ValueSetEvaluator.VisitSlice(Reko.Core.Expressions.Slice! slice, Reko.Core.BitRange bitRange) -> Reko.Scanning.ValueSet!
Reko.Scanning.ValueSetEvaluator.VisitTestCondition(Reko.Core.Expressions.TestCondition! tc, Reko.Core.BitRange bitRange) -> Reko.Scanning.ValueSet!
Reko.Scanning.ValueSetEvaluator.VisitUnaryExpression(Reko.Core.Expressions.UnaryExpression! unary, Reko.Core.BitRange bitRange) -> Reko.Scanning.ValueSet!
Reko.Scanning.VarargsFormatScanner
Reko.Scanning.VarargsFormatScanner.BuildInstruction(Reko.Core.Expressions.Expression! callee, Reko.Core.Code.CallSite! site, Reko.Core.Serialization.ProcedureCharacteristics? chr) -> Reko.Core.Code.Instruction!
Reko.Scanning.VarargsFormatScanner.TryScan(Reko.Core.Address! addrInstr, Reko.Core.Expressions.Expression! callee, Reko.Core.Types.FunctionType! sig, Reko.Core.Serialization.ProcedureCharacteristics? chr) -> bool
Reko.Scanning.VarargsFormatScanner.VarargsFormatScanner(Reko.Core.Program! program, Reko.Core.Frame! frame, Reko.Core.EvaluationContext! ctx, System.IServiceProvider! services) -> void
Reko.Scanning.VectorBuilder
Reko.Scanning.VectorBuilder.Architecture.get -> Reko.Core.IProcessorArchitecture!
Reko.Scanning.VectorBuilder.AsAssignment(Reko.Core.Code.Instruction! instr) -> (Reko.Core.Expressions.Expression?, Reko.Core.Expressions.Expression?)
Reko.Scanning.VectorBuilder.AsBranch(Reko.Core.Code.Instruction! instr) -> Reko.Core.Expressions.Expression?
Reko.Scanning.VectorBuilder.BlockInstructionCount(Reko.Core.Block! block) -> int
Reko.Scanning.VectorBuilder.Build(Reko.Core.Address! addrTable, Reko.Core.Address! addrFrom, Reko.Core.ProcessorState! state) -> System.Collections.Generic.List<Reko.Core.Address!>!
Reko.Scanning.VectorBuilder.BuildAux(Reko.Scanning.Backwalker<Reko.Core.Block!, Reko.Core.Code.Instruction!>! bw, Reko.Core.Address! addrFrom, Reko.Core.ProcessorState! state) -> System.Collections.Generic.List<Reko.Core.Address!>!
Reko.Scanning.VectorBuilder.BuildTable(Reko.Core.Address! addrTable, int limit, int[]! permutation, int stride, Reko.Core.ProcessorState! state) -> System.Collections.Generic.List<Reko.Core.Address!>!
Reko.Scanning.VectorBuilder.GetBlockInstructions(Reko.Core.Block! block) -> System.Collections.Generic.IEnumerable<Reko.Core.Code.Instruction!>!
Reko.Scanning.VectorBuilder.GetPredecessors(Reko.Core.Block! block) -> System.Collections.Generic.List<Reko.Core.Block!>!
Reko.Scanning.VectorBuilder.GetSinglePredecessor(Reko.Core.Block! block) -> Reko.Core.Block?
Reko.Scanning.VectorBuilder.GetSubregister(Reko.Core.RegisterStorage! reg, Reko.Core.BitRange range) -> Reko.Core.RegisterStorage!
Reko.Scanning.VectorBuilder.IndexRegister.get -> Reko.Core.RegisterStorage!
Reko.Scanning.VectorBuilder.IsFallthrough(Reko.Core.Code.Instruction! instr, Reko.Core.Block! block) -> bool
Reko.Scanning.VectorBuilder.IsStackRegister(Reko.Core.Storage! stg) -> bool
Reko.Scanning.VectorBuilder.IsValidAddress(Reko.Core.Address! addr) -> bool
Reko.Scanning.VectorBuilder.MakeAddressFromConstant(Reko.Core.Expressions.Constant! c) -> Reko.Core.Address?
Reko.Scanning.VectorBuilder.MakeSegmentedAddress(Reko.Core.Expressions.Constant! seg, Reko.Core.Expressions.Constant! off) -> Reko.Core.Address!
Reko.Scanning.VectorBuilder.Program.get -> Reko.Core.Program!
Reko.Scanning.VectorBuilder.SegmentMap.get -> Reko.Core.SegmentMap!
Reko.Scanning.VectorBuilder.TableByteSize.get -> int
Reko.Scanning.VectorBuilder.VectorBuilder(System.IServiceProvider! services, Reko.Core.Program! program, Reko.Core.Graphs.DirectedGraphImpl<object!>! jumpGraph) -> void
Reko.Scanning.Vsa.AbstractLocation
Reko.Scanning.Vsa.AbstractLocation.AbstractLocation() -> void
Reko.Scanning.Vsa.ReducedIntervalCongruence
Reko.Scanning.Vsa.ReducedIntervalCongruence.Base -> long
Reko.Scanning.Vsa.ReducedIntervalCongruence.First -> int
Reko.Scanning.Vsa.ReducedIntervalCongruence.Last -> int
Reko.Scanning.Vsa.ReducedIntervalCongruence.ReducedIntervalCongruence() -> void
Reko.Scanning.Vsa.ReducedIntervalCongruence.Scale -> int
Reko.Scanning.WorkItem
Reko.Scanning.WorkItem.Address.get -> Reko.Core.Address!
Reko.Scanning.WorkItem.WorkItem(Reko.Core.Address! addr) -> void
Reko.Services.DecompilerService
Reko.Services.DecompilerService.Decompiler.get -> Reko.IDecompiler?
Reko.Services.DecompilerService.Decompiler.set -> void
Reko.Services.DecompilerService.DecompilerChanged -> System.EventHandler?
Reko.Services.DecompilerService.DecompilerService() -> void
Reko.Services.DecompilerService.ProjectName.get -> string!
Reko.Services.IDecompilerService
Reko.Services.IDecompilerService.Decompiler.get -> Reko.IDecompiler?
Reko.Services.IDecompilerService.Decompiler.set -> void
Reko.Services.IDecompilerService.DecompilerChanged -> System.EventHandler!
Reko.Services.IDecompilerService.ProjectName.get -> string!
Reko.Services.TestGenerationService
Reko.Services.TestGenerationService.OutputDirectory.get -> string?
Reko.Services.TestGenerationService.OutputDirectory.set -> void
Reko.Services.TestGenerationService.RemoveFiles(string! filePrefix) -> void
Reko.Services.TestGenerationService.ReportMissingDecoder(string! testPrefix, Reko.Core.Address! addrStart, Reko.Core.Memory.EndianImageReader! rdr, string! message, System.Func<byte[]!, string!>? hexizer) -> void
Reko.Services.TestGenerationService.ReportMissingDecoder(string! testPrefix, Reko.Core.Address! addrStart, string! message, string! opcodeAsText) -> void
Reko.Services.TestGenerationService.ReportMissingRewriter(string! testPrefix, Reko.Core.Machine.MachineInstruction! instr, string! mnemonic, Reko.Core.Memory.EndianImageReader! rdr, string! message, string! opcodeAsText) -> void
Reko.Services.TestGenerationService.ReportMissingRewriter(string! testPrefix, Reko.Core.Machine.MachineInstruction! instr, string! mnemonic, Reko.Core.Memory.EndianImageReader! rdr, string! message, System.Func<byte[]!, string!>? hexizer = null) -> void
Reko.Services.TestGenerationService.ReportProcedure(string! fileName, string! testCaption, Reko.Core.Procedure! proc) -> void
Reko.Services.TestGenerationService.TestGenerationService(System.IServiceProvider! services) -> void
Reko.Structure.AbsynStatementEmitter
Reko.Structure.AbsynStatementEmitter.AbsynStatementEmitter(System.Collections.Generic.List<Reko.Core.Absyn.AbsynStatement!>! stms) -> void
Reko.Structure.AbsynStatementEmitter.EmitAssign(Reko.Core.Expressions.Expression! dst, Reko.Core.Expressions.Expression! src) -> Reko.Core.Absyn.AbsynAssignment!
Reko.Structure.AbsynStatementEmitter.EmitBreak() -> void
Reko.Structure.AbsynStatementEmitter.EmitContinue() -> void
Reko.Structure.AbsynStatementEmitter.EmitDoWhile(System.Collections.Generic.List<Reko.Core.Absyn.AbsynStatement!>! body, Reko.Core.Expressions.Expression! expr) -> void
Reko.Structure.AbsynStatementEmitter.EmitReturn(Reko.Core.Expressions.Expression! expr) -> void
Reko.Structure.AbsynStatementEmitter.EmitStatement(Reko.Core.Absyn.AbsynStatement! stm) -> void
Reko.Structure.AbsynStatementEmitter.EmitStatement(Reko.Core.Statement! stm) -> void
Reko.Structure.AbsynStatementEmitter.StripDeclarations.get -> bool
Reko.Structure.AbsynStatementEmitter.StripDeclarations.set -> void
Reko.Structure.AbsynStatementEmitter.VisitAssignment(Reko.Core.Absyn.AbsynAssignment! ass) -> void
Reko.Structure.AbsynStatementEmitter.VisitBreak(Reko.Core.Absyn.AbsynBreak! brk) -> void
Reko.Structure.AbsynStatementEmitter.VisitCase(Reko.Core.Absyn.AbsynCase! absynCase) -> void
Reko.Structure.AbsynStatementEmitter.VisitCompoundAssignment(Reko.Core.Absyn.AbsynCompoundAssignment! compound) -> void
Reko.Structure.AbsynStatementEmitter.VisitContinue(Reko.Core.Absyn.AbsynContinue! cont) -> void
Reko.Structure.AbsynStatementEmitter.VisitDeclaration(Reko.Core.Absyn.AbsynDeclaration! decl) -> void
Reko.Structure.AbsynStatementEmitter.VisitDefault(Reko.Core.Absyn.AbsynDefault! def) -> void
Reko.Structure.AbsynStatementEmitter.VisitDoWhile(Reko.Core.Absyn.AbsynDoWhile! loop) -> void
Reko.Structure.AbsynStatementEmitter.VisitFor(Reko.Core.Absyn.AbsynFor! forLoop) -> void
Reko.Structure.AbsynStatementEmitter.VisitGoto(Reko.Core.Absyn.AbsynGoto! gotoStm) -> void
Reko.Structure.AbsynStatementEmitter.VisitIf(Reko.Core.Absyn.AbsynIf! ifStm) -> void
Reko.Structure.AbsynStatementEmitter.VisitLabel(Reko.Core.Absyn.AbsynLabel! lbl) -> void
Reko.Structure.AbsynStatementEmitter.VisitLineComment(Reko.Core.Absyn.AbsynLineComment! comment) -> void
Reko.Structure.AbsynStatementEmitter.VisitReturn(Reko.Core.Absyn.AbsynReturn! ret) -> void
Reko.Structure.AbsynStatementEmitter.VisitSideEffect(Reko.Core.Absyn.AbsynSideEffect! side) -> void
Reko.Structure.AbsynStatementEmitter.VisitSwitch(Reko.Core.Absyn.AbsynSwitch! absynSwitch) -> void
Reko.Structure.AbsynStatementEmitter.VisitWhile(Reko.Core.Absyn.AbsynWhile! loop) -> void
Reko.Structure.CompoundConditionCoalescer
Reko.Structure.CompoundConditionCoalescer.CompoundConditionCoalescer(Reko.Core.Procedure! proc) -> void
Reko.Structure.CompoundConditionCoalescer.Transform() -> void
Reko.Structure.ControlFlowGraphCleaner
Reko.Structure.ControlFlowGraphCleaner.Coalesce(Reko.Core.Block! block, Reko.Core.Block! next) -> Reko.Core.Block!
Reko.Structure.ControlFlowGraphCleaner.ControlFlowGraphCleaner(Reko.Core.Procedure! proc) -> void
Reko.Structure.ControlFlowGraphCleaner.EndsInJump(Reko.Core.Block! block) -> bool
Reko.Structure.ControlFlowGraphCleaner.Transform() -> void
Reko.Structure.ForLoopCandidate
Reko.Structure.ForLoopCandidate.Condition -> Reko.Core.Expressions.Expression?
Reko.Structure.ForLoopCandidate.Container -> System.Collections.Generic.List<Reko.Core.Absyn.AbsynStatement!>?
Reko.Structure.ForLoopCandidate.DeadDeclaration -> Reko.Core.Absyn.AbsynDeclaration?
Reko.Structure.ForLoopCandidate.ForLoopCandidate() -> void
Reko.Structure.ForLoopCandidate.Initializer -> Reko.Core.Absyn.AbsynAssignment?
Reko.Structure.ForLoopCandidate.LoopBody -> System.Collections.Generic.List<Reko.Core.Absyn.AbsynStatement!>?
Reko.Structure.ForLoopCandidate.LoopVariable -> Reko.Core.Expressions.Identifier?
Reko.Structure.ForLoopCandidate.Update -> Reko.Core.Absyn.AbsynAssignment?
Reko.Structure.ForLoopRewriter
Reko.Structure.ForLoopRewriter.ForLoopRewriter(Reko.Core.Procedure! proc) -> void
Reko.Structure.ForLoopRewriter.RewriteForLoops(System.Collections.Generic.List<Reko.Core.Absyn.AbsynStatement!>! stmts) -> void
Reko.Structure.ForLoopRewriter.Transform() -> void
Reko.Structure.ForLoopRewriter.TryMakeLoopCandidate(Reko.Core.Expressions.Expression! cond, System.Collections.Generic.List<Reko.Core.Absyn.AbsynStatement!>! loopBody, System.Collections.Generic.List<Reko.Core.Absyn.AbsynStatement!>! container, int i) -> Reko.Structure.ForLoopCandidate?
Reko.Structure.IStructureAnalysis
Reko.Structure.IStructureAnalysis.Structure() -> void
Reko.Structure.LoopFinder<T>
Reko.Structure.LoopFinder<T>.LoopFinder(Reko.Core.Graphs.DirectedGraph<T!>! graph, T! entry, Reko.Core.Graphs.DominatorGraph<T!>! doms) -> void
Reko.Structure.LoopFinder<T>.LoopNodes.get -> System.Collections.Generic.ISet<T!>!
Reko.Structure.NodeColor
Reko.Structure.NodeColor.Black = 1 -> Reko.Structure.NodeColor
Reko.Structure.NodeColor.Gray = 0 -> Reko.Structure.NodeColor
Reko.Structure.ProcedurePrettifier
Reko.Structure.ProcedurePrettifier.ProcedurePrettifier(Reko.Core.Procedure! proc) -> void
Reko.Structure.ProcedurePrettifier.Transform() -> void
Reko.Structure.ProcedurePrettifier.VisitAssignment(Reko.Core.Absyn.AbsynAssignment! ass) -> Reko.Core.Absyn.AbsynStatement!
Reko.Structure.ProcedurePrettifier.VisitBreak(Reko.Core.Absyn.AbsynBreak! brk) -> Reko.Core.Absyn.AbsynStatement!
Reko.Structure.ProcedurePrettifier.VisitCase(Reko.Core.Absyn.AbsynCase! absynCase) -> Reko.Core.Absyn.AbsynStatement!
Reko.Structure.ProcedurePrettifier.VisitCompoundAssignment(Reko.Core.Absyn.AbsynCompoundAssignment! compound) -> Reko.Core.Absyn.AbsynStatement!
Reko.Structure.ProcedurePrettifier.VisitContinue(Reko.Core.Absyn.AbsynContinue! cont) -> Reko.Core.Absyn.AbsynStatement!
Reko.Structure.ProcedurePrettifier.VisitDeclaration(Reko.Core.Absyn.AbsynDeclaration! decl) -> Reko.Core.Absyn.AbsynStatement!
Reko.Structure.ProcedurePrettifier.VisitDefault(Reko.Core.Absyn.AbsynDefault! def) -> Reko.Core.Absyn.AbsynStatement!
Reko.Structure.ProcedurePrettifier.VisitDoWhile(Reko.Core.Absyn.AbsynDoWhile! loop) -> Reko.Core.Absyn.AbsynStatement!
Reko.Structure.ProcedurePrettifier.VisitFor(Reko.Core.Absyn.AbsynFor! forLoop) -> Reko.Core.Absyn.AbsynStatement!
Reko.Structure.ProcedurePrettifier.VisitGoto(Reko.Core.Absyn.AbsynGoto! gotoStm) -> Reko.Core.Absyn.AbsynStatement!
Reko.Structure.ProcedurePrettifier.VisitIf(Reko.Core.Absyn.AbsynIf! ifStm) -> Reko.Core.Absyn.AbsynStatement!
Reko.Structure.ProcedurePrettifier.VisitLabel(Reko.Core.Absyn.AbsynLabel! lbl) -> Reko.Core.Absyn.AbsynStatement!
Reko.Structure.ProcedurePrettifier.VisitLineComment(Reko.Core.Absyn.AbsynLineComment! comment) -> Reko.Core.Absyn.AbsynStatement!
Reko.Structure.ProcedurePrettifier.VisitReturn(Reko.Core.Absyn.AbsynReturn! ret) -> Reko.Core.Absyn.AbsynStatement!
Reko.Structure.ProcedurePrettifier.VisitSideEffect(Reko.Core.Absyn.AbsynSideEffect! side) -> Reko.Core.Absyn.AbsynStatement!
Reko.Structure.ProcedurePrettifier.VisitSwitch(Reko.Core.Absyn.AbsynSwitch! absynSwitch) -> Reko.Core.Absyn.AbsynStatement!
Reko.Structure.ProcedurePrettifier.VisitWhile(Reko.Core.Absyn.AbsynWhile! loop) -> Reko.Core.Absyn.AbsynStatement!
Reko.Structure.Region
Reko.Structure.Region.Block.get -> Reko.Core.Block!
Reko.Structure.Region.Expression.get -> Reko.Core.Expressions.Expression?
Reko.Structure.Region.Expression.set -> void
Reko.Structure.Region.IsReturn.get -> bool
Reko.Structure.Region.IsSwitchPad.get -> bool
Reko.Structure.Region.IsSwitchPad.set -> void
Reko.Structure.Region.Region(Reko.Core.Block! block) -> void
Reko.Structure.Region.Region(Reko.Core.Block! block, System.Collections.Generic.IEnumerable<Reko.Core.Absyn.AbsynStatement!>! stmts) -> void
Reko.Structure.Region.Statements.get -> System.Collections.Generic.List<Reko.Core.Absyn.AbsynStatement!>!
Reko.Structure.Region.Statements.set -> void
Reko.Structure.Region.SwitchPredecessor.get -> string!
Reko.Structure.Region.SwitchPredecessor.set -> void
Reko.Structure.Region.Type.get -> Reko.Structure.RegionType
Reko.Structure.Region.Type.set -> void
Reko.Structure.RegionFactory
Reko.Structure.RegionFactory.Create(Reko.Core.Block! b) -> Reko.Structure.Region!
Reko.Structure.RegionFactory.RegionFactory() -> void
Reko.Structure.RegionFactory.VisitAssignment(Reko.Core.Code.Assignment! ass) -> Reko.Core.Absyn.AbsynStatement!
Reko.Structure.RegionFactory.VisitBranch(Reko.Core.Code.Branch! branch) -> Reko.Core.Absyn.AbsynStatement?
Reko.Structure.RegionFactory.VisitCallInstruction(Reko.Core.Code.CallInstruction! ci) -> Reko.Core.Absyn.AbsynStatement!
Reko.Structure.RegionFactory.VisitComment(Reko.Core.Code.CodeComment! comment) -> Reko.Core.Absyn.AbsynStatement!
Reko.Structure.RegionFactory.VisitDeclaration(Reko.Core.Code.Declaration! decl) -> Reko.Core.Absyn.AbsynStatement!
Reko.Structure.RegionFactory.VisitDefInstruction(Reko.Core.Code.DefInstruction! def) -> Reko.Core.Absyn.AbsynStatement!
Reko.Structure.RegionFactory.VisitGotoInstruction(Reko.Core.Code.GotoInstruction! gotoInstruction) -> Reko.Core.Absyn.AbsynStatement!
Reko.Structure.RegionFactory.VisitPhiAssignment(Reko.Core.Code.PhiAssignment! phi) -> Reko.Core.Absyn.AbsynStatement!
Reko.Structure.RegionFactory.VisitReturnInstruction(Reko.Core.Code.ReturnInstruction! ret) -> Reko.Core.Absyn.AbsynStatement!
Reko.Structure.RegionFactory.VisitSideEffect(Reko.Core.Code.SideEffect! side) -> Reko.Core.Absyn.AbsynStatement!
Reko.Structure.RegionFactory.VisitStore(Reko.Core.Code.Store! store) -> Reko.Core.Absyn.AbsynStatement!
Reko.Structure.RegionFactory.VisitSwitchInstruction(Reko.Core.Code.SwitchInstruction! si) -> Reko.Core.Absyn.AbsynStatement?
Reko.Structure.RegionFactory.VisitUseInstruction(Reko.Core.Code.UseInstruction! use) -> Reko.Core.Absyn.AbsynStatement!
Reko.Structure.RegionGraphBuilder
Reko.Structure.RegionGraphBuilder.Build() -> (Reko.Core.Graphs.DirectedGraph<Reko.Structure.Region!>!, Reko.Structure.Region!)
Reko.Structure.RegionGraphBuilder.RegionGraphBuilder(Reko.Core.Procedure! proc) -> void
Reko.Structure.RegionType
Reko.Structure.RegionType.Condition = 1 -> Reko.Structure.RegionType
Reko.Structure.RegionType.IncSwitch = 2 -> Reko.Structure.RegionType
Reko.Structure.RegionType.Linear = 0 -> Reko.Structure.RegionType
Reko.Structure.RegionType.Tail = 3 -> Reko.Structure.RegionType
Reko.Structure.ReverseGraph
Reko.Structure.ReverseGraph.AddEdge(Reko.Structure.Region! nodeFrom, Reko.Structure.Region! nodeTo) -> void
Reko.Structure.ReverseGraph.ContainsEdge(Reko.Structure.Region! nodeFrom, Reko.Structure.Region! nodeTo) -> bool
Reko.Structure.ReverseGraph.Nodes.get -> System.Collections.Generic.ICollection<Reko.Structure.Region!>!
Reko.Structure.ReverseGraph.Predecessors(Reko.Structure.Region! node) -> System.Collections.Generic.ICollection<Reko.Structure.Region!>!
Reko.Structure.ReverseGraph.RemoveEdge(Reko.Structure.Region! nodeFrom, Reko.Structure.Region! nodeTo) -> void
Reko.Structure.ReverseGraph.ReverseGraph(Reko.Core.Graphs.DirectedGraph<Reko.Structure.Region!>! graph) -> void
Reko.Structure.ReverseGraph.Successors(Reko.Structure.Region! node) -> System.Collections.Generic.ICollection<Reko.Structure.Region!>!
Reko.Structure.StructureAnalysis
Reko.Structure.StructureAnalysis.CollapseToTailRegion(Reko.Structure.Region! from, Reko.Structure.Region! to, Reko.Core.Absyn.AbsynStatement! stm) -> void
Reko.Structure.StructureAnalysis.Execute() -> Reko.Structure.Region!
Reko.Structure.StructureAnalysis.LoopType
Reko.Structure.StructureAnalysis.LoopType.DoWhile = 1 -> Reko.Structure.StructureAnalysis.LoopType
Reko.Structure.StructureAnalysis.LoopType.While = 0 -> Reko.Structure.StructureAnalysis.LoopType
Reko.Structure.StructureAnalysis.ProcessUnresolvedRegions() -> bool
Reko.Structure.StructureAnalysis.ReduceAcyclic(Reko.Structure.Region! n) -> bool
Reko.Structure.StructureAnalysis.ReduceCyclic(Reko.Structure.Region! n) -> bool
Reko.Structure.StructureAnalysis.Structure() -> void
~Reko.Structure.StructureAnalysis.StructureAnalysis(Reko.Core.Services.DecompilerEventListener listener, Reko.Core.Program program, Reko.Core.Procedure proc) -> void
Reko.Structure.StructureAnalysis.VirtualEdge
Reko.Structure.StructureAnalysis.VirtualEdge.From -> Reko.Structure.Region!
Reko.Structure.StructureAnalysis.VirtualEdge.To -> Reko.Structure.Region!
Reko.Structure.StructureAnalysis.VirtualEdge.Type -> Reko.Structure.StructureAnalysis.VirtualEdgeType
Reko.Structure.StructureAnalysis.VirtualEdge.VirtualEdge(Reko.Structure.Region! from, Reko.Structure.Region! to, Reko.Structure.StructureAnalysis.VirtualEdgeType type) -> void
Reko.Structure.StructureAnalysis.VirtualEdgeType
Reko.Structure.StructureAnalysis.VirtualEdgeType.Break = 1 -> Reko.Structure.StructureAnalysis.VirtualEdgeType
Reko.Structure.StructureAnalysis.VirtualEdgeType.Continue = 2 -> Reko.Structure.StructureAnalysis.VirtualEdgeType
Reko.Structure.StructureAnalysis.VirtualEdgeType.Goto = 0 -> Reko.Structure.StructureAnalysis.VirtualEdgeType
Reko.Structure.StructureAnalysis.VirtualizeEdge(Reko.Structure.StructureAnalysis.VirtualEdge! vEdge) -> void
Reko.Structure.TailReturnRemover
Reko.Structure.TailReturnRemover.TailReturnRemover(Reko.Core.Procedure! proc) -> void
Reko.Structure.TailReturnRemover.Transform() -> void
Reko.Structure.TailReturnRemover.VisitAssignment(Reko.Core.Absyn.AbsynAssignment! ass) -> bool
Reko.Structure.TailReturnRemover.VisitBreak(Reko.Core.Absyn.AbsynBreak! brk) -> bool
Reko.Structure.TailReturnRemover.VisitCase(Reko.Core.Absyn.AbsynCase! absynCase) -> bool
Reko.Structure.TailReturnRemover.VisitCompoundAssignment(Reko.Core.Absyn.AbsynCompoundAssignment! compound) -> bool
Reko.Structure.TailReturnRemover.VisitContinue(Reko.Core.Absyn.AbsynContinue! cont) -> bool
Reko.Structure.TailReturnRemover.VisitDeclaration(Reko.Core.Absyn.AbsynDeclaration! decl) -> bool
Reko.Structure.TailReturnRemover.VisitDefault(Reko.Core.Absyn.AbsynDefault! decl) -> bool
Reko.Structure.TailReturnRemover.VisitDoWhile(Reko.Core.Absyn.AbsynDoWhile! loop) -> bool
Reko.Structure.TailReturnRemover.VisitFor(Reko.Core.Absyn.AbsynFor! forLoop) -> bool
Reko.Structure.TailReturnRemover.VisitGoto(Reko.Core.Absyn.AbsynGoto! gotoStm) -> bool
Reko.Structure.TailReturnRemover.VisitIf(Reko.Core.Absyn.AbsynIf! ifStm) -> bool
Reko.Structure.TailReturnRemover.VisitLabel(Reko.Core.Absyn.AbsynLabel! lbl) -> bool
Reko.Structure.TailReturnRemover.VisitLineComment(Reko.Core.Absyn.AbsynLineComment! comment) -> bool
Reko.Structure.TailReturnRemover.VisitReturn(Reko.Core.Absyn.AbsynReturn! ret) -> bool
Reko.Structure.TailReturnRemover.VisitSideEffect(Reko.Core.Absyn.AbsynSideEffect! side) -> bool
Reko.Structure.TailReturnRemover.VisitSwitch(Reko.Core.Absyn.AbsynSwitch! absynSwitch) -> bool
Reko.Structure.TailReturnRemover.VisitWhile(Reko.Core.Absyn.AbsynWhile! loop) -> bool
Reko.Typing.AddressTraitCollector
Reko.Typing.AddressTraitCollector.AddressTraitCollector(Reko.Core.Types.TypeFactory! factory, Reko.Core.Types.ITypeStore! store, Reko.Typing.ITraitHandler! handler, Reko.Core.Program! program) -> void
Reko.Typing.AddressTraitCollector.Collect(Reko.Core.Expressions.Expression? tvBasePointer, int basePointerBitSize, Reko.Core.Expressions.Expression! eField, Reko.Core.Expressions.Expression! effectiveAddress) -> void
Reko.Typing.AddressTraitCollector.CollectArray(Reko.Core.Expressions.Expression? tvBasePointer, Reko.Core.Expressions.Expression! tvField, Reko.Core.Expressions.Expression! arrayBase, int elementSize, int length) -> void
Reko.Typing.AddressTraitCollector.EmitAccessTrait(Reko.Core.Expressions.Expression? baseExpr, Reko.Core.Expressions.Expression! memPtr, int ptrBitSize, int offset) -> void
Reko.Typing.AddressTraitCollector.GetInductionVariable(Reko.Core.Expressions.Expression! e) -> Reko.Core.LinearInductionVariable?
Reko.Typing.AddressTraitCollector.VisitAddress(Reko.Core.Address! addr) -> void
Reko.Typing.AddressTraitCollector.VisitApplication(Reko.Core.Expressions.Application! appl) -> void
Reko.Typing.AddressTraitCollector.VisitArrayAccess(Reko.Core.Expressions.ArrayAccess! access) -> void
Reko.Typing.AddressTraitCollector.VisitBinaryExpression(Reko.Core.Expressions.BinaryExpression! bin) -> void
Reko.Typing.AddressTraitCollector.VisitBinaryExpression(Reko.Core.Operators.Operator! op, Reko.Core.Types.DataType! dataType, Reko.Core.Expressions.Expression! left, Reko.Core.Expressions.Expression! right) -> void
Reko.Typing.AddressTraitCollector.VisitCast(Reko.Core.Expressions.Cast! cast) -> void
Reko.Typing.AddressTraitCollector.VisitConditionalExpression(Reko.Core.Expressions.ConditionalExpression! c) -> void
Reko.Typing.AddressTraitCollector.VisitConditionOf(Reko.Core.Expressions.ConditionOf! cond) -> void
Reko.Typing.AddressTraitCollector.VisitConstant(Reko.Core.Expressions.Constant! c) -> void
Reko.Typing.AddressTraitCollector.VisitConversion(Reko.Core.Expressions.Conversion! conversion) -> void
Reko.Typing.AddressTraitCollector.VisitDereference(Reko.Core.Expressions.Dereference! deref) -> void
Reko.Typing.AddressTraitCollector.VisitFieldAccess(Reko.Core.Expressions.FieldAccess! access) -> void
Reko.Typing.AddressTraitCollector.VisitIdentifier(Reko.Core.Expressions.Identifier! id) -> void
Reko.Typing.AddressTraitCollector.VisitInductionVariable(Reko.Core.Expressions.Identifier! id, Reko.Core.LinearInductionVariable! iv, Reko.Core.Expressions.Constant? cOffset) -> void
Reko.Typing.AddressTraitCollector.VisitMemberPointerSelector(Reko.Core.Expressions.MemberPointerSelector! mps) -> void
Reko.Typing.AddressTraitCollector.VisitMemoryAccess(Reko.Core.Expressions.MemoryAccess! access) -> void
Reko.Typing.AddressTraitCollector.VisitMkSequence(Reko.Core.Expressions.MkSequence! seq) -> void
Reko.Typing.AddressTraitCollector.VisitOutArgument(Reko.Core.Expressions.OutArgument! outArg) -> void
Reko.Typing.AddressTraitCollector.VisitPhiFunction(Reko.Core.Expressions.PhiFunction! phi) -> void
Reko.Typing.AddressTraitCollector.VisitPointerAddition(Reko.Core.Expressions.PointerAddition! padd) -> void
Reko.Typing.AddressTraitCollector.VisitProcedureConstant(Reko.Core.Expressions.ProcedureConstant! pc) -> void
Reko.Typing.AddressTraitCollector.VisitScopeResolution(Reko.Core.Expressions.ScopeResolution! scope) -> void
Reko.Typing.AddressTraitCollector.VisitSegmentedAccess(Reko.Core.Expressions.SegmentedAccess! access) -> void
Reko.Typing.AddressTraitCollector.VisitSlice(Reko.Core.Expressions.Slice! slice) -> void
Reko.Typing.AddressTraitCollector.VisitTestCondition(Reko.Core.Expressions.TestCondition! test) -> void
Reko.Typing.AddressTraitCollector.VisitUnaryExpression(Reko.Core.Expressions.UnaryExpression! unary) -> void
Reko.Typing.ArrayExpressionMatcher
Reko.Typing.ArrayExpressionMatcher.ArrayExpressionMatcher(Reko.Core.Types.PrimitiveType! dtPointer) -> void
Reko.Typing.ArrayExpressionMatcher.ArrayPointer.get -> Reko.Core.Expressions.Expression?
Reko.Typing.ArrayExpressionMatcher.ArrayPointer.set -> void
Reko.Typing.ArrayExpressionMatcher.ElementSize.get -> Reko.Core.Expressions.Constant?
Reko.Typing.ArrayExpressionMatcher.Index.get -> Reko.Core.Expressions.Expression?
Reko.Typing.ArrayExpressionMatcher.Index.set -> void
Reko.Typing.ArrayExpressionMatcher.Match(Reko.Core.Expressions.Expression! e) -> bool
Reko.Typing.ArrayExpressionMatcher.MatchMul(Reko.Core.Expressions.BinaryExpression! b) -> bool
Reko.Typing.ArrayExpressionMatcher.Transform(Reko.Core.Expressions.Expression? baseptr, Reko.Core.Types.DataType! dtAccess) -> Reko.Core.Expressions.Expression!
Reko.Typing.ComplexExpressionBuilder
Reko.Typing.ComplexExpressionBuilder.BuildComplex(bool dereferenced) -> Reko.Core.Expressions.Expression!
Reko.Typing.ComplexExpressionBuilder.ComplexExpressionBuilder(Reko.Core.Program! program, Reko.Core.Expressions.Expression? basePtr, Reko.Core.Expressions.Expression! complex, Reko.Core.Expressions.Expression? index, int offset) -> void
Reko.Typing.ComplexExpressionBuilder.VisitArray(Reko.Core.Types.ArrayType! at) -> Reko.Core.Expressions.Expression!
Reko.Typing.ComplexExpressionBuilder.VisitClass(Reko.Core.Types.ClassType! ct) -> Reko.Core.Expressions.Expression!
Reko.Typing.ComplexExpressionBuilder.VisitCode(Reko.Core.Types.CodeType! c) -> Reko.Core.Expressions.Expression!
Reko.Typing.ComplexExpressionBuilder.VisitEnum(Reko.Core.Types.EnumType! e) -> Reko.Core.Expressions.Expression!
Reko.Typing.ComplexExpressionBuilder.VisitEquivalenceClass(Reko.Core.Types.EquivalenceClass! eq) -> Reko.Core.Expressions.Expression!
Reko.Typing.ComplexExpressionBuilder.VisitFunctionType(Reko.Core.Types.FunctionType! ft) -> Reko.Core.Expressions.Expression!
Reko.Typing.ComplexExpressionBuilder.VisitMemberPointer(Reko.Core.Types.MemberPointer! memptr) -> Reko.Core.Expressions.Expression!
Reko.Typing.ComplexExpressionBuilder.VisitPointer(Reko.Core.Types.Pointer! ptr) -> Reko.Core.Expressions.Expression!
Reko.Typing.ComplexExpressionBuilder.VisitPrimitive(Reko.Core.Types.PrimitiveType! pt) -> Reko.Core.Expressions.Expression!
Reko.Typing.ComplexExpressionBuilder.VisitReference(Reko.Core.Types.ReferenceTo! refTo) -> Reko.Core.Expressions.Expression!
Reko.Typing.ComplexExpressionBuilder.VisitString(Reko.Core.Types.StringType! str) -> Reko.Core.Expressions.Expression!
Reko.Typing.ComplexExpressionBuilder.VisitStructure(Reko.Core.Types.StructureType! str) -> Reko.Core.Expressions.Expression!
Reko.Typing.ComplexExpressionBuilder.VisitTypeReference(Reko.Core.Types.TypeReference! typeref) -> Reko.Core.Expressions.Expression!
Reko.Typing.ComplexExpressionBuilder.VisitTypeVariable(Reko.Core.Types.TypeVariable! tv) -> Reko.Core.Expressions.Expression!
Reko.Typing.ComplexExpressionBuilder.VisitUnion(Reko.Core.Types.UnionType! ut) -> Reko.Core.Expressions.Expression!
Reko.Typing.ComplexExpressionBuilder.VisitUnknownType(Reko.Core.Types.UnknownType! ut) -> Reko.Core.Expressions.Expression!
Reko.Typing.ComplexExpressionBuilder.VisitVoidType(Reko.Core.Types.VoidType! voidType) -> Reko.Core.Expressions.Expression!
Reko.Typing.ComplexTypeNamer
Reko.Typing.ComplexTypeNamer.ComplexTypeNamer() -> void
Reko.Typing.ComplexTypeNamer.RenameAllTypes(Reko.Core.Types.TypeStore! store) -> void
Reko.Typing.ComplexTypeNamer.VisitArray(Reko.Core.Types.ArrayType! at) -> Reko.Core.Types.DataType!
Reko.Typing.ComplexTypeNamer.VisitClass(Reko.Core.Types.ClassType! ct) -> Reko.Core.Types.DataType!
Reko.Typing.ComplexTypeNamer.VisitCode(Reko.Core.Types.CodeType! c) -> Reko.Core.Types.DataType!
Reko.Typing.ComplexTypeNamer.VisitEnum(Reko.Core.Types.EnumType! e) -> Reko.Core.Types.DataType!
Reko.Typing.ComplexTypeNamer.VisitEquivalenceClass(Reko.Core.Types.EquivalenceClass! eq) -> Reko.Core.Types.DataType!
Reko.Typing.ComplexTypeNamer.VisitFunctionType(Reko.Core.Types.FunctionType! ft) -> Reko.Core.Types.DataType!
Reko.Typing.ComplexTypeNamer.VisitMemberPointer(Reko.Core.Types.MemberPointer! memptr) -> Reko.Core.Types.DataType!
Reko.Typing.ComplexTypeNamer.VisitPointer(Reko.Core.Types.Pointer! ptr) -> Reko.Core.Types.DataType!
Reko.Typing.ComplexTypeNamer.VisitPrimitive(Reko.Core.Types.PrimitiveType! pt) -> Reko.Core.Types.DataType!
Reko.Typing.ComplexTypeNamer.VisitReference(Reko.Core.Types.ReferenceTo! refTo) -> Reko.Core.Types.DataType!
Reko.Typing.ComplexTypeNamer.VisitString(Reko.Core.Types.StringType! str) -> Reko.Core.Types.DataType!
Reko.Typing.ComplexTypeNamer.VisitStructure(Reko.Core.Types.StructureType! str) -> Reko.Core.Types.DataType!
Reko.Typing.ComplexTypeNamer.VisitTypeReference(Reko.Core.Types.TypeReference! typeref) -> Reko.Core.Types.DataType!
Reko.Typing.ComplexTypeNamer.VisitTypeVariable(Reko.Core.Types.TypeVariable! tv) -> Reko.Core.Types.DataType!
Reko.Typing.ComplexTypeNamer.VisitUnion(Reko.Core.Types.UnionType! ut) -> Reko.Core.Types.DataType!
Reko.Typing.ComplexTypeNamer.VisitUnknownType(Reko.Core.Types.UnknownType! ut) -> Reko.Core.Types.DataType!
Reko.Typing.ComplexTypeNamer.VisitVoidType(Reko.Core.Types.VoidType! vt) -> Reko.Core.Types.DataType!
Reko.Typing.ConstantPointerAnalysis
Reko.Typing.ConstantPointerAnalysis.ConstantPointerAnalysis(Reko.Core.Types.TypeFactory! factory, Reko.Core.Types.TypeStore! store, Reko.Core.Program! program) -> void
Reko.Typing.ConstantPointerAnalysis.CreatePointerToField(int offset, Reko.Core.Types.DataType! tvField) -> Reko.Core.Types.Pointer!
Reko.Typing.ConstantPointerAnalysis.FollowConstantPointers() -> void
Reko.Typing.ConstantPointerAnalysis.Globals.get -> Reko.Core.Expressions.Identifier!
Reko.Typing.ConstantPointerAnalysis.Globals.set -> void
Reko.Typing.ConstantPointerAnalysis.IsInsideArray(Reko.Core.Types.StructureType! strGlobals, int offset, Reko.Core.Types.DataType! dt) -> bool
Reko.Typing.ConstantPointerAnalysis.IsInsideStruct(Reko.Core.Types.StructureType! strGlobals, int offset) -> bool
Reko.Typing.ConstantPointerAnalysis.ResolveAs<T>(Reko.Core.Types.DataType! dt) -> T?
Reko.Typing.ConstantPointerTraversal
Reko.Typing.ConstantPointerTraversal.ConstantPointerTraversal(Reko.Core.IProcessorArchitecture! arch, Reko.Core.Types.StructureType! globalStr, Reko.Core.SegmentMap! segmentMap) -> void
Reko.Typing.ConstantPointerTraversal.ConstantPointerTraversal(Reko.Core.Program! program) -> void
Reko.Typing.ConstantPointerTraversal.Discoveries.get -> System.Collections.Generic.List<Reko.Core.Types.StructureField!>!
Reko.Typing.ConstantPointerTraversal.Traverse() -> void
Reko.Typing.ConstantPointerTraversal.VisitArray(Reko.Core.Types.ArrayType! at) -> System.Collections.Generic.IEnumerable<Reko.Typing.ConstantPointerTraversal.WorkItem>!
Reko.Typing.ConstantPointerTraversal.VisitClass(Reko.Core.Types.ClassType! ct) -> System.Collections.Generic.IEnumerable<Reko.Typing.ConstantPointerTraversal.WorkItem>!
Reko.Typing.ConstantPointerTraversal.VisitCode(Reko.Core.Types.CodeType! c) -> System.Collections.Generic.IEnumerable<Reko.Typing.ConstantPointerTraversal.WorkItem>!
Reko.Typing.ConstantPointerTraversal.VisitEnum(Reko.Core.Types.EnumType! e) -> System.Collections.Generic.IEnumerable<Reko.Typing.ConstantPointerTraversal.WorkItem>?
Reko.Typing.ConstantPointerTraversal.VisitEquivalenceClass(Reko.Core.Types.EquivalenceClass! eq) -> System.Collections.Generic.IEnumerable<Reko.Typing.ConstantPointerTraversal.WorkItem>?
Reko.Typing.ConstantPointerTraversal.VisitFunctionType(Reko.Core.Types.FunctionType! ft) -> System.Collections.Generic.IEnumerable<Reko.Typing.ConstantPointerTraversal.WorkItem>!
Reko.Typing.ConstantPointerTraversal.VisitMemberPointer(Reko.Core.Types.MemberPointer! memptr) -> System.Collections.Generic.IEnumerable<Reko.Typing.ConstantPointerTraversal.WorkItem>!
Reko.Typing.ConstantPointerTraversal.VisitPointer(Reko.Core.Types.Pointer! ptr) -> System.Collections.Generic.IEnumerable<Reko.Typing.ConstantPointerTraversal.WorkItem>?
Reko.Typing.ConstantPointerTraversal.VisitPrimitive(Reko.Core.Types.PrimitiveType! pt) -> System.Collections.Generic.IEnumerable<Reko.Typing.ConstantPointerTraversal.WorkItem>?
Reko.Typing.ConstantPointerTraversal.VisitReference(Reko.Core.Types.ReferenceTo! refTo) -> System.Collections.Generic.IEnumerable<Reko.Typing.ConstantPointerTraversal.WorkItem>!
Reko.Typing.ConstantPointerTraversal.VisitString(Reko.Core.Types.StringType! str) -> System.Collections.Generic.IEnumerable<Reko.Typing.ConstantPointerTraversal.WorkItem>!
Reko.Typing.ConstantPointerTraversal.VisitStructure(Reko.Core.Types.StructureType! str) -> System.Collections.Generic.IEnumerable<Reko.Typing.ConstantPointerTraversal.WorkItem>!
Reko.Typing.ConstantPointerTraversal.VisitTypeReference(Reko.Core.Types.TypeReference! typeref) -> System.Collections.Generic.IEnumerable<Reko.Typing.ConstantPointerTraversal.WorkItem>!
Reko.Typing.ConstantPointerTraversal.VisitTypeVariable(Reko.Core.Types.TypeVariable! tv) -> System.Collections.Generic.IEnumerable<Reko.Typing.ConstantPointerTraversal.WorkItem>!
Reko.Typing.ConstantPointerTraversal.VisitUnion(Reko.Core.Types.UnionType! ut) -> System.Collections.Generic.IEnumerable<Reko.Typing.ConstantPointerTraversal.WorkItem>!
Reko.Typing.ConstantPointerTraversal.VisitUnknownType(Reko.Core.Types.UnknownType! ut) -> System.Collections.Generic.IEnumerable<Reko.Typing.ConstantPointerTraversal.WorkItem>!
Reko.Typing.ConstantPointerTraversal.VisitVoidType(Reko.Core.Types.VoidType! voidType) -> System.Collections.Generic.IEnumerable<Reko.Typing.ConstantPointerTraversal.WorkItem>!
Reko.Typing.ConstantPointerTraversal.WorkItem
Reko.Typing.ConstantPointerTraversal.WorkItem.DataType -> Reko.Core.Types.DataType!
Reko.Typing.ConstantPointerTraversal.WorkItem.GlobalOffset -> int
Reko.Typing.ConstantPointerTraversal.WorkItem.WorkItem() -> void
Reko.Typing.DataTypeBuilder
Reko.Typing.DataTypeBuilder.ArrayTrait(Reko.Core.Types.TypeVariable! tArray, int elementSize, int length) -> void
Reko.Typing.DataTypeBuilder.BuildEquivalenceClassDataTypes() -> void
Reko.Typing.DataTypeBuilder.DataTypeBuilder(Reko.Core.Types.TypeFactory! factory, Reko.Core.Types.ITypeStore! store, Reko.Core.IPlatform! platform) -> void
Reko.Typing.DataTypeBuilder.DataTypeTrait(Reko.Core.Expressions.Expression! exp, Reko.Core.Types.DataType? dt) -> Reko.Core.Types.DataType!
Reko.Typing.DataTypeBuilder.DataTypeTrait(Reko.Core.Types.TypeVariable! type, Reko.Core.Types.DataType! dt) -> void
Reko.Typing.DataTypeBuilder.EqualTrait(Reko.Core.Expressions.Expression! tv1, Reko.Core.Expressions.Expression! tv2) -> Reko.Core.Types.DataType!
Reko.Typing.DataTypeBuilder.FunctionTrait(Reko.Core.Expressions.Expression! function, int funcPtrSize, Reko.Core.Types.TypeVariable! ret, params Reko.Core.Types.TypeVariable![]! actuals) -> Reko.Core.Types.DataType!
Reko.Typing.DataTypeBuilder.MemAccessArrayTrait(Reko.Core.Expressions.Expression? expBase, Reko.Core.Expressions.Expression! expStruct, int structPtrBitSize, int offset, int elementSize, int length, Reko.Core.Expressions.Expression! expField) -> Reko.Core.Types.DataType!
Reko.Typing.DataTypeBuilder.MemAccessTrait(Reko.Core.Expressions.Expression? tBase, Reko.Core.Expressions.Expression! tStruct, int structPtrBitSize, Reko.Core.Expressions.Expression! tField, int offset) -> Reko.Core.Types.DataType!
Reko.Typing.DataTypeBuilder.MemFieldTrait(Reko.Core.Expressions.Expression? tBase, Reko.Core.Expressions.Expression! tStruct, Reko.Core.Expressions.Expression! tField, int offset) -> Reko.Core.Types.DataType!
Reko.Typing.DataTypeBuilder.MemoryAccessCommon(Reko.Core.Expressions.Expression? tBase, Reko.Core.Expressions.Expression! tStruct, int offset, Reko.Core.Types.DataType! tField, int structPtrBitSize) -> Reko.Core.Types.DataType!
Reko.Typing.DataTypeBuilder.MemSizeTrait(Reko.Core.Expressions.Expression? tBase, Reko.Core.Expressions.Expression! tStruct, int size) -> Reko.Core.Types.DataType!
Reko.Typing.DataTypeBuilder.MergeIntoDataType(Reko.Core.Expressions.Expression! exp, Reko.Core.Types.DataType? dtNew) -> Reko.Core.Types.DataType!
Reko.Typing.DataTypeBuilder.MergeIntoDataType(Reko.Core.Types.DataType! dtNew, Reko.Core.Types.TypeVariable! tv) -> Reko.Core.Types.DataType!
Reko.Typing.DataTypeBuilder.PointerTrait(Reko.Core.Expressions.Expression! ptrExp, int ptrSize, Reko.Core.Expressions.Expression! tPointee) -> Reko.Core.Types.DataType!
Reko.Typing.EquivalenceClassBuilder
Reko.Typing.EquivalenceClassBuilder.Build(Reko.Core.Program! program) -> void
Reko.Typing.EquivalenceClassBuilder.EnsureSegmentTypeVariables(System.Collections.Generic.IEnumerable<Reko.Core.ImageSegment!>! segments) -> void
Reko.Typing.EquivalenceClassBuilder.EnsureSignatureTypeVariables(Reko.Core.Types.FunctionType! signature) -> void
Reko.Typing.EquivalenceClassBuilder.EnsureTypeVariable(Reko.Core.Expressions.Expression! e) -> Reko.Core.Types.TypeVariable!
Reko.Typing.EquivalenceClassBuilder.EquivalenceClassBuilder(Reko.Core.Types.TypeFactory! factory, Reko.Core.Types.TypeStore! store, Reko.Core.Services.DecompilerEventListener! listener) -> void
Reko.Typing.EquivalenceClassBuilder.VisitProcedure(Reko.Core.ProcedureBase! proc) -> void
Reko.Typing.ExpressionNormalizer
Reko.Typing.ExpressionNormalizer.ExpressionNormalizer(Reko.Core.Types.PrimitiveType! pointerType) -> void
Reko.Typing.ExpressionNormalizer.Transform(Reko.Core.Program! program) -> void
Reko.Typing.ExpressionTypeAscender
Reko.Typing.ExpressionTypeAscender.ExpressionTypeAscender(Reko.Core.Program! program, Reko.Core.Types.TypeStore! store, Reko.Core.Types.TypeFactory! factory) -> void
Reko.Typing.ExpressionTypeDescender
Reko.Typing.ExpressionTypeDescender.ExpressionTypeDescender(Reko.Core.Program! program, Reko.Core.Types.TypeStore! store, Reko.Core.Types.TypeFactory! factory) -> void
Reko.Typing.ExpressionTypeDescender.FunctionTrait(Reko.Core.Expressions.Expression! function, int funcPtrBitSize, Reko.Core.Types.TypeVariable! ret, params Reko.Core.Types.TypeVariable![]! actuals) -> void
Reko.Typing.ExpressionTypeDescender.GetInductionVariable(Reko.Core.Expressions.Expression! e) -> Reko.Core.LinearInductionVariable?
Reko.Typing.ExpressionTypeDescender.MeetDataType(Reko.Core.Expressions.Expression! exp, Reko.Core.Types.DataType! dt) -> Reko.Core.Types.DataType!
Reko.Typing.ExpressionTypeDescender.MeetDataType(Reko.Core.Types.TypeVariable! tvExp, Reko.Core.Types.DataType! dt) -> Reko.Core.Types.DataType!
Reko.Typing.ExpressionTypeDescender.SetSize(Reko.Core.Expressions.Expression! eBase, Reko.Core.Expressions.Expression! tStruct, int size) -> Reko.Core.Types.DataType!
Reko.Typing.ExpressionTypeDescender.StructField(Reko.Core.Expressions.Expression? eBase, Reko.Core.Expressions.Expression! eStructPtr, int offset, Reko.Core.Types.DataType! dtField, int structPtrBitSize) -> Reko.Core.Types.DataType!
Reko.Typing.ExpressionTypeDescender.VisitAddress(Reko.Core.Address! addr, Reko.Core.Types.TypeVariable! tv) -> bool
Reko.Typing.ExpressionTypeDescender.VisitApplication(Reko.Core.Expressions.Application! appl, Reko.Core.Types.TypeVariable! tv) -> bool
Reko.Typing.ExpressionTypeDescender.VisitArrayAccess(Reko.Core.Expressions.ArrayAccess! acc, Reko.Core.Types.TypeVariable! tv) -> bool
Reko.Typing.ExpressionTypeDescender.VisitBinaryExpression(Reko.Core.Expressions.BinaryExpression! binExp, Reko.Core.Types.TypeVariable! tv) -> bool
Reko.Typing.ExpressionTypeDescender.VisitCast(Reko.Core.Expressions.Cast! cast, Reko.Core.Types.TypeVariable? tv) -> bool
Reko.Typing.ExpressionTypeDescender.VisitConditionalExpression(Reko.Core.Expressions.ConditionalExpression! c, Reko.Core.Types.TypeVariable! tv) -> bool
Reko.Typing.ExpressionTypeDescender.VisitConditionOf(Reko.Core.Expressions.ConditionOf! cof, Reko.Core.Types.TypeVariable! tv) -> bool
Reko.Typing.ExpressionTypeDescender.VisitConstant(Reko.Core.Expressions.Constant! c, Reko.Core.Types.TypeVariable! tv) -> bool
Reko.Typing.ExpressionTypeDescender.VisitConversion(Reko.Core.Expressions.Conversion! conversion, Reko.Core.Types.TypeVariable! tv) -> bool
Reko.Typing.ExpressionTypeDescender.VisitDereference(Reko.Core.Expressions.Dereference! deref, Reko.Core.Types.TypeVariable! tv) -> bool
Reko.Typing.ExpressionTypeDescender.VisitFieldAccess(Reko.Core.Expressions.FieldAccess! acc, Reko.Core.Types.TypeVariable! tv) -> bool
Reko.Typing.ExpressionTypeDescender.VisitIdentifier(Reko.Core.Expressions.Identifier! id, Reko.Core.Types.TypeVariable! tv) -> bool
Reko.Typing.ExpressionTypeDescender.VisitInductionVariable(Reko.Core.Expressions.Expression! eBase, Reko.Core.Expressions.Identifier! id, Reko.Core.LinearInductionVariable! iv, int offset, Reko.Core.Types.TypeVariable! tvField) -> void
Reko.Typing.ExpressionTypeDescender.VisitMemberPointerSelector(Reko.Core.Expressions.MemberPointerSelector! mps, Reko.Core.Types.TypeVariable! tv) -> bool
Reko.Typing.ExpressionTypeDescender.VisitMemoryAccess(Reko.Core.Expressions.MemoryAccess! access, Reko.Core.Types.TypeVariable! tv) -> bool
Reko.Typing.ExpressionTypeDescender.VisitMkSequence(Reko.Core.Expressions.MkSequence! seq, Reko.Core.Types.TypeVariable! tv) -> bool
Reko.Typing.ExpressionTypeDescender.VisitOutArgument(Reko.Core.Expressions.OutArgument! outArgument, Reko.Core.Types.TypeVariable! tv) -> bool
Reko.Typing.ExpressionTypeDescender.VisitPhiFunction(Reko.Core.Expressions.PhiFunction! phi, Reko.Core.Types.TypeVariable! tv) -> bool
Reko.Typing.ExpressionTypeDescender.VisitPointerAddition(Reko.Core.Expressions.PointerAddition! pa, Reko.Core.Types.TypeVariable! tv) -> bool
Reko.Typing.ExpressionTypeDescender.VisitProcedureConstant(Reko.Core.Expressions.ProcedureConstant! pc, Reko.Core.Types.TypeVariable! tv) -> bool
Reko.Typing.ExpressionTypeDescender.VisitScopeResolution(Reko.Core.Expressions.ScopeResolution! scopeResolution, Reko.Core.Types.TypeVariable! tv) -> bool
Reko.Typing.ExpressionTypeDescender.VisitSegmentedAccess(Reko.Core.Expressions.SegmentedAccess! access, Reko.Core.Types.TypeVariable! tv) -> bool
Reko.Typing.ExpressionTypeDescender.VisitSlice(Reko.Core.Expressions.Slice! slice, Reko.Core.Types.TypeVariable! tv) -> bool
Reko.Typing.ExpressionTypeDescender.VisitTestCondition(Reko.Core.Expressions.TestCondition! tc, Reko.Core.Types.TypeVariable! tv) -> bool
Reko.Typing.ExpressionTypeDescender.VisitUnaryExpression(Reko.Core.Expressions.UnaryExpression! unary, Reko.Core.Types.TypeVariable! tv) -> bool
Reko.Typing.InductionVariableCollector
Reko.Typing.InductionVariableCollector.InductionVariableCollector(Reko.Core.Program! program) -> void
Reko.Typing.InductionVariableCollector.MergeInductionVariableConstant(Reko.Core.LinearInductionVariable? iv, Reko.Core.Operators.Operator! op, Reko.Core.Expressions.Constant? c) -> Reko.Core.LinearInductionVariable?
Reko.Typing.ITraitHandler
Reko.Typing.ITraitHandler.ArrayTrait(Reko.Core.Types.TypeVariable! tArray, int elementSize, int length) -> void
Reko.Typing.ITraitHandler.BuildEquivalenceClassDataTypes() -> void
Reko.Typing.ITraitHandler.DataTypeTrait(Reko.Core.Expressions.Expression! exp, Reko.Core.Types.DataType? dataType) -> Reko.Core.Types.DataType!
Reko.Typing.ITraitHandler.EqualTrait(Reko.Core.Expressions.Expression! exp1, Reko.Core.Expressions.Expression! exp2) -> Reko.Core.Types.DataType!
Reko.Typing.ITraitHandler.FunctionTrait(Reko.Core.Expressions.Expression! function, int funcPtrSize, Reko.Core.Types.TypeVariable! ret, params Reko.Core.Types.TypeVariable![]! actuals) -> Reko.Core.Types.DataType!
Reko.Typing.ITraitHandler.MemAccessArrayTrait(Reko.Core.Expressions.Expression? tBase, Reko.Core.Expressions.Expression! tStruct, int structPtrSize, int offset, int elementSize, int length, Reko.Core.Expressions.Expression! tField) -> Reko.Core.Types.DataType!
Reko.Typing.ITraitHandler.MemAccessTrait(Reko.Core.Expressions.Expression? eBase, Reko.Core.Expressions.Expression! eStruct, int structPtrBitSize, Reko.Core.Expressions.Expression! eField, int offset) -> Reko.Core.Types.DataType!
Reko.Typing.ITraitHandler.MemFieldTrait(Reko.Core.Expressions.Expression? eBase, Reko.Core.Expressions.Expression! eStruct, Reko.Core.Expressions.Expression! eField, int offset) -> Reko.Core.Types.DataType!
Reko.Typing.ITraitHandler.MemSizeTrait(Reko.Core.Expressions.Expression? tBase, Reko.Core.Expressions.Expression! tStruct, int size) -> Reko.Core.Types.DataType!
Reko.Typing.ITraitHandler.PointerTrait(Reko.Core.Expressions.Expression! tPointer, int ptrSize, Reko.Core.Expressions.Expression! tPointee) -> Reko.Core.Types.DataType!
Reko.Typing.NestedComplexTypeExtractor
Reko.Typing.NestedComplexTypeExtractor.Changed.get -> bool
Reko.Typing.NestedComplexTypeExtractor.CreateEquivalenceClass(Reko.Core.Types.DataType! dt) -> Reko.Core.Types.EquivalenceClass!
Reko.Typing.NestedComplexTypeExtractor.NestedComplexTypeExtractor(Reko.Core.Types.TypeFactory! factory, Reko.Core.Types.TypeStore! store) -> void
Reko.Typing.PtrPrimitiveReplacer
Reko.Typing.PtrPrimitiveReplacer.PtrPrimitiveReplacer(Reko.Core.Types.TypeFactory! factory, Reko.Core.Types.TypeStore! store, Reko.Core.Program! program, Reko.Core.Services.DecompilerEventListener! eventListener) -> void
Reko.Typing.PtrPrimitiveReplacer.Replace(Reko.Core.Types.DataType? dt) -> Reko.Core.Types.DataType?
Reko.Typing.PtrPrimitiveReplacer.ReplaceAll() -> bool
Reko.Typing.StructureFieldMerger
Reko.Typing.StructureFieldMerger.BuildOverlappedStructure(System.Collections.Generic.List<Reko.Core.Types.StructureField!>! fields) -> Reko.Core.Types.DataType!
Reko.Typing.StructureFieldMerger.GetOverlappingClusters(Reko.Core.Types.StructureFieldCollection! fields) -> System.Collections.Generic.IEnumerable<System.Collections.Generic.List<Reko.Core.Types.StructureField!>!>!
Reko.Typing.StructureFieldMerger.Merge() -> Reko.Core.Types.StructureType!
Reko.Typing.StructureFieldMerger.StructureFieldMerger(Reko.Core.Types.StructureType! str) -> void
Reko.Typing.StructureMerger
Reko.Typing.StructureMerger.Merge() -> void
Reko.Typing.StructureMerger.MergedClass.get -> Reko.Core.Types.EquivalenceClass!
Reko.Typing.StructureMerger.StructureMerger(System.Collections.Generic.ICollection<Reko.Core.Types.StructureType!>! structures, System.Collections.Generic.ICollection<Reko.Core.Types.EquivalenceClass!>! eqClasses) -> void
Reko.Typing.TraitCollector
Reko.Typing.TraitCollector.CollectEffectiveAddress(Reko.Core.Expressions.Expression! basePtr, int basePtrBitSize, Reko.Core.Expressions.Expression! field, Reko.Core.Expressions.Expression! effectiveAddress) -> void
Reko.Typing.TraitCollector.CollectEffectiveAddress(Reko.Core.Expressions.Expression! field, Reko.Core.Expressions.Expression! effectiveAddress) -> void
Reko.Typing.TraitCollector.CollectProgramTraits(Reko.Core.Program! program) -> void
Reko.Typing.TraitCollector.DomainOf(Reko.Core.Types.DataType! t) -> Reko.Core.Types.Domain
Reko.Typing.TraitCollector.MakeNotSigned(Reko.Core.Types.DataType! t) -> Reko.Core.Types.PrimitiveType?
Reko.Typing.TraitCollector.MakeSigned(Reko.Core.Types.DataType! t) -> Reko.Core.Types.PrimitiveType?
Reko.Typing.TraitCollector.MakeUnsigned(Reko.Core.Types.DataType! t) -> Reko.Core.Types.PrimitiveType?
Reko.Typing.TraitCollector.MergeInductionVariableConstant(Reko.Core.LinearInductionVariable! iv, Reko.Core.Operators.Operator! op, Reko.Core.Expressions.Constant? c) -> Reko.Core.LinearInductionVariable?
Reko.Typing.TraitCollector.TraitCollector(Reko.Core.Types.TypeFactory! factory, Reko.Core.Types.ITypeStore! store, Reko.Typing.ITraitHandler! handler, Reko.Core.Program! program) -> void
Reko.Typing.TraitCollector.VisitAddress(Reko.Core.Address! addr) -> Reko.Core.Types.DataType!
Reko.Typing.TraitCollector.VisitApplication(Reko.Core.Expressions.Application! appl) -> Reko.Core.Types.DataType!
Reko.Typing.TraitCollector.VisitArrayAccess(Reko.Core.Expressions.ArrayAccess! acc) -> Reko.Core.Types.DataType!
Reko.Typing.TraitCollector.VisitAssignment(Reko.Core.Code.Assignment! a) -> Reko.Core.Types.DataType!
Reko.Typing.TraitCollector.VisitBinaryExpression(Reko.Core.Expressions.BinaryExpression! binExp) -> Reko.Core.Types.DataType!
Reko.Typing.TraitCollector.VisitBranch(Reko.Core.Code.Branch! b) -> Reko.Core.Types.DataType?
Reko.Typing.TraitCollector.VisitCallInstruction(Reko.Core.Code.CallInstruction! call) -> Reko.Core.Types.DataType?
Reko.Typing.TraitCollector.VisitCast(Reko.Core.Expressions.Cast! cast) -> Reko.Core.Types.DataType!
Reko.Typing.TraitCollector.VisitComment(Reko.Core.Code.CodeComment! comment) -> Reko.Core.Types.DataType!
Reko.Typing.TraitCollector.VisitConditionalExpression(Reko.Core.Expressions.ConditionalExpression! c) -> Reko.Core.Types.DataType!
Reko.Typing.TraitCollector.VisitConditionOf(Reko.Core.Expressions.ConditionOf! cof) -> Reko.Core.Types.DataType!
Reko.Typing.TraitCollector.VisitConstant(Reko.Core.Expressions.Constant! c) -> Reko.Core.Types.DataType!
Reko.Typing.TraitCollector.VisitConversion(Reko.Core.Expressions.Conversion! conversion) -> Reko.Core.Types.DataType!
Reko.Typing.TraitCollector.VisitDeclaration(Reko.Core.Code.Declaration! decl) -> Reko.Core.Types.DataType?
Reko.Typing.TraitCollector.VisitDefInstruction(Reko.Core.Code.DefInstruction! def) -> Reko.Core.Types.DataType?
Reko.Typing.TraitCollector.VisitDereference(Reko.Core.Expressions.Dereference! deref) -> Reko.Core.Types.DataType!
Reko.Typing.TraitCollector.VisitFieldAccess(Reko.Core.Expressions.FieldAccess! acc) -> Reko.Core.Types.DataType!
Reko.Typing.TraitCollector.VisitGotoInstruction(Reko.Core.Code.GotoInstruction! g) -> Reko.Core.Types.DataType!
Reko.Typing.TraitCollector.VisitIdentifier(Reko.Core.Expressions.Identifier! id) -> Reko.Core.Types.DataType!
Reko.Typing.TraitCollector.VisitMemberPointerSelector(Reko.Core.Expressions.MemberPointerSelector! mps) -> Reko.Core.Types.DataType!
Reko.Typing.TraitCollector.VisitMemoryAccess(Reko.Core.Expressions.MemoryAccess! access) -> Reko.Core.Types.DataType!
Reko.Typing.TraitCollector.VisitMkSequence(Reko.Core.Expressions.MkSequence! seq) -> Reko.Core.Types.DataType?
Reko.Typing.TraitCollector.VisitOutArgument(Reko.Core.Expressions.OutArgument! outArg) -> Reko.Core.Types.DataType!
Reko.Typing.TraitCollector.VisitPhiAssignment(Reko.Core.Code.PhiAssignment! phi) -> Reko.Core.Types.DataType!
Reko.Typing.TraitCollector.VisitPhiFunction(Reko.Core.Expressions.PhiFunction! phi) -> Reko.Core.Types.DataType!
Reko.Typing.TraitCollector.VisitPointerAddition(Reko.Core.Expressions.PointerAddition! pa) -> Reko.Core.Types.DataType!
Reko.Typing.TraitCollector.VisitProcedureConstant(Reko.Core.Expressions.ProcedureConstant! pc) -> Reko.Core.Types.DataType?
Reko.Typing.TraitCollector.VisitReturnInstruction(Reko.Core.Code.ReturnInstruction! ret) -> Reko.Core.Types.DataType?
Reko.Typing.TraitCollector.VisitScopeResolution(Reko.Core.Expressions.ScopeResolution! sr) -> Reko.Core.Types.DataType!
Reko.Typing.TraitCollector.VisitSegmentedAccess(Reko.Core.Expressions.SegmentedAccess! access) -> Reko.Core.Types.DataType!
Reko.Typing.TraitCollector.VisitSideEffect(Reko.Core.Code.SideEffect! sideEffect) -> Reko.Core.Types.DataType!
Reko.Typing.TraitCollector.VisitSlice(Reko.Core.Expressions.Slice! slice) -> Reko.Core.Types.DataType!
Reko.Typing.TraitCollector.VisitStore(Reko.Core.Code.Store! store) -> Reko.Core.Types.DataType!
Reko.Typing.TraitCollector.VisitSwitchInstruction(Reko.Core.Code.SwitchInstruction! si) -> Reko.Core.Types.DataType!
Reko.Typing.TraitCollector.VisitTestCondition(Reko.Core.Expressions.TestCondition! tc) -> Reko.Core.Types.DataType!
Reko.Typing.TraitCollector.VisitUnaryExpression(Reko.Core.Expressions.UnaryExpression! unary) -> Reko.Core.Types.DataType!
Reko.Typing.TraitCollector.VisitUseInstruction(Reko.Core.Code.UseInstruction! u) -> Reko.Core.Types.DataType!
Reko.Typing.TypeAnalyzer
Reko.Typing.TypeAnalyzer.RewriteProgram(Reko.Core.Program! program) -> void
Reko.Typing.TypeAnalyzer.TypeAnalyzer(Reko.Core.Services.DecompilerEventListener! eventListener) -> void
Reko.Typing.TypeAnalyzer.WriteTypes(string! filename, System.IO.TextWriter! output) -> void
Reko.Typing.TypeCollector
Reko.Typing.TypeCollector.CollectGlobalType() -> void
Reko.Typing.TypeCollector.CollectImageSymbols() -> void
Reko.Typing.TypeCollector.CollectTypes() -> void
Reko.Typing.TypeCollector.CollectUserGlobalVariableTypes() -> void
Reko.Typing.TypeCollector.TypeCollector(Reko.Core.Types.TypeFactory! factory, Reko.Core.Types.TypeStore! store, Reko.Core.Program! program, Reko.Core.Services.DecompilerEventListener! eventListener) -> void
Reko.Typing.TypeCollector.VisitAssignment(Reko.Core.Code.Assignment! ass) -> void
Reko.Typing.TypeCollector.VisitBranch(Reko.Core.Code.Branch! branch) -> void
Reko.Typing.TypeCollector.VisitCallInstruction(Reko.Core.Code.CallInstruction! call) -> void
Reko.Typing.TypeCollector.VisitComment(Reko.Core.Code.CodeComment! comment) -> void
Reko.Typing.TypeCollector.VisitDeclaration(Reko.Core.Code.Declaration! decl) -> void
Reko.Typing.TypeCollector.VisitDefInstruction(Reko.Core.Code.DefInstruction! def) -> void
Reko.Typing.TypeCollector.VisitGotoInstruction(Reko.Core.Code.GotoInstruction! g) -> void
Reko.Typing.TypeCollector.VisitPhiAssignment(Reko.Core.Code.PhiAssignment! phi) -> void
Reko.Typing.TypeCollector.VisitReturnInstruction(Reko.Core.Code.ReturnInstruction! ret) -> void
Reko.Typing.TypeCollector.VisitSideEffect(Reko.Core.Code.SideEffect! side) -> void
Reko.Typing.TypeCollector.VisitStore(Reko.Core.Code.Store! store) -> void
Reko.Typing.TypeCollector.VisitSwitchInstruction(Reko.Core.Code.SwitchInstruction! si) -> void
Reko.Typing.TypeCollector.VisitUseInstruction(Reko.Core.Code.UseInstruction! use) -> void
Reko.Typing.TypedConstantRewriter
Reko.Typing.TypedConstantRewriter.Rewrite(Reko.Core.Address! addr, Reko.Core.Expressions.Expression? basePtr, bool dereferenced) -> Reko.Core.Expressions.Expression!
Reko.Typing.TypedConstantRewriter.Rewrite(Reko.Core.Expressions.Constant! c, Reko.Core.Expressions.Expression? basePtr, bool dereferenced) -> Reko.Core.Expressions.Expression!
Reko.Typing.TypedConstantRewriter.TypedConstantRewriter(Reko.Core.Program! program, Reko.Core.Services.DecompilerEventListener! eventListener) -> void
Reko.Typing.TypedConstantRewriter.VisitArray(Reko.Core.Types.ArrayType! at) -> Reko.Core.Expressions.Expression!
Reko.Typing.TypedConstantRewriter.VisitClass(Reko.Core.Types.ClassType! ct) -> Reko.Core.Expressions.Expression!
Reko.Typing.TypedConstantRewriter.VisitCode(Reko.Core.Types.CodeType! c) -> Reko.Core.Expressions.Expression!
Reko.Typing.TypedConstantRewriter.VisitEnum(Reko.Core.Types.EnumType! e) -> Reko.Core.Expressions.Expression!
Reko.Typing.TypedConstantRewriter.VisitEquivalenceClass(Reko.Core.Types.EquivalenceClass! eq) -> Reko.Core.Expressions.Expression!
Reko.Typing.TypedConstantRewriter.VisitFunctionType(Reko.Core.Types.FunctionType! ft) -> Reko.Core.Expressions.Expression!
Reko.Typing.TypedConstantRewriter.VisitMemberPointer(Reko.Core.Types.MemberPointer! memptr) -> Reko.Core.Expressions.Expression!
Reko.Typing.TypedConstantRewriter.VisitPointer(Reko.Core.Types.Pointer! ptr) -> Reko.Core.Expressions.Expression!
Reko.Typing.TypedConstantRewriter.VisitPrimitive(Reko.Core.Types.PrimitiveType! pt) -> Reko.Core.Expressions.Expression!
Reko.Typing.TypedConstantRewriter.VisitReference(Reko.Core.Types.ReferenceTo! refTo) -> Reko.Core.Expressions.Expression!
Reko.Typing.TypedConstantRewriter.VisitString(Reko.Core.Types.StringType! str) -> Reko.Core.Expressions.Expression!
Reko.Typing.TypedConstantRewriter.VisitStructure(Reko.Core.Types.StructureType! str) -> Reko.Core.Expressions.Expression!
Reko.Typing.TypedConstantRewriter.VisitTypeReference(Reko.Core.Types.TypeReference! typeref) -> Reko.Core.Expressions.Expression!
Reko.Typing.TypedConstantRewriter.VisitTypeVariable(Reko.Core.Types.TypeVariable! tv) -> Reko.Core.Expressions.Expression!
Reko.Typing.TypedConstantRewriter.VisitUnion(Reko.Core.Types.UnionType! ut) -> Reko.Core.Expressions.Expression!
Reko.Typing.TypedConstantRewriter.VisitUnknownType(Reko.Core.Types.UnknownType! ut) -> Reko.Core.Expressions.Expression!
Reko.Typing.TypedConstantRewriter.VisitVoidType(Reko.Core.Types.VoidType! vt) -> Reko.Core.Expressions.Expression!
Reko.Typing.TypedExpressionRewriter
Reko.Typing.TypedExpressionRewriter.Rewrite(Reko.Core.Expressions.Expression! expression, bool dereferenced) -> Reko.Core.Expressions.Expression!
Reko.Typing.TypedExpressionRewriter.RewriteComplexExpression(Reko.Core.Expressions.Expression! complex, Reko.Core.Expressions.Expression? index, int offset, bool dereferenced) -> Reko.Core.Expressions.Expression!
Reko.Typing.TypedExpressionRewriter.RewriteProgram(Reko.Core.Program! program) -> void
Reko.Typing.TypedExpressionRewriter.TypedExpressionRewriter(Reko.Core.Program! program, Reko.Core.Services.DecompilerEventListener! eventListener) -> void
Reko.Typing.TypeStoreCycleFinder
Reko.Typing.TypeStoreCycleFinder.Find(Reko.Core.Types.DataType! dt) -> bool
Reko.Typing.TypeStoreCycleFinder.VisitArray(Reko.Core.Types.ArrayType! at) -> bool
Reko.Typing.TypeStoreCycleFinder.VisitClass(Reko.Core.Types.ClassType! ct) -> bool
Reko.Typing.TypeStoreCycleFinder.VisitCode(Reko.Core.Types.CodeType! c) -> bool
Reko.Typing.TypeStoreCycleFinder.VisitEnum(Reko.Core.Types.EnumType! e) -> bool
Reko.Typing.TypeStoreCycleFinder.VisitEquivalenceClass(Reko.Core.Types.EquivalenceClass! eq) -> bool
Reko.Typing.TypeStoreCycleFinder.VisitFunctionType(Reko.Core.Types.FunctionType! ft) -> bool
Reko.Typing.TypeStoreCycleFinder.VisitMemberPointer(Reko.Core.Types.MemberPointer! memptr) -> bool
Reko.Typing.TypeStoreCycleFinder.VisitPointer(Reko.Core.Types.Pointer! ptr) -> bool
Reko.Typing.TypeStoreCycleFinder.VisitPrimitive(Reko.Core.Types.PrimitiveType! pt) -> bool
Reko.Typing.TypeStoreCycleFinder.VisitReference(Reko.Core.Types.ReferenceTo! refTo) -> bool
Reko.Typing.TypeStoreCycleFinder.VisitString(Reko.Core.Types.StringType! str) -> bool
Reko.Typing.TypeStoreCycleFinder.VisitStructure(Reko.Core.Types.StructureType! str) -> bool
Reko.Typing.TypeStoreCycleFinder.VisitTypeReference(Reko.Core.Types.TypeReference! typeref) -> bool
Reko.Typing.TypeStoreCycleFinder.VisitTypeVariable(Reko.Core.Types.TypeVariable! tv) -> bool
Reko.Typing.TypeStoreCycleFinder.VisitUnion(Reko.Core.Types.UnionType! ut) -> bool
Reko.Typing.TypeStoreCycleFinder.VisitUnknownType(Reko.Core.Types.UnknownType! ut) -> bool
Reko.Typing.TypeStoreCycleFinder.VisitVoidType(Reko.Core.Types.VoidType! voidType) -> bool
Reko.Typing.TypeTransformer
Reko.Typing.TypeTransformer.Changed.get -> bool
Reko.Typing.TypeTransformer.Changed.set -> void
Reko.Typing.TypeTransformer.FactorDuplicateAlternatives(Reko.Core.Types.UnionType! u) -> Reko.Core.Types.UnionType!
Reko.Typing.TypeTransformer.HasCoincidentFields(Reko.Core.Types.StructureType! s) -> bool
Reko.Typing.TypeTransformer.MergeOffsetStructures(Reko.Core.Types.StructureType! a, int aOffset, Reko.Core.Types.StructureType! b, int bOffset) -> Reko.Core.Types.StructureType!
Reko.Typing.TypeTransformer.MergeStaggeredArrays(Reko.Core.Types.StructureType! s) -> void
Reko.Typing.TypeTransformer.MergeStructureFields(Reko.Core.Types.StructureType! str) -> Reko.Core.Types.StructureType!
Reko.Typing.TypeTransformer.StructuresOverlap(Reko.Core.Types.StructureType? a, int aOffset, Reko.Core.Types.StructureType? b, int bOffset) -> bool
Reko.Typing.TypeTransformer.Transform() -> void
Reko.Typing.TypeTransformer.TypeTransformer(Reko.Core.Types.TypeFactory! factory, Reko.Core.Types.TypeStore! store, Reko.Core.Program! program) -> void
Reko.Typing.TypeTransformer.TypeTransformer(Reko.Core.Types.TypeFactory! factory, Reko.Core.Types.TypeStore! store, Reko.Core.Program! program, Reko.Core.Services.DecompilerEventListener! eventListener) -> void
Reko.Typing.TypeTransformer.VisitArray(Reko.Core.Types.ArrayType! arr) -> Reko.Core.Types.DataType!
Reko.Typing.TypeTransformer.VisitClass(Reko.Core.Types.ClassType! ct) -> Reko.Core.Types.DataType!
Reko.Typing.TypeTransformer.VisitCode(Reko.Core.Types.CodeType! c) -> Reko.Core.Types.DataType!
Reko.Typing.TypeTransformer.VisitEnum(Reko.Core.Types.EnumType! e) -> Reko.Core.Types.DataType!
Reko.Typing.TypeTransformer.VisitEquivalenceClass(Reko.Core.Types.EquivalenceClass! eq) -> Reko.Core.Types.DataType!
Reko.Typing.TypeTransformer.VisitFunctionType(Reko.Core.Types.FunctionType! fn) -> Reko.Core.Types.DataType!
Reko.Typing.TypeTransformer.VisitMemberPointer(Reko.Core.Types.MemberPointer! mptr) -> Reko.Core.Types.DataType!
Reko.Typing.TypeTransformer.VisitPointer(Reko.Core.Types.Pointer! ptr) -> Reko.Core.Types.DataType!
Reko.Typing.TypeTransformer.VisitPrimitive(Reko.Core.Types.PrimitiveType! pt) -> Reko.Core.Types.DataType!
Reko.Typing.TypeTransformer.VisitReference(Reko.Core.Types.ReferenceTo! refTo) -> Reko.Core.Types.DataType!
Reko.Typing.TypeTransformer.VisitString(Reko.Core.Types.StringType! str) -> Reko.Core.Types.DataType!
Reko.Typing.TypeTransformer.VisitStructure(Reko.Core.Types.StructureType! str) -> Reko.Core.Types.DataType!
Reko.Typing.TypeTransformer.VisitTypeReference(Reko.Core.Types.TypeReference! typeref) -> Reko.Core.Types.DataType!
Reko.Typing.TypeTransformer.VisitTypeVariable(Reko.Core.Types.TypeVariable! tv) -> Reko.Core.Types.DataType!
Reko.Typing.TypeTransformer.VisitUnion(Reko.Core.Types.UnionType! ut) -> Reko.Core.Types.DataType!
Reko.Typing.TypeTransformer.VisitUnknownType(Reko.Core.Types.UnknownType! unk) -> Reko.Core.Types.DataType!
Reko.Typing.TypeTransformer.VisitVoidType(Reko.Core.Types.VoidType! vt) -> Reko.Core.Types.DataType!
Reko.Typing.TypeVariableReplacer
Reko.Typing.TypeVariableReplacer.ReplaceTypeVariables() -> void
Reko.Typing.TypeVariableReplacer.TypeVariableReplacer(Reko.Core.Types.TypeStore! store) -> void
Reko.Typing.UnionPointersStructuresMatcher
Reko.Typing.UnionPointersStructuresMatcher.EquivalenceClasses.get -> System.Collections.Generic.ICollection<Reko.Core.Types.EquivalenceClass!>!
Reko.Typing.UnionPointersStructuresMatcher.Match(Reko.Core.Types.UnionType! ut) -> bool
Reko.Typing.UnionPointersStructuresMatcher.PointerBitSize.get -> int
Reko.Typing.UnionPointersStructuresMatcher.Structures.get -> System.Collections.Generic.ICollection<Reko.Core.Types.StructureType!>!
Reko.Typing.UnionPointersStructuresMatcher.UnionPointersStructuresMatcher() -> void
static readonly Reko.NullDecompiledFileService.Instance -> Reko.IDecompiledFileService!
static readonly Reko.Scanning.ValueSet.Any -> Reko.Scanning.ValueSet!
static Reko.Analysis.AdjacentBranchCollector.Transform(Reko.Core.Program! program, Reko.Core.Services.DecompilerEventListener! eventListener) -> void
static Reko.Analysis.CallRewriter.Rewrite(Reko.Core.IPlatform! platform, System.Collections.Generic.List<Reko.Analysis.SsaTransform!>! ssts, Reko.Analysis.ProgramDataFlow! summaries, Reko.Core.Services.DecompilerEventListener! eventListener) -> void
static Reko.Analysis.ConstDivisionImplementedByMultiplication.FindBestRational(uint factor) -> Reko.Core.Lib.Rational
static Reko.Analysis.DataFlow.EmitRegisters(Reko.Core.IProcessorArchitecture! arch, string! caption, System.Collections.Generic.Dictionary<Reko.Core.RegisterStorage!, uint>! grfFlags, System.Collections.Generic.IDictionary<Reko.Core.Storage!, Reko.Core.BitRange>! regRanges, System.IO.TextWriter! sb) -> void
static Reko.Analysis.DataFlow.EmitRegisters(Reko.Core.IProcessorArchitecture! arch, string! caption, System.Collections.Generic.Dictionary<Reko.Core.RegisterStorage!, uint>! grfFlags, System.Collections.Generic.IEnumerable<Reko.Core.Storage!>! regs, System.IO.TextWriter! sb) -> void
static Reko.Analysis.DataFlow.EmitRegisters(string! caption, System.Collections.Generic.HashSet<Reko.Core.Storage!>! regs, System.IO.TextWriter! sb) -> void
static Reko.Analysis.DataFlow.EmitRegisterValues<TValue>(string! caption, System.Collections.Generic.Dictionary<Reko.Core.Storage!, TValue>! symbols, System.IO.TextWriter! sb) -> void
static Reko.Analysis.DeadCode.Eliminate(Reko.Analysis.SsaState! ssa) -> void
static Reko.Analysis.ExpressionIdentifierUseFinder.Find(Reko.Analysis.SsaIdentifierCollection! ssaIds, Reko.Core.Expressions.Expression! exp) -> System.Collections.Generic.List<Reko.Core.Expressions.Identifier!>!
static Reko.Analysis.IntraBlockDeadRegisters.Apply(Reko.Core.Program! program, Reko.Core.Services.DecompilerEventListener! eventListener) -> void
static Reko.Analysis.ProcedureFlow.IntersectCallBindingsWithUses(System.Collections.Generic.IEnumerable<Reko.Core.Code.CallBinding!>! callBindings, System.Collections.Generic.IDictionary<Reko.Core.Storage!, Reko.Core.BitRange>! uses) -> System.Collections.Generic.IEnumerable<Reko.Core.Code.CallBinding!>!
static Reko.Analysis.SsaTransform.ResolveOverlaps(System.Collections.Generic.IEnumerable<Reko.Core.Expressions.Identifier!>! ids) -> System.Collections.Generic.IEnumerable<Reko.Core.Expressions.Identifier!>!
static Reko.Analysis.UnusedOutValuesRemover.trace -> System.Diagnostics.TraceSwitch!
static Reko.Analysis.WebBuilder.OutDefinitionFinder.Find(System.Collections.Generic.IEnumerable<Reko.Analysis.SsaIdentifier!>! sids) -> bool
static Reko.DecompiledFileService.GenerateDerivedFilename(Reko.Core.Program! program, string! newExtension) -> string!
static Reko.Evaluation.ExpressionSimplifier.IsSequence(Reko.Core.EvaluationContext! ctx, Reko.Core.Expressions.Expression! e, out Reko.Core.Expressions.MkSequence! sequence) -> bool
static Reko.Evaluation.ExpressionSimplifier.SimplifyTwoConstants(Reko.Core.Operators.BinaryOperator! op, Reko.Core.Expressions.Constant! l, Reko.Core.Expressions.Constant! r) -> Reko.Core.Expressions.Constant!
static Reko.Evaluation.ExpressionSimplifier.SimplifyTwoConstants(Reko.Core.Operators.Operator! op, Reko.Core.Expressions.Constant! l, Reko.Core.Expressions.Constant! r) -> Reko.Core.Expressions.Constant!
static Reko.Evaluation.ExpressionSimplifier.SliceSequence(Reko.Core.Expressions.MkSequence! seq, Reko.Core.Types.DataType! dtSlice, int sliceOffset) -> Reko.Core.Expressions.Expression?
static Reko.Loading.Loader.CreateCustomImageLoader(System.IServiceProvider! services, string? loader, Reko.Core.ImageLocation! imageLocation, byte[]! bytes) -> Reko.Core.Loading.ProgramImageLoader!
static Reko.Loading.Loader.CreateImageLoader<T>(System.IServiceProvider! services, string! typeName, Reko.Core.ImageLocation! imageLocation, byte[]! bytes) -> T
static Reko.Loading.Loader.CreateOuterImageLoader<T>(System.IServiceProvider! services, string! typeName, Reko.Core.Loading.ImageLoader! innerLoader) -> T
static Reko.Loading.Loader.GetRawBinaryEntryAddress(Reko.Core.Configuration.RawFileDefinition! rawFile, byte[]! image, Reko.Core.IProcessorArchitecture! arch, Reko.Core.Address! baseAddr) -> Reko.Core.Address?
static Reko.Loading.Loader.HexDigit(char digit) -> uint
~static Reko.Scanning.AhoCorasick.main(string[] args) -> void
~static Reko.Scanning.ArrayEx.Fill<T>(this T[] array, T value) -> void
static Reko.Scanning.BackwardSlicerContext.Cond(Reko.Core.BitRange bitRange) -> Reko.Scanning.BackwardSlicerContext!
static Reko.Scanning.BackwardSlicerContext.Jump(Reko.Core.BitRange bitRange) -> Reko.Scanning.BackwardSlicerContext!
static Reko.Scanning.BlockConflictResolver.BuildConflictGraph(System.Collections.Generic.IEnumerable<Reko.Scanning.RtlBlock!>! blocks) -> System.Collections.Generic.HashSet<(Reko.Scanning.RtlBlock!, Reko.Scanning.RtlBlock!)>!
static Reko.Scanning.PromoteBlockWorkItem.SanityCheck(Reko.Core.Block! block) -> void
~static Reko.Scanning.Regexp.Compile(string s) -> Reko.Scanning.Regexp
static Reko.Scanning.ScannerInLinq.BuildBasicBlocks(Reko.Scanning.ScanResults! sr) -> System.Collections.Generic.Dictionary<Reko.Core.Address!, Reko.Scanning.ScanResults.block!>!
static Reko.Scanning.ScannerInLinq.BuildIcfg(Reko.Scanning.ScanResults! sr, Reko.Core.NamingPolicy! namingPolicy, System.Collections.Generic.Dictionary<Reko.Core.Address!, Reko.Scanning.ScanResults.block!>! blocks) -> Reko.Core.Graphs.DiGraph<Reko.Scanning.RtlBlock!>!
static Reko.Scanning.ScannerInLinq.RemoveInvalidBlocks(Reko.Scanning.ScanResults! sr, System.Collections.Generic.Dictionary<Reko.Core.Address!, Reko.Scanning.ScanResults.block!>! blocks) -> System.Collections.Generic.Dictionary<Reko.Core.Address!, Reko.Scanning.ScanResults.block!>!
static Reko.Scanning.StringSearchResult<TSymbol>.Empty.get -> Reko.Scanning.StringSearchResult<TSymbol>
static Reko.Scanning.VarargsFormatScanner.ReplaceVarargs(Reko.Core.IPlatform! platform, Reko.Core.Types.FunctionType! sig, System.Collections.Generic.IEnumerable<Reko.Core.Types.DataType!>! argumentTypes) -> Reko.Core.Types.FunctionType!
static Reko.Services.TestGenerationService.GenerateDecoderUnitTest(string! testPrefix, Reko.Core.Address! addrInstr, Reko.Core.Memory.EndianImageReader! rdr, string! message, System.Func<byte[]!, string!>! hexizer) -> string!
static Reko.Services.TestGenerationService.GenerateDecoderUnitTest(string! testPrefix, Reko.Core.Address! addrInstr, string! instrHexBytes, string! message) -> string!
static Reko.Services.TestGenerationService.GenerateRewriterUnitTest(string! testPrefix, Reko.Core.Machine.MachineInstruction! instr, string! mnemonic, Reko.Core.Memory.EndianImageReader! rdr, string! message, string! hexbytes) -> string!
static Reko.Services.TestGenerationService.GenerateRewriterUnitTest(string! testPrefix, Reko.Core.Machine.MachineInstruction! instr, string! mnemonic, Reko.Core.Memory.EndianImageReader! rdr, string! message, System.Func<byte[]!, string!>! hexizer) -> string!
static Reko.Services.TestGenerationService.ReportProcedure(string! testCaption, Reko.Core.Procedure! proc, System.IO.TextWriter! writer) -> void
static Reko.Structure.StructureAnalysis.BuildRegionGraph(Reko.Core.Procedure! proc) -> (Reko.Core.Graphs.DirectedGraph<Reko.Structure.Region!>!, Reko.Structure.Region!)
static Reko.Typing.NestedComplexTypeExtractor.ReplaceAll(Reko.Core.Types.TypeFactory! factory, Reko.Core.Types.TypeStore! store) -> bool
static Reko.Typing.TypeStoreCycleFinder.IsInCycle(Reko.Core.Types.TypeStore! store, Reko.Core.Types.DataType! dtCandidate) -> bool
virtual Reko.Analysis.LinearInductionVariableFinder.ProcessScc(System.Collections.Generic.IList<Reko.Analysis.SsaIdentifier!>! scc) -> void
virtual Reko.Analysis.SsaTransform.IdentifierTransformer.ReadVariable(Reko.Analysis.SsaTransform.SsaBlockState! bs) -> Reko.Analysis.SsaIdentifier!
virtual Reko.Decompiler.AnalyzeDataFlow() -> void
virtual Reko.Evaluation.ExpressionSimplifier.VisitAddress(Reko.Core.Address! addr) -> (Reko.Core.Expressions.Expression!, bool)
virtual Reko.Evaluation.ExpressionSimplifier.VisitApplication(Reko.Core.Expressions.Application! appl) -> (Reko.Core.Expressions.Expression!, bool)
virtual Reko.Evaluation.ExpressionSimplifier.VisitArrayAccess(Reko.Core.Expressions.ArrayAccess! acc) -> (Reko.Core.Expressions.Expression!, bool)
virtual Reko.Evaluation.ExpressionSimplifier.VisitBinaryExpression(Reko.Core.Expressions.BinaryExpression! binExp) -> (Reko.Core.Expressions.Expression!, bool)
virtual Reko.Evaluation.ExpressionSimplifier.VisitCast(Reko.Core.Expressions.Cast! cast) -> (Reko.Core.Expressions.Expression!, bool)
virtual Reko.Evaluation.ExpressionSimplifier.VisitConditionalExpression(Reko.Core.Expressions.ConditionalExpression! c) -> (Reko.Core.Expressions.Expression!, bool)
virtual Reko.Evaluation.ExpressionSimplifier.VisitConditionOf(Reko.Core.Expressions.ConditionOf! c) -> (Reko.Core.Expressions.Expression!, bool)
virtual Reko.Evaluation.ExpressionSimplifier.VisitConstant(Reko.Core.Expressions.Constant! c) -> (Reko.Core.Expressions.Expression!, bool)
virtual Reko.Evaluation.ExpressionSimplifier.VisitConversion(Reko.Core.Expressions.Conversion! conversion) -> (Reko.Core.Expressions.Expression!, bool)
virtual Reko.Evaluation.ExpressionSimplifier.VisitDereference(Reko.Core.Expressions.Dereference! deref) -> (Reko.Core.Expressions.Expression!, bool)
virtual Reko.Evaluation.ExpressionSimplifier.VisitFieldAccess(Reko.Core.Expressions.FieldAccess! acc) -> (Reko.Core.Expressions.Expression!, bool)
virtual Reko.Evaluation.ExpressionSimplifier.VisitIdentifier(Reko.Core.Expressions.Identifier! id) -> (Reko.Core.Expressions.Expression!, bool)
virtual Reko.Evaluation.ExpressionSimplifier.VisitMemberPointerSelector(Reko.Core.Expressions.MemberPointerSelector! mps) -> (Reko.Core.Expressions.Expression!, bool)
virtual Reko.Evaluation.ExpressionSimplifier.VisitMemoryAccess(Reko.Core.Expressions.MemoryAccess! access) -> (Reko.Core.Expressions.Expression!, bool)
virtual Reko.Evaluation.ExpressionSimplifier.VisitMkSequence(Reko.Core.Expressions.MkSequence! seq) -> (Reko.Core.Expressions.Expression!, bool)
virtual Reko.Evaluation.ExpressionSimplifier.VisitOutArgument(Reko.Core.Expressions.OutArgument! outArg) -> (Reko.Core.Expressions.Expression!, bool)
virtual Reko.Evaluation.ExpressionSimplifier.VisitPhiFunction(Reko.Core.Expressions.PhiFunction! pc) -> (Reko.Core.Expressions.Expression!, bool)
virtual Reko.Evaluation.ExpressionSimplifier.VisitPointerAddition(Reko.Core.Expressions.PointerAddition! pa) -> (Reko.Core.Expressions.Expression!, bool)
virtual Reko.Evaluation.ExpressionSimplifier.VisitProcedureConstant(Reko.Core.Expressions.ProcedureConstant! pc) -> (Reko.Core.Expressions.Expression!, bool)
virtual Reko.Evaluation.ExpressionSimplifier.VisitScopeResolution(Reko.Core.Expressions.ScopeResolution! sc) -> (Reko.Core.Expressions.Expression!, bool)
virtual Reko.Evaluation.ExpressionSimplifier.VisitSegmentedAccess(Reko.Core.Expressions.SegmentedAccess! segMem) -> (Reko.Core.Expressions.Expression!, bool)
virtual Reko.Evaluation.ExpressionSimplifier.VisitSlice(Reko.Core.Expressions.Slice! slice) -> (Reko.Core.Expressions.Expression!, bool)
virtual Reko.Evaluation.ExpressionSimplifier.VisitTestCondition(Reko.Core.Expressions.TestCondition! tc) -> (Reko.Core.Expressions.Expression!, bool)
virtual Reko.Evaluation.ExpressionSimplifier.VisitUnaryExpression(Reko.Core.Expressions.UnaryExpression! unary) -> (Reko.Core.Expressions.Expression!, bool)
virtual Reko.Loading.FlirtoidSignatureLoader.CreateReader(string! filename) -> System.IO.Stream!
virtual Reko.Loading.Loader.LoadFileBytes(string! filepath) -> byte[]!
virtual Reko.Loading.UnpackerSignatureLoader.CreateFileReader(string! filename) -> System.IO.TextReader!
virtual Reko.Loading.UnpackingService.CreateSignatureLoader(string! typeName) -> Reko.Loading.SignatureLoader!
virtual Reko.Scanning.BackwalkOperation.Apply(int n) -> int
virtual Reko.Scanning.Scanner.CreateBlockWorkItem(Reko.Core.Address! addrStart, Reko.Core.Procedure! proc, Reko.Core.ProcessorState! stateOnEntry) -> Reko.Scanning.BlockWorkitem!
virtual Reko.Scanning.Scanner.ScanImage() -> void
virtual Reko.Structure.Region.Write(System.IO.StringWriter! sb) -> void
virtual Reko.Typing.ExpressionTypeDescender.TypeVar(Reko.Core.Expressions.Expression! exp) -> Reko.Core.Types.TypeVariable!