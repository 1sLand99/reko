void fn0C00_0000(Register word16 ax, Register selector ds)
// MayUse:  ax:[0..15] ds:[0..15]
// LiveOut:
// Trashed: SCZO ax si Top
// Preserved: sp
// fn0C00_0000
// Return size: 0
// Mem0:Global
// fp:fp
// sp:sp
// C:C
// ds:ds
// ax:ax
// v6:v6
// SCZO:SCZO
// Top:Top
// si:si
// S:S
// Z:Z
// O:O
// return address size: 2
void fn0C00_0000(word16 ax, selector ds)
fn0C00_0000_entry:
	def ds
	def ax
	def Mem0
	// succ:  l0C00_0000
l0C00_0000:
	C_9 = fn0C00_000A(ax, ds, out ax_7)
	branch C_9 l0C00_0009
	// succ:  l0C00_0005 l0C00_0009
l0C00_0005:
	v6_13 = Mem0[ds:0x0300:word16] + ax_7
	Mem14[ds:0x0300:word16] = v6_13
	// succ:  l0C00_0009
l0C00_0009:
	return
	// succ:  fn0C00_0000_exit
fn0C00_0000_exit:
FlagGroup byte fn0C00_000A(Register word16 ax, Register selector ds, Register out ptr16 axOut)
// MayUse:  ax:[0..15] ds:[0..15]
// LiveOut: C ax
// Trashed: SCZO ax si Top
// Preserved: sp
// fn0C00_000A
// Return size: 0
// Mem0:Global
// fp:fp
// sp:sp
// si:si
// ds:ds
// SCZO:SCZO
// Z:Z
// ax:ax
// SZO:SZO
// C:C
// Top:Top
// S:S
// O:O
// axOut:Out:ax
// return address size: 2
byte fn0C00_000A(word16 ax, selector ds, ptr16 & axOut)
fn0C00_000A_entry:
	def ds
	def Mem0
	def ax
	// succ:  l0C00_000A
l0C00_000A:
	si_6 = Mem0[ds:0x0100:word16]
	branch si_6 == Mem0[ds:0x0102:word16] l0C00_001E
	// succ:  l0C00_0014 l0C00_001E
l0C00_0014:
	ax_10 = Mem0[ds:si_6:word16]
	Mem15[ds:0x0100:word16] = si_6 + 0x0002
	C_16 = false
	axOut = ax_10
	return C_16
	// succ:  fn0C00_000A_exit
l0C00_001E:
	C_9 = true
	axOut = ax
	return C_9
	// succ:  fn0C00_000A_exit
fn0C00_000A_exit:
