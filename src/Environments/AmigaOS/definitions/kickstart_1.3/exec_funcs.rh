typedef long BPTR;
[[reko::amiga_function_vector(ExecLibrary,-480)]] BYTE[[reko::return(register,"D0")]]  AbortIO([[reko::arg(register,"A1")]] struct IORequest * iORequest);
[[reko::amiga_function_vector(ExecLibrary,-432)]] void AddDevice([[reko::arg(register,"A1")]] struct Device * device);
[[reko::amiga_function_vector(ExecLibrary,-240)]] void AddHead([[reko::arg(register,"A0")]] struct List * list,[[reko::arg(register,"A1")]] struct Node * node);
[[reko::amiga_function_vector(ExecLibrary,-168)]] void AddIntServer([[reko::arg(register,"D0",0,4)]] ULONG intNum,[[reko::arg(register,"A1")]] struct Interrupt * interrupt);
[[reko::amiga_function_vector(ExecLibrary,-396)]] void AddLibrary([[reko::arg(register,"A1")]] struct Library * library);
[[reko::amiga_function_vector(ExecLibrary,-618)]] void AddMemList([[reko::arg(register,"D0")]] ULONG size,[[reko::arg(register,"D1")]] ULONG attributes,[[reko::arg(register,"D2")]] LONG pri,[[reko::arg(register,"A0")]] APTR base,[[reko::arg(register,"A1")]] char * name);
[[reko::amiga_function_vector(ExecLibrary,-354)]] void AddPort([[reko::arg(register,"A1")]] struct MsgPort * port);
[[reko::amiga_function_vector(ExecLibrary,-486)]] void AddResource([[reko::arg(register,"A1")]] APTR resource);
[[reko::amiga_function_vector(ExecLibrary,-600)]] void AddSemaphore([[reko::arg(register,"A1")]] struct SignalSemaphore * signalSemaphore);
[[reko::amiga_function_vector(ExecLibrary,-246)]] void AddTail([[reko::arg(register,"A0")]] struct List * list,[[reko::arg(register,"A1")]] struct Node * node);
[[reko::amiga_function_vector(ExecLibrary,-282)]] void AddTask([[reko::arg(register,"A1")]] struct Task * task,[[reko::arg(register,"A2")]] APTR initialPC,[[reko::arg(register,"A3")]] APTR finalPC);
[[reko::amiga_function_vector(ExecLibrary,-108)]] void Alert([[reko::arg(register,"D7")]] ULONG alertNum,[[reko::arg(register,"A5")]] APTR parameters);
[[reko::amiga_function_vector(ExecLibrary,-204)]] void *[[reko::return(register,"D0")]]  AllocAbs([[reko::arg(register,"D0")]] ULONG byteSize,[[reko::arg(register,"A1")]] APTR location);
[[reko::amiga_function_vector(ExecLibrary,-186)]] void *[[reko::return(register,"D0")]]  Allocate([[reko::arg(register,"A0")]] struct MemHeader * MemHeader,[[reko::arg(register,"D0")]] ULONG byteSize);
[[reko::amiga_function_vector(ExecLibrary,-222)]] struct MemList *[[reko::return(register,"D0")]]  AllocEntry([[reko::arg(register,"A0")]] struct MemList * memList);
[[reko::amiga_function_vector(ExecLibrary,-198)]] void *[[reko::return(register,"D0")]]  AllocMem([[reko::arg(register,"D0")]] ULONG byteSize,[[reko::arg(register,"D1")]] ULONG attributes);
[[reko::amiga_function_vector(ExecLibrary,-330)]] BYTE[[reko::return(register,"D0")]]  AllocSignal([[reko::arg(register,"D0")]] LONG signalNum);
[[reko::amiga_function_vector(ExecLibrary,-342)]] LONG[[reko::return(register,"D0")]]  AllocTrap([[reko::arg(register,"D0")]] LONG trapNum);
[[reko::amiga_function_vector(ExecLibrary,-576)]] LONG[[reko::return(register,"D0")]]  AttemptSemaphore([[reko::arg(register,"A0")]] struct SignalSemaphore * signalSemaphore);
[[reko::amiga_function_vector(ExecLibrary,-216)]] ULONG[[reko::return(register,"D0")]]  AvailMem([[reko::arg(register,"D1")]] ULONG attributes);
[[reko::amiga_function_vector(ExecLibrary,-180)]] void Cause([[reko::arg(register,"A1")]] struct Interrupt * interrupt);
[[reko::amiga_function_vector(ExecLibrary,-468)]] BOOL[[reko::return(register,"D0")]]  CheckIO([[reko::arg(register,"A1")]] struct IORequest * iORequest);
[[reko::amiga_function_vector(ExecLibrary,-450)]] void CloseDevice([[reko::arg(register,"A1")]] struct IORequest * iORequest);
[[reko::amiga_function_vector(ExecLibrary,-414)]] void CloseLibrary([[reko::arg(register,"A1")]] struct Library * library);
[[reko::amiga_function_vector(ExecLibrary,-624)]] void CopyMem([[reko::arg(register,"A0")]] APTR source,[[reko::arg(register,"A1")]] APTR dest,[[reko::arg(register,"D0")]] ULONG size);
[[reko::amiga_function_vector(ExecLibrary,-630)]] void CopyMemQuick([[reko::arg(register,"A0")]] ULONG * source,[[reko::arg(register,"A1")]] ULONG * dest,[[reko::arg(register,"D0")]] ULONG size);
[[reko::amiga_function_vector(ExecLibrary,-192)]] void Deallocate([[reko::arg(register,"A0")]] struct MemHeader * MemHeader,[[reko::arg(register,"A1")]] APTR memoryBlock,[[reko::arg(register,"D0")]] ULONG byteSize);
[[reko::amiga_function_vector(ExecLibrary,-114)]] void Debug([[reko::arg(register,"D0")]] ULONG unused);
[[reko::amiga_function_vector(ExecLibrary,-120)]] void Disable(void);
[[reko::amiga_function_vector(ExecLibrary,-456)]] BYTE[[reko::return(register,"D0")]]  DoIO([[reko::arg(register,"A1")]] struct IORequest * iORequest);
[[reko::amiga_function_vector(ExecLibrary,-126)]] void Enable(void);
[[reko::amiga_function_vector(ExecLibrary,-270)]] void Enqueue([[reko::arg(register,"A0")]] struct List * list,[[reko::arg(register,"A1")]] struct Node * node);
[[reko::amiga_function_vector(ExecLibrary,-276)]] struct Node *[[reko::return(register,"D0")]]  FindName([[reko::arg(register,"A0")]] struct List * start,[[reko::arg(register,"A1")]] char * name);
[[reko::amiga_function_vector(ExecLibrary,-390)]] struct MsgPort *[[reko::return(register,"D0")]]  FindPort([[reko::arg(register,"A1")]] char * name);
[[reko::amiga_function_vector(ExecLibrary,-96)]] struct Resident *[[reko::return(register,"D0")]]  FindResident([[reko::arg(register,"A1")]] char * name);
[[reko::amiga_function_vector(ExecLibrary,-594)]] struct SignalSemaphore *[[reko::return(register,"D0")]]  FindSemaphore([[reko::arg(register,"A1")]] char * name);
[[reko::amiga_function_vector(ExecLibrary,-294)]] struct Task *[[reko::return(register,"D0")]]  FindTask([[reko::arg(register,"A1")]] char * name);
[[reko::amiga_function_vector(ExecLibrary,-132)]] void Forbid(void);
[[reko::amiga_function_vector(ExecLibrary,-228)]] void FreeEntry([[reko::arg(register,"A0")]] struct MemList * memList);
[[reko::amiga_function_vector(ExecLibrary,-210)]] void FreeMem([[reko::arg(register,"A1")]] void * memoryBlock,[[reko::arg(register,"D0")]] ULONG byteSize);
[[reko::amiga_function_vector(ExecLibrary,-336)]] void FreeSignal([[reko::arg(register,"D0")]] ULONG signalNum);
[[reko::amiga_function_vector(ExecLibrary,-348)]] void FreeTrap([[reko::arg(register,"D0")]] ULONG trapNum);
[[reko::amiga_function_vector(ExecLibrary,-528)]] UWORD[[reko::return(register,"D0")]]  GetCC(void);
[[reko::amiga_function_vector(ExecLibrary,-372)]] struct Message *[[reko::return(register,"D0")]]  GetMsg([[reko::arg(register,"A0")]] struct MsgPort * port);
[[reko::amiga_function_vector(ExecLibrary,-72)]] void InitCode([[reko::arg(register,"D0")]] ULONG startClass,[[reko::arg(register,"D1")]] ULONG version);
[[reko::amiga_function_vector(ExecLibrary,-102)]] void InitResident([[reko::arg(register,"A1")]] struct Resident * resident,[[reko::arg(register,"D1")]] BPTR segList);
[[reko::amiga_function_vector(ExecLibrary,-558)]] void InitSemaphore([[reko::arg(register,"A0")]] struct SignalSemaphore * signalSemaphore);
[[reko::amiga_function_vector(ExecLibrary,-78)]] void InitStruct([[reko::arg(register,"A1")]] struct InitStruct * initTable,[[reko::arg(register,"A2")]] APTR memory,[[reko::arg(register,"D0")]] ULONG size);
[[reko::amiga_function_vector(ExecLibrary,-234)]] void Insert([[reko::arg(register,"A0")]] struct List * list,[[reko::arg(register,"A1")]] struct Node * node,[[reko::arg(register,"A2")]] struct Node * listNode);
[[reko::amiga_function_vector(ExecLibrary,-90)]] ULONG[[reko::return(register,"D0")]]  MakeFunctions([[reko::arg(register,"A0")]] APTR target,[[reko::arg(register,"A1")]] APTR functionArray,[[reko::arg(register,"A2")]] APTR funcDispBase);
[[reko::amiga_function_vector(ExecLibrary,-84)]] struct Library *[[reko::return(register,"D0")]]  MakeLibrary([[reko::arg(register,"A0")]] APTR vectors,[[reko::arg(register,"A1")]] struct InitStruct * structure,[[reko::arg(register,"A2")]] APTR init,[[reko::arg(register,"D0")]] ULONG dSize,[[reko::arg(register,"D1")]] BPTR segList);
[[reko::amiga_function_vector(ExecLibrary,-564)]] void ObtainSemaphore([[reko::arg(register,"A0")]] struct SignalSemaphore * signalSemaphore);
[[reko::amiga_function_vector(ExecLibrary,-582)]] void ObtainSemaphoreList([[reko::arg(register,"A0")]] struct List * list);
[[reko::amiga_function_vector(ExecLibrary,-408)]] struct Library *[[reko::return(register,"D0")]]  OldOpenLibrary([[reko::arg(register,"A1")]] APTR libName);
[[reko::amiga_function_vector(ExecLibrary,-444)]] BYTE[[reko::return(register,"D0")]]  OpenDevice([[reko::arg(register,"A0")]] char * devName,[[reko::arg(register,"D0")]] ULONG unitNumber,[[reko::arg(register,"A1")]] struct IORequest * iORequest,[[reko::arg(register,"D1")]] ULONG flags);
[[reko::amiga_function_vector(ExecLibrary,-552)]] struct Library *[[reko::return(register,"D0")]]  OpenLibrary([[reko::arg(register,"A1")]] char * libName,[[reko::arg(register,"D0")]] ULONG version);
[[reko::amiga_function_vector(ExecLibrary,-498)]] APTR[[reko::return(register,"D0")]]  OpenResource([[reko::arg(register,"A1")]] char * resName);
[[reko::amiga_function_vector(ExecLibrary,-138)]] void Permit(void);
[[reko::amiga_function_vector(ExecLibrary,-540)]] BYTE[[reko::return(register,"D0")]]  Procure([[reko::arg(register,"A0")]] struct Semaphore * semaphore,[[reko::arg(register,"A1")]] struct Message * bidMessage);
[[reko::amiga_function_vector(ExecLibrary,-366)]] void PutMsg([[reko::arg(register,"A0")]] struct MsgPort * port,[[reko::arg(register,"A1")]] struct Message * message);
[[reko::amiga_function_vector(ExecLibrary,-522)]] void RawDoFmt([[reko::arg(register,"A0")]] char * FormatString,[[reko::arg(register,"A1")]] APTR DataStream,[[reko::arg(register,"A2")]] void (*PutChProc)(),[[reko::arg(register,"A3")]] APTR PutChData);
[[reko::amiga_function_vector(ExecLibrary,-570)]] void ReleaseSemaphore([[reko::arg(register,"A0")]] struct SignalSemaphore * signalSemaphore);
[[reko::amiga_function_vector(ExecLibrary,-588)]] void ReleaseSemaphoreList([[reko::arg(register,"A0")]] struct List * list);
[[reko::amiga_function_vector(ExecLibrary,-438)]] void RemDevice([[reko::arg(register,"A1")]] struct Device * device);
[[reko::amiga_function_vector(ExecLibrary,-258)]] struct Node *[[reko::return(register,"D0")]]  RemHead([[reko::arg(register,"A0")]] struct List * list);
[[reko::amiga_function_vector(ExecLibrary,-174)]] void RemIntServer([[reko::arg(register,"D0")]] ULONG intNum,[[reko::arg(register,"A1")]] struct Interrupt * interrupt);
[[reko::amiga_function_vector(ExecLibrary,-402)]] void RemLibrary([[reko::arg(register,"A1")]] struct Library * library);
[[reko::amiga_function_vector(ExecLibrary,-252)]] void Remove([[reko::arg(register,"A1")]] struct Node * node);
[[reko::amiga_function_vector(ExecLibrary,-360)]] void RemPort([[reko::arg(register,"A1")]] struct MsgPort * port);
[[reko::amiga_function_vector(ExecLibrary,-492)]] void RemResource([[reko::arg(register,"A1")]] APTR resource);
[[reko::amiga_function_vector(ExecLibrary,-606)]] void RemSemaphore([[reko::arg(register,"A1")]] struct SignalSemaphore * signalSemaphore);
[[reko::amiga_function_vector(ExecLibrary,-264)]] struct Node *[[reko::return(register,"D0")]]  RemTail([[reko::arg(register,"A0")]] struct List * list);
[[reko::amiga_function_vector(ExecLibrary,-288)]] void RemTask([[reko::arg(register,"A1")]] struct Task * task);
[[reko::amiga_function_vector(ExecLibrary,-378)]] void ReplyMsg([[reko::arg(register,"A1")]] struct Message * message);
[[reko::amiga_function_vector(ExecLibrary,-462)]] void SendIO([[reko::arg(register,"A1")]] struct IORequest * iORequest);
[[reko::amiga_function_vector(ExecLibrary,-312)]] ULONG[[reko::return(register,"D0")]]  SetExcept([[reko::arg(register,"D0")]] ULONG newSignals,[[reko::arg(register,"D1")]] ULONG signalMask);
[[reko::amiga_function_vector(ExecLibrary,-420)]] APTR[[reko::return(register,"D0")]]  SetFunction([[reko::arg(register,"A1")]] struct Library * library,[[reko::arg(register,"A0.W")]] LONG funcOffset,[[reko::arg(register,"D0")]] APTR funcEntry);
[[reko::amiga_function_vector(ExecLibrary,-162)]] struct Interrupt *[[reko::return(register,"D0")]]  SetIntVector([[reko::arg(register,"D0",0,4)]] ULONG intNumber,[[reko::arg(register,"A1")]] struct Interrupt * interrupt);
[[reko::amiga_function_vector(ExecLibrary,-306)]] ULONG[[reko::return(register,"D0")]]  SetSignal([[reko::arg(register,"D0")]] ULONG newSignals,[[reko::arg(register,"D1")]] ULONG signalMask);
[[reko::amiga_function_vector(ExecLibrary,-144)]] ULONG[[reko::return(register,"D0")]]  SetSR([[reko::arg(register,"D0")]] ULONG newSR,[[reko::arg(register,"D1")]] ULONG mask);
[[reko::amiga_function_vector(ExecLibrary,-300)]] BYTE[[reko::return(register,"D0",0,8)]]  SetTaskPri([[reko::arg(register,"A1")]] struct Task * task,[[reko::arg(register,"D0",0,8)]] LONG priority);
[[reko::amiga_function_vector(ExecLibrary,-324)]] void Signal([[reko::arg(register,"A1")]] struct Task * task,[[reko::arg(register,"D0")]] ULONG signals);
[[reko::amiga_function_vector(ExecLibrary,-612)]] void SumKickData(void);
[[reko::amiga_function_vector(ExecLibrary,-426)]] void SumLibrary([[reko::arg(register,"A1")]] struct Library * library);
[[reko::amiga_function_vector(ExecLibrary,-150)]] APTR[[reko::return(register,"D0")]]  SuperState(void);
[[reko::amiga_function_vector(ExecLibrary,-534)]] ULONG[[reko::return(register,"D0")]]  TypeOfMem([[reko::arg(register,"A1")]] void * address);
[[reko::amiga_function_vector(ExecLibrary,-156)]] void UserState([[reko::arg(register,"D0")]] APTR sysStack);
[[reko::amiga_function_vector(ExecLibrary,-546)]] void Vacate([[reko::arg(register,"A0")]] struct Semaphore * semaphore);
[[reko::amiga_function_vector(ExecLibrary,-318)]] ULONG[[reko::return(register,"D0")]]  Wait([[reko::arg(register,"D0")]] ULONG signalSet);
[[reko::amiga_function_vector(ExecLibrary,-474)]] BYTE[[reko::return(register,"D0")]]  WaitIO([[reko::arg(register,"A1")]] struct IORequest * iORequest);
[[reko::amiga_function_vector(ExecLibrary,-384)]] struct Message *[[reko::return(register,"D0")]]  WaitPort([[reko::arg(register,"A0")]] struct MsgPort * port);
