[[reko::amiga_function_vector(ExecLibrary,-480)]] BYTE[[reko::reg("D0")]]  AbortIO([[reko::reg("A1")]] struct IORequest * iORequest);
[[reko::amiga_function_vector(ExecLibrary,-432)]] void AddDevice([[reko::reg("A1")]] struct Device * device);
[[reko::amiga_function_vector(ExecLibrary,-240)]] void AddHead([[reko::reg("A0")]] struct List * list,[[reko::reg("A1")]] struct Node * node);
[[reko::amiga_function_vector(ExecLibrary,-168)]] void AddIntServer([[reko::reg("D0",0,4)]] ULONG intNum,[[reko::reg("A1")]] struct Interrupt * interrupt);
[[reko::amiga_function_vector(ExecLibrary,-396)]] void AddLibrary([[reko::reg("A1")]] struct Library * library);
[[reko::amiga_function_vector(ExecLibrary,-618)]] void AddMemList([[reko::reg("D0")]] ULONG size,[[reko::reg("D1")]] ULONG attributes,[[reko::reg("D2")]] LONG pri,[[reko::reg("A0")]] APTR base,[[reko::reg("A1")]] char * name);
[[reko::amiga_function_vector(ExecLibrary,-354)]] void AddPort([[reko::reg("A1")]] struct MsgPort * port);
[[reko::amiga_function_vector(ExecLibrary,-486)]] void AddResource([[reko::reg("A1")]] APTR resource);
[[reko::amiga_function_vector(ExecLibrary,-600)]] void AddSemaphore([[reko::reg("A1")]] struct SignalSemaphore * signalSemaphore);
[[reko::amiga_function_vector(ExecLibrary,-246)]] void AddTail([[reko::reg("A0")]] struct List * list,[[reko::reg("A1")]] struct Node * node);
[[reko::amiga_function_vector(ExecLibrary,-282)]] void AddTask([[reko::reg("A1")]] struct Task * task,[[reko::reg("A2")]] APTR initialPC,[[reko::reg("A3")]] APTR finalPC);
[[reko::amiga_function_vector(ExecLibrary,-108)]] void Alert([[reko::reg("D7")]] ULONG alertNum,[[reko::reg("A5")]] APTR parameters);
[[reko::amiga_function_vector(ExecLibrary,-204)]] void *[[reko::reg("D0")]]  AllocAbs([[reko::reg("D0")]] ULONG byteSize,[[reko::reg("A1")]] APTR location);
[[reko::amiga_function_vector(ExecLibrary,-186)]] void *[[reko::reg("D0")]]  Allocate([[reko::reg("A0")]] struct MemHeader * MemHeader,[[reko::reg("D0")]] ULONG byteSize);
[[reko::amiga_function_vector(ExecLibrary,-222)]] struct MemList *[[reko::reg("D0")]]  AllocEntry([[reko::reg("A0")]] struct MemList * memList);
[[reko::amiga_function_vector(ExecLibrary,-198)]] void *[[reko::reg("D0")]]  AllocMem([[reko::reg("D0")]] ULONG byteSize,[[reko::reg("D1")]] ULONG attributes);
[[reko::amiga_function_vector(ExecLibrary,-330)]] BYTE[[reko::reg("D0")]]  AllocSignal([[reko::reg("D0")]] LONG signalNum);
[[reko::amiga_function_vector(ExecLibrary,-342)]] LONG[[reko::reg("D0")]]  AllocTrap([[reko::reg("D0")]] LONG trapNum);
[[reko::amiga_function_vector(ExecLibrary,-576)]] LONG[[reko::reg("D0")]]  AttemptSemaphore([[reko::reg("A0")]] struct SignalSemaphore * signalSemaphore);
[[reko::amiga_function_vector(ExecLibrary,-216)]] ULONG[[reko::reg("D0")]]  AvailMem([[reko::reg("D1")]] ULONG attributes);
[[reko::amiga_function_vector(ExecLibrary,-180)]] void Cause([[reko::reg("A1")]] struct Interrupt * interrupt);
[[reko::amiga_function_vector(ExecLibrary,-468)]] BOOL[[reko::reg("D0")]]  CheckIO([[reko::reg("A1")]] struct IORequest * iORequest);
[[reko::amiga_function_vector(ExecLibrary,-450)]] void CloseDevice([[reko::reg("A1")]] struct IORequest * iORequest);
[[reko::amiga_function_vector(ExecLibrary,-414)]] void CloseLibrary([[reko::reg("A1")]] struct Library * library);
[[reko::amiga_function_vector(ExecLibrary,-624)]] void CopyMem([[reko::reg("A0")]] APTR source,[[reko::reg("A1")]] APTR dest,[[reko::reg("D0")]] ULONG size);
[[reko::amiga_function_vector(ExecLibrary,-630)]] void CopyMemQuick([[reko::reg("A0")]] ULONG * source,[[reko::reg("A1")]] ULONG * dest,[[reko::reg("D0")]] ULONG size);
[[reko::amiga_function_vector(ExecLibrary,-192)]] void Deallocate([[reko::reg("A0")]] struct MemHeader * MemHeader,[[reko::reg("A1")]] APTR memoryBlock,[[reko::reg("D0")]] ULONG byteSize);
[[reko::amiga_function_vector(ExecLibrary,-114)]] void Debug([[reko::reg("D0")]] ULONG unused);
[[reko::amiga_function_vector(ExecLibrary,-120)]] void Disable(void);
[[reko::amiga_function_vector(ExecLibrary,-456)]] BYTE[[reko::reg("D0")]]  DoIO([[reko::reg("A1")]] struct IORequest * iORequest);
[[reko::amiga_function_vector(ExecLibrary,-126)]] void Enable(void);
[[reko::amiga_function_vector(ExecLibrary,-270)]] void Enqueue([[reko::reg("A0")]] struct List * list,[[reko::reg("A1")]] struct Node * node);
[[reko::amiga_function_vector(ExecLibrary,-276)]] struct Node *[[reko::reg("D0")]]  FindName([[reko::reg("A0")]] struct List * start,[[reko::reg("A1")]] char * name);
[[reko::amiga_function_vector(ExecLibrary,-390)]] struct MsgPort *[[reko::reg("D0")]]  FindPort([[reko::reg("A1")]] char * name);
[[reko::amiga_function_vector(ExecLibrary,-96)]] struct Resident *[[reko::reg("D0")]]  FindResident([[reko::reg("A1")]] char * name);
[[reko::amiga_function_vector(ExecLibrary,-594)]] struct SignalSemaphore *[[reko::reg("D0")]]  FindSemaphore([[reko::reg("A1")]] char * name);
[[reko::amiga_function_vector(ExecLibrary,-294)]] struct Task *[[reko::reg("D0")]]  FindTask([[reko::reg("A1")]] char * name);
[[reko::amiga_function_vector(ExecLibrary,-132)]] void Forbid(void);
[[reko::amiga_function_vector(ExecLibrary,-228)]] void FreeEntry([[reko::reg("A0")]] struct MemList * memList);
[[reko::amiga_function_vector(ExecLibrary,-210)]] void FreeMem([[reko::reg("A1")]] void * memoryBlock,[[reko::reg("D0")]] ULONG byteSize);
[[reko::amiga_function_vector(ExecLibrary,-336)]] void FreeSignal([[reko::reg("D0")]] ULONG signalNum);
[[reko::amiga_function_vector(ExecLibrary,-348)]] void FreeTrap([[reko::reg("D0")]] ULONG trapNum);
[[reko::amiga_function_vector(ExecLibrary,-528)]] UWORD[[reko::reg("D0")]]  GetCC(void);
[[reko::amiga_function_vector(ExecLibrary,-372)]] struct Message *[[reko::reg("D0")]]  GetMsg([[reko::reg("A0")]] struct MsgPort * port);
[[reko::amiga_function_vector(ExecLibrary,-72)]] void InitCode([[reko::reg("D0")]] ULONG startClass,[[reko::reg("D1")]] ULONG version);
[[reko::amiga_function_vector(ExecLibrary,-102)]] void InitResident([[reko::reg("A1")]] struct Resident * resident,[[reko::reg("D1")]] BPTR segList);
[[reko::amiga_function_vector(ExecLibrary,-558)]] void InitSemaphore([[reko::reg("A0")]] struct SignalSemaphore * signalSemaphore);
[[reko::amiga_function_vector(ExecLibrary,-78)]] void InitStruct([[reko::reg("A1")]] struct InitStruct * initTable,[[reko::reg("A2")]] APTR memory,[[reko::reg("D0")]] ULONG size);
[[reko::amiga_function_vector(ExecLibrary,-234)]] void Insert([[reko::reg("A0")]] struct List * list,[[reko::reg("A1")]] struct Node * node,[[reko::reg("A2")]] struct Node * listNode);
[[reko::amiga_function_vector(ExecLibrary,-90)]] ULONG[[reko::reg("D0")]]  MakeFunctions([[reko::reg("A0")]] APTR target,[[reko::reg("A1")]] APTR functionArray,[[reko::reg("A2")]] APTR funcDispBase);
[[reko::amiga_function_vector(ExecLibrary,-84)]] struct Library *[[reko::reg("D0")]]  MakeLibrary([[reko::reg("A0")]] APTR vectors,[[reko::reg("A1")]] struct InitStruct * structure,[[reko::reg("A2")]] APTR init,[[reko::reg("D0")]] ULONG dSize,[[reko::reg("D1")]] BPTR segList);
[[reko::amiga_function_vector(ExecLibrary,-564)]] void ObtainSemaphore([[reko::reg("A0")]] struct SignalSemaphore * signalSemaphore);
[[reko::amiga_function_vector(ExecLibrary,-582)]] void ObtainSemaphoreList([[reko::reg("A0")]] struct List * list);
[[reko::amiga_function_vector(ExecLibrary,-408)]] struct Library *[[reko::reg("D0")]]  OldOpenLibrary([[reko::reg("A1")]] APTR libName);
[[reko::amiga_function_vector(ExecLibrary,-444)]] BYTE[[reko::reg("D0")]]  OpenDevice([[reko::reg("A0")]] char * devName,[[reko::reg("D0")]] ULONG unitNumber,[[reko::reg("A1")]] struct IORequest * iORequest,[[reko::reg("D1")]] ULONG flags);
[[reko::amiga_function_vector(ExecLibrary,-552)]] struct Library *[[reko::reg("D0")]]  OpenLibrary([[reko::reg("A1")]] char * libName,[[reko::reg("D0")]] ULONG version);
[[reko::amiga_function_vector(ExecLibrary,-498)]] APTR[[reko::reg("D0")]]  OpenResource([[reko::reg("A1")]] char * resName);
[[reko::amiga_function_vector(ExecLibrary,-138)]] void Permit(void);
[[reko::amiga_function_vector(ExecLibrary,-540)]] BYTE[[reko::reg("D0")]]  Procure([[reko::reg("A0")]] struct Semaphore * semaphore,[[reko::reg("A1")]] struct Message * bidMessage);
[[reko::amiga_function_vector(ExecLibrary,-366)]] void PutMsg([[reko::reg("A0")]] struct MsgPort * port,[[reko::reg("A1")]] struct Message * message);
[[reko::amiga_function_vector(ExecLibrary,-522)]] void RawDoFmt([[reko::reg("A0")]] char * FormatString,[[reko::reg("A1")]] APTR DataStream,[[reko::reg("A2")]] void (*PutChProc)(),[[reko::reg("A3")]] APTR PutChData);
[[reko::amiga_function_vector(ExecLibrary,-570)]] void ReleaseSemaphore([[reko::reg("A0")]] struct SignalSemaphore * signalSemaphore);
[[reko::amiga_function_vector(ExecLibrary,-588)]] void ReleaseSemaphoreList([[reko::reg("A0")]] struct List * list);
[[reko::amiga_function_vector(ExecLibrary,-438)]] void RemDevice([[reko::reg("A1")]] struct Device * device);
[[reko::amiga_function_vector(ExecLibrary,-258)]] struct Node *[[reko::reg("D0")]]  RemHead([[reko::reg("A0")]] struct List * list);
[[reko::amiga_function_vector(ExecLibrary,-174)]] void RemIntServer([[reko::reg("D0")]] ULONG intNum,[[reko::reg("A1")]] struct Interrupt * interrupt);
[[reko::amiga_function_vector(ExecLibrary,-402)]] void RemLibrary([[reko::reg("A1")]] struct Library * library);
[[reko::amiga_function_vector(ExecLibrary,-252)]] void Remove([[reko::reg("A1")]] struct Node * node);
[[reko::amiga_function_vector(ExecLibrary,-360)]] void RemPort([[reko::reg("A1")]] struct MsgPort * port);
[[reko::amiga_function_vector(ExecLibrary,-492)]] void RemResource([[reko::reg("A1")]] APTR resource);
[[reko::amiga_function_vector(ExecLibrary,-606)]] void RemSemaphore([[reko::reg("A1")]] struct SignalSemaphore * signalSemaphore);
[[reko::amiga_function_vector(ExecLibrary,-264)]] struct Node *[[reko::reg("D0")]]  RemTail([[reko::reg("A0")]] struct List * list);
[[reko::amiga_function_vector(ExecLibrary,-288)]] void RemTask([[reko::reg("A1")]] struct Task * task);
[[reko::amiga_function_vector(ExecLibrary,-378)]] void ReplyMsg([[reko::reg("A1")]] struct Message * message);
[[reko::amiga_function_vector(ExecLibrary,-462)]] void SendIO([[reko::reg("A1")]] struct IORequest * iORequest);
[[reko::amiga_function_vector(ExecLibrary,-312)]] ULONG[[reko::reg("D0")]]  SetExcept([[reko::reg("D0")]] ULONG newSignals,[[reko::reg("D1")]] ULONG signalMask);
[[reko::amiga_function_vector(ExecLibrary,-420)]] APTR[[reko::reg("D0")]]  SetFunction([[reko::reg("A1")]] struct Library * library,[[reko::reg("A0.W")]] LONG funcOffset,[[reko::reg("D0")]] APTR funcEntry);
[[reko::amiga_function_vector(ExecLibrary,-162)]] struct Interrupt *[[reko::reg("D0")]]  SetIntVector([[reko::reg("D0",0,4)]] ULONG intNumber,[[reko::reg("A1")]] struct Interrupt * interrupt);
[[reko::amiga_function_vector(ExecLibrary,-306)]] ULONG[[reko::reg("D0")]]  SetSignal([[reko::reg("D0")]] ULONG newSignals,[[reko::reg("D1")]] ULONG signalMask);
[[reko::amiga_function_vector(ExecLibrary,-144)]] ULONG[[reko::reg("D0")]]  SetSR([[reko::reg("D0")]] ULONG newSR,[[reko::reg("D1")]] ULONG mask);
[[reko::amiga_function_vector(ExecLibrary,-300)]] BYTE[[reko::reg("D0",0,8)]]  SetTaskPri([[reko::reg("A1")]] struct Task * task,[[reko::reg("D0",0,8)]] LONG priority);
[[reko::amiga_function_vector(ExecLibrary,-324)]] void Signal([[reko::reg("A1")]] struct Task * task,[[reko::reg("D0")]] ULONG signals);
[[reko::amiga_function_vector(ExecLibrary,-612)]] void SumKickData(void);
[[reko::amiga_function_vector(ExecLibrary,-426)]] void SumLibrary([[reko::reg("A1")]] struct Library * library);
[[reko::amiga_function_vector(ExecLibrary,-150)]] APTR[[reko::reg("D0")]]  SuperState(void);
[[reko::amiga_function_vector(ExecLibrary,-534)]] ULONG[[reko::reg("D0")]]  TypeOfMem([[reko::reg("A1")]] void * address);
[[reko::amiga_function_vector(ExecLibrary,-156)]] void UserState([[reko::reg("D0")]] APTR sysStack);
[[reko::amiga_function_vector(ExecLibrary,-546)]] void Vacate([[reko::reg("A0")]] struct Semaphore * semaphore);
[[reko::amiga_function_vector(ExecLibrary,-318)]] ULONG[[reko::reg("D0")]]  Wait([[reko::reg("D0")]] ULONG signalSet);
[[reko::amiga_function_vector(ExecLibrary,-474)]] BYTE[[reko::reg("D0")]]  WaitIO([[reko::reg("A1")]] struct IORequest * iORequest);
[[reko::amiga_function_vector(ExecLibrary,-384)]] struct Message *[[reko::reg("D0")]]  WaitPort([[reko::reg("A0")]] struct MsgPort * port);
