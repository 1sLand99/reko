#nullable enable
abstract Reko.Core.Absyn.AbsynStatement.Accept(Reko.Core.Absyn.IAbsynVisitor visitor) -> void
abstract Reko.Core.Absyn.AbsynStatement.Accept<T>(Reko.Core.Absyn.IAbsynVisitor<T> visitor) -> T
abstract Reko.Core.Address.Add(long offset) -> Reko.Core.Address
abstract Reko.Core.Address.Align(int alignment) -> Reko.Core.Address
abstract Reko.Core.Address.GenerateName(string prefix, string suffix) -> string
abstract Reko.Core.Address.IsNull.get -> bool
abstract Reko.Core.Address.NewOffset(ulong offset) -> Reko.Core.Address
abstract Reko.Core.Address.Offset.get -> ulong
abstract Reko.Core.Address.Selector.get -> ushort?
abstract Reko.Core.Address.ToConstant() -> Reko.Core.Expressions.Constant
abstract Reko.Core.Address.ToLinear() -> ulong
abstract Reko.Core.Address.ToUInt16() -> ushort
abstract Reko.Core.Address.ToUInt32() -> uint
abstract Reko.Core.ApplicationBuilder.Bind(Reko.Core.Expressions.Identifier id) -> Reko.Core.Expressions.Expression
abstract Reko.Core.ApplicationBuilder.BindOutArg(Reko.Core.Expressions.Identifier id) -> Reko.Core.Expressions.OutArgument
abstract Reko.Core.ApplicationBuilder.BindReturnValue(Reko.Core.Expressions.Identifier id) -> Reko.Core.Expressions.Expression
abstract Reko.Core.Code.Instruction.Accept(Reko.Core.Code.InstructionTransformer xform) -> Reko.Core.Code.Instruction
abstract Reko.Core.Code.Instruction.Accept(Reko.Core.Code.InstructionVisitor v) -> void
abstract Reko.Core.Code.Instruction.Accept<T, C>(Reko.Core.Code.InstructionVisitor<T, C> visitor, C ctx) -> T
abstract Reko.Core.Code.Instruction.Accept<T>(Reko.Core.Code.InstructionVisitor<T> visitor) -> T
abstract Reko.Core.Code.Instruction.IsControlFlow.get -> bool
abstract Reko.Core.CodeEmitter.Emit(Reko.Core.Code.Instruction instr) -> Reko.Core.Statement
abstract Reko.Core.CodeEmitter.Frame.get -> Reko.Core.Frame
abstract Reko.Core.Collections.BTreeDictionary<TKey, TValue>.Collection<T>.Contains(T item) -> bool
abstract Reko.Core.Collections.BTreeDictionary<TKey, TValue>.Collection<T>.CopyTo(T[] array, int arrayIndex) -> void
abstract Reko.Core.Collections.BTreeDictionary<TKey, TValue>.Collection<T>.GetEnumerator() -> System.Collections.Generic.IEnumerator<T>
abstract Reko.Core.Collections.BTreeDictionary<TKey, TValue>.Collection<T>.this[int index].get -> T
abstract Reko.Core.Collections.ConcurrentBTreeDictionary<TKey, TValue>.Collection<T>.Contains(T item) -> bool
abstract Reko.Core.Collections.ConcurrentBTreeDictionary<TKey, TValue>.Collection<T>.CopyTo(T[] array, int arrayIndex) -> void
abstract Reko.Core.Collections.ConcurrentBTreeDictionary<TKey, TValue>.Collection<T>.GetEnumerator() -> System.Collections.Generic.IEnumerator<T>
abstract Reko.Core.Collections.ConcurrentBTreeDictionary<TKey, TValue>.Collection<T>.this[int index].get -> T
abstract Reko.Core.Emulation.EmulatorBase.CurrentInstruction.get -> Reko.Core.Machine.MachineInstruction
abstract Reko.Core.Emulation.EmulatorBase.InstructionPointer.get -> Reko.Core.Address
abstract Reko.Core.Emulation.EmulatorBase.InstructionPointer.set -> void
abstract Reko.Core.Emulation.EmulatorBase.ReadRegister(Reko.Core.RegisterStorage! reg) -> ulong
abstract Reko.Core.Emulation.EmulatorBase.Run() -> void
abstract Reko.Core.Emulation.EmulatorBase.WriteRegister(Reko.Core.RegisterStorage reg, ulong value) -> ulong
abstract Reko.Core.EndianServices.CreateImageReader(byte[] bytes, long off) -> Reko.Core.Memory.EndianImageReader
abstract Reko.Core.EndianServices.CreateImageReader(Reko.Core.Memory.MemoryArea mem, long off) -> Reko.Core.Memory.EndianImageReader
abstract Reko.Core.EndianServices.CreateImageReader(Reko.Core.Memory.MemoryArea mem, Reko.Core.Address addr) -> Reko.Core.Memory.EndianImageReader
abstract Reko.Core.EndianServices.CreateImageReader(Reko.Core.Memory.MemoryArea memoryArea, long offsetBegin, long offsetEnd) -> Reko.Core.Memory.EndianImageReader
abstract Reko.Core.EndianServices.CreateImageReader(Reko.Core.Memory.MemoryArea memoryArea, Reko.Core.Address addr, long cbUnits) -> Reko.Core.Memory.EndianImageReader
abstract Reko.Core.EndianServices.CreateImageWriter() -> Reko.Core.Memory.ImageWriter
abstract Reko.Core.EndianServices.CreateImageWriter(byte[] bytes, long offset) -> Reko.Core.Memory.ImageWriter
abstract Reko.Core.EndianServices.CreateImageWriter(Reko.Core.Memory.MemoryArea memoryArea, Reko.Core.Address addr) -> Reko.Core.Memory.ImageWriter
abstract Reko.Core.EndianServices.MakeSequence(Reko.Core.Types.DataType dataType, Reko.Core.Expressions.Expression[] accesses) -> Reko.Core.Expressions.MkSequence
abstract Reko.Core.EndianServices.MakeSlice(Reko.Core.Types.DataType dataType, Reko.Core.Expressions.Expression expr, int loOffset, int bitsPerUnit) -> Reko.Core.Expressions.Slice
abstract Reko.Core.EndianServices.OffsetsAdjacent(long oLsb, long oMsb, long size) -> bool
abstract Reko.Core.EndianServices.SliceStackStorage(Reko.Core.StackStorage stg, Reko.Core.BitRange bitRange, int granularity) -> Reko.Core.StackStorage
abstract Reko.Core.EndianServices.TryRead(Reko.Core.Memory.MemoryArea mem, Reko.Core.Address addr, Reko.Core.Types.PrimitiveType dt, out Reko.Core.Expressions.Constant value) -> bool
abstract Reko.Core.Expressions.Constant.Complement() -> Reko.Core.Expressions.Constant
abstract Reko.Core.Expressions.Constant.GetHashOfValue() -> int
abstract Reko.Core.Expressions.Constant.GetValue() -> object
abstract Reko.Core.Expressions.Constant.ToBigInteger() -> System.Numerics.BigInteger
abstract Reko.Core.Expressions.Constant.ToByte() -> byte
abstract Reko.Core.Expressions.Constant.ToInt16() -> short
abstract Reko.Core.Expressions.Constant.ToInt32() -> int
abstract Reko.Core.Expressions.Constant.ToInt64() -> long
abstract Reko.Core.Expressions.Constant.ToUInt16() -> ushort
abstract Reko.Core.Expressions.Constant.ToUInt32() -> uint
abstract Reko.Core.Expressions.Constant.ToUInt64() -> ulong
abstract Reko.Core.Expressions.Expression.Accept(Reko.Core.Expressions.IExpressionVisitor visitor) -> void
abstract Reko.Core.Expressions.Expression.Accept<T, C>(Reko.Core.Expressions.ExpressionVisitor<T, C> visitor, C context) -> T
abstract Reko.Core.Expressions.Expression.Accept<T>(Reko.Core.Expressions.ExpressionVisitor<T> visitor) -> T
abstract Reko.Core.Expressions.Expression.Children.get -> System.Collections.Generic.IEnumerable<Reko.Core.Expressions.Expression>
abstract Reko.Core.Expressions.Expression.CloneExpression() -> Reko.Core.Expressions.Expression
abstract Reko.Core.Expressions.ExpressionTypeAscenderBase.EnsureDataType(Reko.Core.Types.DataType dt, Reko.Core.Expressions.Expression exp) -> Reko.Core.Types.DataType
abstract Reko.Core.Expressions.ExpressionTypeAscenderBase.RecordDataType(Reko.Core.Types.DataType dt, Reko.Core.Expressions.Expression exp) -> Reko.Core.Types.DataType
abstract Reko.Core.Expressions.ExpressionVisitorBase<T>.DefaultValue.get -> T
abstract Reko.Core.Hll.C.CExpression.Accept<T>(Reko.Core.Hll.C.CExpressionVisitor<T> visitor) -> T
abstract Reko.Core.Hll.C.CSyntax.Accept<T>(Reko.Core.Hll.C.CSyntaxVisitor<T> visitor) -> T
abstract Reko.Core.Hll.C.Declarator.Accept<T>(Reko.Core.Hll.C.DeclaratorVisitor<T> visitor) -> T
abstract Reko.Core.Hll.C.DeclSpec.Accept<T>(Reko.Core.Hll.C.DeclSpecVisitor<T> visitor) -> T
abstract Reko.Core.Hll.Pascal.PascalSyntax.Accept<T>(Reko.Core.Hll.Pascal.IPascalSyntaxVisitor<T> visitor) -> T
abstract Reko.Core.Hll.Pascal.PascalSyntax.Write(System.IO.TextWriter writer) -> void
abstract Reko.Core.ImageSegmentRenderer.Render(Reko.Core.ImageSegment segment, Reko.Core.Program program, Reko.Core.Output.Formatter formatter) -> void
abstract Reko.Core.ImportReference.CompareTo(Reko.Core.ImportReference that) -> int
abstract Reko.Core.ImportReference.ResolveImport(Reko.Core.IDynamicLinker dynamicLinker, Reko.Core.IPlatform platform, Reko.Core.AddressContext ctx) -> Reko.Core.Expressions.Expression
abstract Reko.Core.ImportReference.ResolveImportedProcedure(Reko.Core.IDynamicLinker dynamicLinker, Reko.Core.IPlatform platform, Reko.Core.AddressContext ctx) -> Reko.Core.ExternalProcedure
abstract Reko.Core.Lib.PatternCollector.readSyms(System.IO.Stream f) -> int
abstract Reko.Core.Loading.ImageHeader.PreferredBaseAddress.get -> Reko.Core.Address
abstract Reko.Core.Loading.ImageHeader.PreferredBaseAddress.set -> void
abstract Reko.Core.Loading.ImageLoader.Load(Reko.Core.Address addrLoad) -> Reko.Core.Loading.ILoadedImage
abstract Reko.Core.Loading.ProgramImageLoader.LoadProgram(Reko.Core.Address address) -> Reko.Core.Program
abstract Reko.Core.Loading.ProgramImageLoader.PreferredBaseAddress.get -> Reko.Core.Address
abstract Reko.Core.Loading.ProgramImageLoader.PreferredBaseAddress.set -> void
abstract Reko.Core.Machine.AbstractMachineOperand.DoRender(Reko.Core.Machine.MachineInstructionRenderer! renderer, Reko.Core.Machine.MachineInstructionRendererOptions! options) -> void
abstract Reko.Core.Machine.Decoder<TDasm, TMnemonic, TInstr>.Decode(uint wInstr, TDasm dasm) -> TInstr
abstract Reko.Core.Machine.DisassemblerBase<TInstr, TMnemonic>.CreateInvalidInstruction() -> TInstr!
abstract Reko.Core.Machine.DisassemblerBase<TInstr, TMnemonic>.DisassembleInstruction() -> TInstr?
abstract Reko.Core.Machine.DisassemblerBase<TInstr, TMnemonic>.NotYetImplemented(string! message) -> TInstr!
abstract Reko.Core.Machine.InstructionComparer.CompareOperands(Reko.Core.Machine.MachineInstruction x, Reko.Core.Machine.MachineInstruction y) -> bool
abstract Reko.Core.Machine.InstructionComparer.GetOperandsHash(Reko.Core.Machine.MachineInstruction instr) -> int
abstract Reko.Core.Machine.MachineInstruction.MnemonicAsInteger.get -> int
abstract Reko.Core.Machine.MachineInstruction.MnemonicAsString.get -> string
abstract Reko.Core.Machine.WideDecoder<TDasm, TMnemonic, TInstr>.Decode(ulong ulInstr, TDasm dasm) -> TInstr
abstract Reko.Core.Memory.EndianByteImageReader.CreateNew(byte[] bytes, long offset) -> Reko.Core.Memory.EndianImageReader
abstract Reko.Core.Memory.EndianByteImageReader.CreateNew(Reko.Core.Memory.MemoryArea image, Reko.Core.Address addr) -> Reko.Core.Memory.EndianImageReader
abstract Reko.Core.Memory.EndianByteImageReader.ReadInt16() -> short
abstract Reko.Core.Memory.EndianByteImageReader.ReadInt16(int offset) -> short
abstract Reko.Core.Memory.EndianByteImageReader.ReadInt32() -> int
abstract Reko.Core.Memory.EndianByteImageReader.ReadInt32(int offset) -> int
abstract Reko.Core.Memory.EndianByteImageReader.ReadInt64() -> long
abstract Reko.Core.Memory.EndianByteImageReader.ReadInt64(int offset) -> long
abstract Reko.Core.Memory.EndianByteImageReader.ReadUInt16() -> ushort
abstract Reko.Core.Memory.EndianByteImageReader.ReadUInt16(int offset) -> ushort
abstract Reko.Core.Memory.EndianByteImageReader.ReadUInt32() -> uint
abstract Reko.Core.Memory.EndianByteImageReader.ReadUInt32(int offset) -> uint
abstract Reko.Core.Memory.EndianByteImageReader.ReadUInt64() -> ulong
abstract Reko.Core.Memory.EndianByteImageReader.ReadUInt64(int offset) -> ulong
abstract Reko.Core.Memory.EndianByteImageReader.TryPeekUInt32(int offset, out uint value) -> bool
abstract Reko.Core.Memory.EndianByteImageReader.TryPeekUInt64(int offset, out ulong value) -> bool
abstract Reko.Core.Memory.EndianByteImageReader.TryRead(Reko.Core.Types.PrimitiveType dataType, out Reko.Core.Expressions.Constant c) -> bool
abstract Reko.Core.Memory.EndianByteImageReader.TryReadInt16(out short i16) -> bool
abstract Reko.Core.Memory.EndianByteImageReader.TryReadInt32(out int i32) -> bool
abstract Reko.Core.Memory.EndianByteImageReader.TryReadInt64(out long value) -> bool
abstract Reko.Core.Memory.EndianByteImageReader.TryReadUInt16(out ushort ui16) -> bool
abstract Reko.Core.Memory.EndianByteImageReader.TryReadUInt32(out uint ui32) -> bool
abstract Reko.Core.Memory.EndianByteImageReader.TryReadUInt64(out ulong ui64) -> bool
abstract Reko.Core.Memory.ImageWriter.Clone() -> Reko.Core.Memory.ImageWriter
abstract Reko.Core.Memory.ImageWriter.WriteUInt16(ushort us) -> Reko.Core.Memory.ImageWriter
abstract Reko.Core.Memory.ImageWriter.WriteUInt32(uint offset, uint w) -> Reko.Core.Memory.ImageWriter
abstract Reko.Core.Memory.ImageWriter.WriteUInt32(uint w) -> Reko.Core.Memory.ImageWriter
abstract Reko.Core.Memory.ImageWriter.WriteUInt64(ulong w) -> Reko.Core.Memory.ImageWriter
abstract Reko.Core.Memory.MemoryArea.CreateBeReader(long offset) -> Reko.Core.Memory.EndianImageReader
abstract Reko.Core.Memory.MemoryArea.CreateBeReader(long offsetBegin, long offsetEnd) -> Reko.Core.Memory.EndianImageReader
abstract Reko.Core.Memory.MemoryArea.CreateBeReader(Reko.Core.Address addr) -> Reko.Core.Memory.EndianImageReader
abstract Reko.Core.Memory.MemoryArea.CreateBeReader(Reko.Core.Address addr, long cUnits) -> Reko.Core.Memory.EndianImageReader
abstract Reko.Core.Memory.MemoryArea.CreateBeWriter(long offset) -> Reko.Core.Memory.BeImageWriter
abstract Reko.Core.Memory.MemoryArea.CreateBeWriter(Reko.Core.Address addr) -> Reko.Core.Memory.BeImageWriter
abstract Reko.Core.Memory.MemoryArea.CreateLeReader(long offset) -> Reko.Core.Memory.EndianImageReader
abstract Reko.Core.Memory.MemoryArea.CreateLeReader(long offsetBegin, long offsetEnd) -> Reko.Core.Memory.EndianImageReader
abstract Reko.Core.Memory.MemoryArea.CreateLeReader(Reko.Core.Address addr) -> Reko.Core.Memory.EndianImageReader
abstract Reko.Core.Memory.MemoryArea.CreateLeReader(Reko.Core.Address addr, long cUnits) -> Reko.Core.Memory.EndianImageReader
abstract Reko.Core.Memory.MemoryArea.CreateLeWriter(long offset) -> Reko.Core.Memory.LeImageWriter
abstract Reko.Core.Memory.MemoryArea.CreateLeWriter(Reko.Core.Address addr) -> Reko.Core.Memory.LeImageWriter
abstract Reko.Core.Memory.MemoryArea.TryReadBe(long imageOffset, Reko.Core.Types.DataType type, out Reko.Core.Expressions.Constant c) -> bool
abstract Reko.Core.Memory.MemoryArea.TryReadBeUInt16(long off, out ushort retvalue) -> bool
abstract Reko.Core.Memory.MemoryArea.TryReadBeUInt32(long off, out uint retvalue) -> bool
abstract Reko.Core.Memory.MemoryArea.TryReadBeUInt64(long off, out ulong retvalue) -> bool
abstract Reko.Core.Memory.MemoryArea.TryReadByte(long off, out byte b) -> bool
abstract Reko.Core.Memory.MemoryArea.TryReadLe(long imageOffset, Reko.Core.Types.DataType type, out Reko.Core.Expressions.Constant c) -> bool
abstract Reko.Core.Memory.MemoryArea.TryReadLeInt32(long off, out int retvalue) -> bool
abstract Reko.Core.Memory.MemoryArea.TryReadLeUInt16(long off, out ushort retvalue) -> bool
abstract Reko.Core.Memory.MemoryArea.TryReadLeUInt32(long off, out uint retvalue) -> bool
abstract Reko.Core.Memory.MemoryArea.TryReadLeUInt64(long off, out ulong retvalue) -> bool
abstract Reko.Core.Memory.MemoryArea.WriteBeUInt16(long off, ushort value) -> void
abstract Reko.Core.Memory.MemoryArea.WriteBeUInt32(long off, uint value) -> void
abstract Reko.Core.Memory.MemoryArea.WriteByte(long off, byte value) -> void
abstract Reko.Core.Memory.MemoryArea.WriteLeUInt16(long off, ushort value) -> void
abstract Reko.Core.Memory.MemoryArea.WriteLeUInt32(long off, uint value) -> void
abstract Reko.Core.MetadataLoader.Load(Reko.Core.IPlatform platform, Reko.Core.TypeLibrary dstLib) -> Reko.Core.TypeLibrary
abstract Reko.Core.Operators.ConditionalOperator.Negate() -> Reko.Core.Operators.Operator
abstract Reko.Core.Operators.UnaryOperator.ApplyConstant(Reko.Core.Expressions.Constant c) -> Reko.Core.Expressions.Constant
abstract Reko.Core.Output.Formatter.Begin(object tag) -> void
abstract Reko.Core.Output.Formatter.Terminate() -> void
abstract Reko.Core.Output.Formatter.Write(char ch) -> Reko.Core.Output.Formatter
abstract Reko.Core.Output.Formatter.Write(string format, params object[] arguments) -> void
abstract Reko.Core.Output.Formatter.Write(string s) -> void
abstract Reko.Core.Output.Formatter.WriteComment(string comment) -> void
abstract Reko.Core.Output.Formatter.WriteHyperlink(string text, object href) -> void
abstract Reko.Core.Output.Formatter.WriteKeyword(string keyword) -> void
abstract Reko.Core.Output.Formatter.WriteLabel(string label, object block) -> void
abstract Reko.Core.Output.Formatter.WriteLine() -> void
abstract Reko.Core.Output.Formatter.WriteLine(string format, params object[] arguments) -> void
abstract Reko.Core.Output.Formatter.WriteLine(string s) -> void
abstract Reko.Core.Output.Formatter.WriteType(string typeName, Reko.Core.Types.DataType dt) -> void
abstract Reko.Core.Output.OutputFilePolicy.GetItemPlacements(string fileExtension) -> System.Collections.Generic.Dictionary<string, System.Collections.Generic.Dictionary<Reko.Core.ImageSegment, System.Collections.Generic.List<Reko.Core.ImageMapItem>>>
abstract Reko.Core.Output.OutputFilePolicy.GetObjectPlacements(string fileExtension, Reko.Core.Services.DecompilerEventListener listener) -> System.Collections.Generic.Dictionary<string, System.Collections.Generic.IDictionary<Reko.Core.Address, Reko.Core.IAddressable>>
abstract Reko.Core.Platform.CreateTrashedRegisters() -> System.Collections.Generic.HashSet<Reko.Core.RegisterStorage!>!
abstract Reko.Core.Platform.DefaultCallingConvention.get -> string
abstract Reko.Core.Platform.FindService(int vector, Reko.Core.ProcessorState state, Reko.Core.SegmentMap segmentMap) -> Reko.Core.SystemService
abstract Reko.Core.Platform.GetBitSizeFromCBasicType(Reko.Core.Hll.C.CBasicType cb) -> int
abstract Reko.Core.Platform.GetCallingConvention(string? ccName) -> Reko.Core.CallingConvention?
abstract Reko.Core.Platform.LookupProcedureByName(string moduleName, string procName) -> Reko.Core.ExternalProcedure
abstract Reko.Core.PointerScanner<T>.GetLinearAddress(Reko.Core.Address address) -> T
abstract Reko.Core.PointerScanner<T>.MatchCall(Reko.Core.Memory.EndianImageReader rdr, uint opcode, out T target) -> bool
abstract Reko.Core.PointerScanner<T>.MatchJump(Reko.Core.Memory.EndianImageReader rdr, uint opcode, out T target) -> bool
abstract Reko.Core.PointerScanner<T>.PointerAlignment.get -> int
abstract Reko.Core.PointerScanner<T>.TryPeekOpcode(Reko.Core.Memory.EndianImageReader rdr, out uint opcode) -> bool
abstract Reko.Core.PointerScanner<T>.TryPeekPointer(Reko.Core.Memory.EndianImageReader rdr, out T target) -> bool
abstract Reko.Core.ProcedureBase.Signature.get -> Reko.Core.Types.FunctionType
abstract Reko.Core.ProcedureBase.Signature.set -> void
abstract Reko.Core.ProcessorArchitecture.CreateDisassembler(Reko.Core.Memory.EndianImageReader imageReader) -> System.Collections.Generic.IEnumerable<Reko.Core.Machine.MachineInstruction>
abstract Reko.Core.ProcessorArchitecture.CreateInstructionComparer(Reko.Core.Normalize norm) -> System.Collections.Generic.IEqualityComparer<Reko.Core.Machine.MachineInstruction>
abstract Reko.Core.ProcessorArchitecture.CreatePointerScanner(Reko.Core.SegmentMap map, Reko.Core.Memory.EndianImageReader rdr, System.Collections.Generic.IEnumerable<Reko.Core.Address> knownAddresses, Reko.Core.PointerScannerFlags flags) -> System.Collections.Generic.IEnumerable<Reko.Core.Address>
abstract Reko.Core.ProcessorArchitecture.CreateProcessorState() -> Reko.Core.ProcessorState
abstract Reko.Core.ProcessorArchitecture.CreateRewriter(Reko.Core.Memory.EndianImageReader rdr, Reko.Core.ProcessorState state, Reko.Core.IStorageBinder binder, Reko.Core.IRewriterHost host) -> System.Collections.Generic.IEnumerable<Reko.Core.Rtl.RtlInstructionCluster>
abstract Reko.Core.ProcessorArchitecture.GetFlagGroup(Reko.Core.RegisterStorage flagRegister, uint grf) -> Reko.Core.FlagGroupStorage
abstract Reko.Core.ProcessorArchitecture.GetFlagGroup(string name) -> Reko.Core.FlagGroupStorage
abstract Reko.Core.ProcessorArchitecture.GetMnemonicNames() -> System.Collections.Generic.SortedList<string, int>
abstract Reko.Core.ProcessorArchitecture.GetMnemonicNumber(string name) -> int?
abstract Reko.Core.ProcessorArchitecture.GetRegister(Reko.Core.StorageDomain domain, Reko.Core.BitRange range) -> Reko.Core.RegisterStorage
abstract Reko.Core.ProcessorArchitecture.GetRegister(string name) -> Reko.Core.RegisterStorage
abstract Reko.Core.ProcessorArchitecture.GetRegisters() -> Reko.Core.RegisterStorage[]
abstract Reko.Core.ProcessorArchitecture.GrfToString(Reko.Core.RegisterStorage flagRegister, string prefix, uint grf) -> string
abstract Reko.Core.ProcessorArchitecture.MakeAddressFromConstant(Reko.Core.Expressions.Constant c, bool codeAlign) -> Reko.Core.Address
abstract Reko.Core.ProcessorArchitecture.ReadCodeAddress(int size, Reko.Core.Memory.EndianImageReader rdr, Reko.Core.ProcessorState state) -> Reko.Core.Address
abstract Reko.Core.ProcessorArchitecture.TryGetRegister(string name, out Reko.Core.RegisterStorage reg) -> bool
abstract Reko.Core.ProcessorArchitecture.TryParseAddress(string txtAddr, out Reko.Core.Address addr) -> bool
abstract Reko.Core.ProcessorState.Architecture.get -> Reko.Core.IProcessorArchitecture
abstract Reko.Core.ProcessorState.Clone() -> Reko.Core.ProcessorState
abstract Reko.Core.ProcessorState.GetRegister(Reko.Core.RegisterStorage r) -> Reko.Core.Expressions.Constant
abstract Reko.Core.ProcessorState.OnAfterCall(Reko.Core.Types.FunctionType sigCallee) -> void
abstract Reko.Core.ProcessorState.OnBeforeCall(Reko.Core.Expressions.Identifier stackReg, int returnAddressSize) -> Reko.Core.Code.CallSite
abstract Reko.Core.ProcessorState.OnProcedureEntered() -> void
abstract Reko.Core.ProcessorState.OnProcedureLeft(Reko.Core.Types.FunctionType procedureSignature) -> void
abstract Reko.Core.ProcessorState.SetRegister(Reko.Core.RegisterStorage r, Reko.Core.Expressions.Constant v) -> void
abstract Reko.Core.ProjectFile.Accept<T>(Reko.Core.IProjectFileVisitor<T> visitor) -> T
abstract Reko.Core.Rtl.RtlInstruction.Accept<T>(Reko.Core.Rtl.RtlInstructionVisitor<T> visitor) -> T
abstract Reko.Core.Rtl.RtlInstruction.WriteInner(System.IO.TextWriter writer) -> void
abstract Reko.Core.Scripts.ScriptFile.Evaluate(string script) -> void
abstract Reko.Core.Scripts.ScriptFile.FireEvent(Reko.Core.Scripts.ScriptEvent event, Reko.Core.Program program) -> void
abstract Reko.Core.Serialization.SerializedKind.Deserialize(Reko.Core.Serialization.ArgumentDeserializer sser) -> Reko.Core.Expressions.Identifier
abstract Reko.Core.Serialization.SerializedProject.Accept<T>(Reko.Core.Serialization.ISerializedProjectVisitor<T> visitor) -> T
abstract Reko.Core.Serialization.SerializedType.Accept<T>(Reko.Core.Serialization.ISerializedTypeVisitor<T> visitor) -> T
abstract Reko.Core.Storage.Accept<T, C>(Reko.Core.StorageVisitor<T, C> visitor, C context) -> T
abstract Reko.Core.Storage.Accept<T>(Reko.Core.StorageVisitor<T> visitor) -> T
abstract Reko.Core.Storage.Covers(Reko.Core.Storage that) -> bool
abstract Reko.Core.Storage.OffsetOf(Reko.Core.Storage storage) -> int
abstract Reko.Core.Storage.OverlapsWith(Reko.Core.Storage that) -> bool
abstract Reko.Core.Storage.Write(System.IO.TextWriter writer) -> void
abstract Reko.Core.Types.DataType.Accept(Reko.Core.Types.IDataTypeVisitor v) -> void
abstract Reko.Core.Types.DataType.Accept<T>(Reko.Core.Types.IDataTypeVisitor<T> v) -> T
abstract Reko.Core.Types.DataType.Clone(System.Collections.Generic.IDictionary<Reko.Core.Types.DataType, Reko.Core.Types.DataType> clonedTypes) -> Reko.Core.Types.DataType
abstract Reko.Core.Types.DataType.Size.get -> int
abstract Reko.Core.Types.DataType.Size.set -> void
abstract Reko.Core.Types.Field.Name.get -> string
abstract Reko.Core.Types.Field.Name.set -> void
const Reko.AssemblyMetadata.AssemblyFileVersion = "0.11.2.0" -> string
const Reko.AssemblyMetadata.AssemblyVersion = "0.11.2.0" -> string
const Reko.AssemblyMetadata.Company = "John Källén Konsult AB" -> string
const Reko.AssemblyMetadata.Copyright = "Copyright © 1999-2022 John Källén" -> string
const Reko.AssemblyMetadata.Product = "Reko decompiler" -> string
const Reko.Core.IntrinsicProcedure.Align = "__align" -> string
const Reko.Core.IntrinsicProcedure.LwL = "__lwl" -> string
const Reko.Core.IntrinsicProcedure.LwR = "__lwr" -> string
const Reko.Core.IntrinsicProcedure.SwL = "__swl" -> string
const Reko.Core.IntrinsicProcedure.SwR = "__swr" -> string
const Reko.Core.IntrinsicProcedure.Syscall = "__syscall" -> string
const Reko.Core.Lib.Float80.MaxExponent = 32767 -> ushort
const Reko.Core.Lib.Float80.SignBit = 32768 -> ushort
const Reko.Core.Lib.Float96.MaxExponent = 32767 -> ushort
const Reko.Core.Lib.Float96.SignBit = 32768 -> ushort
const Reko.Core.ProcessorOption.Endianness = "Endianness" -> string
const Reko.Core.ProcessorOption.InstructionSet = "ISA" -> string
const Reko.Core.ProcessorOption.Model = "Model" -> string
const Reko.Core.ProcessorOption.WordSize = "WordSize" -> string
const Reko.Core.Program.SegmentFilePolicy = "Segment" -> string
const Reko.Core.Program.SingleFilePolicy = "SingleFile" -> string
const Reko.Core.Serialization.GlobalVariable_v1.NoOrdinal = -1 -> int
const Reko.Core.Serialization.ProcedureBase_v1.NoOrdinal = -1 -> int
const Reko.Core.Serialization.Project_v4.FileExtension = ".dcproject" -> string
const Reko.Core.Serialization.Project_v5.FileExtension = ".dcproject" -> string
const Reko.Core.Serialization.SerializedLibrary.Namespace_v1 = "http://schemata.jklnet.org/Decompiler" -> string
const Reko.Core.Serialization.SerializedLibrary.Namespace_v4 = "http://schemata.jklnet.org/Reko/v4" -> string
const Reko.Core.Serialization.SerializedLibrary.Namespace_v5 = "http://schemata.jklnet.org/Reko/v5" -> string
const Reko.Core.Serialization.StringType_v2.MsbTermination = "m" -> string
const Reko.Core.Serialization.StringType_v2.ZeroTermination = "z" -> string
const Reko.Core.Types.DataType.BitsPerByte = 8 -> int
const Reko.Core.UserProcedure.NoOrdinal = -1 -> int
override Reko.Core.Absyn.AbsynAssignment.Accept(Reko.Core.Absyn.IAbsynVisitor! visitor) -> void
override Reko.Core.Absyn.AbsynAssignment.Accept<T>(Reko.Core.Absyn.IAbsynVisitor<T>! visitor) -> T
override Reko.Core.Absyn.AbsynBreak.Accept(Reko.Core.Absyn.IAbsynVisitor! visitor) -> void
override Reko.Core.Absyn.AbsynBreak.Accept<T>(Reko.Core.Absyn.IAbsynVisitor<T>! visitor) -> T
override Reko.Core.Absyn.AbsynCase.Accept(Reko.Core.Absyn.IAbsynVisitor! visitor) -> void
override Reko.Core.Absyn.AbsynCase.Accept<T>(Reko.Core.Absyn.IAbsynVisitor<T>! visitor) -> T
override Reko.Core.Absyn.AbsynCompoundAssignment.Accept(Reko.Core.Absyn.IAbsynVisitor! visitor) -> void
override Reko.Core.Absyn.AbsynCompoundAssignment.Accept<T>(Reko.Core.Absyn.IAbsynVisitor<T>! visitor) -> T
override Reko.Core.Absyn.AbsynContinue.Accept(Reko.Core.Absyn.IAbsynVisitor! visitor) -> void
override Reko.Core.Absyn.AbsynContinue.Accept<T>(Reko.Core.Absyn.IAbsynVisitor<T>! visitor) -> T
override Reko.Core.Absyn.AbsynDeclaration.Accept(Reko.Core.Absyn.IAbsynVisitor visitor) -> void
override Reko.Core.Absyn.AbsynDeclaration.Accept<T>(Reko.Core.Absyn.IAbsynVisitor<T> visitor) -> T
override Reko.Core.Absyn.AbsynDefault.Accept(Reko.Core.Absyn.IAbsynVisitor! visitor) -> void
override Reko.Core.Absyn.AbsynDefault.Accept<T>(Reko.Core.Absyn.IAbsynVisitor<T>! visitor) -> T
override Reko.Core.Absyn.AbsynDoWhile.Accept(Reko.Core.Absyn.IAbsynVisitor visitor) -> void
override Reko.Core.Absyn.AbsynDoWhile.Accept<T>(Reko.Core.Absyn.IAbsynVisitor<T> visitor) -> T
override Reko.Core.Absyn.AbsynFor.Accept(Reko.Core.Absyn.IAbsynVisitor visitor) -> void
override Reko.Core.Absyn.AbsynFor.Accept<T>(Reko.Core.Absyn.IAbsynVisitor<T> visitor) -> T
override Reko.Core.Absyn.AbsynGoto.Accept(Reko.Core.Absyn.IAbsynVisitor visitor) -> void
override Reko.Core.Absyn.AbsynGoto.Accept<T>(Reko.Core.Absyn.IAbsynVisitor<T> visitor) -> T
override Reko.Core.Absyn.AbsynIf.Accept(Reko.Core.Absyn.IAbsynVisitor v) -> void
override Reko.Core.Absyn.AbsynIf.Accept<T>(Reko.Core.Absyn.IAbsynVisitor<T> visitor) -> T
override Reko.Core.Absyn.AbsynLabel.Accept(Reko.Core.Absyn.IAbsynVisitor visitor) -> void
override Reko.Core.Absyn.AbsynLabel.Accept<T>(Reko.Core.Absyn.IAbsynVisitor<T> visitor) -> T
override Reko.Core.Absyn.AbsynLineComment.Accept(Reko.Core.Absyn.IAbsynVisitor visitor) -> void
override Reko.Core.Absyn.AbsynLineComment.Accept<T>(Reko.Core.Absyn.IAbsynVisitor<T> visitor) -> T
override Reko.Core.Absyn.AbsynReturn.Accept(Reko.Core.Absyn.IAbsynVisitor visitor) -> void
override Reko.Core.Absyn.AbsynReturn.Accept<T>(Reko.Core.Absyn.IAbsynVisitor<T> visitor) -> T
override Reko.Core.Absyn.AbsynSideEffect.Accept(Reko.Core.Absyn.IAbsynVisitor visitor) -> void
override Reko.Core.Absyn.AbsynSideEffect.Accept<T>(Reko.Core.Absyn.IAbsynVisitor<T> visitor) -> T
override Reko.Core.Absyn.AbsynSwitch.Accept(Reko.Core.Absyn.IAbsynVisitor visitor) -> void
override Reko.Core.Absyn.AbsynSwitch.Accept<T>(Reko.Core.Absyn.IAbsynVisitor<T> visitor) -> T
override Reko.Core.Absyn.AbsynWhile.Accept(Reko.Core.Absyn.IAbsynVisitor visitor) -> void
override Reko.Core.Absyn.AbsynWhile.Accept<T>(Reko.Core.Absyn.IAbsynVisitor<T> visitor) -> T
override Reko.Core.Address.Accept(Reko.Core.Expressions.IExpressionVisitor visit) -> void
override Reko.Core.Address.Accept<T, C>(Reko.Core.Expressions.ExpressionVisitor<T, C> v, C context) -> T
override Reko.Core.Address.Accept<T>(Reko.Core.Expressions.ExpressionVisitor<T> v) -> T
override Reko.Core.Address.Children.get -> System.Collections.Generic.IEnumerable<Reko.Core.Expressions.Expression>
override Reko.Core.Address.Equals(object obj) -> bool
override Reko.Core.Address.GetHashCode() -> int
override Reko.Core.Address32.Add(long offset) -> Reko.Core.Address
override Reko.Core.Address32.Align(int alignment) -> Reko.Core.Address
override Reko.Core.Address32.CloneExpression() -> Reko.Core.Expressions.Expression
override Reko.Core.Address32.GenerateName(string prefix, string suffix) -> string
override Reko.Core.Address32.IsNull.get -> bool
override Reko.Core.Address32.NewOffset(ulong offset) -> Reko.Core.Address
override Reko.Core.Address32.Offset.get -> ulong
override Reko.Core.Address32.Selector.get -> ushort?
override Reko.Core.Address32.ToConstant() -> Reko.Core.Expressions.Constant
override Reko.Core.Address32.ToLinear() -> ulong
override Reko.Core.Address32.ToString() -> string
override Reko.Core.Address32.ToUInt16() -> ushort
override Reko.Core.Address32.ToUInt32() -> uint
override Reko.Core.Address64.Add(long offset) -> Reko.Core.Address
override Reko.Core.Address64.Align(int alignment) -> Reko.Core.Address
override Reko.Core.Address64.CloneExpression() -> Reko.Core.Expressions.Expression
override Reko.Core.Address64.GenerateName(string prefix, string suffix) -> string
override Reko.Core.Address64.IsNull.get -> bool
override Reko.Core.Address64.NewOffset(ulong offset) -> Reko.Core.Address
override Reko.Core.Address64.Offset.get -> ulong
override Reko.Core.Address64.Selector.get -> ushort?
override Reko.Core.Address64.ToConstant() -> Reko.Core.Expressions.Constant
override Reko.Core.Address64.ToLinear() -> ulong
override Reko.Core.Address64.ToString() -> string
override Reko.Core.Address64.ToUInt16() -> ushort
override Reko.Core.Address64.ToUInt32() -> uint
override Reko.Core.Assemblers.Symbol.ToString() -> string
override Reko.Core.BitRange.Equals(object obj) -> bool
override Reko.Core.BitRange.GetHashCode() -> int
override Reko.Core.BitRange.ToString() -> string
override Reko.Core.Block.ToString() -> string
override Reko.Core.CallingConventionEmitter.ToString() -> string
override Reko.Core.CHeaderLoader.Load(Reko.Core.IPlatform platform, Reko.Core.TypeLibrary dstLib) -> Reko.Core.TypeLibrary
override Reko.Core.Code.AliasAssignment.IsAlias.get -> bool
override Reko.Core.Code.Assignment.Accept(Reko.Core.Code.InstructionTransformer xform) -> Reko.Core.Code.Instruction
override Reko.Core.Code.Assignment.Accept(Reko.Core.Code.InstructionVisitor v) -> void
override Reko.Core.Code.Assignment.Accept<T, C>(Reko.Core.Code.InstructionVisitor<T, C> visitor, C ctx) -> T
override Reko.Core.Code.Assignment.Accept<T>(Reko.Core.Code.InstructionVisitor<T> visitor) -> T
override Reko.Core.Code.Assignment.IsControlFlow.get -> bool
override Reko.Core.Code.Branch.Accept(Reko.Core.Code.InstructionTransformer xform) -> Reko.Core.Code.Instruction
override Reko.Core.Code.Branch.Accept(Reko.Core.Code.InstructionVisitor v) -> void
override Reko.Core.Code.Branch.Accept<T, C>(Reko.Core.Code.InstructionVisitor<T, C> visitor, C ctx) -> T
override Reko.Core.Code.Branch.Accept<T>(Reko.Core.Code.InstructionVisitor<T> visitor) -> T
override Reko.Core.Code.Branch.IsControlFlow.get -> bool
override Reko.Core.Code.CallBinding.ToString() -> string
override Reko.Core.Code.CallInstruction.Accept(Reko.Core.Code.InstructionTransformer xform) -> Reko.Core.Code.Instruction
override Reko.Core.Code.CallInstruction.Accept(Reko.Core.Code.InstructionVisitor v) -> void
override Reko.Core.Code.CallInstruction.Accept<T, C>(Reko.Core.Code.InstructionVisitor<T, C> visitor, C ctx) -> T
override Reko.Core.Code.CallInstruction.Accept<T>(Reko.Core.Code.InstructionVisitor<T> visitor) -> T
override Reko.Core.Code.CallInstruction.IsControlFlow.get -> bool
override Reko.Core.Code.CallSite.ToString() -> string
override Reko.Core.Code.CodeComment.Accept(Reko.Core.Code.InstructionTransformer xform) -> Reko.Core.Code.Instruction
override Reko.Core.Code.CodeComment.Accept(Reko.Core.Code.InstructionVisitor v) -> void
override Reko.Core.Code.CodeComment.Accept<T, C>(Reko.Core.Code.InstructionVisitor<T, C> visitor, C ctx) -> T
override Reko.Core.Code.CodeComment.Accept<T>(Reko.Core.Code.InstructionVisitor<T> visitor) -> T
override Reko.Core.Code.CodeComment.IsControlFlow.get -> bool
override Reko.Core.Code.Declaration.Accept(Reko.Core.Code.InstructionTransformer xform) -> Reko.Core.Code.Instruction
override Reko.Core.Code.Declaration.Accept(Reko.Core.Code.InstructionVisitor v) -> void
override Reko.Core.Code.Declaration.Accept<T, C>(Reko.Core.Code.InstructionVisitor<T, C> visitor, C ctx) -> T
override Reko.Core.Code.Declaration.Accept<T>(Reko.Core.Code.InstructionVisitor<T> visitor) -> T
override Reko.Core.Code.Declaration.IsControlFlow.get -> bool
override Reko.Core.Code.DefInstruction.Accept(Reko.Core.Code.InstructionTransformer xform) -> Reko.Core.Code.Instruction
override Reko.Core.Code.DefInstruction.Accept(Reko.Core.Code.InstructionVisitor v) -> void
override Reko.Core.Code.DefInstruction.Accept<T, C>(Reko.Core.Code.InstructionVisitor<T, C> visitor, C ctx) -> T
override Reko.Core.Code.DefInstruction.Accept<T>(Reko.Core.Code.InstructionVisitor<T> visitor) -> T
override Reko.Core.Code.DefInstruction.IsControlFlow.get -> bool
override Reko.Core.Code.GotoInstruction.Accept(Reko.Core.Code.InstructionTransformer xform) -> Reko.Core.Code.Instruction
override Reko.Core.Code.GotoInstruction.Accept(Reko.Core.Code.InstructionVisitor v) -> void
override Reko.Core.Code.GotoInstruction.Accept<T, C>(Reko.Core.Code.InstructionVisitor<T, C> visitor, C ctx) -> T
override Reko.Core.Code.GotoInstruction.Accept<T>(Reko.Core.Code.InstructionVisitor<T> visitor) -> T
override Reko.Core.Code.GotoInstruction.IsControlFlow.get -> bool
override Reko.Core.Code.IdentifierCollector.VisitIdentifier(Reko.Core.Expressions.Identifier id) -> void
override Reko.Core.Code.Instruction.ToString() -> string
override Reko.Core.Code.PhiAssignment.Accept(Reko.Core.Code.InstructionTransformer xform) -> Reko.Core.Code.Instruction
override Reko.Core.Code.PhiAssignment.Accept(Reko.Core.Code.InstructionVisitor v) -> void
override Reko.Core.Code.PhiAssignment.Accept<T, C>(Reko.Core.Code.InstructionVisitor<T, C> visitor, C ctx) -> T
override Reko.Core.Code.PhiAssignment.Accept<T>(Reko.Core.Code.InstructionVisitor<T> visitor) -> T
override Reko.Core.Code.PhiAssignment.IsControlFlow.get -> bool
override Reko.Core.Code.ReturnInstruction.Accept(Reko.Core.Code.InstructionTransformer xform) -> Reko.Core.Code.Instruction
override Reko.Core.Code.ReturnInstruction.Accept(Reko.Core.Code.InstructionVisitor v) -> void
override Reko.Core.Code.ReturnInstruction.Accept<T, C>(Reko.Core.Code.InstructionVisitor<T, C> visitor, C ctx) -> T
override Reko.Core.Code.ReturnInstruction.Accept<T>(Reko.Core.Code.InstructionVisitor<T> visitor) -> T
override Reko.Core.Code.ReturnInstruction.IsControlFlow.get -> bool
override Reko.Core.Code.SideEffect.Accept(Reko.Core.Code.InstructionTransformer xform) -> Reko.Core.Code.Instruction
override Reko.Core.Code.SideEffect.Accept(Reko.Core.Code.InstructionVisitor v) -> void
override Reko.Core.Code.SideEffect.Accept<T, C>(Reko.Core.Code.InstructionVisitor<T, C> visitor, C ctx) -> T
override Reko.Core.Code.SideEffect.Accept<T>(Reko.Core.Code.InstructionVisitor<T> visitor) -> T
override Reko.Core.Code.SideEffect.IsControlFlow.get -> bool
override Reko.Core.Code.Store.Accept(Reko.Core.Code.InstructionTransformer xform) -> Reko.Core.Code.Instruction
override Reko.Core.Code.Store.Accept(Reko.Core.Code.InstructionVisitor v) -> void
override Reko.Core.Code.Store.Accept<T, C>(Reko.Core.Code.InstructionVisitor<T, C> visitor, C ctx) -> T
override Reko.Core.Code.Store.Accept<T>(Reko.Core.Code.InstructionVisitor<T> visitor) -> T
override Reko.Core.Code.Store.IsControlFlow.get -> bool
override Reko.Core.Code.SwitchInstruction.Accept(Reko.Core.Code.InstructionTransformer xform) -> Reko.Core.Code.Instruction
override Reko.Core.Code.SwitchInstruction.Accept(Reko.Core.Code.InstructionVisitor v) -> void
override Reko.Core.Code.SwitchInstruction.Accept<T, C>(Reko.Core.Code.InstructionVisitor<T, C> visitor, C ctx) -> T
override Reko.Core.Code.SwitchInstruction.Accept<T>(Reko.Core.Code.InstructionVisitor<T> visitor) -> T
override Reko.Core.Code.SwitchInstruction.IsControlFlow.get -> bool
override Reko.Core.Code.UseInstruction.Accept(Reko.Core.Code.InstructionTransformer xform) -> Reko.Core.Code.Instruction
override Reko.Core.Code.UseInstruction.Accept(Reko.Core.Code.InstructionVisitor v) -> void
override Reko.Core.Code.UseInstruction.Accept<T, C>(Reko.Core.Code.InstructionVisitor<T, C> visitor, C ctx) -> T
override Reko.Core.Code.UseInstruction.Accept<T>(Reko.Core.Code.InstructionVisitor<T> visitor) -> T
override Reko.Core.Code.UseInstruction.IsControlFlow.get -> bool
override Reko.Core.Collections.BTreeDictionary<TKey, TValue>.KeyCollection.Contains(TKey item) -> bool
override Reko.Core.Collections.BTreeDictionary<TKey, TValue>.KeyCollection.CopyTo(TKey[] array, int arrayIndex) -> void
override Reko.Core.Collections.BTreeDictionary<TKey, TValue>.KeyCollection.GetEnumerator() -> System.Collections.Generic.IEnumerator<TKey>
override Reko.Core.Collections.BTreeDictionary<TKey, TValue>.KeyCollection.this[int index].get -> TKey
override Reko.Core.Collections.BTreeDictionary<TKey, TValue>.ValueCollection.Contains(TValue item) -> bool
override Reko.Core.Collections.BTreeDictionary<TKey, TValue>.ValueCollection.CopyTo(TValue[] array, int arrayIndex) -> void
override Reko.Core.Collections.BTreeDictionary<TKey, TValue>.ValueCollection.GetEnumerator() -> System.Collections.Generic.IEnumerator<TValue>
override Reko.Core.Collections.BTreeDictionary<TKey, TValue>.ValueCollection.this[int index].get -> TValue
override Reko.Core.Collections.ConcurrentBTreeDictionary<TKey, TValue>.KeyCollection.Contains(TKey item) -> bool
override Reko.Core.Collections.ConcurrentBTreeDictionary<TKey, TValue>.KeyCollection.CopyTo(TKey[] array, int arrayIndex) -> void
override Reko.Core.Collections.ConcurrentBTreeDictionary<TKey, TValue>.KeyCollection.GetEnumerator() -> System.Collections.Generic.IEnumerator<TKey>
override Reko.Core.Collections.ConcurrentBTreeDictionary<TKey, TValue>.KeyCollection.this[int index].get -> TKey
override Reko.Core.Collections.ConcurrentBTreeDictionary<TKey, TValue>.ValueCollection.Contains(TValue item) -> bool
override Reko.Core.Collections.ConcurrentBTreeDictionary<TKey, TValue>.ValueCollection.CopyTo(TValue[] array, int arrayIndex) -> void
override Reko.Core.Collections.ConcurrentBTreeDictionary<TKey, TValue>.ValueCollection.GetEnumerator() -> System.Collections.Generic.IEnumerator<TValue>
override Reko.Core.Collections.ConcurrentBTreeDictionary<TKey, TValue>.ValueCollection.this[int index].get -> TValue
override Reko.Core.Collections.Interval<T>.Equals(object obj) -> bool
override Reko.Core.Collections.Interval<T>.GetHashCode() -> int
override Reko.Core.Collections.Interval<T>.ToString() -> string
override Reko.Core.Collections.LinqAlgorithms.Item.ToString() -> string
override Reko.Core.Configuration.ListOption_v1.ToString() -> string
override Reko.Core.Configuration.PlatformDefinition.ToString() -> string
override Reko.Core.Configuration.PropertyOption.ToString() -> string
override Reko.Core.DefaultPlatform.CreateTrashedRegisters() -> System.Collections.Generic.HashSet<Reko.Core.RegisterStorage!>!
override Reko.Core.DefaultPlatform.DefaultCallingConvention.get -> string
override Reko.Core.DefaultPlatform.FindService(int vector, Reko.Core.ProcessorState? state, Reko.Core.SegmentMap? segmentMap) -> Reko.Core.SystemService?
override Reko.Core.DefaultPlatform.GetBitSizeFromCBasicType(Reko.Core.Hll.C.CBasicType cb) -> int
override Reko.Core.DefaultPlatform.GetCallingConvention(string? ccName) -> Reko.Core.CallingConvention?
override Reko.Core.DefaultPlatform.LookupProcedureByName(string moduleName, string procName) -> Reko.Core.ExternalProcedure
override Reko.Core.DefaultProcessorState.Architecture.get -> Reko.Core.IProcessorArchitecture
override Reko.Core.DefaultProcessorState.Clone() -> Reko.Core.ProcessorState
override Reko.Core.DefaultProcessorState.GetRegister(Reko.Core.RegisterStorage r) -> Reko.Core.Expressions.Constant
override Reko.Core.DefaultProcessorState.OnAfterCall(Reko.Core.Types.FunctionType sigCallee) -> void
override Reko.Core.DefaultProcessorState.OnBeforeCall(Reko.Core.Expressions.Identifier stackReg, int returnAddressSize) -> Reko.Core.Code.CallSite
override Reko.Core.DefaultProcessorState.OnProcedureEntered() -> void
override Reko.Core.DefaultProcessorState.OnProcedureLeft(Reko.Core.Types.FunctionType procedureSignature) -> void
override Reko.Core.DefaultProcessorState.SetRegister(Reko.Core.RegisterStorage r, Reko.Core.Expressions.Constant v) -> void
override Reko.Core.Dfa.TreeNode.ToString() -> string
override Reko.Core.DispatchProcedure.Signature.get -> Reko.Core.Types.FunctionType
override Reko.Core.DispatchProcedure.Signature.set -> void
override Reko.Core.ErrorDiagnostic.ImageKey.get -> string
override Reko.Core.Expressions.Application.Accept(Reko.Core.Expressions.IExpressionVisitor v) -> void
override Reko.Core.Expressions.Application.Accept<T, C>(Reko.Core.Expressions.ExpressionVisitor<T, C> v, C context) -> T
override Reko.Core.Expressions.Application.Accept<T>(Reko.Core.Expressions.ExpressionVisitor<T> v) -> T
override Reko.Core.Expressions.Application.Children.get -> System.Collections.Generic.IEnumerable<Reko.Core.Expressions.Expression>
override Reko.Core.Expressions.Application.CloneExpression() -> Reko.Core.Expressions.Expression
override Reko.Core.Expressions.Application.Invert() -> Reko.Core.Expressions.Expression
override Reko.Core.Expressions.ArrayAccess.Accept(Reko.Core.Expressions.IExpressionVisitor visit) -> void
override Reko.Core.Expressions.ArrayAccess.Accept<T, C>(Reko.Core.Expressions.ExpressionVisitor<T, C> v, C context) -> T
override Reko.Core.Expressions.ArrayAccess.Accept<T>(Reko.Core.Expressions.ExpressionVisitor<T> v) -> T
override Reko.Core.Expressions.ArrayAccess.Children.get -> System.Collections.Generic.IEnumerable<Reko.Core.Expressions.Expression>
override Reko.Core.Expressions.ArrayAccess.CloneExpression() -> Reko.Core.Expressions.Expression
override Reko.Core.Expressions.BigConstant.CloneExpression() -> Reko.Core.Expressions.Expression
override Reko.Core.Expressions.BigConstant.Complement() -> Reko.Core.Expressions.Constant
override Reko.Core.Expressions.BigConstant.DoSlice(Reko.Core.Types.DataType dt, int offset) -> Reko.Core.Expressions.Constant
override Reko.Core.Expressions.BigConstant.GetHashOfValue() -> int
override Reko.Core.Expressions.BigConstant.GetValue() -> object
override Reko.Core.Expressions.BigConstant.IsIntegerOne.get -> bool
override Reko.Core.Expressions.BigConstant.IsIntegerZero.get -> bool
override Reko.Core.Expressions.BigConstant.IsMaxUnsigned.get -> bool
override Reko.Core.Expressions.BigConstant.IsZero.get -> bool
override Reko.Core.Expressions.BigConstant.Negate() -> Reko.Core.Expressions.Constant
override Reko.Core.Expressions.BigConstant.ToBigInteger() -> System.Numerics.BigInteger
override Reko.Core.Expressions.BigConstant.ToByte() -> byte
override Reko.Core.Expressions.BigConstant.ToInt16() -> short
override Reko.Core.Expressions.BigConstant.ToInt32() -> int
override Reko.Core.Expressions.BigConstant.ToInt64() -> long
override Reko.Core.Expressions.BigConstant.ToUInt16() -> ushort
override Reko.Core.Expressions.BigConstant.ToUInt32() -> uint
override Reko.Core.Expressions.BigConstant.ToUInt64() -> ulong
override Reko.Core.Expressions.BinaryExpression.Accept(Reko.Core.Expressions.IExpressionVisitor v) -> void
override Reko.Core.Expressions.BinaryExpression.Accept<T, C>(Reko.Core.Expressions.ExpressionVisitor<T, C> v, C context) -> T
override Reko.Core.Expressions.BinaryExpression.Accept<T>(Reko.Core.Expressions.ExpressionVisitor<T> v) -> T
override Reko.Core.Expressions.BinaryExpression.Children.get -> System.Collections.Generic.IEnumerable<Reko.Core.Expressions.Expression>
override Reko.Core.Expressions.BinaryExpression.CloneExpression() -> Reko.Core.Expressions.Expression
override Reko.Core.Expressions.BinaryExpression.Invert() -> Reko.Core.Expressions.Expression
override Reko.Core.Expressions.Cast.Accept(Reko.Core.Expressions.IExpressionVisitor visit) -> void
override Reko.Core.Expressions.Cast.Accept<T, C>(Reko.Core.Expressions.ExpressionVisitor<T, C> v, C context) -> T
override Reko.Core.Expressions.Cast.Accept<T>(Reko.Core.Expressions.ExpressionVisitor<T> v) -> T
override Reko.Core.Expressions.Cast.Children.get -> System.Collections.Generic.IEnumerable<Reko.Core.Expressions.Expression>
override Reko.Core.Expressions.Cast.CloneExpression() -> Reko.Core.Expressions.Expression
override Reko.Core.Expressions.Cast.Invert() -> Reko.Core.Expressions.Expression
override Reko.Core.Expressions.ConditionalExpression.Accept(Reko.Core.Expressions.IExpressionVisitor visitor) -> void
override Reko.Core.Expressions.ConditionalExpression.Accept<T, C>(Reko.Core.Expressions.ExpressionVisitor<T, C> visitor, C context) -> T
override Reko.Core.Expressions.ConditionalExpression.Accept<T>(Reko.Core.Expressions.ExpressionVisitor<T> visitor) -> T
override Reko.Core.Expressions.ConditionalExpression.Children.get -> System.Collections.Generic.IEnumerable<Reko.Core.Expressions.Expression>
override Reko.Core.Expressions.ConditionalExpression.CloneExpression() -> Reko.Core.Expressions.Expression
override Reko.Core.Expressions.ConditionOf.Accept(Reko.Core.Expressions.IExpressionVisitor v) -> void
override Reko.Core.Expressions.ConditionOf.Accept<T, C>(Reko.Core.Expressions.ExpressionVisitor<T, C> v, C context) -> T
override Reko.Core.Expressions.ConditionOf.Accept<T>(Reko.Core.Expressions.ExpressionVisitor<T> visitor) -> T
override Reko.Core.Expressions.ConditionOf.Children.get -> System.Collections.Generic.IEnumerable<Reko.Core.Expressions.Expression>
override Reko.Core.Expressions.ConditionOf.CloneExpression() -> Reko.Core.Expressions.Expression
override Reko.Core.Expressions.Constant.Accept(Reko.Core.Expressions.IExpressionVisitor v) -> void
override Reko.Core.Expressions.Constant.Accept<T, C>(Reko.Core.Expressions.ExpressionVisitor<T, C> v, C context) -> T
override Reko.Core.Expressions.Constant.Accept<T>(Reko.Core.Expressions.ExpressionVisitor<T> v) -> T
override Reko.Core.Expressions.Constant.Children.get -> System.Collections.Generic.IEnumerable<Reko.Core.Expressions.Expression>
override Reko.Core.Expressions.Constant.IsZero.get -> bool
override Reko.Core.Expressions.ConstantReal.IsIntegerOne.get -> bool
override Reko.Core.Expressions.ConstantReal16.CloneExpression() -> Reko.Core.Expressions.Expression
override Reko.Core.Expressions.ConstantReal16.Complement() -> Reko.Core.Expressions.Constant
override Reko.Core.Expressions.ConstantReal16.DoSlice(Reko.Core.Types.DataType dt, int offset) -> Reko.Core.Expressions.Constant
override Reko.Core.Expressions.ConstantReal16.GetHashOfValue() -> int
override Reko.Core.Expressions.ConstantReal16.GetValue() -> object
override Reko.Core.Expressions.ConstantReal16.IsValid.get -> bool
override Reko.Core.Expressions.ConstantReal16.Negate() -> Reko.Core.Expressions.Constant!
override Reko.Core.Expressions.ConstantReal16.ToBigInteger() -> System.Numerics.BigInteger
override Reko.Core.Expressions.ConstantReal16.ToByte() -> byte
override Reko.Core.Expressions.ConstantReal16.ToFloat() -> float
override Reko.Core.Expressions.ConstantReal16.ToInt16() -> short
override Reko.Core.Expressions.ConstantReal16.ToInt32() -> int
override Reko.Core.Expressions.ConstantReal16.ToInt64() -> long
override Reko.Core.Expressions.ConstantReal16.ToReal64() -> double
override Reko.Core.Expressions.ConstantReal16.ToUInt16() -> ushort
override Reko.Core.Expressions.ConstantReal16.ToUInt32() -> uint
override Reko.Core.Expressions.ConstantReal16.ToUInt64() -> ulong
override Reko.Core.Expressions.Conversion.Accept(Reko.Core.Expressions.IExpressionVisitor visitor) -> void
override Reko.Core.Expressions.Conversion.Accept<T, C>(Reko.Core.Expressions.ExpressionVisitor<T, C> visitor, C context) -> T
override Reko.Core.Expressions.Conversion.Accept<T>(Reko.Core.Expressions.ExpressionVisitor<T> visitor) -> T
override Reko.Core.Expressions.Conversion.Children.get -> System.Collections.Generic.IEnumerable<Reko.Core.Expressions.Expression>
override Reko.Core.Expressions.Conversion.CloneExpression() -> Reko.Core.Expressions.Expression
override Reko.Core.Expressions.Dereference.Accept(Reko.Core.Expressions.IExpressionVisitor visit) -> void
override Reko.Core.Expressions.Dereference.Accept<T, C>(Reko.Core.Expressions.ExpressionVisitor<T, C> v, C context) -> T
override Reko.Core.Expressions.Dereference.Accept<T>(Reko.Core.Expressions.ExpressionVisitor<T> v) -> T
override Reko.Core.Expressions.Dereference.Children.get -> System.Collections.Generic.IEnumerable<Reko.Core.Expressions.Expression>
override Reko.Core.Expressions.Dereference.CloneExpression() -> Reko.Core.Expressions.Expression
override Reko.Core.Expressions.Expression.ToString() -> string
override Reko.Core.Expressions.FieldAccess.Accept(Reko.Core.Expressions.IExpressionVisitor visit) -> void
override Reko.Core.Expressions.FieldAccess.Accept<T, C>(Reko.Core.Expressions.ExpressionVisitor<T, C> v, C context) -> T
override Reko.Core.Expressions.FieldAccess.Accept<T>(Reko.Core.Expressions.ExpressionVisitor<T> v) -> T
override Reko.Core.Expressions.FieldAccess.Children.get -> System.Collections.Generic.IEnumerable<Reko.Core.Expressions.Expression>
override Reko.Core.Expressions.FieldAccess.CloneExpression() -> Reko.Core.Expressions.Expression
override Reko.Core.Expressions.FieldAccess.Invert() -> Reko.Core.Expressions.Expression
override Reko.Core.Expressions.Identifier.Accept(Reko.Core.Expressions.IExpressionVisitor v) -> void
override Reko.Core.Expressions.Identifier.Accept<T, C>(Reko.Core.Expressions.ExpressionVisitor<T, C> v, C context) -> T
override Reko.Core.Expressions.Identifier.Accept<T>(Reko.Core.Expressions.ExpressionVisitor<T> v) -> T
override Reko.Core.Expressions.Identifier.Children.get -> System.Collections.Generic.IEnumerable<Reko.Core.Expressions.Expression>
override Reko.Core.Expressions.Identifier.CloneExpression() -> Reko.Core.Expressions.Expression
override Reko.Core.Expressions.Identifier.Invert() -> Reko.Core.Expressions.Expression
override Reko.Core.Expressions.InvalidConstant.CloneExpression() -> Reko.Core.Expressions.Expression
override Reko.Core.Expressions.InvalidConstant.Complement() -> Reko.Core.Expressions.Constant
override Reko.Core.Expressions.InvalidConstant.GetHashOfValue() -> int
override Reko.Core.Expressions.InvalidConstant.GetValue() -> object
override Reko.Core.Expressions.InvalidConstant.IsMaxUnsigned.get -> bool
override Reko.Core.Expressions.InvalidConstant.IsValid.get -> bool
override Reko.Core.Expressions.InvalidConstant.IsZero.get -> bool
override Reko.Core.Expressions.InvalidConstant.Slice(Reko.Core.Types.DataType dt, int offset) -> Reko.Core.Expressions.Constant
override Reko.Core.Expressions.InvalidConstant.ToBigInteger() -> System.Numerics.BigInteger
override Reko.Core.Expressions.InvalidConstant.ToByte() -> byte
override Reko.Core.Expressions.InvalidConstant.ToInt16() -> short
override Reko.Core.Expressions.InvalidConstant.ToInt32() -> int
override Reko.Core.Expressions.InvalidConstant.ToInt64() -> long
override Reko.Core.Expressions.InvalidConstant.ToUInt16() -> ushort
override Reko.Core.Expressions.InvalidConstant.ToUInt32() -> uint
override Reko.Core.Expressions.InvalidConstant.ToUInt64() -> ulong
override Reko.Core.Expressions.MemberPointerSelector.Accept(Reko.Core.Expressions.IExpressionVisitor visit) -> void
override Reko.Core.Expressions.MemberPointerSelector.Accept<T, C>(Reko.Core.Expressions.ExpressionVisitor<T, C> v, C context) -> T
override Reko.Core.Expressions.MemberPointerSelector.Accept<T>(Reko.Core.Expressions.ExpressionVisitor<T> v) -> T
override Reko.Core.Expressions.MemberPointerSelector.Children.get -> System.Collections.Generic.IEnumerable<Reko.Core.Expressions.Expression>
override Reko.Core.Expressions.MemberPointerSelector.CloneExpression() -> Reko.Core.Expressions.Expression
override Reko.Core.Expressions.MemoryAccess.Accept(Reko.Core.Expressions.IExpressionVisitor v) -> void
override Reko.Core.Expressions.MemoryAccess.Accept<T, C>(Reko.Core.Expressions.ExpressionVisitor<T, C> v, C context) -> T
override Reko.Core.Expressions.MemoryAccess.Accept<T>(Reko.Core.Expressions.ExpressionVisitor<T> v) -> T
override Reko.Core.Expressions.MemoryAccess.Children.get -> System.Collections.Generic.IEnumerable<Reko.Core.Expressions.Expression>
override Reko.Core.Expressions.MemoryAccess.CloneExpression() -> Reko.Core.Expressions.Expression
override Reko.Core.Expressions.MkSequence.Accept(Reko.Core.Expressions.IExpressionVisitor! visit) -> void
override Reko.Core.Expressions.MkSequence.Accept<T, C>(Reko.Core.Expressions.ExpressionVisitor<T, C>! v, C context) -> T
override Reko.Core.Expressions.MkSequence.Accept<T>(Reko.Core.Expressions.ExpressionVisitor<T>! v) -> T
override Reko.Core.Expressions.MkSequence.Children.get -> System.Collections.Generic.IEnumerable<Reko.Core.Expressions.Expression!>!
override Reko.Core.Expressions.MkSequence.CloneExpression() -> Reko.Core.Expressions.Expression!
override Reko.Core.Expressions.OutArgument.Accept(Reko.Core.Expressions.IExpressionVisitor visitor) -> void
override Reko.Core.Expressions.OutArgument.Accept<T, C>(Reko.Core.Expressions.ExpressionVisitor<T, C> v, C context) -> T
override Reko.Core.Expressions.OutArgument.Accept<T>(Reko.Core.Expressions.ExpressionVisitor<T> visitor) -> T
override Reko.Core.Expressions.OutArgument.Children.get -> System.Collections.Generic.IEnumerable<Reko.Core.Expressions.Expression>
override Reko.Core.Expressions.OutArgument.CloneExpression() -> Reko.Core.Expressions.Expression
override Reko.Core.Expressions.PhiFunction.Accept(Reko.Core.Expressions.IExpressionVisitor v) -> void
override Reko.Core.Expressions.PhiFunction.Accept<T, C>(Reko.Core.Expressions.ExpressionVisitor<T, C> v, C context) -> T
override Reko.Core.Expressions.PhiFunction.Accept<T>(Reko.Core.Expressions.ExpressionVisitor<T> v) -> T
override Reko.Core.Expressions.PhiFunction.Children.get -> System.Collections.Generic.IEnumerable<Reko.Core.Expressions.Expression>
override Reko.Core.Expressions.PhiFunction.CloneExpression() -> Reko.Core.Expressions.Expression
override Reko.Core.Expressions.PointerAddition.Accept(Reko.Core.Expressions.IExpressionVisitor visit) -> void
override Reko.Core.Expressions.PointerAddition.Accept<T, C>(Reko.Core.Expressions.ExpressionVisitor<T, C> v, C context) -> T
override Reko.Core.Expressions.PointerAddition.Accept<T>(Reko.Core.Expressions.ExpressionVisitor<T> v) -> T
override Reko.Core.Expressions.PointerAddition.Children.get -> System.Collections.Generic.IEnumerable<Reko.Core.Expressions.Expression>
override Reko.Core.Expressions.PointerAddition.CloneExpression() -> Reko.Core.Expressions.Expression
override Reko.Core.Expressions.ProcedureConstant.Accept(Reko.Core.Expressions.IExpressionVisitor visit) -> void
override Reko.Core.Expressions.ProcedureConstant.Accept<T, C>(Reko.Core.Expressions.ExpressionVisitor<T, C> v, C context) -> T
override Reko.Core.Expressions.ProcedureConstant.Accept<T>(Reko.Core.Expressions.ExpressionVisitor<T> v) -> T
override Reko.Core.Expressions.ProcedureConstant.Children.get -> System.Collections.Generic.IEnumerable<Reko.Core.Expressions.Expression>
override Reko.Core.Expressions.ProcedureConstant.CloneExpression() -> Reko.Core.Expressions.Expression
override Reko.Core.Expressions.ScopeResolution.Accept(Reko.Core.Expressions.IExpressionVisitor visit) -> void
override Reko.Core.Expressions.ScopeResolution.Accept<T, C>(Reko.Core.Expressions.ExpressionVisitor<T, C> v, C context) -> T
override Reko.Core.Expressions.ScopeResolution.Accept<T>(Reko.Core.Expressions.ExpressionVisitor<T> v) -> T
override Reko.Core.Expressions.ScopeResolution.Children.get -> System.Collections.Generic.IEnumerable<Reko.Core.Expressions.Expression>
override Reko.Core.Expressions.ScopeResolution.CloneExpression() -> Reko.Core.Expressions.Expression
override Reko.Core.Expressions.SegmentedAccess.Accept(Reko.Core.Expressions.IExpressionVisitor visit) -> void
override Reko.Core.Expressions.SegmentedAccess.Accept<T, C>(Reko.Core.Expressions.ExpressionVisitor<T, C> v, C context) -> T
override Reko.Core.Expressions.SegmentedAccess.Accept<T>(Reko.Core.Expressions.ExpressionVisitor<T> visit) -> T
override Reko.Core.Expressions.SegmentedAccess.CloneExpression() -> Reko.Core.Expressions.Expression
override Reko.Core.Expressions.Slice.Accept(Reko.Core.Expressions.IExpressionVisitor v) -> void
override Reko.Core.Expressions.Slice.Accept<T, C>(Reko.Core.Expressions.ExpressionVisitor<T, C> v, C context) -> T
override Reko.Core.Expressions.Slice.Accept<T>(Reko.Core.Expressions.ExpressionVisitor<T> v) -> T
override Reko.Core.Expressions.Slice.Children.get -> System.Collections.Generic.IEnumerable<Reko.Core.Expressions.Expression>
override Reko.Core.Expressions.Slice.CloneExpression() -> Reko.Core.Expressions.Expression
override Reko.Core.Expressions.Slice.Invert() -> Reko.Core.Expressions.Expression
override Reko.Core.Expressions.StringConstant.CloneExpression() -> Reko.Core.Expressions.Expression
override Reko.Core.Expressions.StringConstant.Complement() -> Reko.Core.Expressions.Constant
override Reko.Core.Expressions.StringConstant.DoSlice(Reko.Core.Types.DataType dt, int offset) -> Reko.Core.Expressions.Constant
override Reko.Core.Expressions.StringConstant.GetHashOfValue() -> int
override Reko.Core.Expressions.StringConstant.GetValue() -> object
override Reko.Core.Expressions.StringConstant.IsIntegerOne.get -> bool
override Reko.Core.Expressions.StringConstant.Negate() -> Reko.Core.Expressions.Constant
override Reko.Core.Expressions.StringConstant.ToBigInteger() -> System.Numerics.BigInteger
override Reko.Core.Expressions.StringConstant.ToByte() -> byte
override Reko.Core.Expressions.StringConstant.ToInt16() -> short
override Reko.Core.Expressions.StringConstant.ToInt32() -> int
override Reko.Core.Expressions.StringConstant.ToInt64() -> long
override Reko.Core.Expressions.StringConstant.ToString() -> string
override Reko.Core.Expressions.StringConstant.ToUInt16() -> ushort
override Reko.Core.Expressions.StringConstant.ToUInt32() -> uint
override Reko.Core.Expressions.StringConstant.ToUInt64() -> ulong
override Reko.Core.Expressions.TestCondition.Accept(Reko.Core.Expressions.IExpressionVisitor visitor) -> void
override Reko.Core.Expressions.TestCondition.Accept<T, C>(Reko.Core.Expressions.ExpressionVisitor<T, C> v, C context) -> T
override Reko.Core.Expressions.TestCondition.Accept<T>(Reko.Core.Expressions.ExpressionVisitor<T> visitor) -> T
override Reko.Core.Expressions.TestCondition.Children.get -> System.Collections.Generic.IEnumerable<Reko.Core.Expressions.Expression>
override Reko.Core.Expressions.TestCondition.CloneExpression() -> Reko.Core.Expressions.Expression
override Reko.Core.Expressions.TestCondition.Invert() -> Reko.Core.Expressions.Expression
override Reko.Core.Expressions.UnaryExpression.Accept(Reko.Core.Expressions.IExpressionVisitor v) -> void
override Reko.Core.Expressions.UnaryExpression.Accept<T, C>(Reko.Core.Expressions.ExpressionVisitor<T, C> v, C context) -> T
override Reko.Core.Expressions.UnaryExpression.Accept<T>(Reko.Core.Expressions.ExpressionVisitor<T> v) -> T
override Reko.Core.Expressions.UnaryExpression.Children.get -> System.Collections.Generic.IEnumerable<Reko.Core.Expressions.Expression>
override Reko.Core.Expressions.UnaryExpression.CloneExpression() -> Reko.Core.Expressions.Expression
override Reko.Core.Expressions.UnaryExpression.Invert() -> Reko.Core.Expressions.Expression
override Reko.Core.ExternalProcedure.Signature.get -> Reko.Core.Types.FunctionType
override Reko.Core.ExternalProcedure.Signature.set -> void
override Reko.Core.ExternalProcedure.ToString() -> string
override Reko.Core.FlagGroupStorage.Accept<T, C>(Reko.Core.StorageVisitor<T, C> visitor, C context) -> T
override Reko.Core.FlagGroupStorage.Accept<T>(Reko.Core.StorageVisitor<T> visitor) -> T
override Reko.Core.FlagGroupStorage.Covers(Reko.Core.Storage sThat) -> bool
override Reko.Core.FlagGroupStorage.Equals(object obj) -> bool
override Reko.Core.FlagGroupStorage.Exceeds(Reko.Core.Storage sThat) -> bool
override Reko.Core.FlagGroupStorage.GetHashCode() -> int
override Reko.Core.FlagGroupStorage.OffsetOf(Reko.Core.Storage stgSub) -> int
override Reko.Core.FlagGroupStorage.OverlapsWith(Reko.Core.Storage sThat) -> bool
override Reko.Core.FlagGroupStorage.Serialize() -> Reko.Core.Serialization.SerializedKind
override Reko.Core.FlagGroupStorage.Write(System.IO.TextWriter writer) -> void
override Reko.Core.FpuStackStorage.Accept<T, C>(Reko.Core.StorageVisitor<T, C> visitor, C context) -> T
override Reko.Core.FpuStackStorage.Accept<T>(Reko.Core.StorageVisitor<T> visitor) -> T
override Reko.Core.FpuStackStorage.BitSize.get -> ulong
override Reko.Core.FpuStackStorage.Covers(Reko.Core.Storage other) -> bool
override Reko.Core.FpuStackStorage.Equals(object obj) -> bool
override Reko.Core.FpuStackStorage.Exceeds(Reko.Core.Storage that) -> bool
override Reko.Core.FpuStackStorage.GetHashCode() -> int
override Reko.Core.FpuStackStorage.OffsetOf(Reko.Core.Storage stgSub) -> int
override Reko.Core.FpuStackStorage.OverlapsWith(Reko.Core.Storage sThat) -> bool
override Reko.Core.FpuStackStorage.Write(System.IO.TextWriter writer) -> void
override Reko.Core.FrameApplicationBuilder.Bind(Reko.Core.Expressions.Identifier id) -> Reko.Core.Expressions.Expression
override Reko.Core.FrameApplicationBuilder.BindOutArg(Reko.Core.Expressions.Identifier id) -> Reko.Core.Expressions.OutArgument
override Reko.Core.FrameApplicationBuilder.BindReturnValue(Reko.Core.Expressions.Identifier id) -> Reko.Core.Expressions.Expression
override Reko.Core.Graphs.DiGraph<T>.ToString() -> string
override Reko.Core.Hll.C.Application.Accept<T>(Reko.Core.Hll.C.CExpressionVisitor<T> visitor) -> T
override Reko.Core.Hll.C.Application.ToString() -> string
override Reko.Core.Hll.C.ArrayDeclarator.Accept<T>(Reko.Core.Hll.C.DeclaratorVisitor<T> visitor) -> T
override Reko.Core.Hll.C.ArrayDeclarator.ToString() -> string
override Reko.Core.Hll.C.AssignExpression.Accept<T>(Reko.Core.Hll.C.CExpressionVisitor<T> visitor) -> T
override Reko.Core.Hll.C.CallConventionDeclarator.Accept<T>(Reko.Core.Hll.C.DeclaratorVisitor<T> visitor) -> T
override Reko.Core.Hll.C.CallConventionDeclarator.ToString() -> string
override Reko.Core.Hll.C.CArrayAccess.Accept<T>(Reko.Core.Hll.C.CExpressionVisitor<T> visitor) -> T
override Reko.Core.Hll.C.CArrayAccess.ToString() -> string
override Reko.Core.Hll.C.CaseLabel.ToString() -> string
override Reko.Core.Hll.C.CastExpression.Accept<T>(Reko.Core.Hll.C.CExpressionVisitor<T> visitor) -> T
override Reko.Core.Hll.C.CastExpression.ToString() -> string
override Reko.Core.Hll.C.CAttribute.Accept<T>(Reko.Core.Hll.C.CSyntaxVisitor<T> visitor) -> T
override Reko.Core.Hll.C.CAttribute.ToString() -> string
override Reko.Core.Hll.C.CBinaryExpression.Accept<T>(Reko.Core.Hll.C.CExpressionVisitor<T> visitor) -> T
override Reko.Core.Hll.C.CBinaryExpression.ToString() -> string
override Reko.Core.Hll.C.CIdentifier.Accept<T>(Reko.Core.Hll.C.CExpressionVisitor<T> visitor) -> T
override Reko.Core.Hll.C.CIdentifier.ToString() -> string
override Reko.Core.Hll.C.ComplexTypeSpec.Accept<T>(Reko.Core.Hll.C.DeclSpecVisitor<T> visitor) -> T
override Reko.Core.Hll.C.ComplexTypeSpec.ToString() -> string
override Reko.Core.Hll.C.CompoundStatement.ToString() -> string
override Reko.Core.Hll.C.ConditionalExpression.Accept<T>(Reko.Core.Hll.C.CExpressionVisitor<T> visitor) -> T
override Reko.Core.Hll.C.ConditionalExpression.ToString() -> string
override Reko.Core.Hll.C.ConstExp.Accept<T>(Reko.Core.Hll.C.CExpressionVisitor<T> visitor) -> T
override Reko.Core.Hll.C.ConstExp.ToString() -> string
override Reko.Core.Hll.C.CType.Accept<T>(Reko.Core.Hll.C.CSyntaxVisitor<T> visitor) -> T
override Reko.Core.Hll.C.CType.ToString() -> string
override Reko.Core.Hll.C.CUnaryExpression.Accept<T>(Reko.Core.Hll.C.CExpressionVisitor<T> visitor) -> T
override Reko.Core.Hll.C.CUnaryExpression.ToString() -> string
override Reko.Core.Hll.C.Decl.Accept<T>(Reko.Core.Hll.C.CSyntaxVisitor<T> visitor) -> T
override Reko.Core.Hll.C.Decl.ToString() -> string
override Reko.Core.Hll.C.DoWhileStat.ToString() -> string
override Reko.Core.Hll.C.Enumerator.Accept<T>(Reko.Core.Hll.C.CSyntaxVisitor<T> visitor) -> T
override Reko.Core.Hll.C.Enumerator.ToString() -> string
override Reko.Core.Hll.C.EnumeratorTypeSpec.Accept<T>(Reko.Core.Hll.C.DeclSpecVisitor<T> visitor) -> T
override Reko.Core.Hll.C.EnumeratorTypeSpec.ToString() -> string
override Reko.Core.Hll.C.ExpressionInitializer.ToString() -> string
override Reko.Core.Hll.C.ExprStat.ToString() -> string
override Reko.Core.Hll.C.ExtendedDeclspec.Accept<T>(Reko.Core.Hll.C.DeclSpecVisitor<T> visitor) -> T
override Reko.Core.Hll.C.ExtendedDeclspec.ToString() -> string
override Reko.Core.Hll.C.FieldDeclarator.Accept<T>(Reko.Core.Hll.C.DeclaratorVisitor<T> visitor) -> T
override Reko.Core.Hll.C.FieldDeclarator.ToString() -> string
override Reko.Core.Hll.C.FunctionDecl.ToString() -> string
override Reko.Core.Hll.C.FunctionDeclarator.Accept<T>(Reko.Core.Hll.C.DeclaratorVisitor<T> visitor) -> T
override Reko.Core.Hll.C.FunctionDeclarator.ToString() -> string
override Reko.Core.Hll.C.IdDeclarator.Accept<T>(Reko.Core.Hll.C.DeclaratorVisitor<T> visitor) -> T
override Reko.Core.Hll.C.IdDeclarator.ToString() -> string
override Reko.Core.Hll.C.IncrementExpression.Accept<T>(Reko.Core.Hll.C.CExpressionVisitor<T> visitor) -> T
override Reko.Core.Hll.C.InitDeclarator.Accept<T>(Reko.Core.Hll.C.CSyntaxVisitor<T> visitor) -> T
override Reko.Core.Hll.C.InitDeclarator.ToString() -> string
override Reko.Core.Hll.C.LineLabel.ToString() -> string
override Reko.Core.Hll.C.MemberExpression.Accept<T>(Reko.Core.Hll.C.CExpressionVisitor<T> visitor) -> T
override Reko.Core.Hll.C.MemberExpression.ToString() -> string
override Reko.Core.Hll.C.ParamDecl.Accept<T>(Reko.Core.Hll.C.CSyntaxVisitor<T> visitor) -> T
override Reko.Core.Hll.C.ParamDecl.ToString() -> string
override Reko.Core.Hll.C.PointerDeclarator.Accept<T>(Reko.Core.Hll.C.DeclaratorVisitor<T> visitor) -> T
override Reko.Core.Hll.C.PointerDeclarator.ToString() -> string
override Reko.Core.Hll.C.QualifiedName.ToString() -> string
override Reko.Core.Hll.C.ReferenceDeclarator.Accept<T>(Reko.Core.Hll.C.DeclaratorVisitor<T> visitor) -> T
override Reko.Core.Hll.C.ReferenceDeclarator.ToString() -> string
override Reko.Core.Hll.C.SimpleTypeSpec.Accept<T>(Reko.Core.Hll.C.DeclSpecVisitor<T> visitor) -> T
override Reko.Core.Hll.C.SimpleTypeSpec.ToString() -> string
override Reko.Core.Hll.C.SizeofExpression.Accept<T>(Reko.Core.Hll.C.CExpressionVisitor<T> visitor) -> T
override Reko.Core.Hll.C.SizeofExpression.ToString() -> string
override Reko.Core.Hll.C.Stat.Accept<T>(Reko.Core.Hll.C.CSyntaxVisitor<T> visitor) -> T
override Reko.Core.Hll.C.StorageClassSpec.Accept<T>(Reko.Core.Hll.C.DeclSpecVisitor<T> visitor) -> T
override Reko.Core.Hll.C.StorageClassSpec.ToString() -> string
override Reko.Core.Hll.C.StructDecl.Accept<T>(Reko.Core.Hll.C.CSyntaxVisitor<T> visitor) -> T
override Reko.Core.Hll.C.StructDecl.ToString() -> string
override Reko.Core.Hll.C.TypeDefName.Accept<T>(Reko.Core.Hll.C.DeclSpecVisitor<T> visitor) -> T
override Reko.Core.Hll.C.TypeDefName.ToString() -> string
override Reko.Core.Hll.C.TypeQualifier.Accept<T>(Reko.Core.Hll.C.DeclSpecVisitor<T> visitor) -> T
override Reko.Core.Hll.C.TypeQualifier.ToString() -> string
override Reko.Core.Hll.Pascal.Array.Accept<T>(Reko.Core.Hll.Pascal.IPascalSyntaxVisitor<T> visitor) -> T
override Reko.Core.Hll.Pascal.Array.Write(System.IO.TextWriter writer) -> void
override Reko.Core.Hll.Pascal.BinExp.Accept<T>(Reko.Core.Hll.Pascal.IPascalSyntaxVisitor<T> visitor) -> T
override Reko.Core.Hll.Pascal.BinExp.Write(System.IO.TextWriter writer) -> void
override Reko.Core.Hll.Pascal.BooleanLiteral.Accept<T>(Reko.Core.Hll.Pascal.IPascalSyntaxVisitor<T> visitor) -> T
override Reko.Core.Hll.Pascal.BooleanLiteral.Write(System.IO.TextWriter writer) -> void
override Reko.Core.Hll.Pascal.CallableDeclaration.Accept<T>(Reko.Core.Hll.Pascal.IPascalSyntaxVisitor<T> visitor) -> T
override Reko.Core.Hll.Pascal.CallableDeclaration.Write(System.IO.TextWriter writer) -> void
override Reko.Core.Hll.Pascal.CallableType.Accept<T>(Reko.Core.Hll.Pascal.IPascalSyntaxVisitor<T> visitor) -> T
override Reko.Core.Hll.Pascal.CallableType.Write(System.IO.TextWriter writer) -> void
override Reko.Core.Hll.Pascal.ConstantDeclaration.Accept<T>(Reko.Core.Hll.Pascal.IPascalSyntaxVisitor<T> visitor) -> T
override Reko.Core.Hll.Pascal.ConstantDeclaration.Write(System.IO.TextWriter writer) -> void
override Reko.Core.Hll.Pascal.EnumType.Accept<T>(Reko.Core.Hll.Pascal.IPascalSyntaxVisitor<T> visitor) -> T
override Reko.Core.Hll.Pascal.EnumType.Write(System.IO.TextWriter writer) -> void
override Reko.Core.Hll.Pascal.Field.Accept<T>(Reko.Core.Hll.Pascal.IPascalSyntaxVisitor<T> visitor) -> T
override Reko.Core.Hll.Pascal.Field.Write(System.IO.TextWriter writer) -> void
override Reko.Core.Hll.Pascal.File.Accept<T>(Reko.Core.Hll.Pascal.IPascalSyntaxVisitor<T> visitor) -> T
override Reko.Core.Hll.Pascal.File.Write(System.IO.TextWriter writer) -> void
override Reko.Core.Hll.Pascal.Id.Accept<T>(Reko.Core.Hll.Pascal.IPascalSyntaxVisitor<T> visitor) -> T
override Reko.Core.Hll.Pascal.Id.Write(System.IO.TextWriter writer) -> void
override Reko.Core.Hll.Pascal.InlineMachineCode.Accept<T>(Reko.Core.Hll.Pascal.IPascalSyntaxVisitor<T> visitor) -> T
override Reko.Core.Hll.Pascal.InlineMachineCode.Write(System.IO.TextWriter writer) -> void
override Reko.Core.Hll.Pascal.NumericLiteral.Accept<T>(Reko.Core.Hll.Pascal.IPascalSyntaxVisitor<T> visitor) -> T
override Reko.Core.Hll.Pascal.NumericLiteral.Write(System.IO.TextWriter writer) -> void
override Reko.Core.Hll.Pascal.ObjectType.Accept<T>(Reko.Core.Hll.Pascal.IPascalSyntaxVisitor<T> visitor) -> T
override Reko.Core.Hll.Pascal.ObjectType.Write(System.IO.TextWriter writer) -> void
override Reko.Core.Hll.Pascal.Pointer.Accept<T>(Reko.Core.Hll.Pascal.IPascalSyntaxVisitor<T> visitor) -> T
override Reko.Core.Hll.Pascal.Pointer.Write(System.IO.TextWriter writer) -> void
override Reko.Core.Hll.Pascal.Primitive.Accept<T>(Reko.Core.Hll.Pascal.IPascalSyntaxVisitor<T> visitor) -> T
override Reko.Core.Hll.Pascal.Primitive.Write(System.IO.TextWriter writer) -> void
override Reko.Core.Hll.Pascal.RangeType.Accept<T>(Reko.Core.Hll.Pascal.IPascalSyntaxVisitor<T> visitor) -> T
override Reko.Core.Hll.Pascal.RangeType.Write(System.IO.TextWriter writer) -> void
override Reko.Core.Hll.Pascal.RealLiteral.Accept<T>(Reko.Core.Hll.Pascal.IPascalSyntaxVisitor<T> visitor) -> T
override Reko.Core.Hll.Pascal.RealLiteral.Write(System.IO.TextWriter writer) -> void
override Reko.Core.Hll.Pascal.Record.Accept<T>(Reko.Core.Hll.Pascal.IPascalSyntaxVisitor<T> visitor) -> T
override Reko.Core.Hll.Pascal.Record.Write(System.IO.TextWriter writer) -> void
override Reko.Core.Hll.Pascal.SetType.Accept<T>(Reko.Core.Hll.Pascal.IPascalSyntaxVisitor<T> visitor) -> T
override Reko.Core.Hll.Pascal.SetType.Write(System.IO.TextWriter writer) -> void
override Reko.Core.Hll.Pascal.StringLiteral.Accept<T>(Reko.Core.Hll.Pascal.IPascalSyntaxVisitor<T> visitor) -> T
override Reko.Core.Hll.Pascal.StringLiteral.Write(System.IO.TextWriter writer) -> void
override Reko.Core.Hll.Pascal.StringType.Accept<T>(Reko.Core.Hll.Pascal.IPascalSyntaxVisitor<T> visitor) -> T
override Reko.Core.Hll.Pascal.StringType.Write(System.IO.TextWriter writer) -> void
override Reko.Core.Hll.Pascal.Token.ToString() -> string
override Reko.Core.Hll.Pascal.TypeDeclaration.Accept<T>(Reko.Core.Hll.Pascal.IPascalSyntaxVisitor<T> visitor) -> T
override Reko.Core.Hll.Pascal.TypeDeclaration.Write(System.IO.TextWriter writer) -> void
override Reko.Core.Hll.Pascal.TypeReference.Accept<T>(Reko.Core.Hll.Pascal.IPascalSyntaxVisitor<T> visitor) -> T
override Reko.Core.Hll.Pascal.TypeReference.Write(System.IO.TextWriter writer) -> void
override Reko.Core.Hll.Pascal.UnaryExp.Accept<T>(Reko.Core.Hll.Pascal.IPascalSyntaxVisitor<T> visitor) -> T
override Reko.Core.Hll.Pascal.UnaryExp.Write(System.IO.TextWriter writer) -> void
override Reko.Core.ImageLocation.Equals(object obj) -> bool
override Reko.Core.ImageLocation.GetHashCode() -> int
override Reko.Core.ImageLocation.ToString() -> string
override Reko.Core.ImageMapBlock.ToString() -> string
override Reko.Core.ImageMapItem.ToString() -> string
override Reko.Core.ImageSegment.ToString() -> string
override Reko.Core.ImageSymbol.ToString() -> string
override Reko.Core.InformationalDiagnostic.ImageKey.get -> string
override Reko.Core.IntrinsicProcedure.Signature.get -> Reko.Core.Types.FunctionType
override Reko.Core.IntrinsicProcedure.Signature.set -> void
override Reko.Core.IntrinsicProcedure.ToString() -> string
override Reko.Core.IO.SpanStream.CanRead.get -> bool
override Reko.Core.IO.SpanStream.CanSeek.get -> bool
override Reko.Core.IO.SpanStream.CanWrite.get -> bool
override Reko.Core.IO.SpanStream.Flush() -> void
override Reko.Core.IO.SpanStream.Length.get -> long
override Reko.Core.IO.SpanStream.Position.get -> long
override Reko.Core.IO.SpanStream.Position.set -> void
override Reko.Core.IO.SpanStream.Read(byte[] buffer, int offset, int count) -> int
override Reko.Core.IO.SpanStream.Seek(long offset, System.IO.SeekOrigin origin) -> long
override Reko.Core.IO.SpanStream.SetLength(long value) -> void
override Reko.Core.IO.SpanStream.Write(byte[] buffer, int offset, int count) -> void
override Reko.Core.IRFormat.IRProcedureBuilder.Emit(Reko.Core.Code.Instruction instr) -> Reko.Core.Statement
override Reko.Core.IRFormat.IRProcedureBuilder.Frame.get -> Reko.Core.Frame
override Reko.Core.Lib.Bitfield.ToString() -> string
override Reko.Core.Lib.Float16.ToString() -> string
override Reko.Core.Lib.Float80.ToString() -> string
override Reko.Core.Lib.Float96.ToString() -> string
override Reko.Core.Lib.Rational.ToString() -> string
override Reko.Core.Lib.SuffixArray<T>.ToString() -> string
override Reko.Core.Lib.TextWriterStream.CanRead.get -> bool
override Reko.Core.Lib.TextWriterStream.CanSeek.get -> bool
override Reko.Core.Lib.TextWriterStream.CanWrite.get -> bool
override Reko.Core.Lib.TextWriterStream.Flush() -> void
override Reko.Core.Lib.TextWriterStream.Length.get -> long
override Reko.Core.Lib.TextWriterStream.Position.get -> long
override Reko.Core.Lib.TextWriterStream.Position.set -> void
override Reko.Core.Lib.TextWriterStream.Read(byte[] buffer, int offset, int count) -> int
override Reko.Core.Lib.TextWriterStream.Seek(long offset, System.IO.SeekOrigin origin) -> long
override Reko.Core.Lib.TextWriterStream.SetLength(long value) -> void
override Reko.Core.Lib.TextWriterStream.Write(byte[] buffer, int offset, int count) -> void
override Reko.Core.LinearInductionVariable.ToString() -> string
override Reko.Core.Loading.ProgramImageLoader.Load(Reko.Core.Address addrLoad) -> Reko.Core.Loading.ILoadedImage
override Reko.Core.Loading.ResourceType.Equals(object obj) -> bool
override Reko.Core.Loading.ResourceType.GetHashCode() -> int
override Reko.Core.Machine.AddressOperand.DoRender(Reko.Core.Machine.MachineInstructionRenderer renderer, Reko.Core.Machine.MachineInstructionRendererOptions options) -> void
override Reko.Core.Machine.BitfieldDecoder<TDasm, TMnemonic, TInstr>.Decode(uint wInstr, TDasm dasm) -> TInstr
override Reko.Core.Machine.ConditionalDecoder<TDasm, TMnemonic, TInstr>.Decode(uint wInstr, TDasm dasm) -> TInstr
override Reko.Core.Machine.FlagGroupOperand.DoRender(Reko.Core.Machine.MachineInstructionRenderer renderer, Reko.Core.Machine.MachineInstructionRendererOptions options) -> void
override Reko.Core.Machine.FpuOperand.DoRender(Reko.Core.Machine.MachineInstructionRenderer renderer, Reko.Core.Machine.MachineInstructionRendererOptions options) -> void
override Reko.Core.Machine.IfDecoder<TDasm, TMnemonic, TInstr>.Decode(uint wInstr, TDasm dasm) -> TInstr
override Reko.Core.Machine.ImmediateOperand.DoRender(Reko.Core.Machine.MachineInstructionRenderer! renderer, Reko.Core.Machine.MachineInstructionRendererOptions! options) -> void
override Reko.Core.Machine.InstrDecoder<TDasm, TMnemonic, TInstr>.Decode(uint wInstr, TDasm dasm) -> TInstr
override Reko.Core.Machine.InstrDecoder<TDasm, TMnemonic, TInstr>.ToString() -> string
override Reko.Core.Machine.MaskDecoder<TDasm, TMnemonic, TInstr>.Decode(uint wInstr, TDasm dasm) -> TInstr
override Reko.Core.Machine.MaskDecoder<TDasm, TMnemonic, TInstr>.ToString() -> string
override Reko.Core.Machine.NyiDecoder<TDasm, TMnemonic, TInstr>.Decode(uint wInstr, TDasm dasm) -> TInstr
override Reko.Core.Machine.StringRenderer.ToString() -> string
override Reko.Core.Machine.WideInstrDecoder<TDasm, TMnemonic, TInstr>.Decode(ulong ulInstr, TDasm dasm) -> TInstr
override Reko.Core.Machine.WideMaskDecoder<TDasm, TMnemonic, TInstr>.Decode(ulong wInstr, TDasm dasm) -> TInstr
override Reko.Core.Machine.WideMaskDecoder<TDasm, TMnemonic, TInstr>.ToString() -> string
override Reko.Core.Machine.WideNyiDecoder<TDasm, TMnemonic, TInstr>.Decode(ulong wInstr, TDasm dasm) -> TInstr
override Reko.Core.Memory.BeImageReader.CreateNew(byte[] bytes, long offset) -> Reko.Core.Memory.EndianImageReader
override Reko.Core.Memory.BeImageReader.CreateNew(Reko.Core.Memory.MemoryArea image, Reko.Core.Address addr) -> Reko.Core.Memory.EndianImageReader
override Reko.Core.Memory.BeImageReader.ReadInt16() -> short
override Reko.Core.Memory.BeImageReader.ReadInt16(int offset) -> short
override Reko.Core.Memory.BeImageReader.ReadInt32() -> int
override Reko.Core.Memory.BeImageReader.ReadInt32(int offset) -> int
override Reko.Core.Memory.BeImageReader.ReadInt64() -> long
override Reko.Core.Memory.BeImageReader.ReadInt64(int offset) -> long
override Reko.Core.Memory.BeImageReader.ReadUInt16() -> ushort
override Reko.Core.Memory.BeImageReader.ReadUInt16(int offset) -> ushort
override Reko.Core.Memory.BeImageReader.ReadUInt32() -> uint
override Reko.Core.Memory.BeImageReader.ReadUInt32(int offset) -> uint
override Reko.Core.Memory.BeImageReader.ReadUInt64() -> ulong
override Reko.Core.Memory.BeImageReader.ReadUInt64(int offset) -> ulong
override Reko.Core.Memory.BeImageReader.TryPeekUInt32(int offset, out uint value) -> bool
override Reko.Core.Memory.BeImageReader.TryPeekUInt64(int offset, out ulong value) -> bool
override Reko.Core.Memory.BeImageReader.TryRead(Reko.Core.Types.PrimitiveType dataType, out Reko.Core.Expressions.Constant c) -> bool
override Reko.Core.Memory.BeImageReader.TryReadInt16(out short i16) -> bool
override Reko.Core.Memory.BeImageReader.TryReadInt32(out int i32) -> bool
override Reko.Core.Memory.BeImageReader.TryReadInt64(out long value) -> bool
override Reko.Core.Memory.BeImageReader.TryReadUInt16(out ushort ui16) -> bool
override Reko.Core.Memory.BeImageReader.TryReadUInt32(out uint ui32) -> bool
override Reko.Core.Memory.BeImageReader.TryReadUInt64(out ulong ui64) -> bool
override Reko.Core.Memory.BeImageWriter.Clone() -> Reko.Core.Memory.ImageWriter
override Reko.Core.Memory.BeImageWriter.WriteUInt16(ushort us) -> Reko.Core.Memory.ImageWriter
override Reko.Core.Memory.BeImageWriter.WriteUInt32(uint offset, uint w) -> Reko.Core.Memory.ImageWriter
override Reko.Core.Memory.BeImageWriter.WriteUInt32(uint w) -> Reko.Core.Memory.ImageWriter
override Reko.Core.Memory.BeImageWriter.WriteUInt64(ulong w) -> Reko.Core.Memory.ImageWriter
override Reko.Core.Memory.ByteMemoryArea.CreateBeReader(long offset) -> Reko.Core.Memory.EndianImageReader
override Reko.Core.Memory.ByteMemoryArea.CreateBeReader(long offsetBegin, long offsetEnd) -> Reko.Core.Memory.EndianImageReader
override Reko.Core.Memory.ByteMemoryArea.CreateBeReader(Reko.Core.Address addr) -> Reko.Core.Memory.EndianImageReader
override Reko.Core.Memory.ByteMemoryArea.CreateBeReader(Reko.Core.Address addr, long cUnits) -> Reko.Core.Memory.EndianImageReader
override Reko.Core.Memory.ByteMemoryArea.CreateBeWriter(long offset) -> Reko.Core.Memory.BeImageWriter
override Reko.Core.Memory.ByteMemoryArea.CreateBeWriter(Reko.Core.Address addr) -> Reko.Core.Memory.BeImageWriter
override Reko.Core.Memory.ByteMemoryArea.CreateLeReader(long offset) -> Reko.Core.Memory.EndianImageReader
override Reko.Core.Memory.ByteMemoryArea.CreateLeReader(long offsetBegin, long offsetEnd) -> Reko.Core.Memory.EndianImageReader
override Reko.Core.Memory.ByteMemoryArea.CreateLeReader(Reko.Core.Address addr) -> Reko.Core.Memory.EndianImageReader
override Reko.Core.Memory.ByteMemoryArea.CreateLeReader(Reko.Core.Address addr, long cUnits) -> Reko.Core.Memory.EndianImageReader
override Reko.Core.Memory.ByteMemoryArea.CreateLeWriter(long offset) -> Reko.Core.Memory.LeImageWriter
override Reko.Core.Memory.ByteMemoryArea.CreateLeWriter(Reko.Core.Address addr) -> Reko.Core.Memory.LeImageWriter
override Reko.Core.Memory.ByteMemoryArea.ToString() -> string
override Reko.Core.Memory.ByteMemoryArea.TryReadBe(long imageOffset, Reko.Core.Types.DataType type, out Reko.Core.Expressions.Constant c) -> bool
override Reko.Core.Memory.ByteMemoryArea.TryReadBeUInt16(long offset, out ushort value) -> bool
override Reko.Core.Memory.ByteMemoryArea.TryReadBeUInt32(long offset, out uint value) -> bool
override Reko.Core.Memory.ByteMemoryArea.TryReadBeUInt64(long offset, out ulong value) -> bool
override Reko.Core.Memory.ByteMemoryArea.TryReadByte(long off, out byte b) -> bool
override Reko.Core.Memory.ByteMemoryArea.TryReadLe(long imageOffset, Reko.Core.Types.DataType type, out Reko.Core.Expressions.Constant c) -> bool
override Reko.Core.Memory.ByteMemoryArea.TryReadLeInt32(long offset, out int value) -> bool
override Reko.Core.Memory.ByteMemoryArea.TryReadLeUInt16(long offset, out ushort value) -> bool
override Reko.Core.Memory.ByteMemoryArea.TryReadLeUInt32(long offset, out uint value) -> bool
override Reko.Core.Memory.ByteMemoryArea.TryReadLeUInt64(long offset, out ulong value) -> bool
override Reko.Core.Memory.ByteMemoryArea.WriteBeUInt16(long offset, ushort w) -> void
override Reko.Core.Memory.ByteMemoryArea.WriteBeUInt32(long offset, uint dw) -> void
override Reko.Core.Memory.ByteMemoryArea.WriteByte(long offset, byte b) -> void
override Reko.Core.Memory.ByteMemoryArea.WriteLeUInt16(long offset, ushort w) -> void
override Reko.Core.Memory.ByteMemoryArea.WriteLeUInt32(long offset, uint dw) -> void
override Reko.Core.Memory.LeImageReader.CreateNew(byte[] bytes, long offset) -> Reko.Core.Memory.EndianImageReader
override Reko.Core.Memory.LeImageReader.CreateNew(Reko.Core.Memory.MemoryArea image, Reko.Core.Address addr) -> Reko.Core.Memory.EndianImageReader
override Reko.Core.Memory.LeImageReader.ReadInt16() -> short
override Reko.Core.Memory.LeImageReader.ReadInt16(int offset) -> short
override Reko.Core.Memory.LeImageReader.ReadInt32() -> int
override Reko.Core.Memory.LeImageReader.ReadInt32(int offset) -> int
override Reko.Core.Memory.LeImageReader.ReadInt64() -> long
override Reko.Core.Memory.LeImageReader.ReadInt64(int offset) -> long
override Reko.Core.Memory.LeImageReader.ReadUInt16() -> ushort
override Reko.Core.Memory.LeImageReader.ReadUInt16(int offset) -> ushort
override Reko.Core.Memory.LeImageReader.ReadUInt32() -> uint
override Reko.Core.Memory.LeImageReader.ReadUInt32(int offset) -> uint
override Reko.Core.Memory.LeImageReader.ReadUInt64() -> ulong
override Reko.Core.Memory.LeImageReader.ReadUInt64(int offset) -> ulong
override Reko.Core.Memory.LeImageReader.TryPeekUInt32(int offset, out uint value) -> bool
override Reko.Core.Memory.LeImageReader.TryPeekUInt64(int offset, out ulong value) -> bool
override Reko.Core.Memory.LeImageReader.TryRead(Reko.Core.Types.PrimitiveType dataType, out Reko.Core.Expressions.Constant c) -> bool
override Reko.Core.Memory.LeImageReader.TryReadInt16(out short i16) -> bool
override Reko.Core.Memory.LeImageReader.TryReadInt32(out int i32) -> bool
override Reko.Core.Memory.LeImageReader.TryReadInt64(out long value) -> bool
override Reko.Core.Memory.LeImageReader.TryReadUInt16(out ushort value) -> bool
override Reko.Core.Memory.LeImageReader.TryReadUInt32(out uint ui32) -> bool
override Reko.Core.Memory.LeImageReader.TryReadUInt64(out ulong ui64) -> bool
override Reko.Core.Memory.LeImageWriter.Clone() -> Reko.Core.Memory.ImageWriter
override Reko.Core.Memory.LeImageWriter.WriteUInt16(ushort us) -> Reko.Core.Memory.ImageWriter
override Reko.Core.Memory.LeImageWriter.WriteUInt32(uint offset, uint w) -> Reko.Core.Memory.ImageWriter
override Reko.Core.Memory.LeImageWriter.WriteUInt32(uint w) -> Reko.Core.Memory.ImageWriter
override Reko.Core.Memory.LeImageWriter.WriteUInt64(ulong w) -> Reko.Core.Memory.ImageWriter
override Reko.Core.Memory.Word16MemoryArea.CreateBeReader(long beginOffset, long endOffset) -> Reko.Core.Memory.EndianImageReader
override Reko.Core.Memory.Word16MemoryArea.CreateBeReader(long offset) -> Reko.Core.Memory.EndianImageReader
override Reko.Core.Memory.Word16MemoryArea.CreateBeReader(Reko.Core.Address addr) -> Reko.Core.Memory.EndianImageReader
override Reko.Core.Memory.Word16MemoryArea.CreateBeReader(Reko.Core.Address addr, long cUnits) -> Reko.Core.Memory.EndianImageReader
override Reko.Core.Memory.Word16MemoryArea.CreateBeWriter(long offset) -> Reko.Core.Memory.BeImageWriter
override Reko.Core.Memory.Word16MemoryArea.CreateBeWriter(Reko.Core.Address addr) -> Reko.Core.Memory.BeImageWriter
override Reko.Core.Memory.Word16MemoryArea.CreateLeReader(long beginOffset, long endOffset) -> Reko.Core.Memory.EndianImageReader
override Reko.Core.Memory.Word16MemoryArea.CreateLeReader(long offset) -> Reko.Core.Memory.EndianImageReader
override Reko.Core.Memory.Word16MemoryArea.CreateLeReader(Reko.Core.Address addr) -> Reko.Core.Memory.EndianImageReader
override Reko.Core.Memory.Word16MemoryArea.CreateLeReader(Reko.Core.Address addr, long cUnits) -> Reko.Core.Memory.EndianImageReader
override Reko.Core.Memory.Word16MemoryArea.CreateLeWriter(long offset) -> Reko.Core.Memory.LeImageWriter
override Reko.Core.Memory.Word16MemoryArea.CreateLeWriter(Reko.Core.Address addr) -> Reko.Core.Memory.LeImageWriter
override Reko.Core.Memory.Word16MemoryArea.ToString() -> string
override Reko.Core.Memory.Word16MemoryArea.TryReadBe(long imageOffset, Reko.Core.Types.DataType type, out Reko.Core.Expressions.Constant c) -> bool
override Reko.Core.Memory.Word16MemoryArea.TryReadBeUInt16(long off, out ushort retvalue) -> bool
override Reko.Core.Memory.Word16MemoryArea.TryReadBeUInt32(long off, out uint retvalue) -> bool
override Reko.Core.Memory.Word16MemoryArea.TryReadBeUInt64(long off, out ulong retvalue) -> bool
override Reko.Core.Memory.Word16MemoryArea.TryReadByte(long off, out byte b) -> bool
override Reko.Core.Memory.Word16MemoryArea.TryReadLe(long imageOffset, Reko.Core.Types.DataType type, out Reko.Core.Expressions.Constant c) -> bool
override Reko.Core.Memory.Word16MemoryArea.TryReadLeInt32(long off, out int retvalue) -> bool
override Reko.Core.Memory.Word16MemoryArea.TryReadLeUInt16(long off, out ushort retvalue) -> bool
override Reko.Core.Memory.Word16MemoryArea.TryReadLeUInt32(long off, out uint retvalue) -> bool
override Reko.Core.Memory.Word16MemoryArea.TryReadLeUInt64(long off, out ulong retvalue) -> bool
override Reko.Core.Memory.Word16MemoryArea.WriteBeUInt16(long off, ushort value) -> void
override Reko.Core.Memory.Word16MemoryArea.WriteBeUInt32(long off, uint value) -> void
override Reko.Core.Memory.Word16MemoryArea.WriteByte(long off, byte value) -> void
override Reko.Core.Memory.Word16MemoryArea.WriteLeUInt16(long off, ushort value) -> void
override Reko.Core.Memory.Word16MemoryArea.WriteLeUInt32(long off, uint value) -> void
override Reko.Core.Memory.Word64MemoryArea.CreateBeReader(long offset) -> Reko.Core.Memory.EndianImageReader
override Reko.Core.Memory.Word64MemoryArea.CreateBeReader(long offsetBegin, long offsetEnd) -> Reko.Core.Memory.EndianImageReader
override Reko.Core.Memory.Word64MemoryArea.CreateBeReader(Reko.Core.Address addr) -> Reko.Core.Memory.EndianImageReader
override Reko.Core.Memory.Word64MemoryArea.CreateBeReader(Reko.Core.Address addr, long cUnits) -> Reko.Core.Memory.EndianImageReader
override Reko.Core.Memory.Word64MemoryArea.CreateBeWriter(long offset) -> Reko.Core.Memory.BeImageWriter
override Reko.Core.Memory.Word64MemoryArea.CreateBeWriter(Reko.Core.Address addr) -> Reko.Core.Memory.BeImageWriter
override Reko.Core.Memory.Word64MemoryArea.CreateLeReader(long offset) -> Reko.Core.Memory.EndianImageReader
override Reko.Core.Memory.Word64MemoryArea.CreateLeReader(long offsetBegin, long offsetEnd) -> Reko.Core.Memory.EndianImageReader
override Reko.Core.Memory.Word64MemoryArea.CreateLeReader(Reko.Core.Address addr) -> Reko.Core.Memory.EndianImageReader
override Reko.Core.Memory.Word64MemoryArea.CreateLeReader(Reko.Core.Address addr, long cUnits) -> Reko.Core.Memory.EndianImageReader
override Reko.Core.Memory.Word64MemoryArea.CreateLeWriter(long offset) -> Reko.Core.Memory.LeImageWriter
override Reko.Core.Memory.Word64MemoryArea.CreateLeWriter(Reko.Core.Address addr) -> Reko.Core.Memory.LeImageWriter
override Reko.Core.Memory.Word64MemoryArea.TryReadBe(long imageOffset, Reko.Core.Types.DataType type, out Reko.Core.Expressions.Constant c) -> bool
override Reko.Core.Memory.Word64MemoryArea.TryReadBeUInt16(long off, out ushort retvalue) -> bool
override Reko.Core.Memory.Word64MemoryArea.TryReadBeUInt32(long off, out uint retvalue) -> bool
override Reko.Core.Memory.Word64MemoryArea.TryReadBeUInt64(long off, out ulong retvalue) -> bool
override Reko.Core.Memory.Word64MemoryArea.TryReadByte(long off, out byte b) -> bool
override Reko.Core.Memory.Word64MemoryArea.TryReadLe(long imageOffset, Reko.Core.Types.DataType type, out Reko.Core.Expressions.Constant c) -> bool
override Reko.Core.Memory.Word64MemoryArea.TryReadLeInt32(long off, out int retvalue) -> bool
override Reko.Core.Memory.Word64MemoryArea.TryReadLeUInt16(long off, out ushort retvalue) -> bool
override Reko.Core.Memory.Word64MemoryArea.TryReadLeUInt32(long off, out uint retvalue) -> bool
override Reko.Core.Memory.Word64MemoryArea.TryReadLeUInt64(long off, out ulong retvalue) -> bool
override Reko.Core.Memory.Word64MemoryArea.WriteBeUInt16(long off, ushort value) -> void
override Reko.Core.Memory.Word64MemoryArea.WriteBeUInt32(long off, uint value) -> void
override Reko.Core.Memory.Word64MemoryArea.WriteByte(long off, byte value) -> void
override Reko.Core.Memory.Word64MemoryArea.WriteLeUInt16(long off, ushort value) -> void
override Reko.Core.Memory.Word64MemoryArea.WriteLeUInt32(long off, uint value) -> void
override Reko.Core.MemoryStorage.Accept<T, C>(Reko.Core.StorageVisitor<T, C> visitor, C context) -> T
override Reko.Core.MemoryStorage.Accept<T>(Reko.Core.StorageVisitor<T> visitor) -> T
override Reko.Core.MemoryStorage.Covers(Reko.Core.Storage that) -> bool
override Reko.Core.MemoryStorage.Exceeds(Reko.Core.Storage that) -> bool
override Reko.Core.MemoryStorage.OffsetOf(Reko.Core.Storage stgSub) -> int
override Reko.Core.MemoryStorage.OverlapsWith(Reko.Core.Storage that) -> bool
override Reko.Core.MemoryStorage.Write(System.IO.TextWriter writer) -> void
override Reko.Core.MetadataFile.Accept<T>(Reko.Core.IProjectFileVisitor<T> visitor) -> T
override Reko.Core.NamedImportReference.CompareTo(Reko.Core.ImportReference that) -> int
override Reko.Core.NamedImportReference.ResolveImport(Reko.Core.IDynamicLinker resolver, Reko.Core.IPlatform platform, Reko.Core.AddressContext ctx) -> Reko.Core.Expressions.Expression
override Reko.Core.NamedImportReference.ResolveImportedProcedure(Reko.Core.IDynamicLinker resolver, Reko.Core.IPlatform platform, Reko.Core.AddressContext ctx) -> Reko.Core.ExternalProcedure
override Reko.Core.NamedImportReference.ToString() -> string
override Reko.Core.NativeInterface.NativeMachineInstruction.DoRender(Reko.Core.Machine.MachineInstructionRenderer renderer, Reko.Core.Machine.MachineInstructionRendererOptions options) -> void
override Reko.Core.NativeInterface.NativeMachineInstruction.MnemonicAsInteger.get -> int
override Reko.Core.NativeInterface.NativeMachineInstruction.MnemonicAsString.get -> string
override Reko.Core.NativeInterface.NativeProcessorArchitecture.CreateDisassembler(Reko.Core.Memory.EndianImageReader imageReader) -> System.Collections.Generic.IEnumerable<Reko.Core.Machine.MachineInstruction>
override Reko.Core.NativeInterface.NativeProcessorArchitecture.CreateInstructionComparer(Reko.Core.Normalize norm) -> System.Collections.Generic.IEqualityComparer<Reko.Core.Machine.MachineInstruction>
override Reko.Core.NativeInterface.NativeProcessorArchitecture.CreatePointerScanner(Reko.Core.SegmentMap map, Reko.Core.Memory.EndianImageReader rdr, System.Collections.Generic.IEnumerable<Reko.Core.Address> knownAddresses, Reko.Core.PointerScannerFlags flags) -> System.Collections.Generic.IEnumerable<Reko.Core.Address>
override Reko.Core.NativeInterface.NativeProcessorArchitecture.CreateProcessorState() -> Reko.Core.ProcessorState
override Reko.Core.NativeInterface.NativeProcessorArchitecture.CreateRewriter(Reko.Core.Memory.EndianImageReader rdr, Reko.Core.ProcessorState state, Reko.Core.IStorageBinder frame, Reko.Core.IRewriterHost host) -> System.Collections.Generic.IEnumerable<Reko.Core.Rtl.RtlInstructionCluster>
override Reko.Core.NativeInterface.NativeProcessorArchitecture.GetFlagGroup(Reko.Core.RegisterStorage flagRegister, uint grf) -> Reko.Core.FlagGroupStorage
override Reko.Core.NativeInterface.NativeProcessorArchitecture.GetFlagGroup(string name) -> Reko.Core.FlagGroupStorage
override Reko.Core.NativeInterface.NativeProcessorArchitecture.GetFlags() -> Reko.Core.FlagGroupStorage[]
override Reko.Core.NativeInterface.NativeProcessorArchitecture.GetMnemonicNames() -> System.Collections.Generic.SortedList<string, int>
override Reko.Core.NativeInterface.NativeProcessorArchitecture.GetMnemonicNumber(string name) -> int?
override Reko.Core.NativeInterface.NativeProcessorArchitecture.GetRegister(Reko.Core.StorageDomain domain, Reko.Core.BitRange range) -> Reko.Core.RegisterStorage
override Reko.Core.NativeInterface.NativeProcessorArchitecture.GetRegister(string name) -> Reko.Core.RegisterStorage
override Reko.Core.NativeInterface.NativeProcessorArchitecture.GetRegisters() -> Reko.Core.RegisterStorage[]
override Reko.Core.NativeInterface.NativeProcessorArchitecture.GetSubFlags(Reko.Core.FlagGroupStorage flags) -> System.Collections.Generic.IEnumerable<Reko.Core.FlagGroupStorage>
override Reko.Core.NativeInterface.NativeProcessorArchitecture.GrfToString(Reko.Core.RegisterStorage flagregister, string prefix, uint grf) -> string
override Reko.Core.NativeInterface.NativeProcessorArchitecture.MakeAddressFromConstant(Reko.Core.Expressions.Constant c, bool codeAlign) -> Reko.Core.Address
override Reko.Core.NativeInterface.NativeProcessorArchitecture.ReadCodeAddress(int size, Reko.Core.Memory.EndianImageReader rdr, Reko.Core.ProcessorState state) -> Reko.Core.Address
override Reko.Core.NativeInterface.NativeProcessorArchitecture.TryGetRegister(string name, out Reko.Core.RegisterStorage reg) -> bool
override Reko.Core.NativeInterface.NativeProcessorArchitecture.TryParseAddress(string txtAddr, out Reko.Core.Address addr) -> bool
override Reko.Core.NullMetadataLoader.Load(Reko.Core.IPlatform platform, Reko.Core.TypeLibrary dstLib) -> Reko.Core.TypeLibrary
override Reko.Core.Operators.AddressOfOperator.ApplyConstant(Reko.Core.Expressions.Constant c) -> Reko.Core.Expressions.Constant
override Reko.Core.Operators.AddressOfOperator.ToString() -> string
override Reko.Core.Operators.AndOperator.ApplyConstants(Reko.Core.Expressions.Constant c1, Reko.Core.Expressions.Constant c2) -> Reko.Core.Expressions.Constant
override Reko.Core.Operators.AndOperator.AsCompound() -> string
override Reko.Core.Operators.AndOperator.ToString() -> string
override Reko.Core.Operators.CandOperator.ApplyConstants(Reko.Core.Expressions.Constant c1, Reko.Core.Expressions.Constant c2) -> Reko.Core.Expressions.Constant
override Reko.Core.Operators.CandOperator.ToString() -> string
override Reko.Core.Operators.ComplementOperator.ApplyConstant(Reko.Core.Expressions.Constant c) -> Reko.Core.Expressions.Constant
override Reko.Core.Operators.ComplementOperator.ToString() -> string
override Reko.Core.Operators.CorOperator.ApplyConstants(Reko.Core.Expressions.Constant c1, Reko.Core.Expressions.Constant c2) -> Reko.Core.Expressions.Constant
override Reko.Core.Operators.CorOperator.ToString() -> string
override Reko.Core.Operators.EqOperator.ApplyConstants(Reko.Core.Expressions.Constant c1, Reko.Core.Expressions.Constant c2) -> Reko.Core.Expressions.Constant
override Reko.Core.Operators.EqOperator.Negate() -> Reko.Core.Operators.Operator
override Reko.Core.Operators.EqOperator.ToString() -> string
override Reko.Core.Operators.FAddOperator.ApplyConstants(Reko.Core.Expressions.Constant c1, Reko.Core.Expressions.Constant c2) -> Reko.Core.Expressions.Constant
override Reko.Core.Operators.FAddOperator.AsCompound() -> string
override Reko.Core.Operators.FAddOperator.ToString() -> string
override Reko.Core.Operators.FDivOperator.ApplyConstants(Reko.Core.Expressions.Constant c1, Reko.Core.Expressions.Constant c2) -> Reko.Core.Expressions.Constant
override Reko.Core.Operators.FDivOperator.AsCompound() -> string
override Reko.Core.Operators.FDivOperator.ToString() -> string
override Reko.Core.Operators.FModOperator.ApplyConstants(Reko.Core.Expressions.Constant c1, Reko.Core.Expressions.Constant c2) -> Reko.Core.Expressions.Constant
override Reko.Core.Operators.FModOperator.AsCompound() -> string
override Reko.Core.Operators.FModOperator.ToString() -> string
override Reko.Core.Operators.FMulOperator.ApplyConstants(Reko.Core.Expressions.Constant c1, Reko.Core.Expressions.Constant c2) -> Reko.Core.Expressions.Constant
override Reko.Core.Operators.FMulOperator.AsCompound() -> string
override Reko.Core.Operators.FMulOperator.ToString() -> string
override Reko.Core.Operators.FNegOperator.ApplyConstant(Reko.Core.Expressions.Constant c) -> Reko.Core.Expressions.Constant
override Reko.Core.Operators.FNegOperator.ToString() -> string
override Reko.Core.Operators.FSubOperator.ApplyConstants(Reko.Core.Expressions.Constant c1, Reko.Core.Expressions.Constant c2) -> Reko.Core.Expressions.Constant
override Reko.Core.Operators.FSubOperator.AsCompound() -> string
override Reko.Core.Operators.FSubOperator.ToString() -> string
override Reko.Core.Operators.GeOperator.ApplyConstants(Reko.Core.Expressions.Constant c1, Reko.Core.Expressions.Constant c2) -> Reko.Core.Expressions.Constant
override Reko.Core.Operators.GeOperator.Negate() -> Reko.Core.Operators.Operator
override Reko.Core.Operators.GeOperator.ToString() -> string
override Reko.Core.Operators.GtOperator.ApplyConstants(Reko.Core.Expressions.Constant c1, Reko.Core.Expressions.Constant c2) -> Reko.Core.Expressions.Constant
override Reko.Core.Operators.GtOperator.Negate() -> Reko.Core.Operators.Operator
override Reko.Core.Operators.GtOperator.ToString() -> string
override Reko.Core.Operators.IAddOperator.ApplyConstants(Reko.Core.Expressions.Constant c1, Reko.Core.Expressions.Constant c2) -> Reko.Core.Expressions.Constant
override Reko.Core.Operators.IAddOperator.AsCompound() -> string
override Reko.Core.Operators.IAddOperator.ToString() -> string
override Reko.Core.Operators.IModOperator.ApplyConstants(Reko.Core.Expressions.Constant c1, Reko.Core.Expressions.Constant c2) -> Reko.Core.Expressions.Constant
override Reko.Core.Operators.IModOperator.AsCompound() -> string
override Reko.Core.Operators.IModOperator.ToString() -> string
override Reko.Core.Operators.IMulOperator.ApplyConstants(Reko.Core.Expressions.Constant c1, Reko.Core.Expressions.Constant c2) -> Reko.Core.Expressions.Constant
override Reko.Core.Operators.IMulOperator.AsCompound() -> string
override Reko.Core.Operators.IMulOperator.ToString() -> string
override Reko.Core.Operators.ISubOperator.ApplyConstants(Reko.Core.Expressions.Constant c1, Reko.Core.Expressions.Constant c2) -> Reko.Core.Expressions.Constant
override Reko.Core.Operators.ISubOperator.AsCompound() -> string
override Reko.Core.Operators.ISubOperator.ToString() -> string
override Reko.Core.Operators.LeOperator.ApplyConstants(Reko.Core.Expressions.Constant c1, Reko.Core.Expressions.Constant c2) -> Reko.Core.Expressions.Constant
override Reko.Core.Operators.LeOperator.Negate() -> Reko.Core.Operators.Operator
override Reko.Core.Operators.LeOperator.ToString() -> string
override Reko.Core.Operators.LtOperator.ApplyConstants(Reko.Core.Expressions.Constant c1, Reko.Core.Expressions.Constant c2) -> Reko.Core.Expressions.Constant
override Reko.Core.Operators.LtOperator.Negate() -> Reko.Core.Operators.Operator
override Reko.Core.Operators.LtOperator.ToString() -> string
override Reko.Core.Operators.NegateOperator.ApplyConstant(Reko.Core.Expressions.Constant c) -> Reko.Core.Expressions.Constant
override Reko.Core.Operators.NegateOperator.ToString() -> string
override Reko.Core.Operators.NeOperator.ApplyConstants(Reko.Core.Expressions.Constant c1, Reko.Core.Expressions.Constant c2) -> Reko.Core.Expressions.Constant
override Reko.Core.Operators.NeOperator.Negate() -> Reko.Core.Operators.Operator
override Reko.Core.Operators.NeOperator.ToString() -> string
override Reko.Core.Operators.NotOperator.ApplyConstant(Reko.Core.Expressions.Constant c) -> Reko.Core.Expressions.Constant
override Reko.Core.Operators.NotOperator.ToString() -> string
override Reko.Core.Operators.OrOperator.ApplyConstants(Reko.Core.Expressions.Constant c1, Reko.Core.Expressions.Constant c2) -> Reko.Core.Expressions.Constant
override Reko.Core.Operators.OrOperator.AsCompound() -> string
override Reko.Core.Operators.OrOperator.ToString() -> string
override Reko.Core.Operators.ReqOperator.ApplyConstants(Reko.Core.Expressions.Constant c1, Reko.Core.Expressions.Constant c2) -> Reko.Core.Expressions.Constant
override Reko.Core.Operators.ReqOperator.Negate() -> Reko.Core.Operators.Operator
override Reko.Core.Operators.ReqOperator.ToString() -> string
override Reko.Core.Operators.RgeOperator.ApplyConstants(Reko.Core.Expressions.Constant c1, Reko.Core.Expressions.Constant c2) -> Reko.Core.Expressions.Constant
override Reko.Core.Operators.RgeOperator.Negate() -> Reko.Core.Operators.Operator
override Reko.Core.Operators.RgeOperator.ToString() -> string
override Reko.Core.Operators.RgtOperator.ApplyConstants(Reko.Core.Expressions.Constant c1, Reko.Core.Expressions.Constant c2) -> Reko.Core.Expressions.Constant
override Reko.Core.Operators.RgtOperator.Negate() -> Reko.Core.Operators.Operator
override Reko.Core.Operators.RgtOperator.ToString() -> string
override Reko.Core.Operators.RleOperator.ApplyConstants(Reko.Core.Expressions.Constant c1, Reko.Core.Expressions.Constant c2) -> Reko.Core.Expressions.Constant
override Reko.Core.Operators.RleOperator.Negate() -> Reko.Core.Operators.Operator
override Reko.Core.Operators.RleOperator.ToString() -> string
override Reko.Core.Operators.RltOperator.ApplyConstants(Reko.Core.Expressions.Constant c1, Reko.Core.Expressions.Constant c2) -> Reko.Core.Expressions.Constant
override Reko.Core.Operators.RltOperator.Negate() -> Reko.Core.Operators.Operator
override Reko.Core.Operators.RltOperator.ToString() -> string
override Reko.Core.Operators.RneOperator.ApplyConstants(Reko.Core.Expressions.Constant c1, Reko.Core.Expressions.Constant c2) -> Reko.Core.Expressions.Constant
override Reko.Core.Operators.RneOperator.Negate() -> Reko.Core.Operators.Operator
override Reko.Core.Operators.RneOperator.ToString() -> string
override Reko.Core.Operators.SarOperator.ApplyConstants(Reko.Core.Expressions.Constant c1, Reko.Core.Expressions.Constant c2) -> Reko.Core.Expressions.Constant
override Reko.Core.Operators.SarOperator.AsCompound() -> string
override Reko.Core.Operators.SarOperator.ToString() -> string
override Reko.Core.Operators.SDivOperator.ApplyConstants(Reko.Core.Expressions.Constant c1, Reko.Core.Expressions.Constant c2) -> Reko.Core.Expressions.Constant
override Reko.Core.Operators.SDivOperator.AsCompound() -> string
override Reko.Core.Operators.SDivOperator.ToString() -> string
override Reko.Core.Operators.ShlOperator.ApplyConstants(Reko.Core.Expressions.Constant c1, Reko.Core.Expressions.Constant c2) -> Reko.Core.Expressions.Constant
override Reko.Core.Operators.ShlOperator.AsCompound() -> string
override Reko.Core.Operators.ShlOperator.ToString() -> string
override Reko.Core.Operators.ShrOperator.ApplyConstants(Reko.Core.Expressions.Constant c1, Reko.Core.Expressions.Constant c2) -> Reko.Core.Expressions.Constant
override Reko.Core.Operators.ShrOperator.AsCompound() -> string
override Reko.Core.Operators.ShrOperator.ToString() -> string
override Reko.Core.Operators.SModOperator.ApplyConstants(Reko.Core.Expressions.Constant c1, Reko.Core.Expressions.Constant c2) -> Reko.Core.Expressions.Constant
override Reko.Core.Operators.SModOperator.AsCompound() -> string
override Reko.Core.Operators.SModOperator.ToString() -> string
override Reko.Core.Operators.SMulOperator.ApplyConstants(Reko.Core.Expressions.Constant c1, Reko.Core.Expressions.Constant c2) -> Reko.Core.Expressions.Constant
override Reko.Core.Operators.SMulOperator.AsCompound() -> string
override Reko.Core.Operators.SMulOperator.ToString() -> string
override Reko.Core.Operators.UDivOperator.ApplyConstants(Reko.Core.Expressions.Constant c1, Reko.Core.Expressions.Constant c2) -> Reko.Core.Expressions.Constant
override Reko.Core.Operators.UDivOperator.AsCompound() -> string
override Reko.Core.Operators.UDivOperator.ToString() -> string
override Reko.Core.Operators.UgeOperator.ApplyConstants(Reko.Core.Expressions.Constant c1, Reko.Core.Expressions.Constant c2) -> Reko.Core.Expressions.Constant
override Reko.Core.Operators.UgeOperator.Negate() -> Reko.Core.Operators.Operator
override Reko.Core.Operators.UgeOperator.ToString() -> string
override Reko.Core.Operators.UgtOperator.ApplyConstants(Reko.Core.Expressions.Constant c1, Reko.Core.Expressions.Constant c2) -> Reko.Core.Expressions.Constant
override Reko.Core.Operators.UgtOperator.Negate() -> Reko.Core.Operators.Operator
override Reko.Core.Operators.UgtOperator.ToString() -> string
override Reko.Core.Operators.UleOperator.ApplyConstants(Reko.Core.Expressions.Constant c1, Reko.Core.Expressions.Constant c2) -> Reko.Core.Expressions.Constant
override Reko.Core.Operators.UleOperator.Negate() -> Reko.Core.Operators.Operator
override Reko.Core.Operators.UleOperator.ToString() -> string
override Reko.Core.Operators.UltOperator.ApplyConstants(Reko.Core.Expressions.Constant c1, Reko.Core.Expressions.Constant c2) -> Reko.Core.Expressions.Constant
override Reko.Core.Operators.UltOperator.Negate() -> Reko.Core.Operators.Operator
override Reko.Core.Operators.UltOperator.ToString() -> string
override Reko.Core.Operators.UModOperator.ApplyConstants(Reko.Core.Expressions.Constant c1, Reko.Core.Expressions.Constant c2) -> Reko.Core.Expressions.Constant
override Reko.Core.Operators.UModOperator.AsCompound() -> string
override Reko.Core.Operators.UModOperator.ToString() -> string
override Reko.Core.Operators.UMulOperator.ApplyConstants(Reko.Core.Expressions.Constant c1, Reko.Core.Expressions.Constant c2) -> Reko.Core.Expressions.Constant
override Reko.Core.Operators.UMulOperator.AsCompound() -> string
override Reko.Core.Operators.UMulOperator.ToString() -> string
override Reko.Core.Operators.USubOperator.ApplyConstants(Reko.Core.Expressions.Constant c1, Reko.Core.Expressions.Constant c2) -> Reko.Core.Expressions.Constant
override Reko.Core.Operators.USubOperator.AsCompound() -> string
override Reko.Core.Operators.USubOperator.ToString() -> string
override Reko.Core.Operators.XorOperator.ApplyConstants(Reko.Core.Expressions.Constant c1, Reko.Core.Expressions.Constant c2) -> Reko.Core.Expressions.Constant
override Reko.Core.Operators.XorOperator.AsCompound() -> string
override Reko.Core.Operators.XorOperator.ToString() -> string
override Reko.Core.OrdinalImportReference.CompareTo(Reko.Core.ImportReference that) -> int
override Reko.Core.OrdinalImportReference.ResolveImport(Reko.Core.IDynamicLinker dynamicLinker, Reko.Core.IPlatform platform, Reko.Core.AddressContext ctx) -> Reko.Core.Expressions.Expression
override Reko.Core.OrdinalImportReference.ResolveImportedProcedure(Reko.Core.IDynamicLinker resolver, Reko.Core.IPlatform platform, Reko.Core.AddressContext ctx) -> Reko.Core.ExternalProcedure
override Reko.Core.OrdinalImportReference.ToString() -> string
override Reko.Core.OutArgumentStorage.Accept<T, C>(Reko.Core.StorageVisitor<T, C> visitor, C context) -> T
override Reko.Core.OutArgumentStorage.Accept<T>(Reko.Core.StorageVisitor<T> visitor) -> T
override Reko.Core.OutArgumentStorage.Covers(Reko.Core.Storage that) -> bool
override Reko.Core.OutArgumentStorage.Equals(object obj) -> bool
override Reko.Core.OutArgumentStorage.GetHashCode() -> int
override Reko.Core.OutArgumentStorage.OffsetOf(Reko.Core.Storage stgSub) -> int
override Reko.Core.OutArgumentStorage.OverlapsWith(Reko.Core.Storage that) -> bool
override Reko.Core.OutArgumentStorage.Serialize() -> Reko.Core.Serialization.SerializedKind
override Reko.Core.OutArgumentStorage.Write(System.IO.TextWriter writer) -> void
override Reko.Core.Output.AbsynCodeFormatter.VisitConstant(Reko.Core.Expressions.Constant! c) -> void
override Reko.Core.Output.CTypeReferenceFormatter.WritePrimitiveTypeName(Reko.Core.Types.PrimitiveType t) -> void
override Reko.Core.Output.CTypeReferenceFormatter.WriteVoidType(Reko.Core.Types.VoidType t) -> void
override Reko.Core.Output.NullFormatter.Begin(object tag) -> void
override Reko.Core.Output.NullFormatter.Terminate() -> void
override Reko.Core.Output.NullFormatter.Write(char ch) -> Reko.Core.Output.Formatter
override Reko.Core.Output.NullFormatter.Write(string format, params object[] arguments) -> void
override Reko.Core.Output.NullFormatter.Write(string s) -> void
override Reko.Core.Output.NullFormatter.WriteComment(string comment) -> void
override Reko.Core.Output.NullFormatter.WriteHyperlink(string text, object href) -> void
override Reko.Core.Output.NullFormatter.WriteKeyword(string keyword) -> void
override Reko.Core.Output.NullFormatter.WriteLabel(string label, object block) -> void
override Reko.Core.Output.NullFormatter.WriteLine() -> void
override Reko.Core.Output.NullFormatter.WriteLine(string format, params object[] arguments) -> void
override Reko.Core.Output.NullFormatter.WriteLine(string s) -> void
override Reko.Core.Output.NullFormatter.WriteType(string typeName, Reko.Core.Types.DataType dt) -> void
override Reko.Core.Output.SegmentFilePolicy.GetItemPlacements(string fileExtension) -> System.Collections.Generic.Dictionary<string, System.Collections.Generic.Dictionary<Reko.Core.ImageSegment, System.Collections.Generic.List<Reko.Core.ImageMapItem>>>
override Reko.Core.Output.SegmentFilePolicy.GetObjectPlacements(string fileExtension, Reko.Core.Services.DecompilerEventListener listener) -> System.Collections.Generic.Dictionary<string, System.Collections.Generic.IDictionary<Reko.Core.Address, Reko.Core.IAddressable>>
override Reko.Core.Output.SingleFilePolicy.GetItemPlacements(string fileExtension) -> System.Collections.Generic.Dictionary<string, System.Collections.Generic.Dictionary<Reko.Core.ImageSegment, System.Collections.Generic.List<Reko.Core.ImageMapItem>>>
override Reko.Core.Output.SingleFilePolicy.GetObjectPlacements(string fileExtension, Reko.Core.Services.DecompilerEventListener listener) -> System.Collections.Generic.Dictionary<string, System.Collections.Generic.IDictionary<Reko.Core.Address, Reko.Core.IAddressable>>
override Reko.Core.Output.TextFormatter.Begin(object tag) -> void
override Reko.Core.Output.TextFormatter.Terminate() -> void
override Reko.Core.Output.TextFormatter.Write(char ch) -> Reko.Core.Output.Formatter
override Reko.Core.Output.TextFormatter.Write(string format, params object[] arguments) -> void
override Reko.Core.Output.TextFormatter.Write(string s) -> void
override Reko.Core.Output.TextFormatter.WriteComment(string comment) -> void
override Reko.Core.Output.TextFormatter.WriteHyperlink(string text, object href) -> void
override Reko.Core.Output.TextFormatter.WriteKeyword(string keyword) -> void
override Reko.Core.Output.TextFormatter.WriteLabel(string label, object block) -> void
override Reko.Core.Output.TextFormatter.WriteLine() -> void
override Reko.Core.Output.TextFormatter.WriteLine(string format, params object[] args) -> void
override Reko.Core.Output.TextFormatter.WriteLine(string s) -> void
override Reko.Core.Output.TextFormatter.WriteType(string typeName, Reko.Core.Types.DataType dt) -> void
override Reko.Core.Procedure.Signature.get -> Reko.Core.Types.FunctionType
override Reko.Core.Procedure.Signature.set -> void
override Reko.Core.ProcedureBase.ToString() -> string
override Reko.Core.ProgramResource.ToString() -> string
override Reko.Core.ProgramResourceInstance.ToString() -> string
override Reko.Core.ProtectedSegmentedAddress.Add(long offset) -> Reko.Core.Address
override Reko.Core.ProtectedSegmentedAddress.Align(int alignment) -> Reko.Core.Address
override Reko.Core.ProtectedSegmentedAddress.CloneExpression() -> Reko.Core.Expressions.Expression
override Reko.Core.ProtectedSegmentedAddress.GenerateName(string prefix, string suffix) -> string
override Reko.Core.ProtectedSegmentedAddress.IsNull.get -> bool
override Reko.Core.ProtectedSegmentedAddress.NewOffset(ulong offset) -> Reko.Core.Address
override Reko.Core.ProtectedSegmentedAddress.Offset.get -> ulong
override Reko.Core.ProtectedSegmentedAddress.Selector.get -> ushort?
override Reko.Core.ProtectedSegmentedAddress.ToConstant() -> Reko.Core.Expressions.Constant
override Reko.Core.ProtectedSegmentedAddress.ToLinear() -> ulong
override Reko.Core.ProtectedSegmentedAddress.ToString() -> string
override Reko.Core.ProtectedSegmentedAddress.ToUInt16() -> ushort
override Reko.Core.ProtectedSegmentedAddress.ToUInt32() -> uint
override Reko.Core.RealSegmentedAddress.Add(long offset) -> Reko.Core.Address
override Reko.Core.RealSegmentedAddress.Align(int alignment) -> Reko.Core.Address
override Reko.Core.RealSegmentedAddress.CloneExpression() -> Reko.Core.Expressions.Expression
override Reko.Core.RealSegmentedAddress.GenerateName(string prefix, string suffix) -> string
override Reko.Core.RealSegmentedAddress.IsNull.get -> bool
override Reko.Core.RealSegmentedAddress.NewOffset(ulong offset) -> Reko.Core.Address
override Reko.Core.RealSegmentedAddress.Offset.get -> ulong
override Reko.Core.RealSegmentedAddress.Selector.get -> ushort?
override Reko.Core.RealSegmentedAddress.ToConstant() -> Reko.Core.Expressions.Constant
override Reko.Core.RealSegmentedAddress.ToLinear() -> ulong
override Reko.Core.RealSegmentedAddress.ToString() -> string
override Reko.Core.RealSegmentedAddress.ToUInt16() -> ushort
override Reko.Core.RealSegmentedAddress.ToUInt32() -> uint
override Reko.Core.RegisterStorage.Accept<T, C>(Reko.Core.StorageVisitor<T, C> visitor, C context) -> T
override Reko.Core.RegisterStorage.Accept<T>(Reko.Core.StorageVisitor<T> visitor) -> T
override Reko.Core.RegisterStorage.BitSize.get -> ulong
override Reko.Core.RegisterStorage.BitSize.set -> void
override Reko.Core.RegisterStorage.Covers(Reko.Core.Storage other) -> bool
override Reko.Core.RegisterStorage.Equals(object obj) -> bool
override Reko.Core.RegisterStorage.Exceeds(Reko.Core.Storage sThat) -> bool
override Reko.Core.RegisterStorage.GetBitRange() -> Reko.Core.BitRange
override Reko.Core.RegisterStorage.GetHashCode() -> int
override Reko.Core.RegisterStorage.OffsetOf(Reko.Core.Storage stgSub) -> int
override Reko.Core.RegisterStorage.OverlapsWith(Reko.Core.Storage sThat) -> bool
override Reko.Core.RegisterStorage.Serialize() -> Reko.Core.Serialization.SerializedKind
override Reko.Core.RegisterStorage.Write(System.IO.TextWriter writer) -> void
override Reko.Core.Rtl.RtlAssignment.Accept<T>(Reko.Core.Rtl.RtlInstructionVisitor<T> visitor) -> T
override Reko.Core.Rtl.RtlBranch.Accept<T>(Reko.Core.Rtl.RtlInstructionVisitor<T> visitor) -> T
override Reko.Core.Rtl.RtlCall.Accept<T>(Reko.Core.Rtl.RtlInstructionVisitor<T> visitor) -> T
override Reko.Core.Rtl.RtlGoto.Accept<T>(Reko.Core.Rtl.RtlInstructionVisitor<T> visitor) -> T
override Reko.Core.Rtl.RtlIf.Accept<T>(Reko.Core.Rtl.RtlInstructionVisitor<T> visitor) -> T
override Reko.Core.Rtl.RtlInstruction.ToString() -> string
override Reko.Core.Rtl.RtlInstructionCluster.ToString() -> string
override Reko.Core.Rtl.RtlInvalid.Accept<T>(Reko.Core.Rtl.RtlInstructionVisitor<T> visitor) -> T
override Reko.Core.Rtl.RtlLocation.Equals(object obj) -> bool
override Reko.Core.Rtl.RtlLocation.GetHashCode() -> int
override Reko.Core.Rtl.RtlLocation.ToString() -> string
override Reko.Core.Rtl.RtlMicroGoto.Accept<T>(Reko.Core.Rtl.RtlInstructionVisitor<T> visitor) -> T
override Reko.Core.Rtl.RtlMicroGoto.WriteInner(System.IO.TextWriter writer) -> void
override Reko.Core.Rtl.RtlMicroLabel.Accept<T>(Reko.Core.Rtl.RtlInstructionVisitor<T> visitor) -> T
override Reko.Core.Rtl.RtlMicroLabel.WriteInner(System.IO.TextWriter writer) -> void
override Reko.Core.Rtl.RtlNop.Accept<T>(Reko.Core.Rtl.RtlInstructionVisitor<T> visitor) -> T
override Reko.Core.Rtl.RtlReturn.Accept<T>(Reko.Core.Rtl.RtlInstructionVisitor<T> visitor) -> T
override Reko.Core.Rtl.RtlSideEffect.Accept<T>(Reko.Core.Rtl.RtlInstructionVisitor<T> visitor) -> T
override Reko.Core.Rtl.RtlSwitch.Accept<T>(Reko.Core.Rtl.RtlInstructionVisitor<T> visitor) -> T
override Reko.Core.Rtl.RtlSwitch.WriteInner(System.IO.TextWriter writer) -> void
override Reko.Core.Scripts.ScriptStackFrame.ToString() -> string
override Reko.Core.SequenceStorage.Accept<T, C>(Reko.Core.StorageVisitor<T, C> visitor, C context) -> T
override Reko.Core.SequenceStorage.Accept<T>(Reko.Core.StorageVisitor<T> visitor) -> T
override Reko.Core.SequenceStorage.Covers(Reko.Core.Storage that) -> bool
override Reko.Core.SequenceStorage.Equals(object obj) -> bool
override Reko.Core.SequenceStorage.Exceeds(Reko.Core.Storage that) -> bool
override Reko.Core.SequenceStorage.GetHashCode() -> int
override Reko.Core.SequenceStorage.OffsetOf(Reko.Core.Storage stgSub) -> int
override Reko.Core.SequenceStorage.OverlapsWith(Reko.Core.Storage that) -> bool
override Reko.Core.SequenceStorage.Serialize() -> Reko.Core.Serialization.SerializedKind
override Reko.Core.SequenceStorage.Write(System.IO.TextWriter writer) -> void
override Reko.Core.Serialization.Argument_v1.ToString() -> string
override Reko.Core.Serialization.ArrayType_v1.Accept<T>(Reko.Core.Serialization.ISerializedTypeVisitor<T> visitor) -> T
override Reko.Core.Serialization.ArrayType_v1.ToString() -> string
override Reko.Core.Serialization.CodeType_v1.Accept<T>(Reko.Core.Serialization.ISerializedTypeVisitor<T> visitor) -> T
override Reko.Core.Serialization.CodeType_v1.ToString() -> string
override Reko.Core.Serialization.DefaultProcedureCharacteristics.IsAlloca.get -> bool
override Reko.Core.Serialization.DefaultProcedureCharacteristics.IsAlloca.set -> void
override Reko.Core.Serialization.DefaultProcedureCharacteristics.Terminates.get -> bool
override Reko.Core.Serialization.DefaultProcedureCharacteristics.Terminates.set -> void
override Reko.Core.Serialization.DefaultProcedureCharacteristics.VarargsParserClass.get -> string
override Reko.Core.Serialization.DefaultProcedureCharacteristics.VarargsParserClass.set -> void
override Reko.Core.Serialization.FlagGroup_v1.Deserialize(Reko.Core.Serialization.ArgumentDeserializer sser) -> Reko.Core.Expressions.Identifier
override Reko.Core.Serialization.FpuStackVariable_v1.Deserialize(Reko.Core.Serialization.ArgumentDeserializer sser) -> Reko.Core.Expressions.Identifier
override Reko.Core.Serialization.MemberPointer_v1.Accept<T>(Reko.Core.Serialization.ISerializedTypeVisitor<T> visitor) -> T
override Reko.Core.Serialization.PointerType_v1.Accept<T>(Reko.Core.Serialization.ISerializedTypeVisitor<T> visitor) -> T
override Reko.Core.Serialization.PointerType_v1.ToString() -> string
override Reko.Core.Serialization.PrimitiveType_v1.Accept<T>(Reko.Core.Serialization.ISerializedTypeVisitor<T> visitor) -> T
override Reko.Core.Serialization.PrimitiveType_v1.ToString() -> string
override Reko.Core.Serialization.Project_v4.Accept<T>(Reko.Core.Serialization.ISerializedProjectVisitor<T> visitor) -> T
override Reko.Core.Serialization.Project_v5.Accept<T>(Reko.Core.Serialization.ISerializedProjectVisitor<T> visitor) -> T
override Reko.Core.Serialization.ReferenceType_v1.Accept<T>(Reko.Core.Serialization.ISerializedTypeVisitor<T> visitor) -> T
override Reko.Core.Serialization.ReferenceType_v1.ToString() -> string
override Reko.Core.Serialization.Register_v1.Deserialize(Reko.Core.Serialization.ArgumentDeserializer sser) -> Reko.Core.Expressions.Identifier
override Reko.Core.Serialization.SerializedEnumType.Accept<T>(Reko.Core.Serialization.ISerializedTypeVisitor<T> visitor) -> T
override Reko.Core.Serialization.SerializedSequence.Deserialize(Reko.Core.Serialization.ArgumentDeserializer sser) -> Reko.Core.Expressions.Identifier
override Reko.Core.Serialization.SerializedSignature.Accept<T>(Reko.Core.Serialization.ISerializedTypeVisitor<T> visitor) -> T
override Reko.Core.Serialization.SerializedSignature.ToString() -> string
override Reko.Core.Serialization.SerializedTemplate.Accept<T>(Reko.Core.Serialization.ISerializedTypeVisitor<T> visitor) -> T
override Reko.Core.Serialization.SerializedTemplate.ToString() -> string
override Reko.Core.Serialization.SerializedTypedef.Accept<T>(Reko.Core.Serialization.ISerializedTypeVisitor<T> visitor) -> T
override Reko.Core.Serialization.SerializedTypedef.ToString() -> string
override Reko.Core.Serialization.StackVariable_v1.Deserialize(Reko.Core.Serialization.ArgumentDeserializer sser) -> Reko.Core.Expressions.Identifier
override Reko.Core.Serialization.StringType_v2.Accept<T>(Reko.Core.Serialization.ISerializedTypeVisitor<T> visitor) -> T
override Reko.Core.Serialization.StructType_v1.Accept<T>(Reko.Core.Serialization.ISerializedTypeVisitor<T> visitor) -> T
override Reko.Core.Serialization.StructType_v1.ToString() -> string
override Reko.Core.Serialization.TypeReference_v1.Accept<T>(Reko.Core.Serialization.ISerializedTypeVisitor<T> visitor) -> T
override Reko.Core.Serialization.TypeReference_v1.ToString() -> string
override Reko.Core.Serialization.UnionType_v1.Accept<T>(Reko.Core.Serialization.ISerializedTypeVisitor<T> visitor) -> T
override Reko.Core.Serialization.UnionType_v1.ToString() -> string
override Reko.Core.Serialization.VoidType_v1.Accept<T>(Reko.Core.Serialization.ISerializedTypeVisitor<T> visitor) -> T
override Reko.Core.Serialization.VoidType_v1.ToString() -> string
override Reko.Core.Services.NullCodeLocation.ToString() -> string!
override Reko.Core.StackStorage.Accept<T, C>(Reko.Core.StorageVisitor<T, C> visitor, C context) -> T
override Reko.Core.StackStorage.Accept<T>(Reko.Core.StorageVisitor<T> visitor) -> T
override Reko.Core.StackStorage.Covers(Reko.Core.Storage other) -> bool
override Reko.Core.StackStorage.Equals(object obj) -> bool
override Reko.Core.StackStorage.GetHashCode() -> int
override Reko.Core.StackStorage.OffsetOf(Reko.Core.Storage stgSub) -> int
override Reko.Core.StackStorage.OverlapsWith(Reko.Core.Storage other) -> bool
override Reko.Core.StackStorage.Serialize() -> Reko.Core.Serialization.SerializedKind
override Reko.Core.StackStorage.Write(System.IO.TextWriter writer) -> void
override Reko.Core.Statement.ToString() -> string
override Reko.Core.Storage.ToString() -> string
override Reko.Core.StridedInterval.ToString() -> string
override Reko.Core.StringFieldAttribute.ReadValue(System.Reflection.FieldInfo f, Reko.Core.Memory.EndianImageReader rdr, Reko.Core.ReaderContext ctx) -> object
override Reko.Core.TemporaryStorage.Accept<T, C>(Reko.Core.StorageVisitor<T, C> visitor, C context) -> T
override Reko.Core.TemporaryStorage.Accept<T>(Reko.Core.StorageVisitor<T> visitor) -> T
override Reko.Core.TemporaryStorage.Covers(Reko.Core.Storage that) -> bool
override Reko.Core.TemporaryStorage.Exceeds(Reko.Core.Storage that) -> bool
override Reko.Core.TemporaryStorage.OffsetOf(Reko.Core.Storage stgSub) -> int
override Reko.Core.TemporaryStorage.OverlapsWith(Reko.Core.Storage that) -> bool
override Reko.Core.TemporaryStorage.Write(System.IO.TextWriter writer) -> void
override Reko.Core.TypeLibraryLoader.Load(Reko.Core.IPlatform platform, Reko.Core.TypeLibrary dstLib) -> Reko.Core.TypeLibrary
override Reko.Core.Types.ArrayType.Accept(Reko.Core.Types.IDataTypeVisitor v) -> void
override Reko.Core.Types.ArrayType.Accept<T>(Reko.Core.Types.IDataTypeVisitor<T> v) -> T
override Reko.Core.Types.ArrayType.Clone(System.Collections.Generic.IDictionary<Reko.Core.Types.DataType, Reko.Core.Types.DataType> clonedTypes) -> Reko.Core.Types.DataType
override Reko.Core.Types.ArrayType.IsComplex.get -> bool
override Reko.Core.Types.ArrayType.Size.get -> int
override Reko.Core.Types.ArrayType.Size.set -> void
override Reko.Core.Types.ClassType.Accept(Reko.Core.Types.IDataTypeVisitor v) -> void
override Reko.Core.Types.ClassType.Accept<T>(Reko.Core.Types.IDataTypeVisitor<T> v) -> T
override Reko.Core.Types.ClassType.Clone(System.Collections.Generic.IDictionary<Reko.Core.Types.DataType, Reko.Core.Types.DataType> clonedTypes) -> Reko.Core.Types.DataType
override Reko.Core.Types.ClassType.Size.get -> int
override Reko.Core.Types.ClassType.Size.set -> void
override Reko.Core.Types.CodeType.Accept(Reko.Core.Types.IDataTypeVisitor v) -> void
override Reko.Core.Types.CodeType.Accept<T>(Reko.Core.Types.IDataTypeVisitor<T> v) -> T
override Reko.Core.Types.CodeType.Clone(System.Collections.Generic.IDictionary<Reko.Core.Types.DataType, Reko.Core.Types.DataType> clonedTypes) -> Reko.Core.Types.DataType
override Reko.Core.Types.CodeType.Size.get -> int
override Reko.Core.Types.CodeType.Size.set -> void
override Reko.Core.Types.DataTypeBuilderUnifier.UnifyTypeVariables(Reko.Core.Types.TypeVariable tA, Reko.Core.Types.TypeVariable tB) -> Reko.Core.Types.DataType
override Reko.Core.Types.EnumType.Accept(Reko.Core.Types.IDataTypeVisitor v) -> void
override Reko.Core.Types.EnumType.Accept<T>(Reko.Core.Types.IDataTypeVisitor<T> v) -> T
override Reko.Core.Types.EnumType.Clone(System.Collections.Generic.IDictionary<Reko.Core.Types.DataType, Reko.Core.Types.DataType> clonedTypes) -> Reko.Core.Types.DataType
override Reko.Core.Types.EnumType.Size.get -> int
override Reko.Core.Types.EnumType.Size.set -> void
override Reko.Core.Types.EquivalenceClass.Accept(Reko.Core.Types.IDataTypeVisitor v) -> void
override Reko.Core.Types.EquivalenceClass.Accept<T>(Reko.Core.Types.IDataTypeVisitor<T> v) -> T
override Reko.Core.Types.EquivalenceClass.Clone(System.Collections.Generic.IDictionary<Reko.Core.Types.DataType, Reko.Core.Types.DataType> clonedTypes) -> Reko.Core.Types.DataType
override Reko.Core.Types.EquivalenceClass.IsComplex.get -> bool
override Reko.Core.Types.EquivalenceClass.Name.get -> string
override Reko.Core.Types.EquivalenceClass.Size.get -> int
override Reko.Core.Types.EquivalenceClass.Size.set -> void
override Reko.Core.Types.FunctionType.Accept(Reko.Core.Types.IDataTypeVisitor v) -> void
override Reko.Core.Types.FunctionType.Accept<T>(Reko.Core.Types.IDataTypeVisitor<T> v) -> T
override Reko.Core.Types.FunctionType.Clone(System.Collections.Generic.IDictionary<Reko.Core.Types.DataType, Reko.Core.Types.DataType> clonedTypes) -> Reko.Core.Types.DataType
override Reko.Core.Types.FunctionType.Size.get -> int
override Reko.Core.Types.FunctionType.Size.set -> void
override Reko.Core.Types.MemberPointer.Accept(Reko.Core.Types.IDataTypeVisitor v) -> void
override Reko.Core.Types.MemberPointer.Accept<T>(Reko.Core.Types.IDataTypeVisitor<T> v) -> T
override Reko.Core.Types.MemberPointer.BitSize.get -> int
override Reko.Core.Types.MemberPointer.Clone(System.Collections.Generic.IDictionary<Reko.Core.Types.DataType, Reko.Core.Types.DataType> clonedTypes) -> Reko.Core.Types.DataType
override Reko.Core.Types.MemberPointer.IsComplex.get -> bool
override Reko.Core.Types.MemberPointer.Size.get -> int
override Reko.Core.Types.MemberPointer.Size.set -> void
override Reko.Core.Types.Pointer.Accept(Reko.Core.Types.IDataTypeVisitor v) -> void
override Reko.Core.Types.Pointer.Accept<T>(Reko.Core.Types.IDataTypeVisitor<T> v) -> T
override Reko.Core.Types.Pointer.BitSize.get -> int
override Reko.Core.Types.Pointer.Clone(System.Collections.Generic.IDictionary<Reko.Core.Types.DataType, Reko.Core.Types.DataType> clonedTypes) -> Reko.Core.Types.DataType
override Reko.Core.Types.Pointer.IsComplex.get -> bool
override Reko.Core.Types.Pointer.IsPointer.get -> bool
override Reko.Core.Types.Pointer.Size.get -> int
override Reko.Core.Types.Pointer.Size.set -> void
override Reko.Core.Types.PrimitiveType.Accept(Reko.Core.Types.IDataTypeVisitor v) -> void
override Reko.Core.Types.PrimitiveType.Accept<T>(Reko.Core.Types.IDataTypeVisitor<T> v) -> T
override Reko.Core.Types.PrimitiveType.BitSize.get -> int
override Reko.Core.Types.PrimitiveType.Clone(System.Collections.Generic.IDictionary<Reko.Core.Types.DataType, Reko.Core.Types.DataType> clonedTypes) -> Reko.Core.Types.DataType
override Reko.Core.Types.PrimitiveType.Equals(object obj) -> bool
override Reko.Core.Types.PrimitiveType.GetHashCode() -> int
override Reko.Core.Types.PrimitiveType.IsIntegral.get -> bool
override Reko.Core.Types.PrimitiveType.IsPointer.get -> bool
override Reko.Core.Types.PrimitiveType.IsReal.get -> bool
override Reko.Core.Types.PrimitiveType.IsWord.get -> bool
override Reko.Core.Types.PrimitiveType.Size.get -> int
override Reko.Core.Types.PrimitiveType.Size.set -> void
override Reko.Core.Types.ReferenceTo.Accept(Reko.Core.Types.IDataTypeVisitor v) -> void
override Reko.Core.Types.ReferenceTo.Accept<T>(Reko.Core.Types.IDataTypeVisitor<T> v) -> T
override Reko.Core.Types.ReferenceTo.Clone(System.Collections.Generic.IDictionary<Reko.Core.Types.DataType, Reko.Core.Types.DataType> clonedTypes) -> Reko.Core.Types.DataType
override Reko.Core.Types.ReferenceTo.Size.get -> int
override Reko.Core.Types.ReferenceTo.Size.set -> void
override Reko.Core.Types.StringType.Accept(Reko.Core.Types.IDataTypeVisitor v) -> void
override Reko.Core.Types.StringType.Accept<T>(Reko.Core.Types.IDataTypeVisitor<T> v) -> T
override Reko.Core.Types.StringType.Clone(System.Collections.Generic.IDictionary<Reko.Core.Types.DataType, Reko.Core.Types.DataType> clonedTypes) -> Reko.Core.Types.DataType
override Reko.Core.Types.StructureField.Name.get -> string
override Reko.Core.Types.StructureField.Name.set -> void
override Reko.Core.Types.StructureField.ToString() -> string
override Reko.Core.Types.StructureType.Accept(Reko.Core.Types.IDataTypeVisitor v) -> void
override Reko.Core.Types.StructureType.Accept<T>(Reko.Core.Types.IDataTypeVisitor<T> v) -> T
override Reko.Core.Types.StructureType.Clone(System.Collections.Generic.IDictionary<Reko.Core.Types.DataType, Reko.Core.Types.DataType> clonedTypes) -> Reko.Core.Types.DataType
override Reko.Core.Types.StructureType.IsComplex.get -> bool
override Reko.Core.Types.StructureType.Size.get -> int
override Reko.Core.Types.StructureType.Size.set -> void
override Reko.Core.Types.TypeReference.Accept(Reko.Core.Types.IDataTypeVisitor v) -> void
override Reko.Core.Types.TypeReference.Accept<T>(Reko.Core.Types.IDataTypeVisitor<T> v) -> T
override Reko.Core.Types.TypeReference.Clone(System.Collections.Generic.IDictionary<Reko.Core.Types.DataType, Reko.Core.Types.DataType> clonedTypes) -> Reko.Core.Types.DataType
override Reko.Core.Types.TypeReference.IsComplex.get -> bool
override Reko.Core.Types.TypeReference.IsIntegral.get -> bool
override Reko.Core.Types.TypeReference.IsPointer.get -> bool
override Reko.Core.Types.TypeReference.IsReal.get -> bool
override Reko.Core.Types.TypeReference.Size.get -> int
override Reko.Core.Types.TypeReference.Size.set -> void
override Reko.Core.Types.TypeVariable.Accept(Reko.Core.Types.IDataTypeVisitor v) -> void
override Reko.Core.Types.TypeVariable.Accept<T>(Reko.Core.Types.IDataTypeVisitor<T> v) -> T
override Reko.Core.Types.TypeVariable.Clone(System.Collections.Generic.IDictionary<Reko.Core.Types.DataType, Reko.Core.Types.DataType> clonedTypes) -> Reko.Core.Types.DataType
override Reko.Core.Types.TypeVariable.Size.get -> int
override Reko.Core.Types.TypeVariable.Size.set -> void
override Reko.Core.Types.UnionAlternative.Name.get -> string
override Reko.Core.Types.UnionAlternative.Name.set -> void
override Reko.Core.Types.UnionType.Accept(Reko.Core.Types.IDataTypeVisitor v) -> void
override Reko.Core.Types.UnionType.Accept<T>(Reko.Core.Types.IDataTypeVisitor<T> v) -> T
override Reko.Core.Types.UnionType.BitSize.get -> int
override Reko.Core.Types.UnionType.Clone(System.Collections.Generic.IDictionary<Reko.Core.Types.DataType, Reko.Core.Types.DataType> clonedTypes) -> Reko.Core.Types.DataType
override Reko.Core.Types.UnionType.IsComplex.get -> bool
override Reko.Core.Types.UnionType.Size.get -> int
override Reko.Core.Types.UnionType.Size.set -> void
override Reko.Core.Types.UnknownType.Accept(Reko.Core.Types.IDataTypeVisitor v) -> void
override Reko.Core.Types.UnknownType.Accept<T>(Reko.Core.Types.IDataTypeVisitor<T> v) -> T
override Reko.Core.Types.UnknownType.Clone(System.Collections.Generic.IDictionary<Reko.Core.Types.DataType, Reko.Core.Types.DataType> clonedTypes) -> Reko.Core.Types.DataType
override Reko.Core.Types.UnknownType.Size.get -> int
override Reko.Core.Types.UnknownType.Size.set -> void
override Reko.Core.Types.VoidType.Accept(Reko.Core.Types.IDataTypeVisitor v) -> void
override Reko.Core.Types.VoidType.Accept<T>(Reko.Core.Types.IDataTypeVisitor<T> v) -> T
override Reko.Core.Types.VoidType.Clone(System.Collections.Generic.IDictionary<Reko.Core.Types.DataType, Reko.Core.Types.DataType> clonedTypes) -> Reko.Core.Types.DataType
override Reko.Core.Types.VoidType.Size.get -> int
override Reko.Core.Types.VoidType.Size.set -> void
override Reko.Core.WarningDiagnostic.ImageKey.get -> string
override sealed Reko.Core.Absyn.AbsynStatement.ToString() -> string
override sealed Reko.Core.Expressions.ConstantReal.IsMaxUnsigned.get -> bool
override sealed Reko.Core.Hll.C.CExpression.Accept<T>(Reko.Core.Hll.C.CSyntaxVisitor<T> visitor) -> T
override sealed Reko.Core.Hll.C.DeclSpec.Accept<T>(Reko.Core.Hll.C.CSyntaxVisitor<T> visitor) -> T
override sealed Reko.Core.Hll.Pascal.PascalSyntax.ToString() -> string
override sealed Reko.Core.Machine.AbstractMachineOperand.ToString() -> string!
override sealed Reko.Core.Machine.MachineInstruction.ToString() -> string
override sealed Reko.Core.Machine.WideDecoder<TDasm, TMnemonic, TInstr>.Decode(uint wInstr, TDasm dasm) -> TInstr
override sealed Reko.Core.Types.DataType.ToString() -> string
readonly Reko.Core.AddressSearchHit.Address -> Reko.Core.Address
readonly Reko.Core.AddressSearchHit.Length -> int
readonly Reko.Core.AddressSearchHit.Program -> Reko.Core.Program
readonly Reko.Core.Collections.BTreeDictionary<TKey, TValue>.Collection<T>.btree -> Reko.Core.Collections.BTreeDictionary<TKey, TValue>
readonly Reko.Core.Collections.ConcurrentBTreeDictionary<TKey, TValue>.Collection<T>.btree -> Reko.Core.Collections.ConcurrentBTreeDictionary<TKey, TValue>
readonly Reko.Core.Collections.Interval<T>.End -> T
readonly Reko.Core.Collections.Interval<T>.Start -> T
readonly Reko.Core.Expressions.PhiArgument.Block -> Reko.Core.Block
readonly Reko.Core.Expressions.PhiArgument.Value -> Reko.Core.Expressions.Expression
readonly Reko.Core.Hll.Pascal.Primitive.Type -> Reko.Core.Serialization.SerializedType
readonly Reko.Core.Lib.Bitfield.Length -> int
readonly Reko.Core.Lib.Bitfield.Mask -> uint
readonly Reko.Core.Lib.Bitfield.Position -> int
readonly Reko.Core.Lib.Float80.exponent -> ushort
readonly Reko.Core.Lib.Float80.significand -> ulong
readonly Reko.Core.Lib.Float96.exponent -> ushort
readonly Reko.Core.Lib.Float96.significand -> ulong
readonly Reko.Core.Lib.Rational.Denominator -> long
readonly Reko.Core.Lib.Rational.Numerator -> long
readonly Reko.Core.Memory.Word16ImageReader.mem -> Reko.Core.Memory.Word16MemoryArea
readonly Reko.Core.Memory.Word64ImageReader.mem -> Reko.Core.Memory.Word64MemoryArea
readonly Reko.Core.Output.OutputFilePolicy.program -> Reko.Core.Program
readonly Reko.Core.ProgramAddress.Address -> Reko.Core.Address
readonly Reko.Core.ProgramAddress.Program -> Reko.Core.Program
readonly Reko.Core.Provenance<T>.ReachedFrom -> T
readonly Reko.Core.Scripts.ScriptError.Exception -> System.Exception
readonly Reko.Core.Scripts.ScriptError.FileName -> string
readonly Reko.Core.Scripts.ScriptError.LineNumber -> int?
readonly Reko.Core.Scripts.ScriptError.Message -> string
readonly Reko.Core.Scripts.ScriptError.StackFrames -> System.Collections.Generic.IList<Reko.Core.Scripts.ScriptStackFrame>
readonly Reko.Core.Scripts.ScriptStackFrame.FileName -> string
readonly Reko.Core.Scripts.ScriptStackFrame.LineNumber -> int
readonly Reko.Core.Scripts.ScriptStackFrame.MethodName -> string
readonly Reko.Core.StridedInterval.High -> long
readonly Reko.Core.StridedInterval.Low -> long
readonly Reko.Core.StridedInterval.Stride -> int
Reko.AssemblyMetadata
Reko.Core.Absyn.AbsynAssignment
Reko.Core.Absyn.AbsynAssignment.AbsynAssignment(Reko.Core.Expressions.Expression! dst, Reko.Core.Expressions.Expression! src) -> void
Reko.Core.Absyn.AbsynAssignment.Dst.get -> Reko.Core.Expressions.Expression!
Reko.Core.Absyn.AbsynAssignment.Src.get -> Reko.Core.Expressions.Expression!
Reko.Core.Absyn.AbsynBreak
Reko.Core.Absyn.AbsynBreak.AbsynBreak() -> void
Reko.Core.Absyn.AbsynCase
Reko.Core.Absyn.AbsynCase.AbsynCase(Reko.Core.Expressions.Constant! c) -> void
Reko.Core.Absyn.AbsynCase.Constant.get -> Reko.Core.Expressions.Constant!
Reko.Core.Absyn.AbsynCompoundAssignment
Reko.Core.Absyn.AbsynCompoundAssignment.AbsynCompoundAssignment(Reko.Core.Expressions.Expression! dst, Reko.Core.Expressions.BinaryExpression! src) -> void
Reko.Core.Absyn.AbsynCompoundAssignment.Src.get -> Reko.Core.Expressions.BinaryExpression!
Reko.Core.Absyn.AbsynContinue
Reko.Core.Absyn.AbsynContinue.AbsynContinue() -> void
Reko.Core.Absyn.AbsynDeclaration
Reko.Core.Absyn.AbsynDeclaration.AbsynDeclaration(Reko.Core.Expressions.Identifier id, Reko.Core.Expressions.Expression expr) -> void
Reko.Core.Absyn.AbsynDeclaration.Expression.get -> Reko.Core.Expressions.Expression
Reko.Core.Absyn.AbsynDeclaration.Expression.set -> void
Reko.Core.Absyn.AbsynDeclaration.Identifier.get -> Reko.Core.Expressions.Identifier
Reko.Core.Absyn.AbsynDefault
Reko.Core.Absyn.AbsynDefault.AbsynDefault() -> void
Reko.Core.Absyn.AbsynDoWhile
Reko.Core.Absyn.AbsynDoWhile.AbsynDoWhile(System.Collections.Generic.List<Reko.Core.Absyn.AbsynStatement> body, Reko.Core.Expressions.Expression condition) -> void
Reko.Core.Absyn.AbsynFor
Reko.Core.Absyn.AbsynFor.AbsynFor(Reko.Core.Absyn.AbsynAssignment init, Reko.Core.Expressions.Expression condition, Reko.Core.Absyn.AbsynAssignment iteration, System.Collections.Generic.List<Reko.Core.Absyn.AbsynStatement> body) -> void
Reko.Core.Absyn.AbsynFor.Body.get -> System.Collections.Generic.List<Reko.Core.Absyn.AbsynStatement>
Reko.Core.Absyn.AbsynFor.Condition.get -> Reko.Core.Expressions.Expression
Reko.Core.Absyn.AbsynFor.Initialization.get -> Reko.Core.Absyn.AbsynAssignment
Reko.Core.Absyn.AbsynFor.Initialization.set -> void
Reko.Core.Absyn.AbsynFor.Iteration.get -> Reko.Core.Absyn.AbsynAssignment
Reko.Core.Absyn.AbsynFor.Iteration.set -> void
Reko.Core.Absyn.AbsynGoto
Reko.Core.Absyn.AbsynGoto.AbsynGoto(string label) -> void
Reko.Core.Absyn.AbsynGoto.Label.get -> string
Reko.Core.Absyn.AbsynIf
Reko.Core.Absyn.AbsynIf.AbsynIf(Reko.Core.Expressions.Expression e, System.Collections.Generic.List<Reko.Core.Absyn.AbsynStatement> then) -> void
Reko.Core.Absyn.AbsynIf.AbsynIf(Reko.Core.Expressions.Expression e, System.Collections.Generic.List<Reko.Core.Absyn.AbsynStatement> then, System.Collections.Generic.List<Reko.Core.Absyn.AbsynStatement> els) -> void
Reko.Core.Absyn.AbsynIf.Condition.get -> Reko.Core.Expressions.Expression
Reko.Core.Absyn.AbsynIf.Condition.set -> void
Reko.Core.Absyn.AbsynIf.Else.get -> System.Collections.Generic.List<Reko.Core.Absyn.AbsynStatement>
Reko.Core.Absyn.AbsynIf.InvertCondition() -> void
Reko.Core.Absyn.AbsynIf.Then.get -> System.Collections.Generic.List<Reko.Core.Absyn.AbsynStatement>
Reko.Core.Absyn.AbsynLabel
Reko.Core.Absyn.AbsynLabel.AbsynLabel(string lbl) -> void
Reko.Core.Absyn.AbsynLabel.Name.get -> string
Reko.Core.Absyn.AbsynLineComment
Reko.Core.Absyn.AbsynLineComment.AbsynLineComment(string comment) -> void
Reko.Core.Absyn.AbsynLineComment.Comment.get -> string
Reko.Core.Absyn.AbsynLineComment.Comment.set -> void
Reko.Core.Absyn.AbsynLoop
Reko.Core.Absyn.AbsynLoop.AbsynLoop(Reko.Core.Expressions.Expression condition, System.Collections.Generic.List<Reko.Core.Absyn.AbsynStatement> body) -> void
Reko.Core.Absyn.AbsynLoop.Body.get -> System.Collections.Generic.List<Reko.Core.Absyn.AbsynStatement>
Reko.Core.Absyn.AbsynLoop.Condition.get -> Reko.Core.Expressions.Expression
Reko.Core.Absyn.AbsynProcedure
Reko.Core.Absyn.AbsynProcedure.AbsynProcedure() -> void
Reko.Core.Absyn.AbsynProcedure.Body.get -> System.Collections.Generic.List<Reko.Core.Absyn.AbsynStatement>
Reko.Core.Absyn.AbsynReturn
Reko.Core.Absyn.AbsynReturn.AbsynReturn(Reko.Core.Expressions.Expression retval) -> void
Reko.Core.Absyn.AbsynReturn.Value.get -> Reko.Core.Expressions.Expression
Reko.Core.Absyn.AbsynSideEffect
Reko.Core.Absyn.AbsynSideEffect.AbsynSideEffect(Reko.Core.Expressions.Expression expr) -> void
Reko.Core.Absyn.AbsynSideEffect.Expression.get -> Reko.Core.Expressions.Expression
Reko.Core.Absyn.AbsynStatement
Reko.Core.Absyn.AbsynStatement.AbsynStatement() -> void
Reko.Core.Absyn.AbsynSwitch
Reko.Core.Absyn.AbsynSwitch.AbsynSwitch(Reko.Core.Expressions.Expression expr, System.Collections.Generic.List<Reko.Core.Absyn.AbsynStatement> statements) -> void
Reko.Core.Absyn.AbsynSwitch.Expression.get -> Reko.Core.Expressions.Expression
Reko.Core.Absyn.AbsynSwitch.Statements.get -> System.Collections.Generic.List<Reko.Core.Absyn.AbsynStatement>
Reko.Core.Absyn.AbsynWhile
Reko.Core.Absyn.AbsynWhile.AbsynWhile(Reko.Core.Expressions.Expression condition, System.Collections.Generic.List<Reko.Core.Absyn.AbsynStatement> body) -> void
Reko.Core.Absyn.IAbsynVisitor
Reko.Core.Absyn.IAbsynVisitor.VisitAssignment(Reko.Core.Absyn.AbsynAssignment ass) -> void
Reko.Core.Absyn.IAbsynVisitor.VisitBreak(Reko.Core.Absyn.AbsynBreak brk) -> void
Reko.Core.Absyn.IAbsynVisitor.VisitCase(Reko.Core.Absyn.AbsynCase absynCase) -> void
Reko.Core.Absyn.IAbsynVisitor.VisitCompoundAssignment(Reko.Core.Absyn.AbsynCompoundAssignment compound) -> void
Reko.Core.Absyn.IAbsynVisitor.VisitContinue(Reko.Core.Absyn.AbsynContinue cont) -> void
Reko.Core.Absyn.IAbsynVisitor.VisitDeclaration(Reko.Core.Absyn.AbsynDeclaration decl) -> void
Reko.Core.Absyn.IAbsynVisitor.VisitDefault(Reko.Core.Absyn.AbsynDefault decl) -> void
Reko.Core.Absyn.IAbsynVisitor.VisitDoWhile(Reko.Core.Absyn.AbsynDoWhile loop) -> void
Reko.Core.Absyn.IAbsynVisitor.VisitFor(Reko.Core.Absyn.AbsynFor forLoop) -> void
Reko.Core.Absyn.IAbsynVisitor.VisitGoto(Reko.Core.Absyn.AbsynGoto gotoStm) -> void
Reko.Core.Absyn.IAbsynVisitor.VisitIf(Reko.Core.Absyn.AbsynIf ifStm) -> void
Reko.Core.Absyn.IAbsynVisitor.VisitLabel(Reko.Core.Absyn.AbsynLabel lbl) -> void
Reko.Core.Absyn.IAbsynVisitor.VisitLineComment(Reko.Core.Absyn.AbsynLineComment comment) -> void
Reko.Core.Absyn.IAbsynVisitor.VisitReturn(Reko.Core.Absyn.AbsynReturn ret) -> void
Reko.Core.Absyn.IAbsynVisitor.VisitSideEffect(Reko.Core.Absyn.AbsynSideEffect side) -> void
Reko.Core.Absyn.IAbsynVisitor.VisitSwitch(Reko.Core.Absyn.AbsynSwitch absynSwitch) -> void
Reko.Core.Absyn.IAbsynVisitor.VisitWhile(Reko.Core.Absyn.AbsynWhile loop) -> void
Reko.Core.Absyn.IAbsynVisitor<T>
Reko.Core.Absyn.IAbsynVisitor<T>.VisitAssignment(Reko.Core.Absyn.AbsynAssignment ass) -> T
Reko.Core.Absyn.IAbsynVisitor<T>.VisitBreak(Reko.Core.Absyn.AbsynBreak brk) -> T
Reko.Core.Absyn.IAbsynVisitor<T>.VisitCase(Reko.Core.Absyn.AbsynCase absynCase) -> T
Reko.Core.Absyn.IAbsynVisitor<T>.VisitCompoundAssignment(Reko.Core.Absyn.AbsynCompoundAssignment compound) -> T
Reko.Core.Absyn.IAbsynVisitor<T>.VisitContinue(Reko.Core.Absyn.AbsynContinue cont) -> T
Reko.Core.Absyn.IAbsynVisitor<T>.VisitDeclaration(Reko.Core.Absyn.AbsynDeclaration decl) -> T
Reko.Core.Absyn.IAbsynVisitor<T>.VisitDefault(Reko.Core.Absyn.AbsynDefault decl) -> T
Reko.Core.Absyn.IAbsynVisitor<T>.VisitDoWhile(Reko.Core.Absyn.AbsynDoWhile loop) -> T
Reko.Core.Absyn.IAbsynVisitor<T>.VisitFor(Reko.Core.Absyn.AbsynFor forLoop) -> T
Reko.Core.Absyn.IAbsynVisitor<T>.VisitGoto(Reko.Core.Absyn.AbsynGoto gotoStm) -> T
Reko.Core.Absyn.IAbsynVisitor<T>.VisitIf(Reko.Core.Absyn.AbsynIf ifStm) -> T
Reko.Core.Absyn.IAbsynVisitor<T>.VisitLabel(Reko.Core.Absyn.AbsynLabel lbl) -> T
Reko.Core.Absyn.IAbsynVisitor<T>.VisitLineComment(Reko.Core.Absyn.AbsynLineComment comment) -> T
Reko.Core.Absyn.IAbsynVisitor<T>.VisitReturn(Reko.Core.Absyn.AbsynReturn ret) -> T
Reko.Core.Absyn.IAbsynVisitor<T>.VisitSideEffect(Reko.Core.Absyn.AbsynSideEffect side) -> T
Reko.Core.Absyn.IAbsynVisitor<T>.VisitSwitch(Reko.Core.Absyn.AbsynSwitch absynSwitch) -> T
Reko.Core.Absyn.IAbsynVisitor<T>.VisitWhile(Reko.Core.Absyn.AbsynWhile loop) -> T
Reko.Core.AccessMode
Reko.Core.AccessMode.Execute = 1 -> Reko.Core.AccessMode
Reko.Core.AccessMode.Read = 4 -> Reko.Core.AccessMode
Reko.Core.AccessMode.ReadExecute = Reko.Core.AccessMode.Execute | Reko.Core.AccessMode.Read -> Reko.Core.AccessMode
Reko.Core.AccessMode.ReadWrite = Reko.Core.AccessMode.Write | Reko.Core.AccessMode.Read -> Reko.Core.AccessMode
Reko.Core.AccessMode.ReadWriteExecute = Reko.Core.AccessMode.Execute | Reko.Core.AccessMode.ReadWrite -> Reko.Core.AccessMode
Reko.Core.AccessMode.Write = 2 -> Reko.Core.AccessMode
Reko.Core.Address
Reko.Core.Address.Address(Reko.Core.Types.DataType size) -> void
Reko.Core.Address.Comparer
Reko.Core.Address.Comparer.Comparer() -> void
Reko.Core.Address.Comparer.Equals(Reko.Core.Address x, Reko.Core.Address y) -> bool
Reko.Core.Address.Comparer.GetHashCode(Reko.Core.Address obj) -> int
Reko.Core.Address.CompareTo(object a) -> int
Reko.Core.Address.CompareTo(Reko.Core.Address that) -> int
Reko.Core.Address32
Reko.Core.Address32.Address32(uint addr) -> void
Reko.Core.Address64
Reko.Core.Address64.Address64(ulong addr) -> void
Reko.Core.AddressContext
Reko.Core.AddressContext.AddressContext(Reko.Core.Program program, Reko.Core.Address addr, Reko.Core.Services.DecompilerEventListener decompilerEventListener) -> void
Reko.Core.AddressContext.Warn(string format, params object[] args) -> void
Reko.Core.AddressCorrelatedException
Reko.Core.AddressCorrelatedException.Address.get -> Reko.Core.Address
Reko.Core.AddressCorrelatedException.AddressCorrelatedException(Reko.Core.Address addr, string format, params object[] args) -> void
Reko.Core.AddressCorrelatedException.AddressCorrelatedException(Reko.Core.Address addr, System.Exception innerException, string format, params object[] args) -> void
Reko.Core.AddressRange
Reko.Core.AddressRange.AddressRange(Reko.Core.Address addrBegin, Reko.Core.Address addrEnd) -> void
Reko.Core.AddressRange.Begin.get -> Reko.Core.Address
Reko.Core.AddressRange.End.get -> Reko.Core.Address
Reko.Core.AddressRange.IsValid.get -> bool
Reko.Core.AddressSearchHit
Reko.Core.AddressSearchHit.AddressSearchHit(Reko.Core.Program program, Reko.Core.Address address, int length) -> void
Reko.Core.Analysis.IVarargsFormatParser
Reko.Core.Analysis.IVarargsFormatParser.ArgumentTypes.get -> System.Collections.Generic.List<Reko.Core.Types.DataType>
Reko.Core.Analysis.IVarargsFormatParser.Parse() -> void
Reko.Core.Annotation
Reko.Core.Annotation.Address.get -> Reko.Core.Address
Reko.Core.Annotation.Annotation(Reko.Core.Address address, string text) -> void
Reko.Core.Annotation.Text.get -> string
Reko.Core.AnnotationList
Reko.Core.AnnotationList.AnnotationChanged -> System.EventHandler?
Reko.Core.AnnotationList.AnnotationList() -> void
Reko.Core.AnnotationList.AnnotationList(System.Collections.Generic.IEnumerable<Reko.Core.Annotation!>! annotations) -> void
Reko.Core.AnnotationList.GetEnumerator() -> System.Collections.Generic.IEnumerator<Reko.Core.Annotation!>!
Reko.Core.AnnotationList.Remove(Reko.Core.Address! addr) -> void
Reko.Core.AnnotationList.this[Reko.Core.Address! addr].get -> string?
Reko.Core.AnnotationList.this[Reko.Core.Address! addr].set -> void
Reko.Core.ApplicationBuilder
Reko.Core.ApplicationBuilder.ApplicationBuilder(Reko.Core.Code.CallSite site, Reko.Core.Expressions.Expression callee) -> void
Reko.Core.ApplicationBuilder.BindVariadicArguments(Reko.Core.Serialization.ProcedureCharacteristics chr, System.Collections.Generic.List<Reko.Core.Expressions.Expression> actuals) -> System.Collections.Generic.List<Reko.Core.Expressions.Expression>
Reko.Core.ApplicationBuilder.callee -> Reko.Core.Expressions.Expression
Reko.Core.ApplicationBuilder.CreateInstruction(Reko.Core.Types.FunctionType sigCallee, Reko.Core.Serialization.ProcedureCharacteristics chr) -> Reko.Core.Code.Instruction
Reko.Core.ApplicationBuilder.sigCallee -> Reko.Core.Types.FunctionType
Reko.Core.ApplicationBuilder.site -> Reko.Core.Code.CallSite
Reko.Core.Assemblers.BackPatch
Reko.Core.Assemblers.BackPatch.BackPatch(int o, Reko.Core.Types.DataType s, int unitSize) -> void
Reko.Core.Assemblers.BackPatch.offset -> int
Reko.Core.Assemblers.BackPatch.Size.get -> Reko.Core.Types.DataType
Reko.Core.Assemblers.BackPatch.UnitSize -> int
Reko.Core.Assemblers.Emitter
Reko.Core.Assemblers.Emitter.Align(int skip, int alignment) -> void
Reko.Core.Assemblers.Emitter.EmitBeUInt16(int s) -> void
Reko.Core.Assemblers.Emitter.EmitBeUInt32(int s) -> void
Reko.Core.Assemblers.Emitter.EmitByte(int b) -> void
Reko.Core.Assemblers.Emitter.EmitBytes(int b, int count) -> void
Reko.Core.Assemblers.Emitter.EmitLe(Reko.Core.Types.DataType vt, int v) -> void
Reko.Core.Assemblers.Emitter.EmitLeImmediate(Reko.Core.Expressions.Constant c, Reko.Core.Types.DataType dt) -> void
Reko.Core.Assemblers.Emitter.EmitLeUInt16(int s) -> void
Reko.Core.Assemblers.Emitter.EmitLeUInt32(uint l) -> void
Reko.Core.Assemblers.Emitter.EmitString(string pstr, System.Text.Encoding encoding) -> void
Reko.Core.Assemblers.Emitter.Emitter() -> void
Reko.Core.Assemblers.Emitter.Emitter(Reko.Core.Memory.MemoryArea mem) -> void
Reko.Core.Assemblers.Emitter.GetBytes() -> byte[]
Reko.Core.Assemblers.Emitter.PatchBe(int offsetPatch, int offsetRef, Reko.Core.Types.DataType width) -> void
Reko.Core.Assemblers.Emitter.PatchLe(int offsetPatch, int offsetRef, Reko.Core.Types.DataType width) -> void
Reko.Core.Assemblers.Emitter.Position.get -> int
Reko.Core.Assemblers.Emitter.Position.set -> void
Reko.Core.Assemblers.Emitter.Reserve(int size) -> void
Reko.Core.Assemblers.Emitter.Size.get -> int
Reko.Core.Assemblers.IAssembler
Reko.Core.Assemblers.IAssembler.Assemble(Reko.Core.Address baseAddress, System.IO.TextReader reader) -> Reko.Core.Program
Reko.Core.Assemblers.IAssembler.AssembleAt(Reko.Core.Program program, Reko.Core.Address address, System.IO.TextReader reader) -> int
Reko.Core.Assemblers.IAssembler.AssembleFragment(Reko.Core.Address baseAddress, string asmFragment) -> Reko.Core.Program
Reko.Core.Assemblers.IAssembler.AssembleFragmentAt(Reko.Core.Program program, Reko.Core.Address address, string asmFragment) -> int
Reko.Core.Assemblers.IAssembler.EntryPoints.get -> System.Collections.Generic.ICollection<Reko.Core.ImageSymbol>
Reko.Core.Assemblers.IAssembler.ImageSymbols.get -> System.Collections.Generic.ICollection<Reko.Core.ImageSymbol>
Reko.Core.Assemblers.IAssembler.ImportReferences.get -> System.Collections.Generic.Dictionary<Reko.Core.Address, Reko.Core.ImportReference>
Reko.Core.Assemblers.IAssembler.StartAddress.get -> Reko.Core.Address
Reko.Core.Assemblers.IEmitter
Reko.Core.Assemblers.IEmitter.Align(int extra, int align) -> void
Reko.Core.Assemblers.IEmitter.EmitBeUInt16(int us) -> void
Reko.Core.Assemblers.IEmitter.EmitBeUInt32(int ui) -> void
Reko.Core.Assemblers.IEmitter.EmitByte(int b) -> void
Reko.Core.Assemblers.IEmitter.EmitBytes(int b, int count) -> void
Reko.Core.Assemblers.IEmitter.EmitLe(Reko.Core.Types.DataType width, int value) -> void
Reko.Core.Assemblers.IEmitter.EmitLeImmediate(Reko.Core.Expressions.Constant c, Reko.Core.Types.DataType dt) -> void
Reko.Core.Assemblers.IEmitter.EmitLeUInt16(int us) -> void
Reko.Core.Assemblers.IEmitter.EmitLeUInt32(uint ui) -> void
Reko.Core.Assemblers.IEmitter.EmitString(string str, System.Text.Encoding encoding) -> void
Reko.Core.Assemblers.IEmitter.GetBytes() -> byte[]
Reko.Core.Assemblers.IEmitter.PatchBe(int offsetPatch, int offsetRef, Reko.Core.Types.DataType width) -> void
Reko.Core.Assemblers.IEmitter.PatchLe(int offsetPatch, int offsetRef, Reko.Core.Types.DataType width) -> void
Reko.Core.Assemblers.IEmitter.Position.get -> int
Reko.Core.Assemblers.IEmitter.Position.set -> void
Reko.Core.Assemblers.IEmitter.Reserve(int delta) -> void
Reko.Core.Assemblers.IEmitter.Size.get -> int
Reko.Core.Assemblers.Symbol
Reko.Core.Assemblers.Symbol.AddForwardReference(int offset, Reko.Core.Types.DataType width, int unitSize) -> void
Reko.Core.Assemblers.Symbol.fResolved -> bool
Reko.Core.Assemblers.Symbol.offset -> int
Reko.Core.Assemblers.Symbol.Patches.get -> System.Collections.Generic.List<Reko.Core.Assemblers.BackPatch>
Reko.Core.Assemblers.Symbol.ReferToBe(int off, Reko.Core.Types.DataType width, Reko.Core.Assemblers.IEmitter emitter) -> void
Reko.Core.Assemblers.Symbol.ReferToLe(int off, Reko.Core.Types.DataType width, Reko.Core.Assemblers.IEmitter emitter) -> void
Reko.Core.Assemblers.Symbol.ReferToLeWordCount(int off, Reko.Core.Types.DataType width, Reko.Core.Assemblers.IEmitter emitter) -> void
Reko.Core.Assemblers.Symbol.ResolveBe(Reko.Core.Assemblers.IEmitter emitter) -> void
Reko.Core.Assemblers.Symbol.ResolveLe(Reko.Core.Assemblers.IEmitter emitter) -> void
Reko.Core.Assemblers.Symbol.sym -> string
Reko.Core.Assemblers.Symbol.Symbol(string s) -> void
Reko.Core.Assemblers.SymbolTable
Reko.Core.Assemblers.SymbolTable.CreateSymbol(string s) -> Reko.Core.Assemblers.Symbol
Reko.Core.Assemblers.SymbolTable.DefineSymbol(string s, int off) -> Reko.Core.Assemblers.Symbol
Reko.Core.Assemblers.SymbolTable.Equates.get -> System.Collections.Generic.Dictionary<string, int>
Reko.Core.Assemblers.SymbolTable.GetUndefinedSymbols() -> Reko.Core.Assemblers.Symbol[]
Reko.Core.Assemblers.SymbolTable.SymbolTable() -> void
Reko.Core.Assemblers.SymbolTable.Write(System.IO.TextWriter txt) -> void
Reko.Core.BinaryReaderExtensions
Reko.Core.BinaryReaderStructureReader
Reko.Core.BitRange
Reko.Core.BitRange.BitMask() -> ulong
Reko.Core.BitRange.BitRange() -> void
Reko.Core.BitRange.BitRange(int lsb, int msb) -> void
Reko.Core.BitRange.CompareTo(Reko.Core.BitRange that) -> int
Reko.Core.BitRange.Contains(int bitpos) -> bool
Reko.Core.BitRange.Covers(Reko.Core.BitRange that) -> bool
Reko.Core.BitRange.Extent.get -> int
Reko.Core.BitRange.Intersect(Reko.Core.BitRange that) -> Reko.Core.BitRange
Reko.Core.BitRange.IsEmpty.get -> bool
Reko.Core.BitRange.Lsb.get -> short
Reko.Core.BitRange.Msb.get -> short
Reko.Core.BitRange.Offset(int offset) -> Reko.Core.BitRange
Reko.Core.BitRange.Overlaps(Reko.Core.BitRange that) -> bool
Reko.Core.Block
Reko.Core.Block.Address.get -> Reko.Core.Address
Reko.Core.Block.Address.set -> void
Reko.Core.Block.Block(Reko.Core.Procedure proc, Reko.Core.Address addr, string id) -> void
Reko.Core.Block.DisplayName.get -> string
Reko.Core.Block.Dump() -> void
Reko.Core.Block.ElseBlock.get -> Reko.Core.Block
Reko.Core.Block.ElseBlock.set -> void
Reko.Core.Block.Id.get -> string
Reko.Core.Block.IsSynthesized.get -> bool
Reko.Core.Block.IsSynthesized.set -> void
Reko.Core.Block.Pred.get -> System.Collections.Generic.List<Reko.Core.Block>
Reko.Core.Block.Procedure.get -> Reko.Core.Procedure
Reko.Core.Block.Procedure.set -> void
Reko.Core.Block.Statements.get -> Reko.Core.StatementList
Reko.Core.Block.Succ.get -> System.Collections.Generic.List<Reko.Core.Block>
Reko.Core.Block.ThenBlock.get -> Reko.Core.Block
Reko.Core.Block.ThenBlock.set -> void
Reko.Core.Block.UserLabel.get -> string
Reko.Core.Block.UserLabel.set -> void
Reko.Core.Block.Write(System.IO.TextWriter sb) -> void
Reko.Core.Block.WriteStatements(System.IO.TextWriter writer) -> void
Reko.Core.ByteArrayExtensions
Reko.Core.BytePattern
Reko.Core.CallGraph
Reko.Core.CallGraph.AddEdge(Reko.Core.Statement stmCaller, Reko.Core.Procedure callee) -> void
Reko.Core.CallGraph.AddEntryPoint(Reko.Core.Procedure proc) -> void
Reko.Core.CallGraph.AddProcedure(Reko.Core.Procedure proc) -> void
Reko.Core.CallGraph.Callees(Reko.Core.Procedure proc) -> System.Collections.Generic.IEnumerable<Reko.Core.Procedure>
Reko.Core.CallGraph.Callees(Reko.Core.Statement stm) -> System.Collections.Generic.IEnumerable<object>
Reko.Core.CallGraph.CallerProcedures(Reko.Core.Procedure proc) -> System.Collections.Generic.IEnumerable<Reko.Core.Procedure>
Reko.Core.CallGraph.CallerStatements(Reko.Core.Procedure proc) -> System.Collections.Generic.IEnumerable<Reko.Core.Statement>
Reko.Core.CallGraph.CallGraph() -> void
Reko.Core.CallGraph.EntryPoints.get -> System.Collections.Generic.List<Reko.Core.Procedure>
Reko.Core.CallGraph.RemoveCaller(Reko.Core.Statement stm) -> void
Reko.Core.CallGraph.Write(System.IO.TextWriter wri) -> void
Reko.Core.CallingConvention
Reko.Core.CallingConvention.Generate(Reko.Core.ICallingConventionEmitter ccr, int retAddressOnStack, Reko.Core.Types.DataType dtRet, Reko.Core.Types.DataType dtThis, System.Collections.Generic.List<Reko.Core.Types.DataType> dtParams) -> void
Reko.Core.CallingConvention.IsArgument(Reko.Core.Storage stg) -> bool
Reko.Core.CallingConvention.IsOutArgument(Reko.Core.Storage stg) -> bool
Reko.Core.CallingConventionEmitter
Reko.Core.CallingConventionEmitter.CalleeCleanup() -> void
Reko.Core.CallingConventionEmitter.CallerCleanup(int retAddressOnStack) -> void
Reko.Core.CallingConventionEmitter.CallingConventionEmitter() -> void
Reko.Core.CallingConventionEmitter.FpuReturn(int depth, Reko.Core.Types.DataType dt) -> void
Reko.Core.CallingConventionEmitter.FpuStackDelta.get -> int
Reko.Core.CallingConventionEmitter.ImplicitThis.get -> Reko.Core.Storage
Reko.Core.CallingConventionEmitter.ImplicitThisRegister(Reko.Core.Storage dtThis) -> void
Reko.Core.CallingConventionEmitter.ImplicitThisStack(Reko.Core.Types.DataType dt) -> void
Reko.Core.CallingConventionEmitter.LowLevelDetails(int stackAlignment, int initialStackOffset) -> void
Reko.Core.CallingConventionEmitter.Parameters.get -> System.Collections.Generic.List<Reko.Core.Storage>
Reko.Core.CallingConventionEmitter.RegParam(Reko.Core.RegisterStorage stg) -> void
Reko.Core.CallingConventionEmitter.RegReturn(Reko.Core.RegisterStorage stg) -> void
Reko.Core.CallingConventionEmitter.Return.get -> Reko.Core.Storage
Reko.Core.CallingConventionEmitter.ReverseParameters() -> void
Reko.Core.CallingConventionEmitter.SequenceParam(Reko.Core.RegisterStorage stgHi, Reko.Core.RegisterStorage stgLo) -> void
Reko.Core.CallingConventionEmitter.SequenceParam(Reko.Core.SequenceStorage seq) -> void
Reko.Core.CallingConventionEmitter.SequenceReturn(Reko.Core.RegisterStorage stgHi, Reko.Core.RegisterStorage stgLo) -> void
Reko.Core.CallingConventionEmitter.SequenceReturn(Reko.Core.SequenceStorage seq) -> void
Reko.Core.CallingConventionEmitter.StackDelta.get -> int
Reko.Core.CallingConventionEmitter.StackParam(Reko.Core.Types.DataType dt) -> void
Reko.Core.CallingConventionEmitter.StackReturn(Reko.Core.Types.DataType dt) -> void
Reko.Core.CharacteristicsLibrary
Reko.Core.CharacteristicsLibrary.CharacteristicsLibrary() -> void
Reko.Core.CharacteristicsLibrary.Entries.get -> System.Collections.Generic.Dictionary<string, Reko.Core.Serialization.ProcedureCharacteristics>
Reko.Core.CharacteristicsLibrary.Entries.set -> void
Reko.Core.CharacteristicsLibrary.Lookup(string procName) -> Reko.Core.Serialization.ProcedureCharacteristics
Reko.Core.CHeaderLoader
Reko.Core.CHeaderLoader.CHeaderLoader(System.IServiceProvider services, Reko.Core.ImageLocation imagelocation, byte[] bytes) -> void
Reko.Core.Code.AliasAssignment
Reko.Core.Code.AliasAssignment.AliasAssignment(Reko.Core.Expressions.Identifier idDst, Reko.Core.Expressions.Expression expSrc) -> void
Reko.Core.Code.Assignment
Reko.Core.Code.Assignment.Assignment(Reko.Core.Expressions.Identifier dst, Reko.Core.Expressions.Expression src) -> void
Reko.Core.Code.Assignment.Dst.get -> Reko.Core.Expressions.Identifier
Reko.Core.Code.Assignment.Dst.set -> void
Reko.Core.Code.Assignment.Src.get -> Reko.Core.Expressions.Expression
Reko.Core.Code.Assignment.Src.set -> void
Reko.Core.Code.Branch
Reko.Core.Code.Branch.Branch(Reko.Core.Expressions.Expression cond, Reko.Core.Block target) -> void
Reko.Core.Code.Branch.Condition.get -> Reko.Core.Expressions.Expression
Reko.Core.Code.Branch.Condition.set -> void
Reko.Core.Code.Branch.Target.get -> Reko.Core.Block
Reko.Core.Code.Branch.Target.set -> void
Reko.Core.Code.CallBinding
Reko.Core.Code.CallBinding.BitRange -> Reko.Core.BitRange
Reko.Core.Code.CallBinding.CallBinding(Reko.Core.Storage stg, Reko.Core.Expressions.Expression exp) -> void
Reko.Core.Code.CallBinding.Expression -> Reko.Core.Expressions.Expression
Reko.Core.Code.CallBinding.Storage -> Reko.Core.Storage
Reko.Core.Code.CallInstruction
Reko.Core.Code.CallInstruction.Callee.get -> Reko.Core.Expressions.Expression
Reko.Core.Code.CallInstruction.Callee.set -> void
Reko.Core.Code.CallInstruction.CallInstruction(Reko.Core.Expressions.Expression callee, Reko.Core.Code.CallSite site) -> void
Reko.Core.Code.CallInstruction.CallSite.get -> Reko.Core.Code.CallSite
Reko.Core.Code.CallInstruction.Definitions.get -> System.Collections.Generic.HashSet<Reko.Core.Code.CallBinding>
Reko.Core.Code.CallInstruction.Uses.get -> System.Collections.Generic.HashSet<Reko.Core.Code.CallBinding>
Reko.Core.Code.CallSite
Reko.Core.Code.CallSite.CallSite(int sizeOfReturnAddressOnStack, int fpuStackDepthBefore) -> void
Reko.Core.Code.CallSite.FpuStackDepthBefore.get -> int
Reko.Core.Code.CallSite.SizeOfReturnAddressOnStack.get -> int
Reko.Core.Code.CallSite.StackDepthOnEntry.get -> int
Reko.Core.Code.CallSite.StackDepthOnEntry.set -> void
Reko.Core.Code.CodeComment
Reko.Core.Code.CodeComment.CodeComment(string comment) -> void
Reko.Core.Code.CodeComment.Text.get -> string
Reko.Core.Code.CodeComment.Text.set -> void
Reko.Core.Code.CriticalInstruction
Reko.Core.Code.CriticalInstruction.CriticalInstruction() -> void
Reko.Core.Code.CriticalInstruction.VisitAddress(Reko.Core.Address addr) -> bool
Reko.Core.Code.CriticalInstruction.VisitApplication(Reko.Core.Expressions.Application appl) -> bool
Reko.Core.Code.CriticalInstruction.VisitArrayAccess(Reko.Core.Expressions.ArrayAccess arr) -> bool
Reko.Core.Code.CriticalInstruction.VisitAssignment(Reko.Core.Code.Assignment ass) -> bool
Reko.Core.Code.CriticalInstruction.VisitBinaryExpression(Reko.Core.Expressions.BinaryExpression bin) -> bool
Reko.Core.Code.CriticalInstruction.VisitBranch(Reko.Core.Code.Branch b) -> bool
Reko.Core.Code.CriticalInstruction.VisitCallInstruction(Reko.Core.Code.CallInstruction ci) -> bool
Reko.Core.Code.CriticalInstruction.VisitCast(Reko.Core.Expressions.Cast cast) -> bool
Reko.Core.Code.CriticalInstruction.VisitComment(Reko.Core.Code.CodeComment comment) -> bool
Reko.Core.Code.CriticalInstruction.VisitConditionalExpression(Reko.Core.Expressions.ConditionalExpression cond) -> bool
Reko.Core.Code.CriticalInstruction.VisitConditionOf(Reko.Core.Expressions.ConditionOf cond) -> bool
Reko.Core.Code.CriticalInstruction.VisitConstant(Reko.Core.Expressions.Constant c) -> bool
Reko.Core.Code.CriticalInstruction.VisitConversion(Reko.Core.Expressions.Conversion conversion) -> bool
Reko.Core.Code.CriticalInstruction.VisitDeclaration(Reko.Core.Code.Declaration decl) -> bool
Reko.Core.Code.CriticalInstruction.VisitDefInstruction(Reko.Core.Code.DefInstruction def) -> bool
Reko.Core.Code.CriticalInstruction.VisitDereference(Reko.Core.Expressions.Dereference deref) -> bool
Reko.Core.Code.CriticalInstruction.VisitFieldAccess(Reko.Core.Expressions.FieldAccess access) -> bool
Reko.Core.Code.CriticalInstruction.VisitGotoInstruction(Reko.Core.Code.GotoInstruction g) -> bool
Reko.Core.Code.CriticalInstruction.VisitIdentifier(Reko.Core.Expressions.Identifier id) -> bool
Reko.Core.Code.CriticalInstruction.VisitMemberPointerSelector(Reko.Core.Expressions.MemberPointerSelector mps) -> bool
Reko.Core.Code.CriticalInstruction.VisitMemoryAccess(Reko.Core.Expressions.MemoryAccess access) -> bool
Reko.Core.Code.CriticalInstruction.VisitMkSequence(Reko.Core.Expressions.MkSequence seq) -> bool
Reko.Core.Code.CriticalInstruction.VisitOutArgument(Reko.Core.Expressions.OutArgument outArgument) -> bool
Reko.Core.Code.CriticalInstruction.VisitPhiAssignment(Reko.Core.Code.PhiAssignment phi) -> bool
Reko.Core.Code.CriticalInstruction.VisitPhiFunction(Reko.Core.Expressions.PhiFunction phi) -> bool
Reko.Core.Code.CriticalInstruction.VisitPointerAddition(Reko.Core.Expressions.PointerAddition pa) -> bool
Reko.Core.Code.CriticalInstruction.VisitProcedureConstant(Reko.Core.Expressions.ProcedureConstant pc) -> bool
Reko.Core.Code.CriticalInstruction.VisitReturnInstruction(Reko.Core.Code.ReturnInstruction ret) -> bool
Reko.Core.Code.CriticalInstruction.VisitScopeResolution(Reko.Core.Expressions.ScopeResolution sc) -> bool
Reko.Core.Code.CriticalInstruction.VisitSegmentedAccess(Reko.Core.Expressions.SegmentedAccess segmem) -> bool
Reko.Core.Code.CriticalInstruction.VisitSideEffect(Reko.Core.Code.SideEffect side) -> bool
Reko.Core.Code.CriticalInstruction.VisitSlice(Reko.Core.Expressions.Slice slice) -> bool
Reko.Core.Code.CriticalInstruction.VisitStore(Reko.Core.Code.Store store) -> bool
Reko.Core.Code.CriticalInstruction.VisitSwitchInstruction(Reko.Core.Code.SwitchInstruction si) -> bool
Reko.Core.Code.CriticalInstruction.VisitTestCondition(Reko.Core.Expressions.TestCondition test) -> bool
Reko.Core.Code.CriticalInstruction.VisitUnaryExpression(Reko.Core.Expressions.UnaryExpression unary) -> bool
Reko.Core.Code.CriticalInstruction.VisitUseInstruction(Reko.Core.Code.UseInstruction u) -> bool
Reko.Core.Code.Declaration
Reko.Core.Code.Declaration.Declaration(Reko.Core.Expressions.Identifier id, Reko.Core.Expressions.Expression init) -> void
Reko.Core.Code.Declaration.Expression.get -> Reko.Core.Expressions.Expression
Reko.Core.Code.Declaration.Expression.set -> void
Reko.Core.Code.Declaration.Identifier.get -> Reko.Core.Expressions.Identifier
Reko.Core.Code.Declaration.Identifier.set -> void
Reko.Core.Code.DefInstruction
Reko.Core.Code.DefInstruction.DefInstruction(Reko.Core.Expressions.Identifier e) -> void
Reko.Core.Code.DefInstruction.Identifier.get -> Reko.Core.Expressions.Identifier
Reko.Core.Code.DefInstruction.Identifier.set -> void
Reko.Core.Code.DelegatedInstructionVisitor
Reko.Core.Code.DelegatedInstructionVisitor.DelegatedInstructionVisitor(Reko.Core.Code.InstructionVisitor d) -> void
Reko.Core.Code.DelegatedInstructionVisitor.VisitAssignment(Reko.Core.Code.Assignment a) -> void
Reko.Core.Code.DelegatedInstructionVisitor.VisitBranch(Reko.Core.Code.Branch b) -> void
Reko.Core.Code.DelegatedInstructionVisitor.VisitCallInstruction(Reko.Core.Code.CallInstruction ci) -> void
Reko.Core.Code.DelegatedInstructionVisitor.VisitComment(Reko.Core.Code.CodeComment comment) -> void
Reko.Core.Code.DelegatedInstructionVisitor.VisitDeclaration(Reko.Core.Code.Declaration decl) -> void
Reko.Core.Code.DelegatedInstructionVisitor.VisitDefInstruction(Reko.Core.Code.DefInstruction def) -> void
Reko.Core.Code.DelegatedInstructionVisitor.VisitGotoInstruction(Reko.Core.Code.GotoInstruction g) -> void
Reko.Core.Code.DelegatedInstructionVisitor.VisitPhiAssignment(Reko.Core.Code.PhiAssignment phi) -> void
Reko.Core.Code.DelegatedInstructionVisitor.VisitReturnInstruction(Reko.Core.Code.ReturnInstruction ret) -> void
Reko.Core.Code.DelegatedInstructionVisitor.VisitSideEffect(Reko.Core.Code.SideEffect side) -> void
Reko.Core.Code.DelegatedInstructionVisitor.VisitStore(Reko.Core.Code.Store store) -> void
Reko.Core.Code.DelegatedInstructionVisitor.VisitSwitchInstruction(Reko.Core.Code.SwitchInstruction si) -> void
Reko.Core.Code.DelegatedInstructionVisitor.VisitUseInstruction(Reko.Core.Code.UseInstruction u) -> void
Reko.Core.Code.GotoInstruction
Reko.Core.Code.GotoInstruction.Condition.get -> Reko.Core.Expressions.Expression
Reko.Core.Code.GotoInstruction.Condition.set -> void
Reko.Core.Code.GotoInstruction.GotoInstruction(Reko.Core.Expressions.Expression target) -> void
Reko.Core.Code.GotoInstruction.IsConditional.get -> bool
Reko.Core.Code.GotoInstruction.Target.get -> Reko.Core.Expressions.Expression
Reko.Core.Code.GotoInstruction.Target.set -> void
Reko.Core.Code.IdentifierCollector
Reko.Core.Code.IdentifierCollector.IdentifierCollector(System.Collections.Generic.IDictionary<string, Reko.Core.Expressions.Identifier> ids) -> void
Reko.Core.Code.Instruction
Reko.Core.Code.Instruction.Instruction() -> void
Reko.Core.Code.InstructionTransformer
Reko.Core.Code.InstructionTransformer.InstructionTransformer() -> void
Reko.Core.Code.InstructionTransformer.Transform(Reko.Core.Code.Instruction instr) -> Reko.Core.Code.Instruction
Reko.Core.Code.InstructionTransformer.VisitConditionOf(Reko.Core.Expressions.ConditionOf cof) -> Reko.Core.Expressions.Expression
Reko.Core.Code.InstructionVisitor
Reko.Core.Code.InstructionVisitor.VisitAssignment(Reko.Core.Code.Assignment ass) -> void
Reko.Core.Code.InstructionVisitor.VisitBranch(Reko.Core.Code.Branch branch) -> void
Reko.Core.Code.InstructionVisitor.VisitCallInstruction(Reko.Core.Code.CallInstruction ci) -> void
Reko.Core.Code.InstructionVisitor.VisitComment(Reko.Core.Code.CodeComment code) -> void
Reko.Core.Code.InstructionVisitor.VisitDeclaration(Reko.Core.Code.Declaration decl) -> void
Reko.Core.Code.InstructionVisitor.VisitDefInstruction(Reko.Core.Code.DefInstruction def) -> void
Reko.Core.Code.InstructionVisitor.VisitGotoInstruction(Reko.Core.Code.GotoInstruction gotoInstruction) -> void
Reko.Core.Code.InstructionVisitor.VisitPhiAssignment(Reko.Core.Code.PhiAssignment phi) -> void
Reko.Core.Code.InstructionVisitor.VisitReturnInstruction(Reko.Core.Code.ReturnInstruction ret) -> void
Reko.Core.Code.InstructionVisitor.VisitSideEffect(Reko.Core.Code.SideEffect side) -> void
Reko.Core.Code.InstructionVisitor.VisitStore(Reko.Core.Code.Store store) -> void
Reko.Core.Code.InstructionVisitor.VisitSwitchInstruction(Reko.Core.Code.SwitchInstruction si) -> void
Reko.Core.Code.InstructionVisitor.VisitUseInstruction(Reko.Core.Code.UseInstruction use) -> void
Reko.Core.Code.InstructionVisitor<T, C>
Reko.Core.Code.InstructionVisitor<T, C>.VisitAssignment(Reko.Core.Code.Assignment ass, C ctx) -> T
Reko.Core.Code.InstructionVisitor<T, C>.VisitBranch(Reko.Core.Code.Branch branch, C ctx) -> T
Reko.Core.Code.InstructionVisitor<T, C>.VisitCallInstruction(Reko.Core.Code.CallInstruction ci, C ctx) -> T
Reko.Core.Code.InstructionVisitor<T, C>.VisitComment(Reko.Core.Code.CodeComment comment, C ctx) -> T
Reko.Core.Code.InstructionVisitor<T, C>.VisitDeclaration(Reko.Core.Code.Declaration decl, C ctx) -> T
Reko.Core.Code.InstructionVisitor<T, C>.VisitDefInstruction(Reko.Core.Code.DefInstruction def, C ctx) -> T
Reko.Core.Code.InstructionVisitor<T, C>.VisitGotoInstruction(Reko.Core.Code.GotoInstruction gotoInstruction, C ctx) -> T
Reko.Core.Code.InstructionVisitor<T, C>.VisitPhiAssignment(Reko.Core.Code.PhiAssignment phi, C ctx) -> T
Reko.Core.Code.InstructionVisitor<T, C>.VisitReturnInstruction(Reko.Core.Code.ReturnInstruction ret, C ctx) -> T
Reko.Core.Code.InstructionVisitor<T, C>.VisitSideEffect(Reko.Core.Code.SideEffect side, C ctx) -> T
Reko.Core.Code.InstructionVisitor<T, C>.VisitStore(Reko.Core.Code.Store store, C ctx) -> T
Reko.Core.Code.InstructionVisitor<T, C>.VisitSwitchInstruction(Reko.Core.Code.SwitchInstruction si, C ctx) -> T
Reko.Core.Code.InstructionVisitor<T, C>.VisitUseInstruction(Reko.Core.Code.UseInstruction use, C ctx) -> T
Reko.Core.Code.InstructionVisitor<T>
Reko.Core.Code.InstructionVisitor<T>.VisitAssignment(Reko.Core.Code.Assignment ass) -> T
Reko.Core.Code.InstructionVisitor<T>.VisitBranch(Reko.Core.Code.Branch branch) -> T
Reko.Core.Code.InstructionVisitor<T>.VisitCallInstruction(Reko.Core.Code.CallInstruction ci) -> T
Reko.Core.Code.InstructionVisitor<T>.VisitComment(Reko.Core.Code.CodeComment comment) -> T
Reko.Core.Code.InstructionVisitor<T>.VisitDeclaration(Reko.Core.Code.Declaration decl) -> T
Reko.Core.Code.InstructionVisitor<T>.VisitDefInstruction(Reko.Core.Code.DefInstruction def) -> T
Reko.Core.Code.InstructionVisitor<T>.VisitGotoInstruction(Reko.Core.Code.GotoInstruction gotoInstruction) -> T
Reko.Core.Code.InstructionVisitor<T>.VisitPhiAssignment(Reko.Core.Code.PhiAssignment phi) -> T
Reko.Core.Code.InstructionVisitor<T>.VisitReturnInstruction(Reko.Core.Code.ReturnInstruction ret) -> T
Reko.Core.Code.InstructionVisitor<T>.VisitSideEffect(Reko.Core.Code.SideEffect side) -> T
Reko.Core.Code.InstructionVisitor<T>.VisitStore(Reko.Core.Code.Store store) -> T
Reko.Core.Code.InstructionVisitor<T>.VisitSwitchInstruction(Reko.Core.Code.SwitchInstruction si) -> T
Reko.Core.Code.InstructionVisitor<T>.VisitUseInstruction(Reko.Core.Code.UseInstruction use) -> T
Reko.Core.Code.InstructionVisitorBase
Reko.Core.Code.InstructionVisitorBase.InstructionVisitorBase() -> void
Reko.Core.Code.PhiAssignment
Reko.Core.Code.PhiAssignment.Dst -> Reko.Core.Expressions.Identifier
Reko.Core.Code.PhiAssignment.PhiAssignment(Reko.Core.Expressions.Identifier d, params Reko.Core.Expressions.PhiArgument[] args) -> void
Reko.Core.Code.PhiAssignment.PhiAssignment(Reko.Core.Expressions.Identifier d, Reko.Core.Expressions.PhiFunction p) -> void
Reko.Core.Code.PhiAssignment.Src -> Reko.Core.Expressions.PhiFunction
Reko.Core.Code.ReturnInstruction
Reko.Core.Code.ReturnInstruction.Expression.get -> Reko.Core.Expressions.Expression
Reko.Core.Code.ReturnInstruction.Expression.set -> void
Reko.Core.Code.ReturnInstruction.ReturnInstruction() -> void
Reko.Core.Code.ReturnInstruction.ReturnInstruction(Reko.Core.Expressions.Expression exp) -> void
Reko.Core.Code.SideEffect
Reko.Core.Code.SideEffect.Expression.get -> Reko.Core.Expressions.Expression
Reko.Core.Code.SideEffect.Expression.set -> void
Reko.Core.Code.SideEffect.SideEffect(Reko.Core.Expressions.Expression expr) -> void
Reko.Core.Code.Store
Reko.Core.Code.Store.Dst.get -> Reko.Core.Expressions.Expression
Reko.Core.Code.Store.Dst.set -> void
Reko.Core.Code.Store.Src.get -> Reko.Core.Expressions.Expression
Reko.Core.Code.Store.Src.set -> void
Reko.Core.Code.Store.Store(Reko.Core.Expressions.Expression dst, Reko.Core.Expressions.Expression src) -> void
Reko.Core.Code.SwitchInstruction
Reko.Core.Code.SwitchInstruction.Expression.get -> Reko.Core.Expressions.Expression
Reko.Core.Code.SwitchInstruction.Expression.set -> void
Reko.Core.Code.SwitchInstruction.SwitchInstruction(Reko.Core.Expressions.Expression expr, Reko.Core.Block[] targets) -> void
Reko.Core.Code.SwitchInstruction.Targets.get -> Reko.Core.Block[]
Reko.Core.Code.SwitchInstruction.Targets.set -> void
Reko.Core.Code.UseInstruction
Reko.Core.Code.UseInstruction.Expression.get -> Reko.Core.Expressions.Expression
Reko.Core.Code.UseInstruction.Expression.set -> void
Reko.Core.Code.UseInstruction.OutArgument.get -> Reko.Core.Expressions.Identifier
Reko.Core.Code.UseInstruction.OutArgument.set -> void
Reko.Core.Code.UseInstruction.UseInstruction(Reko.Core.Expressions.Expression e) -> void
Reko.Core.Code.UseInstruction.UseInstruction(Reko.Core.Expressions.Expression e, Reko.Core.Expressions.Identifier argument) -> void
Reko.Core.CodeEmitter
Reko.Core.CodeEmitter.CodeEmitter() -> void
Reko.Core.CodeEmitter.Comment(string comment) -> void
Reko.Core.CodeEmitter.Def(Reko.Core.Expressions.Identifier id) -> void
Reko.Core.CodeEmitter.Goto(Reko.Core.Expressions.Expression dest) -> Reko.Core.Code.GotoInstruction
Reko.Core.CodeEmitter.LoadId(Reko.Core.Expressions.Identifier reg, Reko.Core.Expressions.Expression ea) -> void
Reko.Core.CodeEmitter.Local(Reko.Core.Types.PrimitiveType primitiveType, string name) -> Reko.Core.Expressions.Identifier
Reko.Core.CodeEmitter.Local16(string name) -> Reko.Core.Expressions.Identifier
Reko.Core.CodeEmitter.Local32(string name) -> Reko.Core.Expressions.Identifier
Reko.Core.CodeEmitter.LocalBool(string name) -> Reko.Core.Expressions.Identifier
Reko.Core.CodeEmitter.LocalByte(string name) -> Reko.Core.Expressions.Identifier
Reko.Core.CodeEmitter.MStore(Reko.Core.Expressions.Expression ea, Reko.Core.Expressions.Expression src) -> Reko.Core.Statement
Reko.Core.CodeEmitter.MStore(Reko.Core.Expressions.MemoryIdentifier mem, Reko.Core.Expressions.Expression ea, Reko.Core.Expressions.Expression src) -> Reko.Core.Statement
Reko.Core.CodeEmitter.SideEffect(Reko.Core.Expressions.Expression side) -> Reko.Core.Statement
Reko.Core.CodeEmitter.SStore(Reko.Core.Expressions.Expression basePtr, Reko.Core.Expressions.Expression ea, Reko.Core.Expressions.Expression src) -> Reko.Core.Statement
Reko.Core.CodeEmitter.Store(Reko.Core.Expressions.Expression dst, Reko.Core.Expressions.Expression src) -> Reko.Core.Statement
Reko.Core.CodeEmitter.Use(Reko.Core.Expressions.Identifier id) -> Reko.Core.Statement
Reko.Core.CodePatch
Reko.Core.CodePatch.Address.get -> Reko.Core.Address
Reko.Core.CodePatch.Code.get -> Reko.Core.Rtl.RtlInstructionCluster
Reko.Core.CodePatch.CodePatch(Reko.Core.Rtl.RtlInstructionCluster cluster) -> void
Reko.Core.CodePatch.Length.get -> int
Reko.Core.Collections.BTreeDictionary<TKey, TValue>
Reko.Core.Collections.BTreeDictionary<TKey, TValue>.Add(System.Collections.Generic.KeyValuePair<TKey, TValue> item) -> void
Reko.Core.Collections.BTreeDictionary<TKey, TValue>.Add(TKey key, TValue value) -> void
Reko.Core.Collections.BTreeDictionary<TKey, TValue>.BTreeDictionary() -> void
Reko.Core.Collections.BTreeDictionary<TKey, TValue>.BTreeDictionary(System.Collections.Generic.IComparer<TKey> cmp) -> void
Reko.Core.Collections.BTreeDictionary<TKey, TValue>.BTreeDictionary(System.Collections.Generic.IDictionary<TKey, TValue> entries) -> void
Reko.Core.Collections.BTreeDictionary<TKey, TValue>.BTreeDictionary(System.Collections.Generic.IDictionary<TKey, TValue> entries, System.Collections.Generic.IComparer<TKey> comparer) -> void
Reko.Core.Collections.BTreeDictionary<TKey, TValue>.Clear() -> void
Reko.Core.Collections.BTreeDictionary<TKey, TValue>.Collection<T>
Reko.Core.Collections.BTreeDictionary<TKey, TValue>.Collection<T>.Add(T item) -> void
Reko.Core.Collections.BTreeDictionary<TKey, TValue>.Collection<T>.Clear() -> void
Reko.Core.Collections.BTreeDictionary<TKey, TValue>.Collection<T>.Collection(Reko.Core.Collections.BTreeDictionary<TKey, TValue> btree) -> void
Reko.Core.Collections.BTreeDictionary<TKey, TValue>.Collection<T>.Count.get -> int
Reko.Core.Collections.BTreeDictionary<TKey, TValue>.Collection<T>.IsReadOnly.get -> bool
Reko.Core.Collections.BTreeDictionary<TKey, TValue>.Collection<T>.Remove(T item) -> bool
Reko.Core.Collections.BTreeDictionary<TKey, TValue>.Comparer.get -> System.Collections.Generic.IComparer<TKey>
Reko.Core.Collections.BTreeDictionary<TKey, TValue>.Contains(System.Collections.Generic.KeyValuePair<TKey, TValue> item) -> bool
Reko.Core.Collections.BTreeDictionary<TKey, TValue>.ContainsKey(TKey key) -> bool
Reko.Core.Collections.BTreeDictionary<TKey, TValue>.ContainsValue(TValue value) -> bool
Reko.Core.Collections.BTreeDictionary<TKey, TValue>.CopyTo(System.Collections.Generic.KeyValuePair<TKey, TValue>[] array, int arrayIndex) -> void
Reko.Core.Collections.BTreeDictionary<TKey, TValue>.Count.get -> int
Reko.Core.Collections.BTreeDictionary<TKey, TValue>.Dump() -> void
Reko.Core.Collections.BTreeDictionary<TKey, TValue>.GetEnumerator() -> System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<TKey, TValue>>
Reko.Core.Collections.BTreeDictionary<TKey, TValue>.IndexOfKey(TKey key) -> int
Reko.Core.Collections.BTreeDictionary<TKey, TValue>.IsReadOnly.get -> bool
Reko.Core.Collections.BTreeDictionary<TKey, TValue>.KeyCollection
Reko.Core.Collections.BTreeDictionary<TKey, TValue>.KeyCollection.IndexOf(TKey item) -> int
Reko.Core.Collections.BTreeDictionary<TKey, TValue>.Keys.get -> Reko.Core.Collections.BTreeDictionary<TKey, TValue>.KeyCollection
Reko.Core.Collections.BTreeDictionary<TKey, TValue>.Remove(TKey key) -> bool
Reko.Core.Collections.BTreeDictionary<TKey, TValue>.this[TKey key].get -> TValue
Reko.Core.Collections.BTreeDictionary<TKey, TValue>.this[TKey key].set -> void
Reko.Core.Collections.BTreeDictionary<TKey, TValue>.TryGetValue(TKey key, out TValue value) -> bool
Reko.Core.Collections.BTreeDictionary<TKey, TValue>.ValueCollection
Reko.Core.Collections.BTreeDictionary<TKey, TValue>.Values.get -> Reko.Core.Collections.BTreeDictionary<TKey, TValue>.ValueCollection
Reko.Core.Collections.BTreeDictionaryEx
Reko.Core.Collections.ByteTrie<TValue>
Reko.Core.Collections.ByteTrie<TValue>.Add(System.ReadOnlySpan<byte> pattern, System.ReadOnlySpan<byte> mask, TValue value) -> void
Reko.Core.Collections.ByteTrie<TValue>.Add(System.ReadOnlySpan<byte> pattern, TValue value) -> void
Reko.Core.Collections.ByteTrie<TValue>.Add(System.ReadOnlySpan<byte> pattern, TValue value, bool replace) -> void
Reko.Core.Collections.ByteTrie<TValue>.ByteTrie() -> void
Reko.Core.Collections.ByteTrie<TValue>.Dump() -> void
Reko.Core.Collections.ByteTrie<TValue>.Match(System.ReadOnlySpan<byte> data, int index = 0) -> Reko.Core.Collections.ByteTrieMatch<TValue>
Reko.Core.Collections.ByteTrieMatch<T>
Reko.Core.Collections.ByteTrieMatch<T>.Index.get -> int
Reko.Core.Collections.ByteTrieMatch<T>.Length.get -> int
Reko.Core.Collections.ByteTrieMatch<T>.NextMatch(System.ReadOnlySpan<byte> bytes) -> Reko.Core.Collections.ByteTrieMatch<T>
Reko.Core.Collections.ByteTrieMatch<T>.Success.get -> bool
Reko.Core.Collections.ByteTrieMatch<T>.Value.get -> T
Reko.Core.Collections.CachedEnumerable<T>
Reko.Core.Collections.CachedEnumerable<T>.CachedEnumerable(System.Collections.Generic.IEnumerable<T> items) -> void
Reko.Core.Collections.CachedEnumerable<T>.Count.get -> int
Reko.Core.Collections.CachedEnumerable<T>.Dispose() -> void
Reko.Core.Collections.CachedEnumerable<T>.GetEnumerator() -> System.Collections.Generic.IEnumerator<T>
Reko.Core.Collections.CachedEnumerable<T>.this[int index].get -> T
Reko.Core.Collections.ConcurrentBTreeDictionary<TKey, TValue>
Reko.Core.Collections.ConcurrentBTreeDictionary<TKey, TValue>.Add(System.Collections.Generic.KeyValuePair<TKey, TValue> item) -> void
Reko.Core.Collections.ConcurrentBTreeDictionary<TKey, TValue>.Add(TKey key, TValue value) -> void
Reko.Core.Collections.ConcurrentBTreeDictionary<TKey, TValue>.Clear() -> void
Reko.Core.Collections.ConcurrentBTreeDictionary<TKey, TValue>.Collection<T>
Reko.Core.Collections.ConcurrentBTreeDictionary<TKey, TValue>.Collection<T>.Add(T item) -> void
Reko.Core.Collections.ConcurrentBTreeDictionary<TKey, TValue>.Collection<T>.Clear() -> void
Reko.Core.Collections.ConcurrentBTreeDictionary<TKey, TValue>.Collection<T>.Collection(Reko.Core.Collections.ConcurrentBTreeDictionary<TKey, TValue> btree) -> void
Reko.Core.Collections.ConcurrentBTreeDictionary<TKey, TValue>.Collection<T>.Count.get -> int
Reko.Core.Collections.ConcurrentBTreeDictionary<TKey, TValue>.Collection<T>.IsReadOnly.get -> bool
Reko.Core.Collections.ConcurrentBTreeDictionary<TKey, TValue>.Collection<T>.Remove(T item) -> bool
Reko.Core.Collections.ConcurrentBTreeDictionary<TKey, TValue>.Comparer.get -> System.Collections.Generic.IComparer<TKey>
Reko.Core.Collections.ConcurrentBTreeDictionary<TKey, TValue>.ConcurrentBTreeDictionary() -> void
Reko.Core.Collections.ConcurrentBTreeDictionary<TKey, TValue>.ConcurrentBTreeDictionary(Reko.Core.Collections.ConcurrentBTreeDictionary<TKey, TValue> that) -> void
Reko.Core.Collections.ConcurrentBTreeDictionary<TKey, TValue>.ConcurrentBTreeDictionary(System.Collections.Generic.IComparer<TKey> cmp) -> void
Reko.Core.Collections.ConcurrentBTreeDictionary<TKey, TValue>.ConcurrentBTreeDictionary(System.Collections.Generic.IDictionary<TKey, TValue> entries) -> void
Reko.Core.Collections.ConcurrentBTreeDictionary<TKey, TValue>.ConcurrentBTreeDictionary(System.Collections.Generic.IDictionary<TKey, TValue> entries, System.Collections.Generic.IComparer<TKey> comparer) -> void
Reko.Core.Collections.ConcurrentBTreeDictionary<TKey, TValue>.Contains(System.Collections.Generic.KeyValuePair<TKey, TValue> item) -> bool
Reko.Core.Collections.ConcurrentBTreeDictionary<TKey, TValue>.ContainsKey(TKey key) -> bool
Reko.Core.Collections.ConcurrentBTreeDictionary<TKey, TValue>.ContainsValue(TValue value) -> bool
Reko.Core.Collections.ConcurrentBTreeDictionary<TKey, TValue>.CopyTo(System.Collections.Generic.KeyValuePair<TKey, TValue>[] array, int arrayIndex) -> void
Reko.Core.Collections.ConcurrentBTreeDictionary<TKey, TValue>.Count.get -> int
Reko.Core.Collections.ConcurrentBTreeDictionary<TKey, TValue>.Dump() -> void
Reko.Core.Collections.ConcurrentBTreeDictionary<TKey, TValue>.GetEnumerator() -> System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<TKey, TValue>>
Reko.Core.Collections.ConcurrentBTreeDictionary<TKey, TValue>.IndexOfKey(TKey key) -> int
Reko.Core.Collections.ConcurrentBTreeDictionary<TKey, TValue>.IsReadOnly.get -> bool
Reko.Core.Collections.ConcurrentBTreeDictionary<TKey, TValue>.KeyCollection
Reko.Core.Collections.ConcurrentBTreeDictionary<TKey, TValue>.KeyCollection.IndexOf(TKey item) -> int
Reko.Core.Collections.ConcurrentBTreeDictionary<TKey, TValue>.Keys.get -> Reko.Core.Collections.ConcurrentBTreeDictionary<TKey, TValue>.KeyCollection
Reko.Core.Collections.ConcurrentBTreeDictionary<TKey, TValue>.Remove(TKey key) -> bool
Reko.Core.Collections.ConcurrentBTreeDictionary<TKey, TValue>.this[TKey key].get -> TValue
Reko.Core.Collections.ConcurrentBTreeDictionary<TKey, TValue>.this[TKey key].set -> void
Reko.Core.Collections.ConcurrentBTreeDictionary<TKey, TValue>.TryGetLowerBound(TKey key, out TValue value) -> bool
Reko.Core.Collections.ConcurrentBTreeDictionary<TKey, TValue>.TryGetLowerBoundIndex(TKey key, out int closestIndex) -> bool
Reko.Core.Collections.ConcurrentBTreeDictionary<TKey, TValue>.TryGetLowerBoundKey(TKey key, out TKey closestKey) -> bool
Reko.Core.Collections.ConcurrentBTreeDictionary<TKey, TValue>.TryGetUpperBound(TKey key, out TValue value) -> bool
Reko.Core.Collections.ConcurrentBTreeDictionary<TKey, TValue>.TryGetUpperBoundIndex(TKey key, out int closestIndex) -> bool
Reko.Core.Collections.ConcurrentBTreeDictionary<TKey, TValue>.TryGetUpperBoundKey(TKey key, out TKey closestKey) -> bool
Reko.Core.Collections.ConcurrentBTreeDictionary<TKey, TValue>.TryGetValue(TKey key, out TValue value) -> bool
Reko.Core.Collections.ConcurrentBTreeDictionary<TKey, TValue>.ValueCollection
Reko.Core.Collections.ConcurrentBTreeDictionary<TKey, TValue>.Values.get -> Reko.Core.Collections.ConcurrentBTreeDictionary<TKey, TValue>.ValueCollection
Reko.Core.Collections.ConcurrentObservableCollection<T>
Reko.Core.Collections.ConcurrentObservableCollection<T>.Add(T item) -> void
Reko.Core.Collections.ConcurrentObservableCollection<T>.AddRange(System.Collections.Generic.IEnumerable<T> range) -> void
Reko.Core.Collections.ConcurrentObservableCollection<T>.CollectionChanged -> System.Collections.Specialized.NotifyCollectionChangedEventHandler
Reko.Core.Collections.ConcurrentObservableCollection<T>.ConcurrentObservableCollection() -> void
Reko.Core.Collections.ConcurrentObservableCollection<T>.GetEnumerator() -> System.Collections.Generic.IEnumerator<T>
Reko.Core.Collections.ConcurrentObservableCollection<T>.Remove(T item) -> bool
Reko.Core.Collections.Counter<T>
Reko.Core.Collections.Counter<T>.Add(T item) -> int
Reko.Core.Collections.Counter<T>.Counter() -> void
Reko.Core.Collections.Counter<T>.Counter(System.Collections.Generic.IEnumerable<T> items) -> void
Reko.Core.Collections.Counter<T>.GetElements() -> System.Collections.Generic.IEnumerable<T>
Reko.Core.Collections.Counter<T>.Remove(T item) -> bool
Reko.Core.Collections.Dequeue<T>
Reko.Core.Collections.Dequeue<T>.Clear() -> void
Reko.Core.Collections.Dequeue<T>.Count.get -> int
Reko.Core.Collections.Dequeue<T>.Dequeue() -> void
Reko.Core.Collections.Dequeue<T>.Dequeue(int capacity) -> void
Reko.Core.Collections.Dequeue<T>.GetEnumerator() -> System.Collections.Generic.IEnumerator<T>
Reko.Core.Collections.Dequeue<T>.PeekBack() -> T
Reko.Core.Collections.Dequeue<T>.PeekFront() -> T
Reko.Core.Collections.Dequeue<T>.PopBack() -> T
Reko.Core.Collections.Dequeue<T>.PopFront() -> T
Reko.Core.Collections.Dequeue<T>.PushBack(T item) -> void
Reko.Core.Collections.Dequeue<T>.PushFront(T item) -> void
Reko.Core.Collections.DisjointPartition<T>
Reko.Core.Collections.DisjointPartition<T>.Add(T item) -> void
Reko.Core.Collections.DisjointPartition<T>.DisjointPartition() -> void
Reko.Core.Collections.DisjointPartition<T>.Find(T! item) -> T!
Reko.Core.Collections.DisjointPartition<T>.Union(T! x, T! y) -> void
Reko.Core.Collections.EnumerableEx
Reko.Core.Collections.FibonacciHeap<TKey, TValue>
Reko.Core.Collections.FibonacciHeap<TKey, TValue>.Clear() -> void
Reko.Core.Collections.FibonacciHeap<TKey, TValue>.Count.get -> int
Reko.Core.Collections.FibonacciHeap<TKey, TValue>.decreaseKey(Reko.Core.Collections.FibonacciHeap<TKey, TValue>.Node x, TValue newData, TKey k) -> void
Reko.Core.Collections.FibonacciHeap<TKey, TValue>.decreaseKey(TValue x, TKey k) -> void
Reko.Core.Collections.FibonacciHeap<TKey, TValue>.delete(Reko.Core.Collections.FibonacciHeap<TKey, TValue>.Node x) -> void
Reko.Core.Collections.FibonacciHeap<TKey, TValue>.FibonacciHeap() -> void
Reko.Core.Collections.FibonacciHeap<TKey, TValue>.insert(TValue x, TKey key) -> Reko.Core.Collections.FibonacciHeap<TKey, TValue>.Node
Reko.Core.Collections.FibonacciHeap<TKey, TValue>.isEmpty() -> bool
Reko.Core.Collections.FibonacciHeap<TKey, TValue>.Minimum() -> Reko.Core.Collections.FibonacciHeap<TKey, TValue>.Node
Reko.Core.Collections.FibonacciHeap<TKey, TValue>.Node
Reko.Core.Collections.FibonacciHeap<TKey, TValue>.Node.addToList(System.Collections.Generic.List<Reko.Core.Collections.FibonacciHeap<TKey, TValue>.Node> l) -> void
Reko.Core.Collections.FibonacciHeap<TKey, TValue>.Node.cascadingCut(Reko.Core.Collections.FibonacciHeap<TKey, TValue>.Node min) -> void
Reko.Core.Collections.FibonacciHeap<TKey, TValue>.Node.child -> Reko.Core.Collections.FibonacciHeap<TKey, TValue>.Node
Reko.Core.Collections.FibonacciHeap<TKey, TValue>.Node.cut(Reko.Core.Collections.FibonacciHeap<TKey, TValue>.Node x, Reko.Core.Collections.FibonacciHeap<TKey, TValue>.Node min) -> void
Reko.Core.Collections.FibonacciHeap<TKey, TValue>.Node.degree -> int
Reko.Core.Collections.FibonacciHeap<TKey, TValue>.Node.getData -> TValue
Reko.Core.Collections.FibonacciHeap<TKey, TValue>.Node.getKey -> TKey
Reko.Core.Collections.FibonacciHeap<TKey, TValue>.Node.left -> Reko.Core.Collections.FibonacciHeap<TKey, TValue>.Node
Reko.Core.Collections.FibonacciHeap<TKey, TValue>.Node.link(Reko.Core.Collections.FibonacciHeap<TKey, TValue>.Node parent) -> void
Reko.Core.Collections.FibonacciHeap<TKey, TValue>.Node.Node(TValue data, TKey key) -> void
Reko.Core.Collections.FibonacciHeap<TKey, TValue>.Node.parent -> Reko.Core.Collections.FibonacciHeap<TKey, TValue>.Node
Reko.Core.Collections.FibonacciHeap<TKey, TValue>.Node.right -> Reko.Core.Collections.FibonacciHeap<TKey, TValue>.Node
Reko.Core.Collections.FibonacciHeap<TKey, TValue>.nodeList() -> System.Collections.Generic.List<Reko.Core.Collections.FibonacciHeap<TKey, TValue>.Node>
Reko.Core.Collections.FibonacciHeap<TKey, TValue>.removeMin() -> TValue
Reko.Core.Collections.IDequeue<T>
Reko.Core.Collections.IDequeue<T>.Clear() -> void
Reko.Core.Collections.IDequeue<T>.Count.get -> int
Reko.Core.Collections.IDequeue<T>.PeekBack() -> T
Reko.Core.Collections.IDequeue<T>.PeekFront() -> T
Reko.Core.Collections.IDequeue<T>.PopBack() -> T
Reko.Core.Collections.IDequeue<T>.PopFront() -> T
Reko.Core.Collections.IDequeue<T>.PushBack(T item) -> void
Reko.Core.Collections.IDequeue<T>.PushFront(T item) -> void
Reko.Core.Collections.Interval
Reko.Core.Collections.Interval<T>
Reko.Core.Collections.Interval<T>.Covers(Reko.Core.Collections.Interval<T> that) -> bool
Reko.Core.Collections.Interval<T>.Except(Reko.Core.Collections.Interval<T> that) -> Reko.Core.Collections.Interval<T>
Reko.Core.Collections.Interval<T>.Intersect(Reko.Core.Collections.Interval<T> that) -> Reko.Core.Collections.Interval<T>
Reko.Core.Collections.Interval<T>.Interval() -> void
Reko.Core.Collections.Interval<T>.Interval(T start, T end) -> void
Reko.Core.Collections.Interval<T>.OverlapsWith(Reko.Core.Collections.Interval<T> other) -> bool
Reko.Core.Collections.IntervalTree<T, TypeValue>
Reko.Core.Collections.IntervalTree<T, TypeValue>.Add(Reko.Core.Collections.Interval<T> interval, TypeValue value) -> bool
Reko.Core.Collections.IntervalTree<T, TypeValue>.Add(T x, T y, TypeValue value) -> void
Reko.Core.Collections.IntervalTree<T, TypeValue>.Clear() -> void
Reko.Core.Collections.IntervalTree<T, TypeValue>.ComparerUtil
Reko.Core.Collections.IntervalTree<T, TypeValue>.Count.get -> int
Reko.Core.Collections.IntervalTree<T, TypeValue>.Delete(Reko.Core.Collections.Interval<T> arg) -> bool
Reko.Core.Collections.IntervalTree<T, TypeValue>.Dump() -> void
Reko.Core.Collections.IntervalTree<T, TypeValue>.GetEnumerator() -> System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<Reko.Core.Collections.Interval<T>, TypeValue>>
Reko.Core.Collections.IntervalTree<T, TypeValue>.GetIntervalsOverlappingWith(Reko.Core.Collections.Interval<T> toFind) -> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<Reko.Core.Collections.Interval<T>, TypeValue>>
Reko.Core.Collections.IntervalTree<T, TypeValue>.GetIntervalsOverlappingWith(Reko.Core.Collections.Interval<T> toFind, ref System.Collections.Generic.List<System.Collections.Generic.KeyValuePair<Reko.Core.Collections.Interval<T>, TypeValue>> list) -> void
Reko.Core.Collections.IntervalTree<T, TypeValue>.GetIntervalsStartingAt(T arg) -> System.Collections.Generic.List<System.Collections.Generic.KeyValuePair<Reko.Core.Collections.Interval<T>, TypeValue>>
Reko.Core.Collections.IntervalTree<T, TypeValue>.Intervals.get -> System.Collections.Generic.IEnumerable<Reko.Core.Collections.Interval<T>>
Reko.Core.Collections.IntervalTree<T, TypeValue>.IntervalTree() -> void
Reko.Core.Collections.IntervalTree<T, TypeValue>.IntervalTree(System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<Reko.Core.Collections.Interval<T>, TypeValue>> elems) -> void
Reko.Core.Collections.IntervalTree<T, TypeValue>.IntervalValuePairs.get -> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<Reko.Core.Collections.Interval<T>, TypeValue>>
Reko.Core.Collections.IntervalTree<T, TypeValue>.TryGetInterval(Reko.Core.Collections.Interval<T> data, out TypeValue value) -> bool
Reko.Core.Collections.IntervalTree<T, TypeValue>.Values.get -> System.Collections.Generic.IEnumerable<TypeValue>
Reko.Core.Collections.IntervalTree<T, TypeValue>.Write(System.IO.TextWriter w) -> void
Reko.Core.Collections.LinqAlgorithms
Reko.Core.Collections.LinqAlgorithms.Item
Reko.Core.Collections.LinqAlgorithms.Item.component_id -> long
Reko.Core.Collections.LinqAlgorithms.Item.id -> long
Reko.Core.Collections.LinqAlgorithms.Item.Item() -> void
Reko.Core.Collections.LinqAlgorithms.Link
Reko.Core.Collections.LinqAlgorithms.Link.first -> long
Reko.Core.Collections.LinqAlgorithms.Link.Link() -> void
Reko.Core.Collections.LinqAlgorithms.Link.second -> long
Reko.Core.Collections.LinqAlgorithms.LinqAlgorithms() -> void
Reko.Core.Collections.LookaheadEnumerator<T>
Reko.Core.Collections.LookaheadEnumerator<T>.Current.get -> T
Reko.Core.Collections.LookaheadEnumerator<T>.Dispose() -> void
Reko.Core.Collections.LookaheadEnumerator<T>.LookaheadEnumerator(System.Collections.Generic.IEnumerable<T> collection) -> void
Reko.Core.Collections.LookaheadEnumerator<T>.LookaheadEnumerator(System.Collections.Generic.IEnumerator<T> innerEnumerator) -> void
Reko.Core.Collections.LookaheadEnumerator<T>.MoveNext() -> bool
Reko.Core.Collections.LookaheadEnumerator<T>.Peek(int ahead) -> T
Reko.Core.Collections.LookaheadEnumerator<T>.Reset() -> void
Reko.Core.Collections.LookaheadEnumerator<T>.Skip(int skip) -> void
Reko.Core.Collections.ObservableRangeCollection<T>
Reko.Core.Collections.ObservableRangeCollection<T>.AddRange(System.Collections.Generic.IEnumerable<T> collection) -> void
Reko.Core.Collections.ObservableRangeCollection<T>.ObservableRangeCollection() -> void
Reko.Core.Collections.ObservableRangeCollection<T>.ObservableRangeCollection(System.Collections.Generic.IEnumerable<T> collection) -> void
Reko.Core.Collections.ObservableRangeCollection<T>.RemoveRange(System.Collections.Generic.IEnumerable<T> collection) -> void
Reko.Core.Collections.ObservableRangeCollection<T>.Replace(T item) -> void
Reko.Core.Collections.ObservableRangeCollection<T>.ReplaceRange(System.Collections.Generic.IEnumerable<T> collection) -> void
Reko.Core.Collections.PriorityQueue<T>
Reko.Core.Collections.PriorityQueue<T>.Clear() -> void
Reko.Core.Collections.PriorityQueue<T>.Contains(T item) -> bool
Reko.Core.Collections.PriorityQueue<T>.CopyTo(T[] array, int arrayIndex) -> void
Reko.Core.Collections.PriorityQueue<T>.Count.get -> int
Reko.Core.Collections.PriorityQueue<T>.Dequeue() -> T
Reko.Core.Collections.PriorityQueue<T>.Enqueue(int priority, T value) -> void
Reko.Core.Collections.PriorityQueue<T>.GetEnumerator() -> System.Collections.Generic.IEnumerator<T>
Reko.Core.Collections.PriorityQueue<T>.HeapItem
Reko.Core.Collections.PriorityQueue<T>.HeapItem.HeapItem() -> void
Reko.Core.Collections.PriorityQueue<T>.HeapItem.Priority -> int
Reko.Core.Collections.PriorityQueue<T>.HeapItem.Value -> T
Reko.Core.Collections.PriorityQueue<T>.IsReadOnly.get -> bool
Reko.Core.Collections.PriorityQueue<T>.PriorityQueue() -> void
Reko.Core.Collections.qTrie<Key>
Reko.Core.Collections.qTrie<Key>.change(Key k, System.Func<bool> f) -> Reko.Core.Collections.qTrie<Key>
Reko.Core.Collections.qTrie<Key>.qTrie() -> void
Reko.Core.Collections.SortedListEx
Reko.Core.Configuration.ArchitectureDefinition
Reko.Core.Configuration.ArchitectureDefinition.ArchitectureDefinition() -> void
Reko.Core.Configuration.ArchitectureDefinition.Description.get -> string
Reko.Core.Configuration.ArchitectureDefinition.Description.set -> void
Reko.Core.Configuration.ArchitectureDefinition.Models.get -> System.Collections.Generic.Dictionary<string, Reko.Core.Configuration.ModelDefinition>
Reko.Core.Configuration.ArchitectureDefinition.Models.set -> void
Reko.Core.Configuration.ArchitectureDefinition.Name.get -> string
Reko.Core.Configuration.ArchitectureDefinition.Name.set -> void
Reko.Core.Configuration.ArchitectureDefinition.Options.get -> System.Collections.Generic.List<Reko.Core.Configuration.PropertyOption>
Reko.Core.Configuration.ArchitectureDefinition.Options.set -> void
Reko.Core.Configuration.ArchitectureDefinition.TypeName.get -> string
Reko.Core.Configuration.ArchitectureDefinition.TypeName.set -> void
Reko.Core.Configuration.Architecture_v1
Reko.Core.Configuration.Architecture_v1.Architecture_v1() -> void
Reko.Core.Configuration.Architecture_v1.Description -> string
Reko.Core.Configuration.Architecture_v1.Models -> Reko.Core.Configuration.ModelDefinition_v1[]
Reko.Core.Configuration.Architecture_v1.Name -> string
Reko.Core.Configuration.Architecture_v1.Options -> Reko.Core.Configuration.PropertyOption_v1[]
Reko.Core.Configuration.Architecture_v1.Type -> string
Reko.Core.Configuration.Assembler_v1
Reko.Core.Configuration.Assembler_v1.Assembler_v1() -> void
Reko.Core.Configuration.Assembler_v1.Description -> string
Reko.Core.Configuration.Assembler_v1.Name -> string
Reko.Core.Configuration.Assembler_v1.Type -> string
Reko.Core.Configuration.BytePattern_v1
Reko.Core.Configuration.BytePattern_v1.BytePattern_v1() -> void
Reko.Core.Configuration.BytePattern_v1.Bytes -> string
Reko.Core.Configuration.BytePattern_v1.Mask -> string
Reko.Core.Configuration.EntryPointDefinition
Reko.Core.Configuration.EntryPointDefinition.Address.get -> string
Reko.Core.Configuration.EntryPointDefinition.Address.set -> void
Reko.Core.Configuration.EntryPointDefinition.EntryPointDefinition() -> void
Reko.Core.Configuration.EntryPointDefinition.Follow.get -> bool
Reko.Core.Configuration.EntryPointDefinition.Follow.set -> void
Reko.Core.Configuration.EntryPointDefinition.Name.get -> string
Reko.Core.Configuration.EntryPointDefinition.Name.set -> void
Reko.Core.Configuration.EntryPoint_v1
Reko.Core.Configuration.EntryPoint_v1.Address -> string
Reko.Core.Configuration.EntryPoint_v1.EntryPoint_v1() -> void
Reko.Core.Configuration.EntryPoint_v1.Follow -> bool
Reko.Core.Configuration.EntryPoint_v1.Name -> string
Reko.Core.Configuration.Environment_v1
Reko.Core.Configuration.Environment_v1.Architectures -> Reko.Core.Configuration.PlatformArchitecture_v1[]
Reko.Core.Configuration.Environment_v1.CaseInsensitive -> bool
Reko.Core.Configuration.Environment_v1.Characteristics -> Reko.Core.Configuration.TypeLibraryReference_v1[]
Reko.Core.Configuration.Environment_v1.Description -> string
Reko.Core.Configuration.Environment_v1.Environment_v1() -> void
Reko.Core.Configuration.Environment_v1.Heuristics -> Reko.Core.Configuration.PlatformHeuristics_v1
Reko.Core.Configuration.Environment_v1.MemoryMap -> string
Reko.Core.Configuration.Environment_v1.Name -> string
Reko.Core.Configuration.Environment_v1.Options -> System.Xml.XmlElement[]
Reko.Core.Configuration.Environment_v1.SignatureFiles -> Reko.Core.Configuration.SignatureFile_v1[]
Reko.Core.Configuration.Environment_v1.Type -> string
Reko.Core.Configuration.Environment_v1.TypeLibraries -> Reko.Core.Configuration.TypeLibraryReference_v1[]
Reko.Core.Configuration.IConfigurationService
Reko.Core.Configuration.IConfigurationService.GetArchitecture(string archLabel) -> Reko.Core.IProcessorArchitecture
Reko.Core.Configuration.IConfigurationService.GetArchitecture(string archLabel, string modelName) -> Reko.Core.IProcessorArchitecture
Reko.Core.Configuration.IConfigurationService.GetArchitecture(string archLabel, System.Collections.Generic.Dictionary<string, object> options) -> Reko.Core.IProcessorArchitecture
Reko.Core.Configuration.IConfigurationService.GetArchitectures() -> System.Collections.Generic.ICollection<Reko.Core.Configuration.ArchitectureDefinition>
Reko.Core.Configuration.IConfigurationService.GetDefaultPreferences() -> System.Collections.Generic.IEnumerable<Reko.Core.Configuration.UiStyleDefinition>
Reko.Core.Configuration.IConfigurationService.GetEnvironment(string envName) -> Reko.Core.Configuration.PlatformDefinition
Reko.Core.Configuration.IConfigurationService.GetEnvironments() -> System.Collections.Generic.ICollection<Reko.Core.Configuration.PlatformDefinition>
Reko.Core.Configuration.IConfigurationService.GetImageLoader(string loader) -> Reko.Core.Configuration.LoaderDefinition
Reko.Core.Configuration.IConfigurationService.GetImageLoaders() -> System.Collections.Generic.ICollection<Reko.Core.Configuration.LoaderDefinition>
Reko.Core.Configuration.IConfigurationService.GetInstallationRelativePath(params string[] pathComponents) -> string
Reko.Core.Configuration.IConfigurationService.GetRawFile(string rawFileFormat) -> Reko.Core.Configuration.RawFileDefinition
Reko.Core.Configuration.IConfigurationService.GetRawFiles() -> System.Collections.Generic.ICollection<Reko.Core.Configuration.RawFileDefinition>
Reko.Core.Configuration.IConfigurationService.GetSignatureFiles() -> System.Collections.Generic.ICollection<Reko.Core.Configuration.SignatureFileDefinition>
Reko.Core.Configuration.IConfigurationService.GetSymbolSources() -> System.Collections.Generic.ICollection<Reko.Core.Configuration.SymbolSourceDefinition>
Reko.Core.Configuration.ListOption_v1
Reko.Core.Configuration.ListOption_v1.ListOption_v1() -> void
Reko.Core.Configuration.ListOption_v1.Text -> string
Reko.Core.Configuration.ListOption_v1.Value -> string
Reko.Core.Configuration.LoaderDefinition
Reko.Core.Configuration.LoaderDefinition.Argument.get -> string
Reko.Core.Configuration.LoaderDefinition.Argument.set -> void
Reko.Core.Configuration.LoaderDefinition.Description.get -> string
Reko.Core.Configuration.LoaderDefinition.Description.set -> void
Reko.Core.Configuration.LoaderDefinition.Extension.get -> string
Reko.Core.Configuration.LoaderDefinition.Extension.set -> void
Reko.Core.Configuration.LoaderDefinition.Label.get -> string
Reko.Core.Configuration.LoaderDefinition.Label.set -> void
Reko.Core.Configuration.LoaderDefinition.LoaderDefinition() -> void
Reko.Core.Configuration.LoaderDefinition.MagicNumber.get -> string
Reko.Core.Configuration.LoaderDefinition.MagicNumber.set -> void
Reko.Core.Configuration.LoaderDefinition.Offset.get -> long
Reko.Core.Configuration.LoaderDefinition.Offset.set -> void
Reko.Core.Configuration.LoaderDefinition.TypeName.get -> string
Reko.Core.Configuration.LoaderDefinition.TypeName.set -> void
Reko.Core.Configuration.ModelDefinition
Reko.Core.Configuration.ModelDefinition.ModelDefinition() -> void
Reko.Core.Configuration.ModelDefinition.Name.get -> string
Reko.Core.Configuration.ModelDefinition.Name.set -> void
Reko.Core.Configuration.ModelDefinition.Options.get -> System.Collections.Generic.List<Reko.Core.Configuration.ListOption_v1>
Reko.Core.Configuration.ModelDefinition.Options.set -> void
Reko.Core.Configuration.ModelDefinition_v1
Reko.Core.Configuration.ModelDefinition_v1.ModelDefinition_v1() -> void
Reko.Core.Configuration.ModelDefinition_v1.Name -> string
Reko.Core.Configuration.ModelDefinition_v1.Options -> Reko.Core.Configuration.ListOption_v1[]
Reko.Core.Configuration.PlatformArchitectureDefinition
Reko.Core.Configuration.PlatformArchitectureDefinition.Name.get -> string
Reko.Core.Configuration.PlatformArchitectureDefinition.Name.set -> void
Reko.Core.Configuration.PlatformArchitectureDefinition.PlatformArchitectureDefinition() -> void
Reko.Core.Configuration.PlatformArchitectureDefinition.ProcedurePrologs.get -> System.Collections.Generic.List<Reko.Core.MaskedPattern>
Reko.Core.Configuration.PlatformArchitectureDefinition.ProcedurePrologs.set -> void
Reko.Core.Configuration.PlatformArchitectureDefinition.TrashedRegisters.get -> System.Collections.Generic.List<string>
Reko.Core.Configuration.PlatformArchitectureDefinition.TrashedRegisters.set -> void
Reko.Core.Configuration.PlatformArchitectureDefinition.TypeLibraries.get -> System.Collections.Generic.List<Reko.Core.Configuration.TypeLibraryDefinition>
Reko.Core.Configuration.PlatformArchitectureDefinition.TypeLibraries.set -> void
Reko.Core.Configuration.PlatformArchitecture_v1
Reko.Core.Configuration.PlatformArchitecture_v1.Name -> string
Reko.Core.Configuration.PlatformArchitecture_v1.PlatformArchitecture_v1() -> void
Reko.Core.Configuration.PlatformArchitecture_v1.ProcedurePrologs -> Reko.Core.Configuration.BytePattern_v1[]
Reko.Core.Configuration.PlatformArchitecture_v1.TrashedRegisters -> string
Reko.Core.Configuration.PlatformArchitecture_v1.TypeLibraries -> Reko.Core.Configuration.TypeLibraryReference_v1[]
Reko.Core.Configuration.PlatformDefinition
Reko.Core.Configuration.PlatformDefinition.CaseInsensitive.get -> bool
Reko.Core.Configuration.PlatformDefinition.CaseInsensitive.set -> void
Reko.Core.Configuration.PlatformDefinition.Description.get -> string
Reko.Core.Configuration.PlatformDefinition.Description.set -> void
Reko.Core.Configuration.PlatformDefinition.Heuristics.get -> Reko.Core.Configuration.PlatformHeuristics_v1
Reko.Core.Configuration.PlatformDefinition.Heuristics.set -> void
Reko.Core.Configuration.PlatformDefinition.LoadSettingsFromConfiguration(System.IServiceProvider services, Reko.Core.Platform platform) -> void
Reko.Core.Configuration.PlatformDefinition.MemoryMapFile.get -> string
Reko.Core.Configuration.PlatformDefinition.MemoryMapFile.set -> void
Reko.Core.Configuration.PlatformDefinition.Name.get -> string
Reko.Core.Configuration.PlatformDefinition.Name.set -> void
Reko.Core.Configuration.PlatformDefinition.PlatformDefinition() -> void
Reko.Core.Configuration.PlatformDefinition.TypeName.get -> string
Reko.Core.Configuration.PlatformDefinition.TypeName.set -> void
Reko.Core.Configuration.PlatformHeuristics_v1
Reko.Core.Configuration.PlatformHeuristics_v1.PlatformHeuristics_v1() -> void
Reko.Core.Configuration.PlatformHeuristics_v1.ProcedurePrologs -> Reko.Core.Configuration.BytePattern_v1[]
Reko.Core.Configuration.PropertyOption
Reko.Core.Configuration.PropertyOption.Choices.get -> Reko.Core.Configuration.ListOption_v1[]
Reko.Core.Configuration.PropertyOption.Choices.set -> void
Reko.Core.Configuration.PropertyOption.Description.get -> string
Reko.Core.Configuration.PropertyOption.Description.set -> void
Reko.Core.Configuration.PropertyOption.Name.get -> string
Reko.Core.Configuration.PropertyOption.Name.set -> void
Reko.Core.Configuration.PropertyOption.PropertyOption() -> void
Reko.Core.Configuration.PropertyOption.Required.get -> bool
Reko.Core.Configuration.PropertyOption.Required.set -> void
Reko.Core.Configuration.PropertyOption.Text.get -> string
Reko.Core.Configuration.PropertyOption.Text.set -> void
Reko.Core.Configuration.PropertyOption.TypeName.get -> string
Reko.Core.Configuration.PropertyOption.TypeName.set -> void
Reko.Core.Configuration.PropertyOption_v1
Reko.Core.Configuration.PropertyOption_v1.Choices -> Reko.Core.Configuration.ListOption_v1[]
Reko.Core.Configuration.PropertyOption_v1.Description -> string
Reko.Core.Configuration.PropertyOption_v1.Name -> string
Reko.Core.Configuration.PropertyOption_v1.PropertyOption_v1() -> void
Reko.Core.Configuration.PropertyOption_v1.Required -> bool
Reko.Core.Configuration.PropertyOption_v1.Text -> string
Reko.Core.Configuration.PropertyOption_v1.TypeName -> string
Reko.Core.Configuration.RawFileDefinition
Reko.Core.Configuration.RawFileDefinition.Architecture.get -> string
Reko.Core.Configuration.RawFileDefinition.Architecture.set -> void
Reko.Core.Configuration.RawFileDefinition.BaseAddress.get -> string
Reko.Core.Configuration.RawFileDefinition.BaseAddress.set -> void
Reko.Core.Configuration.RawFileDefinition.Description.get -> string
Reko.Core.Configuration.RawFileDefinition.Description.set -> void
Reko.Core.Configuration.RawFileDefinition.EntryPoint.get -> Reko.Core.Configuration.EntryPointDefinition
Reko.Core.Configuration.RawFileDefinition.EntryPoint.set -> void
Reko.Core.Configuration.RawFileDefinition.Environment.get -> string
Reko.Core.Configuration.RawFileDefinition.Environment.set -> void
Reko.Core.Configuration.RawFileDefinition.Loader.get -> string
Reko.Core.Configuration.RawFileDefinition.Loader.set -> void
Reko.Core.Configuration.RawFileDefinition.Name.get -> string
Reko.Core.Configuration.RawFileDefinition.Name.set -> void
Reko.Core.Configuration.RawFileDefinition.RawFileDefinition() -> void
Reko.Core.Configuration.RawFile_v1
Reko.Core.Configuration.RawFile_v1.Architecture -> string
Reko.Core.Configuration.RawFile_v1.Base -> string
Reko.Core.Configuration.RawFile_v1.Description -> string
Reko.Core.Configuration.RawFile_v1.Entry -> Reko.Core.Configuration.EntryPoint_v1
Reko.Core.Configuration.RawFile_v1.Environment -> string
Reko.Core.Configuration.RawFile_v1.LoaderType -> string
Reko.Core.Configuration.RawFile_v1.Name -> string
Reko.Core.Configuration.RawFile_v1.RawFile_v1() -> void
Reko.Core.Configuration.RekoConfigurationService
Reko.Core.Configuration.RekoConfigurationService.GetArchitecture(string archLabel) -> Reko.Core.IProcessorArchitecture
Reko.Core.Configuration.RekoConfigurationService.GetArchitecture(string archLabel, string modelName) -> Reko.Core.IProcessorArchitecture
Reko.Core.Configuration.RekoConfigurationService.GetArchitecture(string archLabel, System.Collections.Generic.Dictionary<string, object> options) -> Reko.Core.IProcessorArchitecture
Reko.Core.Configuration.RekoConfigurationService.GetDefaultPreferences() -> System.Collections.Generic.IEnumerable<Reko.Core.Configuration.UiStyleDefinition>
Reko.Core.Configuration.RekoConfigurationService.GetEnvironment(string envName) -> Reko.Core.Configuration.PlatformDefinition
Reko.Core.Configuration.RekoConfigurationService.GetInstallationRelativePath(string[] pathComponents) -> string
Reko.Core.Configuration.RekoConfigurationService.RekoConfigurationService(System.IServiceProvider services, string rekoConfigPath, Reko.Core.Configuration.RekoConfiguration_v1 config) -> void
Reko.Core.Configuration.RekoConfiguration_v1
Reko.Core.Configuration.RekoConfiguration_v1.Architectures -> Reko.Core.Configuration.Architecture_v1[]
Reko.Core.Configuration.RekoConfiguration_v1.Assemblers -> Reko.Core.Configuration.Assembler_v1[]
Reko.Core.Configuration.RekoConfiguration_v1.Environments -> Reko.Core.Configuration.Environment_v1[]
Reko.Core.Configuration.RekoConfiguration_v1.Loaders -> Reko.Core.Configuration.RekoLoader[]
Reko.Core.Configuration.RekoConfiguration_v1.RawFiles -> Reko.Core.Configuration.RawFile_v1[]
Reko.Core.Configuration.RekoConfiguration_v1.RekoConfiguration_v1() -> void
Reko.Core.Configuration.RekoConfiguration_v1.SignatureFiles -> Reko.Core.Configuration.SignatureFile_v1[]
Reko.Core.Configuration.RekoConfiguration_v1.SymbolSources -> Reko.Core.Configuration.SymbolSource_v1[]
Reko.Core.Configuration.RekoConfiguration_v1.UiPreferences -> Reko.Core.Configuration.RekoUiPreferences
Reko.Core.Configuration.RekoLoader
Reko.Core.Configuration.RekoLoader.Argument -> string
Reko.Core.Configuration.RekoLoader.Extension -> string
Reko.Core.Configuration.RekoLoader.Label -> string
Reko.Core.Configuration.RekoLoader.MagicNumber -> string
Reko.Core.Configuration.RekoLoader.Offset -> string
Reko.Core.Configuration.RekoLoader.RekoLoader() -> void
Reko.Core.Configuration.RekoLoader.Type -> string
Reko.Core.Configuration.RekoUiPreferences
Reko.Core.Configuration.RekoUiPreferences.RekoUiPreferences() -> void
Reko.Core.Configuration.RekoUiPreferences.Styles -> Reko.Core.Configuration.StyleDefinition_v1[]
Reko.Core.Configuration.SignatureFileDefinition
Reko.Core.Configuration.SignatureFileDefinition.Filename.get -> string
Reko.Core.Configuration.SignatureFileDefinition.Filename.set -> void
Reko.Core.Configuration.SignatureFileDefinition.Label.get -> string
Reko.Core.Configuration.SignatureFileDefinition.Label.set -> void
Reko.Core.Configuration.SignatureFileDefinition.SignatureFileDefinition() -> void
Reko.Core.Configuration.SignatureFileDefinition.TypeName.get -> string
Reko.Core.Configuration.SignatureFileDefinition.TypeName.set -> void
Reko.Core.Configuration.SignatureFile_v1
Reko.Core.Configuration.SignatureFile_v1.Filename -> string
Reko.Core.Configuration.SignatureFile_v1.Label -> string
Reko.Core.Configuration.SignatureFile_v1.SignatureFile_v1() -> void
Reko.Core.Configuration.SignatureFile_v1.TypeName -> string
Reko.Core.Configuration.StyleDefinition_v1
Reko.Core.Configuration.StyleDefinition_v1.BackColor -> string
Reko.Core.Configuration.StyleDefinition_v1.Cursor -> string
Reko.Core.Configuration.StyleDefinition_v1.Font -> string
Reko.Core.Configuration.StyleDefinition_v1.ForeColor -> string
Reko.Core.Configuration.StyleDefinition_v1.Name -> string
Reko.Core.Configuration.StyleDefinition_v1.PaddingBottom -> string
Reko.Core.Configuration.StyleDefinition_v1.PaddingLeft -> string
Reko.Core.Configuration.StyleDefinition_v1.PaddingRight -> string
Reko.Core.Configuration.StyleDefinition_v1.PaddingTop -> string
Reko.Core.Configuration.StyleDefinition_v1.StyleDefinition_v1() -> void
Reko.Core.Configuration.StyleDefinition_v1.TextAlign -> string
Reko.Core.Configuration.StyleDefinition_v1.Width -> string
Reko.Core.Configuration.SymbolSourceDefinition
Reko.Core.Configuration.SymbolSourceDefinition.Description.get -> string
Reko.Core.Configuration.SymbolSourceDefinition.Description.set -> void
Reko.Core.Configuration.SymbolSourceDefinition.Extension.get -> string
Reko.Core.Configuration.SymbolSourceDefinition.Extension.set -> void
Reko.Core.Configuration.SymbolSourceDefinition.Name.get -> string
Reko.Core.Configuration.SymbolSourceDefinition.Name.set -> void
Reko.Core.Configuration.SymbolSourceDefinition.SymbolSourceDefinition() -> void
Reko.Core.Configuration.SymbolSourceDefinition.TypeName.get -> string
Reko.Core.Configuration.SymbolSourceDefinition.TypeName.set -> void
Reko.Core.Configuration.SymbolSource_v1
Reko.Core.Configuration.SymbolSource_v1.Description -> string
Reko.Core.Configuration.SymbolSource_v1.Extension -> string
Reko.Core.Configuration.SymbolSource_v1.Name -> string
Reko.Core.Configuration.SymbolSource_v1.SymbolSource_v1() -> void
Reko.Core.Configuration.SymbolSource_v1.Type -> string
Reko.Core.Configuration.TypeLibraryDefinition
Reko.Core.Configuration.TypeLibraryDefinition.Architecture.get -> string
Reko.Core.Configuration.TypeLibraryDefinition.Architecture.set -> void
Reko.Core.Configuration.TypeLibraryDefinition.Loader.get -> string
Reko.Core.Configuration.TypeLibraryDefinition.Loader.set -> void
Reko.Core.Configuration.TypeLibraryDefinition.MatchArchitecture(string archName) -> bool
Reko.Core.Configuration.TypeLibraryDefinition.Module.get -> string
Reko.Core.Configuration.TypeLibraryDefinition.Module.set -> void
Reko.Core.Configuration.TypeLibraryDefinition.Name.get -> string
Reko.Core.Configuration.TypeLibraryDefinition.Name.set -> void
Reko.Core.Configuration.TypeLibraryDefinition.TypeLibraryDefinition() -> void
Reko.Core.Configuration.TypeLibraryReference_v1
Reko.Core.Configuration.TypeLibraryReference_v1.Arch -> string
Reko.Core.Configuration.TypeLibraryReference_v1.Loader -> string
Reko.Core.Configuration.TypeLibraryReference_v1.Module -> string
Reko.Core.Configuration.TypeLibraryReference_v1.Name -> string
Reko.Core.Configuration.TypeLibraryReference_v1.TypeLibraryReference_v1() -> void
Reko.Core.Configuration.UiPreferencesConfiguration
Reko.Core.Configuration.UiPreferencesConfiguration.Styles.get -> System.Collections.Generic.List<Reko.Core.Configuration.UiStyleDefinition>
Reko.Core.Configuration.UiPreferencesConfiguration.Styles.set -> void
Reko.Core.Configuration.UiPreferencesConfiguration.UiPreferencesConfiguration() -> void
Reko.Core.Configuration.UiStyleDefinition
Reko.Core.Configuration.UiStyleDefinition.BackColor.get -> string
Reko.Core.Configuration.UiStyleDefinition.BackColor.set -> void
Reko.Core.Configuration.UiStyleDefinition.Cursor.get -> string
Reko.Core.Configuration.UiStyleDefinition.Cursor.set -> void
Reko.Core.Configuration.UiStyleDefinition.FontName.get -> string
Reko.Core.Configuration.UiStyleDefinition.FontName.set -> void
Reko.Core.Configuration.UiStyleDefinition.ForeColor.get -> string
Reko.Core.Configuration.UiStyleDefinition.ForeColor.set -> void
Reko.Core.Configuration.UiStyleDefinition.Name.get -> string
Reko.Core.Configuration.UiStyleDefinition.Name.set -> void
Reko.Core.Configuration.UiStyleDefinition.PaddingBottom.get -> string
Reko.Core.Configuration.UiStyleDefinition.PaddingBottom.set -> void
Reko.Core.Configuration.UiStyleDefinition.PaddingLeft.get -> string
Reko.Core.Configuration.UiStyleDefinition.PaddingLeft.set -> void
Reko.Core.Configuration.UiStyleDefinition.PaddingRight.get -> string
Reko.Core.Configuration.UiStyleDefinition.PaddingRight.set -> void
Reko.Core.Configuration.UiStyleDefinition.PaddingTop.get -> string
Reko.Core.Configuration.UiStyleDefinition.PaddingTop.set -> void
Reko.Core.Configuration.UiStyleDefinition.TextAlign.get -> string
Reko.Core.Configuration.UiStyleDefinition.TextAlign.set -> void
Reko.Core.Configuration.UiStyleDefinition.UiStyleDefinition() -> void
Reko.Core.Configuration.UiStyleDefinition.Width.get -> string
Reko.Core.Configuration.UiStyleDefinition.Width.set -> void
Reko.Core.DefaultPlatform
Reko.Core.DefaultPlatform.DefaultPlatform(System.IServiceProvider services, Reko.Core.IProcessorArchitecture arch) -> void
Reko.Core.DefaultPlatform.DefaultPlatform(System.IServiceProvider services, Reko.Core.IProcessorArchitecture arch, string description) -> void
Reko.Core.DefaultPlatform.TypeLibraries.get -> System.Collections.Generic.List<Reko.Core.TypeLibrary>
Reko.Core.DefaultProcessorState
Reko.Core.DefaultProcessorState.DefaultProcessorState(Reko.Core.IProcessorArchitecture arch) -> void
Reko.Core.Dfa.Automaton
Reko.Core.Dfa.Automaton.Automaton(Reko.Core.Dfa.State[] states, int[,] transitions) -> void
Reko.Core.Dfa.Automaton.GetMatches(byte[] bytes, int iStart) -> System.Collections.Generic.IEnumerable<int>
Reko.Core.Dfa.Automaton.GetMatches(byte[] bytes, int iStart, int iEnd) -> System.Collections.Generic.IEnumerable<int>
Reko.Core.Dfa.DfaBuilder
Reko.Core.Dfa.DfaBuilder.BuildAutomaton() -> void
Reko.Core.Dfa.DfaBuilder.BuildAutomaton(Reko.Core.Dfa.TreeNode tree) -> void
Reko.Core.Dfa.DfaBuilder.BuildNodeSets() -> void
Reko.Core.Dfa.DfaBuilder.BuildNodeSets(Reko.Core.Dfa.TreeNode node) -> void
Reko.Core.Dfa.DfaBuilder.DfaBuilder(Reko.Core.Dfa.TreeNode node) -> void
Reko.Core.Dfa.DfaBuilder.DfaBuilder(string pattern) -> void
Reko.Core.Dfa.DfaBuilder.ExtendWithEos() -> void
Reko.Core.Dfa.DfaBuilder.ParseTree.get -> Reko.Core.Dfa.TreeNode
Reko.Core.Dfa.DfaBuilder.States.get -> Reko.Core.Dfa.State[]
Reko.Core.Dfa.DfaBuilder.States.set -> void
Reko.Core.Dfa.DfaBuilder.Transitions.get -> int[,]
Reko.Core.Dfa.DfaBuilder.Transitions.set -> void
Reko.Core.Dfa.NodeType
Reko.Core.Dfa.NodeType.Any = 8 -> Reko.Core.Dfa.NodeType
Reko.Core.Dfa.NodeType.Cat = 3 -> Reko.Core.Dfa.NodeType
Reko.Core.Dfa.NodeType.Char = 6 -> Reko.Core.Dfa.NodeType
Reko.Core.Dfa.NodeType.CharClass = 7 -> Reko.Core.Dfa.NodeType
Reko.Core.Dfa.NodeType.Cut = 1 -> Reko.Core.Dfa.NodeType
Reko.Core.Dfa.NodeType.EOS = -1 -> Reko.Core.Dfa.NodeType
Reko.Core.Dfa.NodeType.Epsilon = 9 -> Reko.Core.Dfa.NodeType
Reko.Core.Dfa.NodeType.Or = 2 -> Reko.Core.Dfa.NodeType
Reko.Core.Dfa.NodeType.Plus = 5 -> Reko.Core.Dfa.NodeType
Reko.Core.Dfa.NodeType.Star = 4 -> Reko.Core.Dfa.NodeType
Reko.Core.Dfa.PatternParser
Reko.Core.Dfa.PatternParser.Parse() -> Reko.Core.Dfa.TreeNode
Reko.Core.Dfa.PatternParser.PatternParser(string pattern) -> void
Reko.Core.Dfa.State
Reko.Core.Dfa.State.Accepts -> bool
Reko.Core.Dfa.State.Number -> int
Reko.Core.Dfa.State.Starts -> bool
Reko.Core.Dfa.State.State() -> void
Reko.Core.Dfa.TreeNode
Reko.Core.Dfa.TreeNode.FirstPos -> System.Collections.Generic.HashSet<Reko.Core.Dfa.TreeNode>
Reko.Core.Dfa.TreeNode.FollowPos -> System.Collections.Generic.HashSet<Reko.Core.Dfa.TreeNode>
Reko.Core.Dfa.TreeNode.GetTransitionCharacters() -> System.Collections.Generic.IEnumerable<byte>
Reko.Core.Dfa.TreeNode.LastPos -> System.Collections.Generic.HashSet<Reko.Core.Dfa.TreeNode>
Reko.Core.Dfa.TreeNode.Left -> Reko.Core.Dfa.TreeNode
Reko.Core.Dfa.TreeNode.Nullable -> bool
Reko.Core.Dfa.TreeNode.Number -> int
Reko.Core.Dfa.TreeNode.Right -> Reko.Core.Dfa.TreeNode
Reko.Core.Dfa.TreeNode.Starts -> bool
Reko.Core.Dfa.TreeNode.TreeNode() -> void
Reko.Core.Dfa.TreeNode.Type -> Reko.Core.Dfa.NodeType
Reko.Core.Dfa.TreeNode.Value -> byte
Reko.Core.Dfa.TreeNode.ValueClass -> System.Collections.BitArray
Reko.Core.Dfa.TreeNode.Write(System.IO.TextWriter writer) -> void
Reko.Core.Diagnostic
Reko.Core.Diagnostic.Diagnostic(string message) -> void
Reko.Core.Diagnostic.Message.get -> string
Reko.Core.Diagnostics.DebugEx
Reko.Core.DispatchProcedure
Reko.Core.DispatchProcedure.DispatchProcedure(string name, System.Collections.Generic.List<(Reko.Core.SyscallInfo, Reko.Core.ExternalProcedure)> services) -> void
Reko.Core.DispatchProcedure.FindService(Reko.Core.ProcessorState state) -> Reko.Core.ExternalProcedure
Reko.Core.DynamicLinker
Reko.Core.DynamicLinker.DynamicLinker(Reko.Core.Project project, Reko.Core.Program program, Reko.Core.Services.DecompilerEventListener eventListener) -> void
Reko.Core.DynamicLinker.ResolveImport(string moduleName, int ordinal, Reko.Core.IPlatform platform) -> Reko.Core.Expressions.Expression
Reko.Core.DynamicLinker.ResolveImport(string moduleName, string name, Reko.Core.IPlatform platform) -> Reko.Core.Expressions.Expression
Reko.Core.DynamicLinker.ResolveProcedure(string moduleName, int ordinal, Reko.Core.IPlatform platform) -> Reko.Core.ExternalProcedure
Reko.Core.DynamicLinker.ResolveProcedure(string moduleName, string importName, Reko.Core.IPlatform platform) -> Reko.Core.ExternalProcedure
Reko.Core.DynamicLinker.ResolveService(string moduleName, int ordinal) -> Reko.Core.SystemService
Reko.Core.DynamicLinker.ResolveToImportedValue(Reko.Core.Statement stm, Reko.Core.Expressions.Constant c) -> Reko.Core.Expressions.Expression
Reko.Core.Emulation.DefaultPlatformEmulator
Reko.Core.Emulation.DefaultPlatformEmulator.DefaultPlatformEmulator() -> void
Reko.Core.Emulation.DefaultPlatformEmulator.EmulateSystemCall(Reko.Core.Emulation.IProcessorEmulator emulator, params Reko.Core.Machine.MachineOperand[] operands) -> bool
Reko.Core.Emulation.DefaultPlatformEmulator.InitializeStack(Reko.Core.Emulation.IProcessorEmulator emulator, Reko.Core.ProcessorState state) -> Reko.Core.ImageSegment
Reko.Core.Emulation.DefaultPlatformEmulator.InterceptCall(Reko.Core.Emulation.IProcessorEmulator emulator, uint calledAddress) -> bool
Reko.Core.Emulation.DefaultPlatformEmulator.InterceptedCalls.get -> System.Collections.Generic.Dictionary<Reko.Core.Address, Reko.Core.ExternalProcedure>
Reko.Core.Emulation.DefaultPlatformEmulator.TearDownStack(Reko.Core.ImageSegment stackSeg) -> void
Reko.Core.Emulation.EmulatorBase
Reko.Core.Emulation.EmulatorBase.BeforeStart -> System.EventHandler?
Reko.Core.Emulation.EmulatorBase.DeleteBreakpoint(ulong address) -> void
Reko.Core.Emulation.EmulatorBase.EmulatorBase(Reko.Core.SegmentMap! map) -> void
Reko.Core.Emulation.EmulatorBase.ExceptionRaised -> System.EventHandler<Reko.Core.Emulation.EmulatorExceptionEventArgs!>?
Reko.Core.Emulation.EmulatorBase.IsRunning.get -> bool
Reko.Core.Emulation.EmulatorBase.ReadLeUInt16(ulong ea) -> ushort
Reko.Core.Emulation.EmulatorBase.ReadLeUInt32(ulong ea) -> uint
Reko.Core.Emulation.EmulatorBase.SetBreakpoint(ulong address, System.Action! callback) -> void
Reko.Core.Emulation.EmulatorBase.Start() -> void
Reko.Core.Emulation.EmulatorBase.StepInto(System.Action! callback) -> void
Reko.Core.Emulation.EmulatorBase.StepOver(System.Action! callback) -> void
Reko.Core.Emulation.EmulatorBase.Stop() -> void
Reko.Core.Emulation.EmulatorBase.TestForBreakpoint(ulong linAddrInstr) -> bool
Reko.Core.Emulation.EmulatorBase.TryReadByte(ulong ea, out byte b) -> bool
Reko.Core.Emulation.EmulatorBase.WriteByte(ulong ea, byte value) -> void
Reko.Core.Emulation.EmulatorBase.WriteLeUInt16(ulong ea, ushort value) -> void
Reko.Core.Emulation.EmulatorBase.WriteLeUInt32(ulong ea, uint value) -> void
Reko.Core.Emulation.EmulatorExceptionEventArgs
Reko.Core.Emulation.EmulatorExceptionEventArgs.EmulatorExceptionEventArgs(System.Exception ex) -> void
Reko.Core.Emulation.EmulatorExceptionEventArgs.Exception.get -> System.Exception
Reko.Core.Emulation.IPlatformEmulator
Reko.Core.Emulation.IPlatformEmulator.EmulateSystemCall(Reko.Core.Emulation.IProcessorEmulator emulator, params Reko.Core.Machine.MachineOperand[] operands) -> bool
Reko.Core.Emulation.IPlatformEmulator.InitializeStack(Reko.Core.Emulation.IProcessorEmulator emulator, Reko.Core.ProcessorState state) -> Reko.Core.ImageSegment
Reko.Core.Emulation.IPlatformEmulator.InterceptCall(Reko.Core.Emulation.IProcessorEmulator emulator, uint calledAddress) -> bool
Reko.Core.Emulation.IPlatformEmulator.InterceptedCalls.get -> System.Collections.Generic.Dictionary<Reko.Core.Address, Reko.Core.ExternalProcedure>
Reko.Core.Emulation.IPlatformEmulator.TearDownStack(Reko.Core.ImageSegment stackSeg) -> void
Reko.Core.Emulation.IProcessorEmulator
Reko.Core.Emulation.IProcessorEmulator.BeforeStart -> System.EventHandler
Reko.Core.Emulation.IProcessorEmulator.DeleteBreakpoint(ulong linearAddress) -> void
Reko.Core.Emulation.IProcessorEmulator.ExceptionRaised -> System.EventHandler<Reko.Core.Emulation.EmulatorExceptionEventArgs>
Reko.Core.Emulation.IProcessorEmulator.InstructionPointer.get -> Reko.Core.Address
Reko.Core.Emulation.IProcessorEmulator.InstructionPointer.set -> void
Reko.Core.Emulation.IProcessorEmulator.ReadRegister(Reko.Core.RegisterStorage reg) -> ulong
Reko.Core.Emulation.IProcessorEmulator.SetBreakpoint(ulong linearAddress, System.Action callback) -> void
Reko.Core.Emulation.IProcessorEmulator.Start() -> void
Reko.Core.Emulation.IProcessorEmulator.StepInto(System.Action callback) -> void
Reko.Core.Emulation.IProcessorEmulator.StepOver(System.Action callback) -> void
Reko.Core.Emulation.IProcessorEmulator.Stop() -> void
Reko.Core.Emulation.IProcessorEmulator.WriteRegister(Reko.Core.RegisterStorage reg, ulong value) -> ulong
Reko.Core.EndianServices
Reko.Core.EndianServices.EndianServices() -> void
Reko.Core.ErrorDiagnostic
Reko.Core.ErrorDiagnostic.ErrorDiagnostic(string message) -> void
Reko.Core.ErrorDiagnostic.ErrorDiagnostic(string message, System.Exception ex) -> void
Reko.Core.EvaluationContext
Reko.Core.EvaluationContext.Endianness.get -> Reko.Core.EndianServices
Reko.Core.EvaluationContext.GetDefiningExpression(Reko.Core.Expressions.Identifier id) -> Reko.Core.Expressions.Expression
Reko.Core.EvaluationContext.GetDefiningStatementClosure(Reko.Core.Expressions.Identifier id) -> System.Collections.Generic.List<Reko.Core.Statement>
Reko.Core.EvaluationContext.GetValue(Reko.Core.Expressions.Application appl) -> Reko.Core.Expressions.Expression
Reko.Core.EvaluationContext.GetValue(Reko.Core.Expressions.Identifier id) -> Reko.Core.Expressions.Expression
Reko.Core.EvaluationContext.GetValue(Reko.Core.Expressions.MemoryAccess access, Reko.Core.SegmentMap segmentMap) -> Reko.Core.Expressions.Expression
Reko.Core.EvaluationContext.GetValue(Reko.Core.Expressions.SegmentedAccess access, Reko.Core.SegmentMap segmentMap) -> Reko.Core.Expressions.Expression
Reko.Core.EvaluationContext.IsUsedInPhi(Reko.Core.Expressions.Identifier id) -> bool
Reko.Core.EvaluationContext.MakeSegmentedAddress(Reko.Core.Expressions.Constant c1, Reko.Core.Expressions.Constant c2) -> Reko.Core.Expressions.Expression
Reko.Core.EvaluationContext.MemoryGranularity.get -> int
Reko.Core.EvaluationContext.ReinterpretAsFloat(Reko.Core.Expressions.Constant rawBits) -> Reko.Core.Expressions.Constant
Reko.Core.EvaluationContext.RemoveExpressionUse(Reko.Core.Expressions.Expression expr) -> void
Reko.Core.EvaluationContext.RemoveIdentifierUse(Reko.Core.Expressions.Identifier id) -> void
Reko.Core.EvaluationContext.SetValue(Reko.Core.Expressions.Identifier id, Reko.Core.Expressions.Expression value) -> void
Reko.Core.EvaluationContext.SetValueEa(Reko.Core.Expressions.Expression basePointer, Reko.Core.Expressions.Expression ea, Reko.Core.Expressions.Expression value) -> void
Reko.Core.EvaluationContext.SetValueEa(Reko.Core.Expressions.Expression ea, Reko.Core.Expressions.Expression value) -> void
Reko.Core.EvaluationContext.UseExpression(Reko.Core.Expressions.Expression expr) -> void
Reko.Core.EventEx
Reko.Core.Expressions.Application
Reko.Core.Expressions.Application.Application(Reko.Core.Expressions.Expression proc, Reko.Core.Types.DataType retVal, params Reko.Core.Expressions.Expression[] arguments) -> void
Reko.Core.Expressions.Application.Arguments.get -> Reko.Core.Expressions.Expression[]
Reko.Core.Expressions.Application.Arguments.set -> void
Reko.Core.Expressions.Application.Procedure.get -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.Application.Procedure.set -> void
Reko.Core.Expressions.ArrayAccess
Reko.Core.Expressions.ArrayAccess.Array.get -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.ArrayAccess.ArrayAccess(Reko.Core.Types.DataType elementType, Reko.Core.Expressions.Expression array, Reko.Core.Expressions.Expression index) -> void
Reko.Core.Expressions.ArrayAccess.Index.get -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.BigConstant
Reko.Core.Expressions.BigConstant.BigConstant(Reko.Core.Types.DataType dt, System.Numerics.BigInteger value) -> void
Reko.Core.Expressions.BigConstant.Value.get -> System.Numerics.BigInteger
Reko.Core.Expressions.BinaryExpression
Reko.Core.Expressions.BinaryExpression.BinaryExpression(Reko.Core.Operators.Operator op, Reko.Core.Types.DataType dtResult, Reko.Core.Expressions.Expression left, Reko.Core.Expressions.Expression right) -> void
Reko.Core.Expressions.BinaryExpression.Commute() -> Reko.Core.Expressions.BinaryExpression
Reko.Core.Expressions.BinaryExpression.Commutes() -> bool
Reko.Core.Expressions.BinaryExpression.Left.get -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.BinaryExpression.Operator.get -> Reko.Core.Operators.Operator
Reko.Core.Expressions.BinaryExpression.Right.get -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.BinaryExpression.Right.set -> void
Reko.Core.Expressions.Cast
Reko.Core.Expressions.Cast.Cast(Reko.Core.Types.DataType dt, Reko.Core.Expressions.Expression expr) -> void
Reko.Core.Expressions.Cast.Expression.get -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.ConditionalExpression
Reko.Core.Expressions.ConditionalExpression.Condition.get -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.ConditionalExpression.ConditionalExpression(Reko.Core.Types.DataType dataType, Reko.Core.Expressions.Expression cond, Reko.Core.Expressions.Expression th, Reko.Core.Expressions.Expression fa) -> void
Reko.Core.Expressions.ConditionalExpression.FalseExp.get -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.ConditionalExpression.ThenExp.get -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.ConditionCode
Reko.Core.Expressions.ConditionCode.ALWAYS = 17 -> Reko.Core.Expressions.ConditionCode
Reko.Core.Expressions.ConditionCode.EQ = 14 -> Reko.Core.Expressions.ConditionCode
Reko.Core.Expressions.ConditionCode.GE = 5 -> Reko.Core.Expressions.ConditionCode
Reko.Core.Expressions.ConditionCode.GT = 4 -> Reko.Core.Expressions.ConditionCode
Reko.Core.Expressions.ConditionCode.IS_NAN = 19 -> Reko.Core.Expressions.ConditionCode
Reko.Core.Expressions.ConditionCode.LE = 7 -> Reko.Core.Expressions.ConditionCode
Reko.Core.Expressions.ConditionCode.LT = 6 -> Reko.Core.Expressions.ConditionCode
Reko.Core.Expressions.ConditionCode.NE = 11 -> Reko.Core.Expressions.ConditionCode
Reko.Core.Expressions.ConditionCode.NEVER = 18 -> Reko.Core.Expressions.ConditionCode
Reko.Core.Expressions.ConditionCode.NO = 9 -> Reko.Core.Expressions.ConditionCode
Reko.Core.Expressions.ConditionCode.None = 0 -> Reko.Core.Expressions.ConditionCode
Reko.Core.Expressions.ConditionCode.NOT_NAN = 20 -> Reko.Core.Expressions.ConditionCode
Reko.Core.Expressions.ConditionCode.NS = 10 -> Reko.Core.Expressions.ConditionCode
Reko.Core.Expressions.ConditionCode.OV = 12 -> Reko.Core.Expressions.ConditionCode
Reko.Core.Expressions.ConditionCode.PE = 15 -> Reko.Core.Expressions.ConditionCode
Reko.Core.Expressions.ConditionCode.PO = 16 -> Reko.Core.Expressions.ConditionCode
Reko.Core.Expressions.ConditionCode.SG = 13 -> Reko.Core.Expressions.ConditionCode
Reko.Core.Expressions.ConditionCode.UGE = 8 -> Reko.Core.Expressions.ConditionCode
Reko.Core.Expressions.ConditionCode.UGT = 1 -> Reko.Core.Expressions.ConditionCode
Reko.Core.Expressions.ConditionCode.ULE = 2 -> Reko.Core.Expressions.ConditionCode
Reko.Core.Expressions.ConditionCode.ULT = 3 -> Reko.Core.Expressions.ConditionCode
Reko.Core.Expressions.ConditionCodeEx
Reko.Core.Expressions.ConditionOf
Reko.Core.Expressions.ConditionOf.ConditionOf(Reko.Core.Expressions.Expression ex) -> void
Reko.Core.Expressions.ConditionOf.Expression.get -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.Constant
Reko.Core.Expressions.Constant.Constant(Reko.Core.Types.DataType! t) -> void
Reko.Core.Expressions.Constant.DepositBits(Reko.Core.Expressions.Constant newBits, int bitOffset) -> Reko.Core.Expressions.Constant
Reko.Core.Expressions.Constant.IsReal.get -> bool
Reko.Core.Expressions.Constant.ToDouble() -> double
Reko.Core.Expressions.ConstantReal
Reko.Core.Expressions.ConstantReal.ConstantReal(Reko.Core.Types.DataType dt) -> void
Reko.Core.Expressions.ConstantReal16
Reko.Core.Expressions.ConstantReal16.ConstantReal16(Reko.Core.Types.DataType dt, double value) -> void
Reko.Core.Expressions.ConstantReal16.ConstantReal16(Reko.Core.Types.DataType dt, Reko.Core.Lib.Float16 value) -> void
Reko.Core.Expressions.Conversion
Reko.Core.Expressions.Conversion.Conversion(Reko.Core.Expressions.Expression exp, Reko.Core.Types.DataType dtFrom, Reko.Core.Types.DataType dtTo) -> void
Reko.Core.Expressions.Conversion.Expression.get -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.Conversion.SourceDataType.get -> Reko.Core.Types.DataType
Reko.Core.Expressions.Dereference
Reko.Core.Expressions.Dereference.Dereference(Reko.Core.Types.DataType ptrType, Reko.Core.Expressions.Expression exp) -> void
Reko.Core.Expressions.Dereference.Expression.get -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.Expression
Reko.Core.Expressions.Expression.DataType.get -> Reko.Core.Types.DataType
Reko.Core.Expressions.Expression.DataType.set -> void
Reko.Core.Expressions.Expression.Expression(Reko.Core.Types.DataType dataType) -> void
Reko.Core.Expressions.Expression.TypeVariable.get -> Reko.Core.Types.TypeVariable
Reko.Core.Expressions.Expression.TypeVariable.set -> void
Reko.Core.Expressions.ExpressionEmitter
Reko.Core.Expressions.ExpressionEmitter.AddrOf(Reko.Core.Types.DataType ptType, Reko.Core.Expressions.Expression e) -> Reko.Core.Expressions.UnaryExpression
Reko.Core.Expressions.ExpressionEmitter.AddSubSignedInt(Reko.Core.Expressions.Expression e, long c) -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.ExpressionEmitter.And(Reko.Core.Expressions.Expression left, Reko.Core.Expressions.Expression right) -> Reko.Core.Expressions.BinaryExpression
Reko.Core.Expressions.ExpressionEmitter.And(Reko.Core.Expressions.Expression left, ulong right) -> Reko.Core.Expressions.BinaryExpression
Reko.Core.Expressions.ExpressionEmitter.ARef(Reko.Core.Types.DataType elementType, Reko.Core.Expressions.Expression array, Reko.Core.Expressions.Expression index) -> Reko.Core.Expressions.ArrayAccess
Reko.Core.Expressions.ExpressionEmitter.Array(Reko.Core.Types.DataType elemType, Reko.Core.Expressions.Expression arrayPtr, Reko.Core.Expressions.Expression index) -> Reko.Core.Expressions.ArrayAccess
Reko.Core.Expressions.ExpressionEmitter.Byte(byte b) -> Reko.Core.Expressions.Constant
Reko.Core.Expressions.ExpressionEmitter.Cand(Reko.Core.Expressions.Expression a, Reko.Core.Expressions.Expression b) -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.ExpressionEmitter.Comp(Reko.Core.Expressions.Expression expr) -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.ExpressionEmitter.Cond(Reko.Core.Expressions.Expression expr) -> Reko.Core.Expressions.ConditionOf
Reko.Core.Expressions.ExpressionEmitter.Conditional(Reko.Core.Types.DataType dt, Reko.Core.Expressions.Expression cond, Reko.Core.Expressions.Expression th, Reko.Core.Expressions.Expression el) -> Reko.Core.Expressions.ConditionalExpression
Reko.Core.Expressions.ExpressionEmitter.Convert(Reko.Core.Expressions.Expression expr, Reko.Core.Types.DataType dataTypeFrom, Reko.Core.Types.DataType dataTypeTo) -> Reko.Core.Expressions.Conversion
Reko.Core.Expressions.ExpressionEmitter.Cor(Reko.Core.Expressions.Expression a, Reko.Core.Expressions.Expression b) -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.ExpressionEmitter.Deref(Reko.Core.Expressions.Expression a) -> Reko.Core.Expressions.Dereference
Reko.Core.Expressions.ExpressionEmitter.Dpb(Reko.Core.Expressions.Expression dst, Reko.Core.Expressions.Expression src, int offset) -> Reko.Core.Expressions.MkSequence
Reko.Core.Expressions.ExpressionEmitter.Eq(Reko.Core.Expressions.Expression a, int b) -> Reko.Core.Expressions.BinaryExpression
Reko.Core.Expressions.ExpressionEmitter.Eq(Reko.Core.Expressions.Expression a, Reko.Core.Expressions.Expression b) -> Reko.Core.Expressions.BinaryExpression
Reko.Core.Expressions.ExpressionEmitter.Eq0(Reko.Core.Expressions.Expression exp) -> Reko.Core.Expressions.BinaryExpression
Reko.Core.Expressions.ExpressionEmitter.ExpressionEmitter() -> void
Reko.Core.Expressions.ExpressionEmitter.FAdd(Reko.Core.Expressions.Expression a, Reko.Core.Expressions.Expression b) -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.ExpressionEmitter.FDiv(Reko.Core.Expressions.Expression a, Reko.Core.Expressions.Expression b) -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.ExpressionEmitter.FEq(Reko.Core.Expressions.Expression a, Reko.Core.Expressions.Expression b) -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.ExpressionEmitter.FGe(Reko.Core.Expressions.Expression a, Reko.Core.Expressions.Expression b) -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.ExpressionEmitter.FGt(Reko.Core.Expressions.Expression a, Reko.Core.Expressions.Expression b) -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.ExpressionEmitter.Field(Reko.Core.Types.DataType dt, Reko.Core.Expressions.Expression e, Reko.Core.Types.Field field) -> Reko.Core.Expressions.FieldAccess
Reko.Core.Expressions.ExpressionEmitter.FLe(Reko.Core.Expressions.Expression a, Reko.Core.Expressions.Expression b) -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.ExpressionEmitter.FLt(Reko.Core.Expressions.Expression a, Reko.Core.Expressions.Expression b) -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.ExpressionEmitter.FMod(Reko.Core.Expressions.Expression a, Reko.Core.Expressions.Expression b) -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.ExpressionEmitter.FMul(Reko.Core.Expressions.Expression a, Reko.Core.Expressions.Expression b) -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.ExpressionEmitter.FMul(Reko.Core.Types.DataType dtProduct, Reko.Core.Expressions.Expression a, Reko.Core.Expressions.Expression b) -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.ExpressionEmitter.Fn(Reko.Core.Expressions.Expression fn, params Reko.Core.Expressions.Expression[] args) -> Reko.Core.Expressions.Application
Reko.Core.Expressions.ExpressionEmitter.Fn(Reko.Core.Expressions.Expression fn, Reko.Core.Types.DataType retType, params Reko.Core.Expressions.Expression[] exps) -> Reko.Core.Expressions.Application
Reko.Core.Expressions.ExpressionEmitter.Fn(Reko.Core.ExternalProcedure ep, params Reko.Core.Expressions.Expression[] args) -> Reko.Core.Expressions.Application
Reko.Core.Expressions.ExpressionEmitter.Fn(Reko.Core.IntrinsicProcedure intrinsic, params Reko.Core.Expressions.Expression[] args) -> Reko.Core.Expressions.Application
Reko.Core.Expressions.ExpressionEmitter.FNe(Reko.Core.Expressions.Expression a, Reko.Core.Expressions.Expression b) -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.ExpressionEmitter.FNeg(Reko.Core.Expressions.Expression a) -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.ExpressionEmitter.FSub(Reko.Core.Expressions.Expression a, Reko.Core.Expressions.Expression b) -> Reko.Core.Expressions.BinaryExpression
Reko.Core.Expressions.ExpressionEmitter.Ge(Reko.Core.Expressions.Expression a, int b) -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.ExpressionEmitter.Ge(Reko.Core.Expressions.Expression a, Reko.Core.Expressions.Expression b) -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.ExpressionEmitter.Ge0(Reko.Core.Expressions.Expression exp) -> Reko.Core.Expressions.BinaryExpression
Reko.Core.Expressions.ExpressionEmitter.Gt(Reko.Core.Expressions.Expression a, int b) -> Reko.Core.Expressions.BinaryExpression
Reko.Core.Expressions.ExpressionEmitter.Gt(Reko.Core.Expressions.Expression a, Reko.Core.Expressions.Expression b) -> Reko.Core.Expressions.BinaryExpression
Reko.Core.Expressions.ExpressionEmitter.Gt0(Reko.Core.Expressions.Expression exp) -> Reko.Core.Expressions.BinaryExpression
Reko.Core.Expressions.ExpressionEmitter.IAdd(Reko.Core.Expressions.Expression left, int right) -> Reko.Core.Expressions.BinaryExpression
Reko.Core.Expressions.ExpressionEmitter.IAdd(Reko.Core.Expressions.Expression left, Reko.Core.Expressions.Expression right) -> Reko.Core.Expressions.BinaryExpression
Reko.Core.Expressions.ExpressionEmitter.IAddC(Reko.Core.Expressions.Expression left, Reko.Core.Expressions.Expression right, Reko.Core.Expressions.Expression carry) -> Reko.Core.Expressions.BinaryExpression
Reko.Core.Expressions.ExpressionEmitter.IAddS(Reko.Core.Expressions.Expression left, long right) -> Reko.Core.Expressions.BinaryExpression
Reko.Core.Expressions.ExpressionEmitter.IMul(Reko.Core.Expressions.Expression left, int c) -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.ExpressionEmitter.IMul(Reko.Core.Expressions.Expression left, Reko.Core.Expressions.Expression right) -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.ExpressionEmitter.Int16(short n) -> Reko.Core.Expressions.Constant
Reko.Core.Expressions.ExpressionEmitter.Int16(uint n) -> Reko.Core.Expressions.Constant
Reko.Core.Expressions.ExpressionEmitter.Int32(int n) -> Reko.Core.Expressions.Constant
Reko.Core.Expressions.ExpressionEmitter.Int32(uint n) -> Reko.Core.Expressions.Constant
Reko.Core.Expressions.ExpressionEmitter.Int8(int n) -> Reko.Core.Expressions.Constant
Reko.Core.Expressions.ExpressionEmitter.ISub(Reko.Core.Expressions.Expression left, int right) -> Reko.Core.Expressions.BinaryExpression
Reko.Core.Expressions.ExpressionEmitter.ISub(Reko.Core.Expressions.Expression! left, Reko.Core.Expressions.Expression! right) -> Reko.Core.Expressions.BinaryExpression!
Reko.Core.Expressions.ExpressionEmitter.ISubB(Reko.Core.Expressions.Expression! left, Reko.Core.Expressions.Expression! right, Reko.Core.Expressions.Expression! borrow) -> Reko.Core.Expressions.BinaryExpression!
Reko.Core.Expressions.ExpressionEmitter.ISubS(Reko.Core.Expressions.Expression left, long right) -> Reko.Core.Expressions.BinaryExpression
Reko.Core.Expressions.ExpressionEmitter.Le(Reko.Core.Expressions.Expression a, int b) -> Reko.Core.Expressions.BinaryExpression
Reko.Core.Expressions.ExpressionEmitter.Le(Reko.Core.Expressions.Expression a, Reko.Core.Expressions.Expression b) -> Reko.Core.Expressions.BinaryExpression
Reko.Core.Expressions.ExpressionEmitter.Le0(Reko.Core.Expressions.Expression exp) -> Reko.Core.Expressions.BinaryExpression
Reko.Core.Expressions.ExpressionEmitter.Lt(Reko.Core.Expressions.Expression a, int b) -> Reko.Core.Expressions.BinaryExpression
Reko.Core.Expressions.ExpressionEmitter.Lt(Reko.Core.Expressions.Expression a, Reko.Core.Expressions.Expression b) -> Reko.Core.Expressions.BinaryExpression
Reko.Core.Expressions.ExpressionEmitter.Lt0(Reko.Core.Expressions.Expression exp) -> Reko.Core.Expressions.BinaryExpression
Reko.Core.Expressions.ExpressionEmitter.Mem(Reko.Core.Types.DataType dt, Reko.Core.Expressions.Expression ea) -> Reko.Core.Expressions.MemoryAccess
Reko.Core.Expressions.ExpressionEmitter.MembPtr8(Reko.Core.Expressions.Expression ptr, Reko.Core.Expressions.Expression membPtr) -> Reko.Core.Expressions.MemberPointerSelector
Reko.Core.Expressions.ExpressionEmitter.MembPtrW(Reko.Core.Expressions.Expression ptr, Reko.Core.Expressions.Expression membPtr) -> Reko.Core.Expressions.MemberPointerSelector
Reko.Core.Expressions.ExpressionEmitter.Mod(Reko.Core.Expressions.Expression opLeft, Reko.Core.Expressions.Expression opRight) -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.ExpressionEmitter.Mod(Reko.Core.Types.DataType dt, Reko.Core.Expressions.Expression opLeft, Reko.Core.Expressions.Expression opRight) -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.ExpressionEmitter.Ne(Reko.Core.Expressions.Expression a, int n) -> Reko.Core.Expressions.BinaryExpression
Reko.Core.Expressions.ExpressionEmitter.Ne(Reko.Core.Expressions.Expression a, Reko.Core.Expressions.Expression b) -> Reko.Core.Expressions.BinaryExpression
Reko.Core.Expressions.ExpressionEmitter.Ne0(Reko.Core.Expressions.Expression expr) -> Reko.Core.Expressions.BinaryExpression
Reko.Core.Expressions.ExpressionEmitter.Neg(Reko.Core.Expressions.Expression expr) -> Reko.Core.Expressions.UnaryExpression
Reko.Core.Expressions.ExpressionEmitter.Not(Reko.Core.Expressions.Expression exp) -> Reko.Core.Expressions.UnaryExpression
Reko.Core.Expressions.ExpressionEmitter.Or(Reko.Core.Expressions.Expression a, int b) -> Reko.Core.Expressions.BinaryExpression
Reko.Core.Expressions.ExpressionEmitter.Or(Reko.Core.Expressions.Expression a, Reko.Core.Expressions.Expression b) -> Reko.Core.Expressions.BinaryExpression
Reko.Core.Expressions.ExpressionEmitter.Out(Reko.Core.Types.DataType dt, Reko.Core.Expressions.Expression expr) -> Reko.Core.Expressions.OutArgument
Reko.Core.Expressions.ExpressionEmitter.Ptr16(ushort ptr) -> Reko.Core.Address
Reko.Core.Expressions.ExpressionEmitter.Ptr32(uint ptr) -> Reko.Core.Address
Reko.Core.Expressions.ExpressionEmitter.Ptr64(ulong ptr) -> Reko.Core.Address
Reko.Core.Expressions.ExpressionEmitter.Sar(Reko.Core.Expressions.Expression e, byte sh) -> Reko.Core.Expressions.BinaryExpression
Reko.Core.Expressions.ExpressionEmitter.Sar(Reko.Core.Expressions.Expression e, int sh) -> Reko.Core.Expressions.BinaryExpression
Reko.Core.Expressions.ExpressionEmitter.Sar(Reko.Core.Expressions.Expression e, Reko.Core.Expressions.Expression sh) -> Reko.Core.Expressions.BinaryExpression
Reko.Core.Expressions.ExpressionEmitter.SDiv(Reko.Core.Expressions.Expression a, Reko.Core.Expressions.Expression b) -> Reko.Core.Expressions.BinaryExpression
Reko.Core.Expressions.ExpressionEmitter.SDiv(Reko.Core.Types.DataType dt, Reko.Core.Expressions.Expression a, Reko.Core.Expressions.Expression b) -> Reko.Core.Expressions.BinaryExpression
Reko.Core.Expressions.ExpressionEmitter.SegMem16(Reko.Core.Expressions.Expression basePtr, Reko.Core.Expressions.Expression ptr) -> Reko.Core.Expressions.SegmentedAccess
Reko.Core.Expressions.ExpressionEmitter.SegMem8(Reko.Core.Expressions.Expression basePtr, Reko.Core.Expressions.Expression ptr) -> Reko.Core.Expressions.SegmentedAccess
Reko.Core.Expressions.ExpressionEmitter.Seq(params Reko.Core.Expressions.Expression[] exprs) -> Reko.Core.Expressions.MkSequence
Reko.Core.Expressions.ExpressionEmitter.Seq(Reko.Core.Expressions.Expression head, Reko.Core.Expressions.Expression tail) -> Reko.Core.Expressions.MkSequence
Reko.Core.Expressions.ExpressionEmitter.Seq(Reko.Core.Types.DataType dtSeq, params Reko.Core.Expressions.Expression[] exprs) -> Reko.Core.Expressions.MkSequence
Reko.Core.Expressions.ExpressionEmitter.Shl(int c, Reko.Core.Expressions.Expression sh) -> Reko.Core.Expressions.BinaryExpression
Reko.Core.Expressions.ExpressionEmitter.Shl(Reko.Core.Expressions.Expression e, int sh) -> Reko.Core.Expressions.BinaryExpression
Reko.Core.Expressions.ExpressionEmitter.Shl(Reko.Core.Expressions.Expression e, Reko.Core.Expressions.Expression sh) -> Reko.Core.Expressions.BinaryExpression
Reko.Core.Expressions.ExpressionEmitter.Shr(Reko.Core.Expressions.Expression! e, int sh) -> Reko.Core.Expressions.BinaryExpression!
Reko.Core.Expressions.ExpressionEmitter.Shr(Reko.Core.Expressions.Expression exp, byte c) -> Reko.Core.Expressions.BinaryExpression
Reko.Core.Expressions.ExpressionEmitter.Shr(Reko.Core.Expressions.Expression exp, Reko.Core.Expressions.Expression sh) -> Reko.Core.Expressions.BinaryExpression
Reko.Core.Expressions.ExpressionEmitter.Slice(Reko.Core.Expressions.Expression value, int bitOffset, int bitlength) -> Reko.Core.Expressions.Slice
Reko.Core.Expressions.ExpressionEmitter.Slice(Reko.Core.Expressions.Expression value, Reko.Core.Types.DataType dataType, int bitOffset = 0) -> Reko.Core.Expressions.Slice
Reko.Core.Expressions.ExpressionEmitter.Slice(Reko.Core.Types.DataType dataType, Reko.Core.Expressions.Expression value, int bitOffset = 0) -> Reko.Core.Expressions.Slice
Reko.Core.Expressions.ExpressionEmitter.SMod(Reko.Core.Expressions.Expression opLeft, Reko.Core.Expressions.Expression opRight) -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.ExpressionEmitter.SMod(Reko.Core.Types.DataType dt, Reko.Core.Expressions.Expression opLeft, Reko.Core.Expressions.Expression opRight) -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.ExpressionEmitter.SMul(Reko.Core.Expressions.Expression left, int c) -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.ExpressionEmitter.SMul(Reko.Core.Expressions.Expression left, Reko.Core.Expressions.Expression right) -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.ExpressionEmitter.SMul(Reko.Core.Types.PrimitiveType dtProduct, Reko.Core.Expressions.Expression left, Reko.Core.Expressions.Expression right) -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.ExpressionEmitter.Test(Reko.Core.Expressions.ConditionCode cc, Reko.Core.Expressions.Expression expr) -> Reko.Core.Expressions.TestCondition
Reko.Core.Expressions.ExpressionEmitter.UDiv(Reko.Core.Expressions.Expression a, Reko.Core.Expressions.Expression b) -> Reko.Core.Expressions.BinaryExpression
Reko.Core.Expressions.ExpressionEmitter.UDiv(Reko.Core.Types.DataType dt, Reko.Core.Expressions.Expression a, Reko.Core.Expressions.Expression b) -> Reko.Core.Expressions.BinaryExpression
Reko.Core.Expressions.ExpressionEmitter.Uge(Reko.Core.Expressions.Expression a, int n) -> Reko.Core.Expressions.BinaryExpression
Reko.Core.Expressions.ExpressionEmitter.Uge(Reko.Core.Expressions.Expression a, Reko.Core.Expressions.Expression b) -> Reko.Core.Expressions.BinaryExpression
Reko.Core.Expressions.ExpressionEmitter.Ugt(Reko.Core.Expressions.Expression a, Reko.Core.Expressions.Expression b) -> Reko.Core.Expressions.BinaryExpression
Reko.Core.Expressions.ExpressionEmitter.Ule(Reko.Core.Expressions.Expression a, Reko.Core.Expressions.Expression b) -> Reko.Core.Expressions.BinaryExpression
Reko.Core.Expressions.ExpressionEmitter.Ult(Reko.Core.Expressions.Expression a, int b) -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.ExpressionEmitter.Ult(Reko.Core.Expressions.Expression a, Reko.Core.Expressions.Expression b) -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.ExpressionEmitter.UMod(Reko.Core.Expressions.Expression opLeft, Reko.Core.Expressions.Expression opRight) -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.ExpressionEmitter.UMod(Reko.Core.Types.DataType dt, Reko.Core.Expressions.Expression opLeft, Reko.Core.Expressions.Expression opRight) -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.ExpressionEmitter.UMul(Reko.Core.Expressions.Expression left, int c) -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.ExpressionEmitter.UMul(Reko.Core.Expressions.Expression left, Reko.Core.Expressions.Expression right) -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.ExpressionEmitter.UMul(Reko.Core.Types.PrimitiveType dtProduct, Reko.Core.Expressions.Expression left, Reko.Core.Expressions.Expression right) -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.ExpressionEmitter.USub(Reko.Core.Expressions.Expression left, Reko.Core.Expressions.Expression right) -> Reko.Core.Expressions.BinaryExpression
Reko.Core.Expressions.ExpressionEmitter.Word(int bitSize, long n) -> Reko.Core.Expressions.Constant
Reko.Core.Expressions.ExpressionEmitter.Word16(uint n) -> Reko.Core.Expressions.Constant
Reko.Core.Expressions.ExpressionEmitter.Word16(ushort n) -> Reko.Core.Expressions.Constant
Reko.Core.Expressions.ExpressionEmitter.Word32(int n) -> Reko.Core.Expressions.Constant
Reko.Core.Expressions.ExpressionEmitter.Word32(uint n) -> Reko.Core.Expressions.Constant
Reko.Core.Expressions.ExpressionEmitter.Word64(ulong n) -> Reko.Core.Expressions.Constant
Reko.Core.Expressions.ExpressionEmitter.Xor(Reko.Core.Expressions.Expression a, int b) -> Reko.Core.Expressions.BinaryExpression
Reko.Core.Expressions.ExpressionEmitter.Xor(Reko.Core.Expressions.Expression a, Reko.Core.Expressions.Expression b) -> Reko.Core.Expressions.BinaryExpression
Reko.Core.Expressions.ExpressionMatcher
Reko.Core.Expressions.ExpressionMatcher.CapturedExpression(string label) -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.ExpressionMatcher.CapturedOperators(string label) -> Reko.Core.Operators.Operator
Reko.Core.Expressions.ExpressionMatcher.Clear() -> void
Reko.Core.Expressions.ExpressionMatcher.ExpressionMatcher(Reko.Core.Expressions.Expression pattern) -> void
Reko.Core.Expressions.ExpressionMatcher.Match(Reko.Core.Expressions.Expression expr) -> bool
Reko.Core.Expressions.ExpressionMatcher.Pattern.get -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.ExpressionMatcher.Pattern.set -> void
Reko.Core.Expressions.ExpressionReplacer
Reko.Core.Expressions.ExpressionReplacer.VisitAddress(Reko.Core.Address addr) -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.ExpressionReplacer.VisitApplication(Reko.Core.Expressions.Application appl) -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.ExpressionReplacer.VisitArrayAccess(Reko.Core.Expressions.ArrayAccess acc) -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.ExpressionReplacer.VisitBinaryExpression(Reko.Core.Expressions.BinaryExpression binExp) -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.ExpressionReplacer.VisitCast(Reko.Core.Expressions.Cast cast) -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.ExpressionReplacer.VisitConditionalExpression(Reko.Core.Expressions.ConditionalExpression cond) -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.ExpressionReplacer.VisitConditionOf(Reko.Core.Expressions.ConditionOf cof) -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.ExpressionReplacer.VisitConstant(Reko.Core.Expressions.Constant c) -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.ExpressionReplacer.VisitConversion(Reko.Core.Expressions.Conversion conversion) -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.ExpressionReplacer.VisitDereference(Reko.Core.Expressions.Dereference deref) -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.ExpressionReplacer.VisitFieldAccess(Reko.Core.Expressions.FieldAccess acc) -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.ExpressionReplacer.VisitIdentifier(Reko.Core.Expressions.Identifier id) -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.ExpressionReplacer.VisitMemberPointerSelector(Reko.Core.Expressions.MemberPointerSelector mps) -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.ExpressionReplacer.VisitMemoryAccess(Reko.Core.Expressions.MemoryAccess access) -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.ExpressionReplacer.VisitMkSequence(Reko.Core.Expressions.MkSequence seq) -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.ExpressionReplacer.VisitOutArgument(Reko.Core.Expressions.OutArgument outArgument) -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.ExpressionReplacer.VisitPhiFunction(Reko.Core.Expressions.PhiFunction phi) -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.ExpressionReplacer.VisitPointerAddition(Reko.Core.Expressions.PointerAddition pa) -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.ExpressionReplacer.VisitProcedureConstant(Reko.Core.Expressions.ProcedureConstant pc) -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.ExpressionReplacer.VisitScopeResolution(Reko.Core.Expressions.ScopeResolution scopeResolution) -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.ExpressionReplacer.VisitSegmentedAccess(Reko.Core.Expressions.SegmentedAccess access) -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.ExpressionReplacer.VisitSlice(Reko.Core.Expressions.Slice slice) -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.ExpressionReplacer.VisitTestCondition(Reko.Core.Expressions.TestCondition tc) -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.ExpressionReplacer.VisitUnaryExpression(Reko.Core.Expressions.UnaryExpression unary) -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.ExpressionTree
Reko.Core.Expressions.ExpressionTree.AddEdge(Reko.Core.Expressions.Expression nodeFrom, Reko.Core.Expressions.Expression nodeTo) -> void
Reko.Core.Expressions.ExpressionTree.ContainsEdge(Reko.Core.Expressions.Expression nodeFrom, Reko.Core.Expressions.Expression nodeTo) -> bool
Reko.Core.Expressions.ExpressionTree.ExpressionTree() -> void
Reko.Core.Expressions.ExpressionTree.Nodes.get -> System.Collections.Generic.ICollection<Reko.Core.Expressions.Expression>
Reko.Core.Expressions.ExpressionTree.Predecessors(Reko.Core.Expressions.Expression node) -> System.Collections.Generic.ICollection<Reko.Core.Expressions.Expression>
Reko.Core.Expressions.ExpressionTree.RemoveEdge(Reko.Core.Expressions.Expression nodeFrom, Reko.Core.Expressions.Expression nodeTo) -> void
Reko.Core.Expressions.ExpressionTree.Successors(Reko.Core.Expressions.Expression node) -> System.Collections.Generic.ICollection<Reko.Core.Expressions.Expression>
Reko.Core.Expressions.ExpressionTypeAscenderBase
Reko.Core.Expressions.ExpressionTypeAscenderBase.ExpressionTypeAscenderBase(Reko.Core.Program program, Reko.Core.Types.TypeFactory factory) -> void
Reko.Core.Expressions.ExpressionTypeAscenderBase.VisitAddress(Reko.Core.Address addr) -> Reko.Core.Types.DataType
Reko.Core.Expressions.ExpressionTypeAscenderBase.VisitApplication(Reko.Core.Expressions.Application appl) -> Reko.Core.Types.DataType
Reko.Core.Expressions.ExpressionTypeAscenderBase.VisitArrayAccess(Reko.Core.Expressions.ArrayAccess acc) -> Reko.Core.Types.DataType
Reko.Core.Expressions.ExpressionTypeAscenderBase.VisitBinaryExpression(Reko.Core.Expressions.BinaryExpression binExp) -> Reko.Core.Types.DataType
Reko.Core.Expressions.ExpressionTypeAscenderBase.VisitCast(Reko.Core.Expressions.Cast cast) -> Reko.Core.Types.DataType
Reko.Core.Expressions.ExpressionTypeAscenderBase.VisitConditionalExpression(Reko.Core.Expressions.ConditionalExpression cond) -> Reko.Core.Types.DataType
Reko.Core.Expressions.ExpressionTypeAscenderBase.VisitConditionOf(Reko.Core.Expressions.ConditionOf cof) -> Reko.Core.Types.DataType
Reko.Core.Expressions.ExpressionTypeAscenderBase.VisitConstant(Reko.Core.Expressions.Constant c) -> Reko.Core.Types.DataType
Reko.Core.Expressions.ExpressionTypeAscenderBase.VisitConversion(Reko.Core.Expressions.Conversion conversion) -> Reko.Core.Types.DataType
Reko.Core.Expressions.ExpressionTypeAscenderBase.VisitDereference(Reko.Core.Expressions.Dereference deref) -> Reko.Core.Types.DataType
Reko.Core.Expressions.ExpressionTypeAscenderBase.VisitFieldAccess(Reko.Core.Expressions.FieldAccess acc) -> Reko.Core.Types.DataType
Reko.Core.Expressions.ExpressionTypeAscenderBase.VisitIdentifier(Reko.Core.Expressions.Identifier id) -> Reko.Core.Types.DataType
Reko.Core.Expressions.ExpressionTypeAscenderBase.VisitMemberPointerSelector(Reko.Core.Expressions.MemberPointerSelector mps) -> Reko.Core.Types.DataType
Reko.Core.Expressions.ExpressionTypeAscenderBase.VisitMemoryAccess(Reko.Core.Expressions.MemoryAccess access) -> Reko.Core.Types.DataType
Reko.Core.Expressions.ExpressionTypeAscenderBase.VisitMemoryAccessCommon(Reko.Core.Expressions.Expression access, Reko.Core.Expressions.Expression ea) -> Reko.Core.Types.DataType
Reko.Core.Expressions.ExpressionTypeAscenderBase.VisitMkSequence(Reko.Core.Expressions.MkSequence seq) -> Reko.Core.Types.DataType
Reko.Core.Expressions.ExpressionTypeAscenderBase.VisitOutArgument(Reko.Core.Expressions.OutArgument outArgument) -> Reko.Core.Types.DataType
Reko.Core.Expressions.ExpressionTypeAscenderBase.VisitPhiFunction(Reko.Core.Expressions.PhiFunction phi) -> Reko.Core.Types.DataType
Reko.Core.Expressions.ExpressionTypeAscenderBase.VisitPointerAddition(Reko.Core.Expressions.PointerAddition pa) -> Reko.Core.Types.DataType
Reko.Core.Expressions.ExpressionTypeAscenderBase.VisitProcedureConstant(Reko.Core.Expressions.ProcedureConstant pc) -> Reko.Core.Types.DataType
Reko.Core.Expressions.ExpressionTypeAscenderBase.VisitScopeResolution(Reko.Core.Expressions.ScopeResolution scopeResolution) -> Reko.Core.Types.DataType
Reko.Core.Expressions.ExpressionTypeAscenderBase.VisitSegmentedAccess(Reko.Core.Expressions.SegmentedAccess access) -> Reko.Core.Types.DataType
Reko.Core.Expressions.ExpressionTypeAscenderBase.VisitSlice(Reko.Core.Expressions.Slice slice) -> Reko.Core.Types.DataType
Reko.Core.Expressions.ExpressionTypeAscenderBase.VisitTestCondition(Reko.Core.Expressions.TestCondition tc) -> Reko.Core.Types.DataType
Reko.Core.Expressions.ExpressionTypeAscenderBase.VisitUnaryExpression(Reko.Core.Expressions.UnaryExpression unary) -> Reko.Core.Types.DataType
Reko.Core.Expressions.ExpressionValueComparer
Reko.Core.Expressions.ExpressionValueComparer.Equals(Reko.Core.Expressions.Expression? x, Reko.Core.Expressions.Expression? y) -> bool
Reko.Core.Expressions.ExpressionValueComparer.ExpressionValueComparer() -> void
Reko.Core.Expressions.ExpressionValueComparer.GetHashCode(Reko.Core.Expressions.Expression obj) -> int
Reko.Core.Expressions.ExpressionVisitor<T, C>
Reko.Core.Expressions.ExpressionVisitor<T, C>.VisitAddress(Reko.Core.Address addr, C ctx) -> T
Reko.Core.Expressions.ExpressionVisitor<T, C>.VisitApplication(Reko.Core.Expressions.Application appl, C ctx) -> T
Reko.Core.Expressions.ExpressionVisitor<T, C>.VisitArrayAccess(Reko.Core.Expressions.ArrayAccess acc, C ctx) -> T
Reko.Core.Expressions.ExpressionVisitor<T, C>.VisitBinaryExpression(Reko.Core.Expressions.BinaryExpression binExp, C ctx) -> T
Reko.Core.Expressions.ExpressionVisitor<T, C>.VisitCast(Reko.Core.Expressions.Cast cast, C ctx) -> T
Reko.Core.Expressions.ExpressionVisitor<T, C>.VisitConditionalExpression(Reko.Core.Expressions.ConditionalExpression c, C context) -> T
Reko.Core.Expressions.ExpressionVisitor<T, C>.VisitConditionOf(Reko.Core.Expressions.ConditionOf cof, C ctx) -> T
Reko.Core.Expressions.ExpressionVisitor<T, C>.VisitConstant(Reko.Core.Expressions.Constant c, C ctx) -> T
Reko.Core.Expressions.ExpressionVisitor<T, C>.VisitConversion(Reko.Core.Expressions.Conversion conversion, C context) -> T
Reko.Core.Expressions.ExpressionVisitor<T, C>.VisitDereference(Reko.Core.Expressions.Dereference deref, C ctx) -> T
Reko.Core.Expressions.ExpressionVisitor<T, C>.VisitFieldAccess(Reko.Core.Expressions.FieldAccess acc, C ctx) -> T
Reko.Core.Expressions.ExpressionVisitor<T, C>.VisitIdentifier(Reko.Core.Expressions.Identifier id, C ctx) -> T
Reko.Core.Expressions.ExpressionVisitor<T, C>.VisitMemberPointerSelector(Reko.Core.Expressions.MemberPointerSelector mps, C ctx) -> T
Reko.Core.Expressions.ExpressionVisitor<T, C>.VisitMemoryAccess(Reko.Core.Expressions.MemoryAccess access, C ctx) -> T
Reko.Core.Expressions.ExpressionVisitor<T, C>.VisitMkSequence(Reko.Core.Expressions.MkSequence seq, C ctx) -> T
Reko.Core.Expressions.ExpressionVisitor<T, C>.VisitOutArgument(Reko.Core.Expressions.OutArgument outArgument, C ctx) -> T
Reko.Core.Expressions.ExpressionVisitor<T, C>.VisitPhiFunction(Reko.Core.Expressions.PhiFunction phi, C ctx) -> T
Reko.Core.Expressions.ExpressionVisitor<T, C>.VisitPointerAddition(Reko.Core.Expressions.PointerAddition pa, C ctx) -> T
Reko.Core.Expressions.ExpressionVisitor<T, C>.VisitProcedureConstant(Reko.Core.Expressions.ProcedureConstant pc, C ctx) -> T
Reko.Core.Expressions.ExpressionVisitor<T, C>.VisitScopeResolution(Reko.Core.Expressions.ScopeResolution scopeResolution, C ctx) -> T
Reko.Core.Expressions.ExpressionVisitor<T, C>.VisitSegmentedAccess(Reko.Core.Expressions.SegmentedAccess access, C ctx) -> T
Reko.Core.Expressions.ExpressionVisitor<T, C>.VisitSlice(Reko.Core.Expressions.Slice slice, C ctx) -> T
Reko.Core.Expressions.ExpressionVisitor<T, C>.VisitTestCondition(Reko.Core.Expressions.TestCondition tc, C ctx) -> T
Reko.Core.Expressions.ExpressionVisitor<T, C>.VisitUnaryExpression(Reko.Core.Expressions.UnaryExpression unary, C ctx) -> T
Reko.Core.Expressions.ExpressionVisitor<T>
Reko.Core.Expressions.ExpressionVisitor<T>.VisitAddress(Reko.Core.Address addr) -> T
Reko.Core.Expressions.ExpressionVisitor<T>.VisitApplication(Reko.Core.Expressions.Application appl) -> T
Reko.Core.Expressions.ExpressionVisitor<T>.VisitArrayAccess(Reko.Core.Expressions.ArrayAccess acc) -> T
Reko.Core.Expressions.ExpressionVisitor<T>.VisitBinaryExpression(Reko.Core.Expressions.BinaryExpression binExp) -> T
Reko.Core.Expressions.ExpressionVisitor<T>.VisitCast(Reko.Core.Expressions.Cast cast) -> T
Reko.Core.Expressions.ExpressionVisitor<T>.VisitConditionalExpression(Reko.Core.Expressions.ConditionalExpression cond) -> T
Reko.Core.Expressions.ExpressionVisitor<T>.VisitConditionOf(Reko.Core.Expressions.ConditionOf cof) -> T
Reko.Core.Expressions.ExpressionVisitor<T>.VisitConstant(Reko.Core.Expressions.Constant c) -> T
Reko.Core.Expressions.ExpressionVisitor<T>.VisitConversion(Reko.Core.Expressions.Conversion conversion) -> T
Reko.Core.Expressions.ExpressionVisitor<T>.VisitDereference(Reko.Core.Expressions.Dereference deref) -> T
Reko.Core.Expressions.ExpressionVisitor<T>.VisitFieldAccess(Reko.Core.Expressions.FieldAccess acc) -> T
Reko.Core.Expressions.ExpressionVisitor<T>.VisitIdentifier(Reko.Core.Expressions.Identifier id) -> T
Reko.Core.Expressions.ExpressionVisitor<T>.VisitMemberPointerSelector(Reko.Core.Expressions.MemberPointerSelector mps) -> T
Reko.Core.Expressions.ExpressionVisitor<T>.VisitMemoryAccess(Reko.Core.Expressions.MemoryAccess access) -> T
Reko.Core.Expressions.ExpressionVisitor<T>.VisitMkSequence(Reko.Core.Expressions.MkSequence seq) -> T
Reko.Core.Expressions.ExpressionVisitor<T>.VisitOutArgument(Reko.Core.Expressions.OutArgument outArgument) -> T
Reko.Core.Expressions.ExpressionVisitor<T>.VisitPhiFunction(Reko.Core.Expressions.PhiFunction phi) -> T
Reko.Core.Expressions.ExpressionVisitor<T>.VisitPointerAddition(Reko.Core.Expressions.PointerAddition pa) -> T
Reko.Core.Expressions.ExpressionVisitor<T>.VisitProcedureConstant(Reko.Core.Expressions.ProcedureConstant pc) -> T
Reko.Core.Expressions.ExpressionVisitor<T>.VisitScopeResolution(Reko.Core.Expressions.ScopeResolution scopeResolution) -> T
Reko.Core.Expressions.ExpressionVisitor<T>.VisitSegmentedAccess(Reko.Core.Expressions.SegmentedAccess access) -> T
Reko.Core.Expressions.ExpressionVisitor<T>.VisitSlice(Reko.Core.Expressions.Slice slice) -> T
Reko.Core.Expressions.ExpressionVisitor<T>.VisitTestCondition(Reko.Core.Expressions.TestCondition tc) -> T
Reko.Core.Expressions.ExpressionVisitor<T>.VisitUnaryExpression(Reko.Core.Expressions.UnaryExpression unary) -> T
Reko.Core.Expressions.ExpressionVisitorBase
Reko.Core.Expressions.ExpressionVisitorBase.ExpressionVisitorBase() -> void
Reko.Core.Expressions.ExpressionVisitorBase.VisitArrayAccess(Reko.Core.Expressions.ArrayAccess acc) -> void
Reko.Core.Expressions.ExpressionVisitorBase.VisitBinaryExpression(Reko.Core.Expressions.BinaryExpression binExp) -> void
Reko.Core.Expressions.ExpressionVisitorBase.VisitCast(Reko.Core.Expressions.Cast cast) -> void
Reko.Core.Expressions.ExpressionVisitorBase.VisitConditionalExpression(Reko.Core.Expressions.ConditionalExpression cond) -> void
Reko.Core.Expressions.ExpressionVisitorBase.VisitConditionOf(Reko.Core.Expressions.ConditionOf cof) -> void
Reko.Core.Expressions.ExpressionVisitorBase.VisitConstant(Reko.Core.Expressions.Constant c) -> void
Reko.Core.Expressions.ExpressionVisitorBase.VisitDereference(Reko.Core.Expressions.Dereference deref) -> void
Reko.Core.Expressions.ExpressionVisitorBase.VisitFieldAccess(Reko.Core.Expressions.FieldAccess acc) -> void
Reko.Core.Expressions.ExpressionVisitorBase.VisitMemberPointerSelector(Reko.Core.Expressions.MemberPointerSelector mps) -> void
Reko.Core.Expressions.ExpressionVisitorBase.VisitMemoryAccess(Reko.Core.Expressions.MemoryAccess access) -> void
Reko.Core.Expressions.ExpressionVisitorBase.VisitMkSequence(Reko.Core.Expressions.MkSequence seq) -> void
Reko.Core.Expressions.ExpressionVisitorBase.VisitPhiFunction(Reko.Core.Expressions.PhiFunction phi) -> void
Reko.Core.Expressions.ExpressionVisitorBase.VisitPointerAddition(Reko.Core.Expressions.PointerAddition pa) -> void
Reko.Core.Expressions.ExpressionVisitorBase.VisitProcedureConstant(Reko.Core.Expressions.ProcedureConstant pc) -> void
Reko.Core.Expressions.ExpressionVisitorBase.VisitScopeResolution(Reko.Core.Expressions.ScopeResolution scope) -> void
Reko.Core.Expressions.ExpressionVisitorBase.VisitSegmentedAccess(Reko.Core.Expressions.SegmentedAccess access) -> void
Reko.Core.Expressions.ExpressionVisitorBase.VisitSlice(Reko.Core.Expressions.Slice slice) -> void
Reko.Core.Expressions.ExpressionVisitorBase.VisitTestCondition(Reko.Core.Expressions.TestCondition tc) -> void
Reko.Core.Expressions.ExpressionVisitorBase.VisitUnaryExpression(Reko.Core.Expressions.UnaryExpression unary) -> void
Reko.Core.Expressions.ExpressionVisitorBase<T>
Reko.Core.Expressions.ExpressionVisitorBase<T>.ExpressionVisitorBase() -> void
Reko.Core.Expressions.FieldAccess
Reko.Core.Expressions.FieldAccess.Field.get -> Reko.Core.Types.Field
Reko.Core.Expressions.FieldAccess.FieldAccess(Reko.Core.Types.DataType fieldType, Reko.Core.Expressions.Expression expr, Reko.Core.Types.Field field) -> void
Reko.Core.Expressions.FieldAccess.Structure.get -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.Identifier
Reko.Core.Expressions.Identifier.Identifier(string name, Reko.Core.Types.DataType type, Reko.Core.Storage stg) -> void
Reko.Core.Expressions.Identifier.Name.get -> string
Reko.Core.Expressions.Identifier.Storage.get -> Reko.Core.Storage
Reko.Core.Expressions.Identifier.Write(bool writeStorage, System.IO.TextWriter writer) -> void
Reko.Core.Expressions.Identifier.WriteType(bool writeStorage, System.IO.TextWriter writer) -> void
Reko.Core.Expressions.IExpressionVisitor
Reko.Core.Expressions.IExpressionVisitor.VisitAddress(Reko.Core.Address addr) -> void
Reko.Core.Expressions.IExpressionVisitor.VisitApplication(Reko.Core.Expressions.Application appl) -> void
Reko.Core.Expressions.IExpressionVisitor.VisitArrayAccess(Reko.Core.Expressions.ArrayAccess acc) -> void
Reko.Core.Expressions.IExpressionVisitor.VisitBinaryExpression(Reko.Core.Expressions.BinaryExpression binExp) -> void
Reko.Core.Expressions.IExpressionVisitor.VisitCast(Reko.Core.Expressions.Cast cast) -> void
Reko.Core.Expressions.IExpressionVisitor.VisitConditionalExpression(Reko.Core.Expressions.ConditionalExpression cond) -> void
Reko.Core.Expressions.IExpressionVisitor.VisitConditionOf(Reko.Core.Expressions.ConditionOf cof) -> void
Reko.Core.Expressions.IExpressionVisitor.VisitConstant(Reko.Core.Expressions.Constant c) -> void
Reko.Core.Expressions.IExpressionVisitor.VisitConversion(Reko.Core.Expressions.Conversion conversion) -> void
Reko.Core.Expressions.IExpressionVisitor.VisitDereference(Reko.Core.Expressions.Dereference deref) -> void
Reko.Core.Expressions.IExpressionVisitor.VisitFieldAccess(Reko.Core.Expressions.FieldAccess acc) -> void
Reko.Core.Expressions.IExpressionVisitor.VisitIdentifier(Reko.Core.Expressions.Identifier id) -> void
Reko.Core.Expressions.IExpressionVisitor.VisitMemberPointerSelector(Reko.Core.Expressions.MemberPointerSelector mps) -> void
Reko.Core.Expressions.IExpressionVisitor.VisitMemoryAccess(Reko.Core.Expressions.MemoryAccess access) -> void
Reko.Core.Expressions.IExpressionVisitor.VisitMkSequence(Reko.Core.Expressions.MkSequence seq) -> void
Reko.Core.Expressions.IExpressionVisitor.VisitOutArgument(Reko.Core.Expressions.OutArgument outArgument) -> void
Reko.Core.Expressions.IExpressionVisitor.VisitPhiFunction(Reko.Core.Expressions.PhiFunction phi) -> void
Reko.Core.Expressions.IExpressionVisitor.VisitPointerAddition(Reko.Core.Expressions.PointerAddition pa) -> void
Reko.Core.Expressions.IExpressionVisitor.VisitProcedureConstant(Reko.Core.Expressions.ProcedureConstant pc) -> void
Reko.Core.Expressions.IExpressionVisitor.VisitScopeResolution(Reko.Core.Expressions.ScopeResolution scopeResolution) -> void
Reko.Core.Expressions.IExpressionVisitor.VisitSegmentedAccess(Reko.Core.Expressions.SegmentedAccess access) -> void
Reko.Core.Expressions.IExpressionVisitor.VisitSlice(Reko.Core.Expressions.Slice slice) -> void
Reko.Core.Expressions.IExpressionVisitor.VisitTestCondition(Reko.Core.Expressions.TestCondition tc) -> void
Reko.Core.Expressions.IExpressionVisitor.VisitUnaryExpression(Reko.Core.Expressions.UnaryExpression unary) -> void
Reko.Core.Expressions.InvalidConstant
Reko.Core.Expressions.MemberPointerSelector
Reko.Core.Expressions.MemberPointerSelector.BasePointer.get -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.MemberPointerSelector.MemberPointer.get -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.MemberPointerSelector.MemberPointerSelector(Reko.Core.Types.DataType dt, Reko.Core.Expressions.Expression basePtr, Reko.Core.Expressions.Expression memberPtr) -> void
Reko.Core.Expressions.MemoryAccess
Reko.Core.Expressions.MemoryAccess.EffectiveAddress.get -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.MemoryAccess.MemoryAccess(Reko.Core.Expressions.Expression ea, Reko.Core.Types.DataType dt) -> void
Reko.Core.Expressions.MemoryAccess.MemoryAccess(Reko.Core.Expressions.MemoryIdentifier space, Reko.Core.Expressions.Expression effectiveAddress, Reko.Core.Types.DataType dt) -> void
Reko.Core.Expressions.MemoryAccess.MemoryId.get -> Reko.Core.Expressions.MemoryIdentifier
Reko.Core.Expressions.MemoryIdentifier
Reko.Core.Expressions.MemoryIdentifier.MemoryIdentifier(int i, Reko.Core.Types.DataType dt) -> void
Reko.Core.Expressions.MemoryIdentifier.MemoryIdentifier(string name, Reko.Core.Types.DataType dt, Reko.Core.Storage stg) -> void
Reko.Core.Expressions.MkSequence
Reko.Core.Expressions.MkSequence.Expressions.get -> Reko.Core.Expressions.Expression![]!
Reko.Core.Expressions.MkSequence.MkSequence(Reko.Core.Types.DataType! dt, params Reko.Core.Expressions.Expression![]! exprs) -> void
Reko.Core.Expressions.OutArgument
Reko.Core.Expressions.OutArgument.Expression.get -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.OutArgument.OutArgument(Reko.Core.Types.DataType refType, Reko.Core.Expressions.Expression id) -> void
Reko.Core.Expressions.PhiArgument
Reko.Core.Expressions.PhiArgument.Deconstruct(out Reko.Core.Block block, out Reko.Core.Expressions.Expression value) -> void
Reko.Core.Expressions.PhiArgument.PhiArgument() -> void
Reko.Core.Expressions.PhiArgument.PhiArgument(Reko.Core.Block block, Reko.Core.Expressions.Expression value) -> void
Reko.Core.Expressions.PhiFunction
Reko.Core.Expressions.PhiFunction.Arguments.get -> Reko.Core.Expressions.PhiArgument[]
Reko.Core.Expressions.PhiFunction.PhiFunction(Reko.Core.Types.DataType joinType, params Reko.Core.Expressions.PhiArgument[] arguments) -> void
Reko.Core.Expressions.PointerAddition
Reko.Core.Expressions.PointerAddition.Offset.get -> int
Reko.Core.Expressions.PointerAddition.Pointer.get -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.PointerAddition.PointerAddition(Reko.Core.Types.DataType addType, Reko.Core.Expressions.Expression expr, int offset) -> void
Reko.Core.Expressions.ProcedureConstant
Reko.Core.Expressions.ProcedureConstant.Procedure.get -> Reko.Core.ProcedureBase
Reko.Core.Expressions.ProcedureConstant.ProcedureConstant(Reko.Core.Types.DataType ptrType, Reko.Core.ProcedureBase proc) -> void
Reko.Core.Expressions.ScopeResolution
Reko.Core.Expressions.ScopeResolution.ScopeResolution(Reko.Core.Types.DataType dt) -> void
Reko.Core.Expressions.SegmentedAccess
Reko.Core.Expressions.SegmentedAccess.BasePointer.get -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.SegmentedAccess.SegmentedAccess(Reko.Core.Expressions.MemoryIdentifier id, Reko.Core.Expressions.Expression basePtr, Reko.Core.Expressions.Expression ea, Reko.Core.Types.DataType dt) -> void
Reko.Core.Expressions.Slice
Reko.Core.Expressions.Slice.Expression.get -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.Slice.Offset.get -> int
Reko.Core.Expressions.Slice.Slice(Reko.Core.Types.DataType dt, Reko.Core.Expressions.Expression i, int bitOffset) -> void
Reko.Core.Expressions.StringConstant
Reko.Core.Expressions.StringConstant.Length.get -> int
Reko.Core.Expressions.StringConstant.StringConstant(Reko.Core.Types.DataType type, string str) -> void
Reko.Core.Expressions.TestCondition
Reko.Core.Expressions.TestCondition.ConditionCode.get -> Reko.Core.Expressions.ConditionCode
Reko.Core.Expressions.TestCondition.Expression.get -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.TestCondition.TestCondition(Reko.Core.Expressions.ConditionCode cc, Reko.Core.Expressions.Expression expr) -> void
Reko.Core.Expressions.UnaryExpression
Reko.Core.Expressions.UnaryExpression.Expression.get -> Reko.Core.Expressions.Expression
Reko.Core.Expressions.UnaryExpression.Operator.get -> Reko.Core.Operators.UnaryOperator
Reko.Core.Expressions.UnaryExpression.UnaryExpression(Reko.Core.Operators.UnaryOperator op, Reko.Core.Types.DataType type, Reko.Core.Expressions.Expression expr) -> void
Reko.Core.ExternalProcedure
Reko.Core.ExternalProcedure.ExternalProcedure(string name, Reko.Core.Types.FunctionType signature, Reko.Core.Serialization.ProcedureCharacteristics chars = null) -> void
Reko.Core.FieldAttribute
Reko.Core.FieldAttribute.Align -> int
Reko.Core.FieldAttribute.FieldAttribute() -> void
Reko.Core.FlagGroupStorage
Reko.Core.FlagGroupStorage.FlagGroupBits.get -> uint
Reko.Core.FlagGroupStorage.FlagGroupStorage(Reko.Core.RegisterStorage freg, uint grfMask, string name, Reko.Core.Types.DataType dataType) -> void
Reko.Core.FlagGroupStorage.FlagRegister.get -> Reko.Core.RegisterStorage
Reko.Core.FlagGroupStorage.GetFlagBitMasks() -> System.Collections.Generic.IEnumerable<uint>
Reko.Core.FpuStackStorage
Reko.Core.FpuStackStorage.FpuStackOffset.get -> int
Reko.Core.FpuStackStorage.FpuStackStorage(int depth, Reko.Core.Types.DataType dataType) -> void
Reko.Core.Frame
Reko.Core.Frame.CreateSequence(Reko.Core.Types.DataType! dt, params Reko.Core.Storage![]! elements) -> Reko.Core.Expressions.Identifier!
Reko.Core.Frame.CreateSequence(Reko.Core.Types.DataType! dt, string! name, params Reko.Core.Storage![]! elements) -> Reko.Core.Expressions.Identifier!
Reko.Core.Frame.CreateTemporary(Reko.Core.Types.DataType! dt) -> Reko.Core.Expressions.Identifier!
Reko.Core.Frame.CreateTemporary(string! name, Reko.Core.Types.DataType! dt) -> Reko.Core.Expressions.Identifier!
Reko.Core.Frame.EnsureFlagGroup(Reko.Core.FlagGroupStorage! grf) -> Reko.Core.Expressions.Identifier!
Reko.Core.Frame.EnsureFlagGroup(Reko.Core.RegisterStorage! freg, uint grfMask, string! name, Reko.Core.Types.DataType! dt) -> Reko.Core.Expressions.Identifier!
Reko.Core.Frame.EnsureFpuStackVariable(int depth, Reko.Core.Types.DataType! type) -> Reko.Core.Expressions.Identifier!
Reko.Core.Frame.EnsureIdentifier(Reko.Core.Storage! stgForeign) -> Reko.Core.Expressions.Identifier!
Reko.Core.Frame.EnsureOutArgument(Reko.Core.Expressions.Identifier! idOrig, Reko.Core.Types.DataType! outArgumentPointer) -> Reko.Core.Expressions.Identifier!
Reko.Core.Frame.EnsureRegister(Reko.Core.RegisterStorage! reg) -> Reko.Core.Expressions.Identifier!
Reko.Core.Frame.EnsureSequence(Reko.Core.SequenceStorage! sequence) -> Reko.Core.Expressions.Identifier!
Reko.Core.Frame.EnsureSequence(Reko.Core.Types.DataType! dt, params Reko.Core.Storage![]! elements) -> Reko.Core.Expressions.Identifier!
Reko.Core.Frame.EnsureSequence(Reko.Core.Types.DataType! dt, string! name, params Reko.Core.Storage![]! elements) -> Reko.Core.Expressions.Identifier!
Reko.Core.Frame.EnsureStackArgument(int cbOffset, Reko.Core.Types.DataType type) -> Reko.Core.Expressions.Identifier
Reko.Core.Frame.EnsureStackArgument(int cbOffset, Reko.Core.Types.DataType type, string argName) -> Reko.Core.Expressions.Identifier
Reko.Core.Frame.EnsureStackLocal(int cbOffset, Reko.Core.Types.DataType type) -> Reko.Core.Expressions.Identifier
Reko.Core.Frame.EnsureStackLocal(int cbOffset, Reko.Core.Types.DataType type, string name) -> Reko.Core.Expressions.Identifier
Reko.Core.Frame.EnsureStackVariable(int byteOffset, Reko.Core.Types.DataType type) -> Reko.Core.Expressions.Identifier
Reko.Core.Frame.EnsureStackVariable(Reko.Core.Expressions.Constant imm, int cbOffset, Reko.Core.Types.DataType type) -> Reko.Core.Expressions.Identifier
Reko.Core.Frame.Escapes.get -> bool
Reko.Core.Frame.Escapes.set -> void
Reko.Core.Frame.FindFlagGroup(Reko.Core.RegisterStorage reg, uint grfMask) -> Reko.Core.Expressions.Identifier
Reko.Core.Frame.FindFpuStackVariable(int off) -> Reko.Core.Expressions.Identifier
Reko.Core.Frame.FindOutArgument(Reko.Core.Expressions.Identifier idOrig) -> Reko.Core.Expressions.Identifier
Reko.Core.Frame.FindRegister(Reko.Core.RegisterStorage reg) -> Reko.Core.Expressions.Identifier
Reko.Core.Frame.FindSequence(Reko.Core.Storage[] elements) -> Reko.Core.Expressions.Identifier
Reko.Core.Frame.FindStackArgument(int offset, int size) -> Reko.Core.Expressions.Identifier
Reko.Core.Frame.FindStackLocal(int offset, Reko.Core.Types.DataType dt) -> Reko.Core.Expressions.Identifier
Reko.Core.Frame.FindTemporary(string name) -> Reko.Core.Expressions.Identifier
Reko.Core.Frame.Frame(Reko.Core.IProcessorArchitecture! arch, Reko.Core.Types.PrimitiveType! framePointerSize) -> void
Reko.Core.Frame.FrameOffset.get -> int
Reko.Core.Frame.FrameOffset.set -> void
Reko.Core.Frame.FramePointer.get -> Reko.Core.Expressions.Identifier!
Reko.Core.Frame.Identifiers.get -> System.Collections.Generic.List<Reko.Core.Expressions.Identifier!>!
Reko.Core.Frame.Memory.get -> Reko.Core.Expressions.Identifier!
Reko.Core.Frame.ReturnAddressKnown.get -> bool
Reko.Core.Frame.ReturnAddressKnown.set -> void
Reko.Core.Frame.ReturnAddressSize.get -> int
Reko.Core.Frame.ReturnAddressSize.set -> void
Reko.Core.Frame.Write(System.IO.TextWriter text) -> void
Reko.Core.FrameApplicationBuilder
Reko.Core.FrameApplicationBuilder.arch -> Reko.Core.IProcessorArchitecture
Reko.Core.FrameApplicationBuilder.binder -> Reko.Core.IStorageBinder
Reko.Core.FrameApplicationBuilder.ensureVariables -> bool
Reko.Core.FrameApplicationBuilder.FrameApplicationBuilder(Reko.Core.IProcessorArchitecture arch, Reko.Core.IStorageBinder binder, Reko.Core.Code.CallSite site, Reko.Core.Expressions.Expression callee, bool ensureVariables) -> void
Reko.Core.FrameApplicationBuilder.VisitFlagGroupStorage(Reko.Core.FlagGroupStorage grf) -> Reko.Core.Expressions.Expression
Reko.Core.FrameApplicationBuilder.VisitMemoryStorage(Reko.Core.MemoryStorage global) -> Reko.Core.Expressions.Expression
Reko.Core.FrameApplicationBuilder.VisitOutArgumentStorage(Reko.Core.OutArgumentStorage arg) -> Reko.Core.Expressions.Expression
Reko.Core.FrameApplicationBuilder.VisitRegisterStorage(Reko.Core.RegisterStorage reg) -> Reko.Core.Expressions.Expression
Reko.Core.FrameApplicationBuilder.VisitSequenceStorage(Reko.Core.SequenceStorage seq) -> Reko.Core.Expressions.Expression
Reko.Core.FrameApplicationBuilder.VisitStackStorage(Reko.Core.StackStorage stack) -> Reko.Core.Expressions.Expression
Reko.Core.FrameApplicationBuilder.VisitTemporaryStorage(Reko.Core.TemporaryStorage temp) -> Reko.Core.Expressions.Expression
Reko.Core.GlobalStorage
Reko.Core.GlobalStorage.GlobalStorage(string name, Reko.Core.Types.DataType dt) -> void
Reko.Core.GlobalVariable
Reko.Core.GlobalVariable.Address.get -> Reko.Core.Address
Reko.Core.GlobalVariable.DataType.get -> Reko.Core.Types.DataType
Reko.Core.GlobalVariable.GlobalVariable(Reko.Core.Address addr, Reko.Core.Types.DataType dt, string name) -> void
Reko.Core.GlobalVariable.Name.get -> string
Reko.Core.Graphs.ArticulationPointFinder<T>
Reko.Core.Graphs.ArticulationPointFinder<T>.ArticulationPointFinder(Reko.Core.Graphs.DirectedGraph<T> graph) -> void
Reko.Core.Graphs.ArticulationPointFinder<T>.FindArticulationPoints(System.Collections.Generic.IEnumerable<T> nodes) -> System.Collections.Generic.HashSet<T>
Reko.Core.Graphs.BlockDominatorGraph
Reko.Core.Graphs.BlockDominatorGraph.BlockDominatorGraph(Reko.Core.Graphs.DirectedGraph<Reko.Core.Block> graph, Reko.Core.Block entry) -> void
Reko.Core.Graphs.BlockDominatorGraph.DominatesStrictly(Reko.Core.Statement stmDom, Reko.Core.Statement stm) -> bool
Reko.Core.Graphs.BlockGraph
Reko.Core.Graphs.BlockGraph.AddEdge(Reko.Core.Block nodeFrom, Reko.Core.Block nodeTo) -> void
Reko.Core.Graphs.BlockGraph.BlockGraph(System.Collections.Generic.IList<Reko.Core.Block> blocks) -> void
Reko.Core.Graphs.BlockGraph.Blocks.get -> System.Collections.Generic.IList<Reko.Core.Block>
Reko.Core.Graphs.BlockGraph.ContainsEdge(Reko.Core.Block from, Reko.Core.Block to) -> bool
Reko.Core.Graphs.BlockGraph.Predecessors(Reko.Core.Block node) -> System.Collections.Generic.ICollection<Reko.Core.Block>
Reko.Core.Graphs.BlockGraph.RemoveBlock(Reko.Core.Block block) -> void
Reko.Core.Graphs.BlockGraph.RemoveEdge(Reko.Core.Block nodeFrom, Reko.Core.Block nodeTo) -> void
Reko.Core.Graphs.BlockGraph.Successors(Reko.Core.Block node) -> System.Collections.Generic.ICollection<Reko.Core.Block>
Reko.Core.Graphs.DfsIterator<T>
Reko.Core.Graphs.DfsIterator<T>.DfsIterator(Reko.Core.Graphs.DirectedGraph<T> graph) -> void
Reko.Core.Graphs.DfsIterator<T>.PostOrder() -> System.Collections.Generic.IEnumerable<T>
Reko.Core.Graphs.DfsIterator<T>.PostOrder(T item) -> System.Collections.Generic.IEnumerable<T>
Reko.Core.Graphs.DfsIterator<T>.PreOrder() -> System.Collections.Generic.IEnumerable<T>
Reko.Core.Graphs.DfsIterator<T>.PreOrder(T item) -> System.Collections.Generic.IEnumerable<T>
Reko.Core.Graphs.DfsIterator<T>.ReversePostOrder() -> System.Collections.Generic.IEnumerable<T>
Reko.Core.Graphs.DiGraph<T>
Reko.Core.Graphs.DiGraph<T>.AddEdge(T itemFrom, T itemTo) -> void
Reko.Core.Graphs.DiGraph<T>.AddNode(T item) -> void
Reko.Core.Graphs.DiGraph<T>.ContainsEdge(T itemFrom, T itemTo) -> bool
Reko.Core.Graphs.DiGraph<T>.DiGraph() -> void
Reko.Core.Graphs.DiGraph<T>.Nodes.get -> System.Collections.Generic.ICollection<T>
Reko.Core.Graphs.DiGraph<T>.Predecessors(T item) -> System.Collections.Generic.ICollection<T>
Reko.Core.Graphs.DiGraph<T>.RemoveEdge(T itemFrom, T itemTo) -> void
Reko.Core.Graphs.DiGraph<T>.RemoveNode(T item) -> bool
Reko.Core.Graphs.DiGraph<T>.Successors(T item) -> System.Collections.Generic.ICollection<T>
Reko.Core.Graphs.DiGraph<V, E>
Reko.Core.Graphs.DiGraph<V, E>.AddEdge(V nodeFrom, V nodeTo, E edgeData) -> void
Reko.Core.Graphs.DiGraph<V, E>.ContainsEdge(V nodeFrom, V nodeTo) -> bool
Reko.Core.Graphs.DiGraph<V, E>.DiGraph() -> void
Reko.Core.Graphs.DiGraph<V, E>.Nodes.get -> System.Collections.Generic.ICollection<V>
Reko.Core.Graphs.DiGraph<V, E>.Predecessors(V node) -> System.Collections.Generic.ICollection<(V, E)>
Reko.Core.Graphs.DiGraph<V, E>.RemoveEdge(V nodeFrom, V nodeTo) -> void
Reko.Core.Graphs.DiGraph<V, E>.Successors(V node) -> System.Collections.Generic.ICollection<(V, E)>
Reko.Core.Graphs.Dijkstra<T>
Reko.Core.Graphs.Dijkstra<T>.dist -> System.Collections.Generic.Dictionary<T, double>
Reko.Core.Graphs.Dijkstra<T>.GetPath(T destination) -> System.Collections.Generic.List<T>!
Reko.Core.Graphs.Dijkstra<T>.prev -> System.Collections.Generic.Dictionary<T, T>
Reko.Core.Graphs.DirectedGraph<T, E>
Reko.Core.Graphs.DirectedGraph<T, E>.AddEdge(T nodeFrom, T nodeTo, E edgeData) -> void
Reko.Core.Graphs.DirectedGraph<T, E>.ContainsEdge(T nodeFrom, T nodeTo) -> bool
Reko.Core.Graphs.DirectedGraph<T, E>.Nodes.get -> System.Collections.Generic.ICollection<T>!
Reko.Core.Graphs.DirectedGraph<T, E>.Predecessors(T node) -> System.Collections.Generic.ICollection<(T, E)>!
Reko.Core.Graphs.DirectedGraph<T, E>.RemoveEdge(T nodeFrom, T nodeTo) -> void
Reko.Core.Graphs.DirectedGraph<T, E>.Successors(T node) -> System.Collections.Generic.ICollection<(T, E)>!
Reko.Core.Graphs.DirectedGraph<T>
Reko.Core.Graphs.DirectedGraph<T>.AddEdge(T nodeFrom, T nodeTo) -> void
Reko.Core.Graphs.DirectedGraph<T>.ContainsEdge(T nodeFrom, T nodeTo) -> bool
Reko.Core.Graphs.DirectedGraph<T>.Nodes.get -> System.Collections.Generic.ICollection<T>!
Reko.Core.Graphs.DirectedGraph<T>.Predecessors(T node) -> System.Collections.Generic.ICollection<T>!
Reko.Core.Graphs.DirectedGraph<T>.RemoveEdge(T nodeFrom, T nodeTo) -> void
Reko.Core.Graphs.DirectedGraph<T>.Successors(T node) -> System.Collections.Generic.ICollection<T>!
Reko.Core.Graphs.DirectedGraphImpl<T>
Reko.Core.Graphs.DirectedGraphImpl<T>.AddEdge(T! from, T! to) -> void
Reko.Core.Graphs.DirectedGraphImpl<T>.AddNode(T! n) -> void
Reko.Core.Graphs.DirectedGraphImpl<T>.ContainsEdge(T! from, T! to) -> bool
Reko.Core.Graphs.DirectedGraphImpl<T>.DirectedGraphImpl() -> void
Reko.Core.Graphs.DirectedGraphImpl<T>.Nodes.get -> System.Collections.Generic.ICollection<T!>!
Reko.Core.Graphs.DirectedGraphImpl<T>.Predecessors(T! o) -> System.Collections.Generic.ICollection<T!>!
Reko.Core.Graphs.DirectedGraphImpl<T>.RemoveEdge(T! from, T! to) -> void
Reko.Core.Graphs.DirectedGraphImpl<T>.Successors(T! node) -> System.Collections.Generic.ICollection<T!>!
Reko.Core.Graphs.DominatorGraph<T>
Reko.Core.Graphs.DominatorGraph<T>.CommonDominator(System.Collections.Generic.IEnumerable<T> blocks) -> T
Reko.Core.Graphs.DominatorGraph<T>.DominatesStrictly(T dominator, T d) -> bool
Reko.Core.Graphs.DominatorGraph<T>.DominatorFrontier(T node) -> System.Collections.Generic.List<T>
Reko.Core.Graphs.DominatorGraph<T>.DominatorGraph(Reko.Core.Graphs.DirectedGraph<T> graph, T entryNode) -> void
Reko.Core.Graphs.DominatorGraph<T>.Dump() -> void
Reko.Core.Graphs.DominatorGraph<T>.ImmediateDominator(T node) -> T
Reko.Core.Graphs.DominatorGraph<T>.ReversePostOrder.get -> System.Collections.Generic.Dictionary<T, int>
Reko.Core.Graphs.DominatorGraph<T>.ReversePostorderNumbering(Reko.Core.Graphs.DirectedGraph<T> graph) -> System.Collections.Generic.Dictionary<T, int>
Reko.Core.Graphs.DominatorGraph<T>.ReversePostorderNumbering(Reko.Core.Graphs.DirectedGraph<T> graph, T entry) -> System.Collections.Generic.Dictionary<T, int>
Reko.Core.Graphs.DominatorGraph<T>.Write(System.IO.TextWriter writer) -> void
Reko.Core.Graphs.LTDominatorGraph<TNode>
Reko.Core.Graphs.LTDominatorGraph<TNode>.Builder
Reko.Core.Graphs.LTDominatorGraph<TNode>.Builder.Builder(Reko.Core.Graphs.DirectedGraph<TNode> graph, TNode root) -> void
Reko.Core.Graphs.LTDominatorGraph<TNode>.Builder.Dominators() -> System.Collections.Generic.Dictionary<TNode, TNode>
Reko.Core.Graphs.LTDominatorGraph<TNode>.LTDominatorGraph() -> void
Reko.Core.Graphs.SccFinder
Reko.Core.Graphs.UndirectedGraph<T>
Reko.Core.Graphs.UndirectedGraph<T>.AddEdge(T nodeFrom, T nodeTo) -> void
Reko.Core.Graphs.UndirectedGraph<T>.ContainsEdge(T nodeFrom, T nodeTo) -> bool
Reko.Core.Graphs.UndirectedGraph<T>.Neighbors(T node) -> System.Collections.Generic.ICollection<T>
Reko.Core.Graphs.UndirectedGraph<T>.RemoveEdge(T nodeFrom, T nodeTo) -> void
Reko.Core.Graphs.UndirectedGraphImpl<T>
Reko.Core.Graphs.UndirectedGraphImpl<T>.AddEdge(T nodeFrom, T nodeTo) -> void
Reko.Core.Graphs.UndirectedGraphImpl<T>.ContainsEdge(T nodeFrom, T nodeTo) -> bool
Reko.Core.Graphs.UndirectedGraphImpl<T>.Neighbors(T node) -> System.Collections.Generic.ICollection<T>
Reko.Core.Graphs.UndirectedGraphImpl<T>.RemoveEdge(T nodeFrom, T nodeTo) -> void
Reko.Core.Graphs.UndirectedGraphImpl<T>.UndirectedGraphImpl() -> void
Reko.Core.Hll.C.Application
Reko.Core.Hll.C.Application.Application() -> void
Reko.Core.Hll.C.Application.Arguments -> System.Collections.Generic.List<Reko.Core.Hll.C.CExpression>
Reko.Core.Hll.C.Application.Function -> Reko.Core.Hll.C.CExpression
Reko.Core.Hll.C.ArrayDeclarator
Reko.Core.Hll.C.ArrayDeclarator.ArrayDeclarator() -> void
Reko.Core.Hll.C.ArrayDeclarator.Declarator -> Reko.Core.Hll.C.Declarator
Reko.Core.Hll.C.ArrayDeclarator.Size -> Reko.Core.Hll.C.CExpression
Reko.Core.Hll.C.AssignExpression
Reko.Core.Hll.C.AssignExpression.AssignExpression() -> void
Reko.Core.Hll.C.AssignExpression.AssingmentOp -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.AssignExpression.LValue -> Reko.Core.Hll.C.CExpression
Reko.Core.Hll.C.AssignExpression.RValue -> Reko.Core.Hll.C.CExpression
Reko.Core.Hll.C.CallConventionDeclarator
Reko.Core.Hll.C.CallConventionDeclarator.CallConventionDeclarator() -> void
Reko.Core.Hll.C.CallConventionDeclarator.Convention -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CallConventionDeclarator.Declarator -> Reko.Core.Hll.C.Declarator
Reko.Core.Hll.C.CArrayAccess
Reko.Core.Hll.C.CArrayAccess.CArrayAccess() -> void
Reko.Core.Hll.C.CArrayAccess.Expression -> Reko.Core.Hll.C.CExpression
Reko.Core.Hll.C.CArrayAccess.Index -> Reko.Core.Hll.C.CExpression
Reko.Core.Hll.C.CaseLabel
Reko.Core.Hll.C.CaseLabel.CaseLabel() -> void
Reko.Core.Hll.C.CaseLabel.Value -> Reko.Core.Hll.C.CExpression
Reko.Core.Hll.C.CastExpression
Reko.Core.Hll.C.CastExpression.CastExpression() -> void
Reko.Core.Hll.C.CastExpression.Expression -> Reko.Core.Hll.C.CExpression
Reko.Core.Hll.C.CastExpression.Type -> Reko.Core.Hll.C.CType
Reko.Core.Hll.C.CAttribute
Reko.Core.Hll.C.CAttribute.CAttribute() -> void
Reko.Core.Hll.C.CAttribute.Name -> Reko.Core.Hll.C.QualifiedName
Reko.Core.Hll.C.CAttribute.Tokens -> System.Collections.Generic.List<Reko.Core.Hll.C.CToken>
Reko.Core.Hll.C.CBasicType
Reko.Core.Hll.C.CBasicType.Bool = 1 -> Reko.Core.Hll.C.CBasicType
Reko.Core.Hll.C.CBasicType.Char = 2 -> Reko.Core.Hll.C.CBasicType
Reko.Core.Hll.C.CBasicType.Double = 9 -> Reko.Core.Hll.C.CBasicType
Reko.Core.Hll.C.CBasicType.Float = 8 -> Reko.Core.Hll.C.CBasicType
Reko.Core.Hll.C.CBasicType.Int = 5 -> Reko.Core.Hll.C.CBasicType
Reko.Core.Hll.C.CBasicType.Int64 = 11 -> Reko.Core.Hll.C.CBasicType
Reko.Core.Hll.C.CBasicType.Long = 6 -> Reko.Core.Hll.C.CBasicType
Reko.Core.Hll.C.CBasicType.LongDouble = 10 -> Reko.Core.Hll.C.CBasicType
Reko.Core.Hll.C.CBasicType.LongLong = 7 -> Reko.Core.Hll.C.CBasicType
Reko.Core.Hll.C.CBasicType.None = 0 -> Reko.Core.Hll.C.CBasicType
Reko.Core.Hll.C.CBasicType.Short = 4 -> Reko.Core.Hll.C.CBasicType
Reko.Core.Hll.C.CBasicType.WChar_t = 3 -> Reko.Core.Hll.C.CBasicType
Reko.Core.Hll.C.CBinaryExpression
Reko.Core.Hll.C.CBinaryExpression.CBinaryExpression() -> void
Reko.Core.Hll.C.CBinaryExpression.Left -> Reko.Core.Hll.C.CExpression
Reko.Core.Hll.C.CBinaryExpression.Operation -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CBinaryExpression.Right -> Reko.Core.Hll.C.CExpression
Reko.Core.Hll.C.CConstantEvaluator
Reko.Core.Hll.C.CConstantEvaluator.CConstantEvaluator(Reko.Core.IPlatform platform, System.Collections.Generic.Dictionary<string, int> constants) -> void
Reko.Core.Hll.C.CConstantEvaluator.VisitApplication(Reko.Core.Hll.C.Application application) -> object
Reko.Core.Hll.C.CConstantEvaluator.VisitArrayAccess(Reko.Core.Hll.C.CArrayAccess aref) -> object
Reko.Core.Hll.C.CConstantEvaluator.VisitAssign(Reko.Core.Hll.C.AssignExpression assignExpression) -> object
Reko.Core.Hll.C.CConstantEvaluator.VisitBinary(Reko.Core.Hll.C.CBinaryExpression bin) -> object
Reko.Core.Hll.C.CConstantEvaluator.VisitCast(Reko.Core.Hll.C.CastExpression castExpression) -> object
Reko.Core.Hll.C.CConstantEvaluator.VisitConditional(Reko.Core.Hll.C.ConditionalExpression cond) -> object
Reko.Core.Hll.C.CConstantEvaluator.VisitConstant(Reko.Core.Hll.C.ConstExp constExp) -> object
Reko.Core.Hll.C.CConstantEvaluator.VisitIdentifier(Reko.Core.Hll.C.CIdentifier id) -> object
Reko.Core.Hll.C.CConstantEvaluator.VisitIncremeent(Reko.Core.Hll.C.IncrementExpression incrementExpression) -> object
Reko.Core.Hll.C.CConstantEvaluator.VisitMember(Reko.Core.Hll.C.MemberExpression memberExpression) -> object
Reko.Core.Hll.C.CConstantEvaluator.VisitSizeof(Reko.Core.Hll.C.SizeofExpression sizeOf) -> object
Reko.Core.Hll.C.CConstantEvaluator.VisitUnary(Reko.Core.Hll.C.CUnaryExpression unary) -> object
Reko.Core.Hll.C.CDirectiveLexer
Reko.Core.Hll.C.CDirectiveLexer.CDirectiveLexer(Reko.Core.Hll.C.ParserState state, Reko.Core.Hll.C.CLexer lexer) -> void
Reko.Core.Hll.C.CDirectiveLexer.LineNumber.get -> int
Reko.Core.Hll.C.CDirectiveLexer.Read() -> Reko.Core.Hll.C.CToken
Reko.Core.Hll.C.CDirectiveLexer.ReadDefine() -> Reko.Core.Hll.C.CToken
Reko.Core.Hll.C.CExpression
Reko.Core.Hll.C.CExpression.CExpression() -> void
Reko.Core.Hll.C.CExpressionVisitor<T>
Reko.Core.Hll.C.CExpressionVisitor<T>.VisitApplication(Reko.Core.Hll.C.Application application) -> T
Reko.Core.Hll.C.CExpressionVisitor<T>.VisitArrayAccess(Reko.Core.Hll.C.CArrayAccess aref) -> T
Reko.Core.Hll.C.CExpressionVisitor<T>.VisitAssign(Reko.Core.Hll.C.AssignExpression assign) -> T
Reko.Core.Hll.C.CExpressionVisitor<T>.VisitBinary(Reko.Core.Hll.C.CBinaryExpression binary) -> T
Reko.Core.Hll.C.CExpressionVisitor<T>.VisitCast(Reko.Core.Hll.C.CastExpression cast) -> T
Reko.Core.Hll.C.CExpressionVisitor<T>.VisitConditional(Reko.Core.Hll.C.ConditionalExpression conditional) -> T
Reko.Core.Hll.C.CExpressionVisitor<T>.VisitConstant(Reko.Core.Hll.C.ConstExp constant) -> T
Reko.Core.Hll.C.CExpressionVisitor<T>.VisitIdentifier(Reko.Core.Hll.C.CIdentifier id) -> T
Reko.Core.Hll.C.CExpressionVisitor<T>.VisitIncremeent(Reko.Core.Hll.C.IncrementExpression increment) -> T
Reko.Core.Hll.C.CExpressionVisitor<T>.VisitMember(Reko.Core.Hll.C.MemberExpression member) -> T
Reko.Core.Hll.C.CExpressionVisitor<T>.VisitSizeof(Reko.Core.Hll.C.SizeofExpression sizeOf) -> T
Reko.Core.Hll.C.CExpressionVisitor<T>.VisitUnary(Reko.Core.Hll.C.CUnaryExpression unary) -> T
Reko.Core.Hll.C.CGrammar
Reko.Core.Hll.C.CGrammar.Application(Reko.Core.Hll.C.CExpression e) -> Reko.Core.Hll.C.CExpression
Reko.Core.Hll.C.CGrammar.Application(Reko.Core.Hll.C.CExpression fn, System.Collections.Generic.List<Reko.Core.Hll.C.CExpression> list) -> Reko.Core.Hll.C.CExpression
Reko.Core.Hll.C.CGrammar.ArrayAccess(Reko.Core.Hll.C.CExpression e, Reko.Core.Hll.C.CExpression idx) -> Reko.Core.Hll.C.CExpression
Reko.Core.Hll.C.CGrammar.ArrayDeclarator(Reko.Core.Hll.C.Declarator decl, Reko.Core.Hll.C.CExpression expr) -> Reko.Core.Hll.C.Declarator
Reko.Core.Hll.C.CGrammar.BreakStatement() -> Reko.Core.Hll.C.Stat
Reko.Core.Hll.C.CGrammar.CallConventionDeclarator(Reko.Core.Hll.C.CTokenType conv, Reko.Core.Hll.C.Declarator decl) -> Reko.Core.Hll.C.Declarator
Reko.Core.Hll.C.CGrammar.CaseLabel(Reko.Core.Hll.C.CExpression constExpr) -> Reko.Core.Hll.C.Label
Reko.Core.Hll.C.CGrammar.Cast(Reko.Core.Hll.C.CType type, Reko.Core.Hll.C.CExpression exp) -> Reko.Core.Hll.C.CExpression
Reko.Core.Hll.C.CGrammar.CGrammar() -> void
Reko.Core.Hll.C.CGrammar.ComplexType(Reko.Core.Hll.C.CTokenType token, int alignment, string tag, System.Collections.Generic.List<Reko.Core.Hll.C.StructDecl> decls) -> Reko.Core.Hll.C.TypeSpec
Reko.Core.Hll.C.CGrammar.CompoundStatement(System.Collections.Generic.List<Reko.Core.Hll.C.Stat> statements) -> Reko.Core.Hll.C.Stat
Reko.Core.Hll.C.CGrammar.Conditional(Reko.Core.Hll.C.CExpression cond, Reko.Core.Hll.C.CExpression consequent, Reko.Core.Hll.C.CExpression alternant) -> Reko.Core.Hll.C.CExpression
Reko.Core.Hll.C.CGrammar.Const(object value) -> Reko.Core.Hll.C.CExpression
Reko.Core.Hll.C.CGrammar.ContinueStatement() -> Reko.Core.Hll.C.Stat
Reko.Core.Hll.C.CGrammar.Decl(System.Collections.Generic.List<Reko.Core.Hll.C.CAttribute> attrs, System.Collections.Generic.List<Reko.Core.Hll.C.DeclSpec> list, System.Collections.Generic.List<Reko.Core.Hll.C.InitDeclarator> listDecls) -> Reko.Core.Hll.C.Decl
Reko.Core.Hll.C.CGrammar.DeclStat(Reko.Core.Hll.C.Decl decl) -> Reko.Core.Hll.C.Stat
Reko.Core.Hll.C.CGrammar.DefaultCaseLabel() -> Reko.Core.Hll.C.Label
Reko.Core.Hll.C.CGrammar.DoWhileStatement(Reko.Core.Hll.C.Stat doBody, Reko.Core.Hll.C.CExpression expr) -> Reko.Core.Hll.C.Stat
Reko.Core.Hll.C.CGrammar.Ellipsis() -> Reko.Core.Hll.C.ParamDecl
Reko.Core.Hll.C.CGrammar.EmptyStatement() -> Reko.Core.Hll.C.Stat
Reko.Core.Hll.C.CGrammar.Enum(string tag, System.Collections.Generic.List<Reko.Core.Hll.C.Enumerator> enums) -> Reko.Core.Hll.C.TypeSpec
Reko.Core.Hll.C.CGrammar.Enumerator(string id, Reko.Core.Hll.C.CExpression init) -> Reko.Core.Hll.C.Enumerator
Reko.Core.Hll.C.CGrammar.ExprStatement(Reko.Core.Hll.C.CExpression expr) -> Reko.Core.Hll.C.Stat
Reko.Core.Hll.C.CGrammar.ExtendedDeclspec(string s) -> Reko.Core.Hll.C.DeclSpec
Reko.Core.Hll.C.CGrammar.FieldDeclarator(Reko.Core.Hll.C.Declarator decl, Reko.Core.Hll.C.CExpression bitField) -> Reko.Core.Hll.C.FieldDeclarator
Reko.Core.Hll.C.CGrammar.ForStatement(Reko.Core.Hll.C.Stat init, Reko.Core.Hll.C.CExpression test, Reko.Core.Hll.C.CExpression incr, Reko.Core.Hll.C.Stat forBody) -> Reko.Core.Hll.C.Stat
Reko.Core.Hll.C.CGrammar.FunctionDeclarator(Reko.Core.Hll.C.Declarator decl, System.Collections.Generic.List<Reko.Core.Hll.C.ParamDecl> parameters) -> Reko.Core.Hll.C.Declarator
Reko.Core.Hll.C.CGrammar.GotoStatement(string gotoLabel) -> Reko.Core.Hll.C.Stat
Reko.Core.Hll.C.CGrammar.Id(string name) -> Reko.Core.Hll.C.CIdentifier
Reko.Core.Hll.C.CGrammar.IdDeclarator(string name) -> Reko.Core.Hll.C.Declarator
Reko.Core.Hll.C.CGrammar.IfStatement(Reko.Core.Hll.C.CExpression expr, Reko.Core.Hll.C.Stat consequence, Reko.Core.Hll.C.Stat alternative) -> Reko.Core.Hll.C.Stat
Reko.Core.Hll.C.CGrammar.InitDeclarator(Reko.Core.Hll.C.Declarator decl, Reko.Core.Hll.C.Initializer init) -> Reko.Core.Hll.C.InitDeclarator
Reko.Core.Hll.C.CGrammar.LabeledStatement(Reko.Core.Hll.C.Label label, Reko.Core.Hll.C.Stat stat) -> Reko.Core.Hll.C.Stat
Reko.Core.Hll.C.CGrammar.MemberAccess(Reko.Core.Hll.C.CExpression e, string fieldName) -> Reko.Core.Hll.C.CExpression
Reko.Core.Hll.C.CGrammar.ParamDecl(System.Collections.Generic.List<Reko.Core.Hll.C.CAttribute> attrs, System.Collections.Generic.List<Reko.Core.Hll.C.DeclSpec> dsl, Reko.Core.Hll.C.Declarator decl) -> Reko.Core.Hll.C.ParamDecl
Reko.Core.Hll.C.CGrammar.PointerDeclarator() -> Reko.Core.Hll.C.PointerDeclarator
Reko.Core.Hll.C.CGrammar.PointerDeclarator(Reko.Core.Hll.C.Declarator decl, System.Collections.Generic.List<Reko.Core.Hll.C.TypeQualifier> tqs) -> Reko.Core.Hll.C.Declarator
Reko.Core.Hll.C.CGrammar.PostIncrement(Reko.Core.Hll.C.CExpression e, Reko.Core.Hll.C.CTokenType token) -> Reko.Core.Hll.C.CExpression
Reko.Core.Hll.C.CGrammar.PreIncrement(Reko.Core.Hll.C.CTokenType token, Reko.Core.Hll.C.CExpression uexpr) -> Reko.Core.Hll.C.CExpression
Reko.Core.Hll.C.CGrammar.PtrMemberAccess(Reko.Core.Hll.C.CExpression e, string fieldName) -> Reko.Core.Hll.C.CExpression
Reko.Core.Hll.C.CGrammar.ReferenceDeclarator(Reko.Core.Hll.C.Declarator decl, System.Collections.Generic.List<Reko.Core.Hll.C.TypeQualifier> tqs) -> Reko.Core.Hll.C.Declarator
Reko.Core.Hll.C.CGrammar.ReturnStatement(Reko.Core.Hll.C.CExpression expr) -> Reko.Core.Hll.C.Stat
Reko.Core.Hll.C.CGrammar.SimpleType(Reko.Core.Hll.C.CTokenType type) -> Reko.Core.Hll.C.TypeSpec
Reko.Core.Hll.C.CGrammar.Sizeof(Reko.Core.Hll.C.CExpression sexp) -> Reko.Core.Hll.C.CExpression
Reko.Core.Hll.C.CGrammar.Sizeof(Reko.Core.Hll.C.CType type) -> Reko.Core.Hll.C.CExpression
Reko.Core.Hll.C.CGrammar.StorageClass(Reko.Core.Hll.C.CTokenType token) -> Reko.Core.Hll.C.DeclSpec
Reko.Core.Hll.C.CGrammar.StructDecl(System.Collections.Generic.List<Reko.Core.Hll.C.DeclSpec> sql, System.Collections.Generic.List<Reko.Core.Hll.C.FieldDeclarator> decls, System.Collections.Generic.List<Reko.Core.Hll.C.CAttribute> attrs) -> Reko.Core.Hll.C.StructDecl
Reko.Core.Hll.C.CGrammar.SwitchStatement(Reko.Core.Hll.C.CExpression expr, Reko.Core.Hll.C.Stat switchBody) -> Reko.Core.Hll.C.Stat
Reko.Core.Hll.C.CGrammar.TypeName(string name) -> Reko.Core.Hll.C.TypeSpec
Reko.Core.Hll.C.CGrammar.TypeQualifier(Reko.Core.Hll.C.CTokenType qualifier) -> Reko.Core.Hll.C.TypeQualifier
Reko.Core.Hll.C.CGrammar.Unary(Reko.Core.Hll.C.CTokenType operation, Reko.Core.Hll.C.CExpression expr) -> Reko.Core.Hll.C.CExpression
Reko.Core.Hll.C.CGrammar.WhileStatement(Reko.Core.Hll.C.CExpression expr, Reko.Core.Hll.C.Stat whileBody) -> Reko.Core.Hll.C.Stat
Reko.Core.Hll.C.CharacteristicsParser
Reko.Core.Hll.C.CharacteristicsParser.CharacteristicsParser(Reko.Core.Hll.C.CAttribute attrCharacteristics) -> void
Reko.Core.Hll.C.CharacteristicsParser.Parse() -> Reko.Core.Serialization.ProcedureCharacteristics
Reko.Core.Hll.C.CIdentifier
Reko.Core.Hll.C.CIdentifier.CIdentifier() -> void
Reko.Core.Hll.C.CIdentifier.Name -> string
Reko.Core.Hll.C.CLexer
Reko.Core.Hll.C.CLexer.CLexer(System.IO.TextReader rdr, System.Collections.Generic.Dictionary<string, Reko.Core.Hll.C.CTokenType> keywords) -> void
Reko.Core.Hll.C.CLexer.Current.get -> Reko.Core.Hll.C.CToken
Reko.Core.Hll.C.CLexer.Dispose() -> void
Reko.Core.Hll.C.CLexer.LineNumber.get -> int
Reko.Core.Hll.C.CLexer.MoveNext() -> bool
Reko.Core.Hll.C.CLexer.Read() -> Reko.Core.Hll.C.CToken
Reko.Core.Hll.C.CLexer.Reset() -> void
Reko.Core.Hll.C.CLexer.SkipToNextLine() -> void
Reko.Core.Hll.C.ComplexTypeSpec
Reko.Core.Hll.C.ComplexTypeSpec.Alignment -> int
Reko.Core.Hll.C.ComplexTypeSpec.ComplexTypeSpec() -> void
Reko.Core.Hll.C.ComplexTypeSpec.DeclList -> System.Collections.Generic.List<Reko.Core.Hll.C.StructDecl>
Reko.Core.Hll.C.ComplexTypeSpec.IsForwardDeclaration() -> bool
Reko.Core.Hll.C.ComplexTypeSpec.Name -> string
Reko.Core.Hll.C.ComplexTypeSpec.Type -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CompoundStatement
Reko.Core.Hll.C.CompoundStatement.CompoundStatement() -> void
Reko.Core.Hll.C.CompoundStatement.Statements -> System.Collections.Generic.List<Reko.Core.Hll.C.Stat>
Reko.Core.Hll.C.ConditionalExpression
Reko.Core.Hll.C.ConditionalExpression.Alternative -> Reko.Core.Hll.C.CExpression
Reko.Core.Hll.C.ConditionalExpression.Condition -> Reko.Core.Hll.C.CExpression
Reko.Core.Hll.C.ConditionalExpression.ConditionalExpression() -> void
Reko.Core.Hll.C.ConditionalExpression.Consequent -> Reko.Core.Hll.C.CExpression
Reko.Core.Hll.C.ConstExp
Reko.Core.Hll.C.ConstExp.Const -> object
Reko.Core.Hll.C.ConstExp.ConstExp() -> void
Reko.Core.Hll.C.CParser
Reko.Core.Hll.C.CParser.CParser(Reko.Core.Hll.C.ParserState parserState, Reko.Core.Hll.C.CLexer lexer) -> void
Reko.Core.Hll.C.CParser.IsTypeName(Reko.Core.Hll.C.CToken x) -> bool
Reko.Core.Hll.C.CParser.IsTypeName(string id) -> bool
Reko.Core.Hll.C.CParser.Parse() -> System.Collections.Generic.List<Reko.Core.Hll.C.Decl>
Reko.Core.Hll.C.CParser.ParserState.get -> Reko.Core.Hll.C.ParserState
Reko.Core.Hll.C.CParser.Parse_AddExpr() -> Reko.Core.Hll.C.CExpression
Reko.Core.Hll.C.CParser.Parse_AndExpr() -> Reko.Core.Hll.C.CExpression
Reko.Core.Hll.C.CParser.Parse_AssignExpr() -> Reko.Core.Hll.C.CExpression
Reko.Core.Hll.C.CParser.Parse_AttributeSpecifier() -> Reko.Core.Hll.C.CAttribute
Reko.Core.Hll.C.CParser.Parse_AttributeSpecifierSeq() -> System.Collections.Generic.List<Reko.Core.Hll.C.CAttribute>
Reko.Core.Hll.C.CParser.Parse_BalancedTokenSeq() -> System.Collections.Generic.List<Reko.Core.Hll.C.CToken>
Reko.Core.Hll.C.CParser.Parse_CastExpr() -> Reko.Core.Hll.C.CExpression
Reko.Core.Hll.C.CParser.Parse_CondExpr() -> Reko.Core.Hll.C.CExpression
Reko.Core.Hll.C.CParser.Parse_Decl() -> Reko.Core.Hll.C.Decl
Reko.Core.Hll.C.CParser.Parse_Declarator() -> Reko.Core.Hll.C.Declarator
Reko.Core.Hll.C.CParser.Parse_EqlExpr() -> Reko.Core.Hll.C.CExpression
Reko.Core.Hll.C.CParser.Parse_Expr() -> Reko.Core.Hll.C.CExpression
Reko.Core.Hll.C.CParser.Parse_ExternalDecl() -> Reko.Core.Hll.C.Decl
Reko.Core.Hll.C.CParser.Parse_GccAttributeSpecifier() -> System.Collections.Generic.List<Reko.Core.Hll.C.CAttribute>
Reko.Core.Hll.C.CParser.Parse_GccExtensions() -> System.Collections.Generic.List<Reko.Core.Hll.C.CAttribute>
Reko.Core.Hll.C.CParser.Parse_LogAndExpr() -> Reko.Core.Hll.C.CExpression
Reko.Core.Hll.C.CParser.Parse_LogOrExpr() -> Reko.Core.Hll.C.CExpression
Reko.Core.Hll.C.CParser.Parse_MultExpr() -> Reko.Core.Hll.C.CExpression
Reko.Core.Hll.C.CParser.Parse_OrExpr() -> Reko.Core.Hll.C.CExpression
Reko.Core.Hll.C.CParser.Parse_PostfixExpr() -> Reko.Core.Hll.C.CExpression
Reko.Core.Hll.C.CParser.Parse_Primary() -> Reko.Core.Hll.C.CExpression
Reko.Core.Hll.C.CParser.Parse_RelExpr() -> Reko.Core.Hll.C.CExpression
Reko.Core.Hll.C.CParser.Parse_ShiftExpr() -> Reko.Core.Hll.C.CExpression
Reko.Core.Hll.C.CParser.Parse_Stat() -> Reko.Core.Hll.C.Stat
Reko.Core.Hll.C.CParser.Parse_UnaryExpr() -> Reko.Core.Hll.C.CExpression
Reko.Core.Hll.C.CParser.Parse_XorExpr() -> Reko.Core.Hll.C.CExpression
Reko.Core.Hll.C.CParserException
Reko.Core.Hll.C.CParserException.CParserException(string message) -> void
Reko.Core.Hll.C.CSyntax
Reko.Core.Hll.C.CSyntax.CSyntax() -> void
Reko.Core.Hll.C.CSyntaxVisitor<T>
Reko.Core.Hll.C.CSyntaxVisitor<T>.VisitAttribute(Reko.Core.Hll.C.CAttribute cAttribute) -> T
Reko.Core.Hll.C.CSyntaxVisitor<T>.VisitDeclaration(Reko.Core.Hll.C.Decl decl) -> T
Reko.Core.Hll.C.CSyntaxVisitor<T>.VisitDeclSpec(Reko.Core.Hll.C.DeclSpec declSpec) -> T
Reko.Core.Hll.C.CSyntaxVisitor<T>.VisitEnumerator(Reko.Core.Hll.C.Enumerator enumerator) -> T
Reko.Core.Hll.C.CSyntaxVisitor<T>.VisitExpression(Reko.Core.Hll.C.CExpression stm) -> T
Reko.Core.Hll.C.CSyntaxVisitor<T>.VisitInitDeclarator(Reko.Core.Hll.C.InitDeclarator initDeclarator) -> T
Reko.Core.Hll.C.CSyntaxVisitor<T>.VisitParamDeclaration(Reko.Core.Hll.C.ParamDecl paramDecl) -> T
Reko.Core.Hll.C.CSyntaxVisitor<T>.VisitStatement(Reko.Core.Hll.C.Stat stm) -> T
Reko.Core.Hll.C.CSyntaxVisitor<T>.VisitType(Reko.Core.Hll.C.CType cType) -> T
Reko.Core.Hll.C.CToken
Reko.Core.Hll.C.CToken.CToken() -> void
Reko.Core.Hll.C.CToken.CToken(Reko.Core.Hll.C.CTokenType type) -> void
Reko.Core.Hll.C.CToken.CToken(Reko.Core.Hll.C.CTokenType type, object value) -> void
Reko.Core.Hll.C.CToken.Type.get -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CToken.Value.get -> object
Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.Ampersand = 8 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.AndAssign = 17 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.Arrow = 46 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.Assign = 9 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.Auto = 50 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.Bang = 44 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.Bool = 51 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.Break = 115 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.Case = 52 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.Char = 53 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.CharLiteral = 5 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.Class = 54 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.Colon = 34 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.ColonColon = 35 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.Comma = 37 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.Const = 55 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.Continue = 114 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.Decrement = 48 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.Default = 56 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.DivAssign = 11 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.Do = 111 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.Dot = 45 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.Double = 57 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.Ellipsis = 117 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.Else = 58 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.Enum = 59 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.EOF = -1 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.Eq = 20 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.Extern = 60 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.Float = 61 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.For = 112 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.Ge = 24 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.Goto = 113 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.Gt = 25 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.Hash = 118 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.Id = 7 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.If = 116 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.Increment = 47 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.Int = 62 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.LBrace = 26 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.LBracket = 28 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.Le = 23 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.LogicalAnd = 63 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.LogicalOr = 64 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.Long = 65 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.LParen = 30 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.Lt = 22 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.Minus = 42 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.MinusAssign = 14 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.ModAssign = 12 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.MulAssign = 10 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.Ne = 21 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.NewLine = 119 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.None = 0 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.NumericLiteral = 1 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.OrAssign = 18 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.Percent = 40 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.Pipe = 49 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.Plus = 41 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.PlusAssign = 13 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.Question = 66 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.RBrace = 27 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.RBracket = 29 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.RealLiteral = 4 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.Register = 67 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.Restrict = 69 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.Return = 68 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.RParen = 31 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.Semicolon = 36 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.Shl = 32 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.ShlAssign = 15 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.Short = 70 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.Shr = 33 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.ShrAssign = 16 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.Signed = 71 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.Sizeof = 72 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.Slash = 39 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.Star = 38 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.Static = 73 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.StringLiteral = 2 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.Struct = 74 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.Switch = 109 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.Tilde = 43 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.Typedef = 75 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.Union = 76 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.Unsigned = 77 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.Void = 78 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.Volatile = 79 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.Wchar_t = 80 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.While = 110 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.WideCharLiteral = 6 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.WideStringLiteral = 3 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.Xor = 81 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.XorAssign = 19 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType._Atomic = 82 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType._Bool = 83 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType._Far = 84 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType._Huge = 85 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType._Near = 86 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.__Asm = 87 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.__Attribute = 88 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.__Cdecl = 89 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.__Declspec = 90 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.__Extension = 91 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.__Fastcall = 92 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.__ForceInline = 93 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.__In = 94 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.__Inline = 96 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.__Int64 = 97 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.__In_Opt = 95 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.__LoadDs = 98 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.__Out = 99 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.__Out_Bcount_Opt = 100 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.__Pascal = 101 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.__Pragma = 102 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.__Ptr64 = 103 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.__Stdcall = 104 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.__Success = 105 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.__Thiscall = 106 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.__Unaligned = 107 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CTokenType.__W64 = 108 -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.CType
Reko.Core.Hll.C.CType.CType() -> void
Reko.Core.Hll.C.CType.Declarator -> Reko.Core.Hll.C.Declarator
Reko.Core.Hll.C.CType.DeclSpecList -> System.Collections.Generic.List<Reko.Core.Hll.C.DeclSpec>
Reko.Core.Hll.C.CUnaryExpression
Reko.Core.Hll.C.CUnaryExpression.CUnaryExpression() -> void
Reko.Core.Hll.C.CUnaryExpression.Expression -> Reko.Core.Hll.C.CExpression
Reko.Core.Hll.C.CUnaryExpression.Operation -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.Decl
~Reko.Core.Hll.C.Decl.attribute_list -> System.Collections.Generic.List<Reko.Core.Hll.C.CAttribute>
Reko.Core.Hll.C.Decl.Decl() -> void
Reko.Core.Hll.C.Decl.decl_specs -> System.Collections.Generic.List<Reko.Core.Hll.C.DeclSpec>
Reko.Core.Hll.C.Decl.init_declarator_list -> System.Collections.Generic.List<Reko.Core.Hll.C.InitDeclarator>
Reko.Core.Hll.C.Declarator
Reko.Core.Hll.C.Declarator.Declarator() -> void
Reko.Core.Hll.C.DeclaratorVisitor<T>
Reko.Core.Hll.C.DeclaratorVisitor<T>.VisitArray(Reko.Core.Hll.C.ArrayDeclarator array) -> T
Reko.Core.Hll.C.DeclaratorVisitor<T>.VisitCallConvention(Reko.Core.Hll.C.CallConventionDeclarator callConvention) -> T
Reko.Core.Hll.C.DeclaratorVisitor<T>.VisitField(Reko.Core.Hll.C.FieldDeclarator field) -> T
Reko.Core.Hll.C.DeclaratorVisitor<T>.VisitFunction(Reko.Core.Hll.C.FunctionDeclarator function) -> T
Reko.Core.Hll.C.DeclaratorVisitor<T>.VisitId(Reko.Core.Hll.C.IdDeclarator idDeclarator) -> T
Reko.Core.Hll.C.DeclaratorVisitor<T>.VisitPointer(Reko.Core.Hll.C.PointerDeclarator pointer) -> T
Reko.Core.Hll.C.DeclaratorVisitor<T>.VisitReference(Reko.Core.Hll.C.ReferenceDeclarator pointer) -> T
Reko.Core.Hll.C.DeclSpec
Reko.Core.Hll.C.DeclSpec.DeclSpec() -> void
Reko.Core.Hll.C.DeclSpecVisitor<T>
Reko.Core.Hll.C.DeclSpecVisitor<T>.VisitComplexType(Reko.Core.Hll.C.ComplexTypeSpec complexType) -> T
Reko.Core.Hll.C.DeclSpecVisitor<T>.VisitEnum(Reko.Core.Hll.C.EnumeratorTypeSpec enumeratorTypeSpec) -> T
Reko.Core.Hll.C.DeclSpecVisitor<T>.VisitExtendedDeclspec(Reko.Core.Hll.C.ExtendedDeclspec extendedDeclspec) -> T
Reko.Core.Hll.C.DeclSpecVisitor<T>.VisitSimpleType(Reko.Core.Hll.C.SimpleTypeSpec simpleType) -> T
Reko.Core.Hll.C.DeclSpecVisitor<T>.VisitStorageClass(Reko.Core.Hll.C.StorageClassSpec storageClass) -> T
Reko.Core.Hll.C.DeclSpecVisitor<T>.VisitTypedef(Reko.Core.Hll.C.TypeDefName typeDefName) -> T
Reko.Core.Hll.C.DeclSpecVisitor<T>.VisitTypeQualifier(Reko.Core.Hll.C.TypeQualifier typeQualifier) -> T
Reko.Core.Hll.C.DeclStat
Reko.Core.Hll.C.DeclStat.Declaration -> Reko.Core.Hll.C.Decl
Reko.Core.Hll.C.DeclStat.DeclStat() -> void
Reko.Core.Hll.C.DeclStat.Initializer -> Reko.Core.Hll.C.CExpression
Reko.Core.Hll.C.DoWhileStat
Reko.Core.Hll.C.DoWhileStat.Body -> Reko.Core.Hll.C.Stat
Reko.Core.Hll.C.DoWhileStat.DoWhileStat() -> void
Reko.Core.Hll.C.DoWhileStat.Expression -> Reko.Core.Hll.C.CExpression
Reko.Core.Hll.C.Enumerator
Reko.Core.Hll.C.Enumerator.Enumerator() -> void
Reko.Core.Hll.C.Enumerator.Name -> string
Reko.Core.Hll.C.Enumerator.Value -> Reko.Core.Hll.C.CExpression
Reko.Core.Hll.C.EnumeratorTypeSpec
Reko.Core.Hll.C.EnumeratorTypeSpec.EnumeratorTypeSpec() -> void
Reko.Core.Hll.C.EnumeratorTypeSpec.Enums -> System.Collections.Generic.List<Reko.Core.Hll.C.Enumerator>
Reko.Core.Hll.C.EnumeratorTypeSpec.Tag -> string
Reko.Core.Hll.C.EnumEvaluator
Reko.Core.Hll.C.EnumEvaluator.EnumEvaluator(Reko.Core.Hll.C.CConstantEvaluator ceval) -> void
Reko.Core.Hll.C.EnumEvaluator.GetValue(Reko.Core.Hll.C.CExpression cExpression) -> int
Reko.Core.Hll.C.ExpressionInitializer
Reko.Core.Hll.C.ExpressionInitializer.Expression -> Reko.Core.Hll.C.CExpression
Reko.Core.Hll.C.ExpressionInitializer.ExpressionInitializer() -> void
Reko.Core.Hll.C.ExprStat
Reko.Core.Hll.C.ExprStat.Expression -> Reko.Core.Hll.C.CExpression
Reko.Core.Hll.C.ExprStat.ExprStat() -> void
Reko.Core.Hll.C.ExtendedDeclspec
Reko.Core.Hll.C.ExtendedDeclspec.ExtendedDeclspec() -> void
Reko.Core.Hll.C.ExtendedDeclspec.Name -> string
Reko.Core.Hll.C.FieldDeclarator
Reko.Core.Hll.C.FieldDeclarator.Declarator -> Reko.Core.Hll.C.Declarator
Reko.Core.Hll.C.FieldDeclarator.FieldDeclarator() -> void
Reko.Core.Hll.C.FieldDeclarator.FieldSize -> Reko.Core.Hll.C.CExpression
Reko.Core.Hll.C.ForStat
Reko.Core.Hll.C.ForStat.Body -> Reko.Core.Hll.C.Stat
Reko.Core.Hll.C.ForStat.ForStat() -> void
Reko.Core.Hll.C.ForStat.Initializer -> Reko.Core.Hll.C.Stat
Reko.Core.Hll.C.ForStat.Test -> Reko.Core.Hll.C.CExpression
Reko.Core.Hll.C.ForStat.Update -> Reko.Core.Hll.C.CExpression
Reko.Core.Hll.C.FunctionDecl
Reko.Core.Hll.C.FunctionDecl.Body -> System.Collections.Generic.List<Reko.Core.Hll.C.Stat>
Reko.Core.Hll.C.FunctionDecl.calling_convention -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.FunctionDecl.FunctionDecl() -> void
Reko.Core.Hll.C.FunctionDecl.Signature -> Reko.Core.Hll.C.Decl
Reko.Core.Hll.C.FunctionDeclarator
Reko.Core.Hll.C.FunctionDeclarator.Declarator -> Reko.Core.Hll.C.Declarator
Reko.Core.Hll.C.FunctionDeclarator.FunctionDeclarator() -> void
Reko.Core.Hll.C.FunctionDeclarator.Parameters -> System.Collections.Generic.List<Reko.Core.Hll.C.ParamDecl>
Reko.Core.Hll.C.GotoStat
Reko.Core.Hll.C.GotoStat.GotoStat() -> void
Reko.Core.Hll.C.GotoStat.Label -> string
Reko.Core.Hll.C.IdDeclarator
Reko.Core.Hll.C.IdDeclarator.IdDeclarator() -> void
Reko.Core.Hll.C.IdDeclarator.Name -> string
Reko.Core.Hll.C.IfStat
Reko.Core.Hll.C.IfStat.Alternative -> Reko.Core.Hll.C.Stat
Reko.Core.Hll.C.IfStat.Consequence -> Reko.Core.Hll.C.Stat
Reko.Core.Hll.C.IfStat.Expression -> Reko.Core.Hll.C.CExpression
Reko.Core.Hll.C.IfStat.IfStat() -> void
Reko.Core.Hll.C.IncrementExpression
Reko.Core.Hll.C.IncrementExpression.Expression -> Reko.Core.Hll.C.CExpression
Reko.Core.Hll.C.IncrementExpression.IncrementExpression() -> void
Reko.Core.Hll.C.IncrementExpression.Incrementor -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.IncrementExpression.Prefix -> bool
Reko.Core.Hll.C.InitDeclarator
Reko.Core.Hll.C.InitDeclarator.Declarator -> Reko.Core.Hll.C.Declarator
Reko.Core.Hll.C.InitDeclarator.Init -> Reko.Core.Hll.C.Initializer
Reko.Core.Hll.C.InitDeclarator.InitDeclarator() -> void
Reko.Core.Hll.C.Initializer
Reko.Core.Hll.C.Initializer.Initializer() -> void
Reko.Core.Hll.C.Label
Reko.Core.Hll.C.Label.Label() -> void
Reko.Core.Hll.C.LabeledStat
Reko.Core.Hll.C.LabeledStat.Label -> Reko.Core.Hll.C.Label
Reko.Core.Hll.C.LabeledStat.LabeledStat() -> void
Reko.Core.Hll.C.LabeledStat.Stat -> Reko.Core.Hll.C.Stat
Reko.Core.Hll.C.LineLabel
Reko.Core.Hll.C.LineLabel.LineLabel() -> void
Reko.Core.Hll.C.LineLabel.Name -> string
Reko.Core.Hll.C.ListInitializer
Reko.Core.Hll.C.ListInitializer.List.get -> System.Collections.Generic.List<Reko.Core.Hll.C.Initializer>
Reko.Core.Hll.C.ListInitializer.ListInitializer() -> void
Reko.Core.Hll.C.LookAheadLexer
Reko.Core.Hll.C.LookAheadLexer.LineNumber.get -> int
Reko.Core.Hll.C.LookAheadLexer.LookAheadLexer(Reko.Core.Hll.C.StringConcatenator sc) -> void
Reko.Core.Hll.C.LookAheadLexer.Peek(int n) -> Reko.Core.Hll.C.CToken
Reko.Core.Hll.C.LookAheadLexer.Read() -> Reko.Core.Hll.C.CToken
Reko.Core.Hll.C.MemberExpression
Reko.Core.Hll.C.MemberExpression.Dereference -> bool
Reko.Core.Hll.C.MemberExpression.Expression -> Reko.Core.Hll.C.CExpression
Reko.Core.Hll.C.MemberExpression.FieldName -> string
Reko.Core.Hll.C.MemberExpression.MemberExpression() -> void
Reko.Core.Hll.C.NamedDataType
Reko.Core.Hll.C.NamedDataType.DataType.get -> Reko.Core.Serialization.SerializedType
Reko.Core.Hll.C.NamedDataType.DataType.set -> void
Reko.Core.Hll.C.NamedDataType.Name.get -> string
Reko.Core.Hll.C.NamedDataType.Name.set -> void
Reko.Core.Hll.C.NamedDataType.NamedDataType() -> void
Reko.Core.Hll.C.NamedDataType.Size.get -> int
Reko.Core.Hll.C.NamedDataType.Size.set -> void
Reko.Core.Hll.C.NamedDataTypeExtractor
Reko.Core.Hll.C.NamedDataTypeExtractor.GetArgumentKindFromAttributes(string paramType, System.Collections.Generic.List<Reko.Core.Hll.C.CAttribute> attrs) -> Reko.Core.Serialization.SerializedKind
Reko.Core.Hll.C.NamedDataTypeExtractor.GetNameAndType(Reko.Core.Hll.C.Declarator declarator) -> Reko.Core.Hll.C.NamedDataType
Reko.Core.Hll.C.NamedDataTypeExtractor.NamedDataTypeExtractor(Reko.Core.IPlatform platform, System.Collections.Generic.IEnumerable<Reko.Core.Hll.C.DeclSpec> specs, Reko.Core.Hll.C.SymbolTable symbolTyable, int pointerSize) -> void
Reko.Core.Hll.C.NamedDataTypeExtractor.VisitArray(Reko.Core.Hll.C.ArrayDeclarator array) -> System.Func<Reko.Core.Hll.C.NamedDataType, Reko.Core.Hll.C.NamedDataType>
Reko.Core.Hll.C.NamedDataTypeExtractor.VisitCallConvention(Reko.Core.Hll.C.CallConventionDeclarator conv) -> System.Func<Reko.Core.Hll.C.NamedDataType, Reko.Core.Hll.C.NamedDataType>
Reko.Core.Hll.C.NamedDataTypeExtractor.VisitComplexType(Reko.Core.Hll.C.ComplexTypeSpec complexType) -> Reko.Core.Serialization.SerializedType
Reko.Core.Hll.C.NamedDataTypeExtractor.VisitEnum(Reko.Core.Hll.C.EnumeratorTypeSpec e) -> Reko.Core.Serialization.SerializedType
Reko.Core.Hll.C.NamedDataTypeExtractor.VisitExtendedDeclspec(Reko.Core.Hll.C.ExtendedDeclspec declspec) -> Reko.Core.Serialization.SerializedType
Reko.Core.Hll.C.NamedDataTypeExtractor.VisitField(Reko.Core.Hll.C.FieldDeclarator field) -> System.Func<Reko.Core.Hll.C.NamedDataType, Reko.Core.Hll.C.NamedDataType>
Reko.Core.Hll.C.NamedDataTypeExtractor.VisitFunction(Reko.Core.Hll.C.FunctionDeclarator function) -> System.Func<Reko.Core.Hll.C.NamedDataType, Reko.Core.Hll.C.NamedDataType>
Reko.Core.Hll.C.NamedDataTypeExtractor.VisitId(Reko.Core.Hll.C.IdDeclarator id) -> System.Func<Reko.Core.Hll.C.NamedDataType, Reko.Core.Hll.C.NamedDataType>
Reko.Core.Hll.C.NamedDataTypeExtractor.VisitPointer(Reko.Core.Hll.C.PointerDeclarator pointer) -> System.Func<Reko.Core.Hll.C.NamedDataType, Reko.Core.Hll.C.NamedDataType>
Reko.Core.Hll.C.NamedDataTypeExtractor.VisitReference(Reko.Core.Hll.C.ReferenceDeclarator reference) -> System.Func<Reko.Core.Hll.C.NamedDataType, Reko.Core.Hll.C.NamedDataType>
Reko.Core.Hll.C.NamedDataTypeExtractor.VisitSimpleType(Reko.Core.Hll.C.SimpleTypeSpec simpleType) -> Reko.Core.Serialization.SerializedType
Reko.Core.Hll.C.NamedDataTypeExtractor.VisitStorageClass(Reko.Core.Hll.C.StorageClassSpec storageClassSpec) -> Reko.Core.Serialization.SerializedType
Reko.Core.Hll.C.NamedDataTypeExtractor.VisitTypedef(Reko.Core.Hll.C.TypeDefName typeDefName) -> Reko.Core.Serialization.SerializedType
Reko.Core.Hll.C.NamedDataTypeExtractor.VisitTypeQualifier(Reko.Core.Hll.C.TypeQualifier typeQualifier) -> Reko.Core.Serialization.SerializedType
Reko.Core.Hll.C.NameExtractor
Reko.Core.Hll.C.NameExtractor.NameExtractor() -> void
Reko.Core.Hll.C.NameExtractor.VisitArray(Reko.Core.Hll.C.ArrayDeclarator array) -> string
Reko.Core.Hll.C.NameExtractor.VisitCallConvention(Reko.Core.Hll.C.CallConventionDeclarator callConvention) -> string
Reko.Core.Hll.C.NameExtractor.VisitField(Reko.Core.Hll.C.FieldDeclarator field) -> string
Reko.Core.Hll.C.NameExtractor.VisitFunction(Reko.Core.Hll.C.FunctionDeclarator function) -> string
Reko.Core.Hll.C.NameExtractor.VisitId(Reko.Core.Hll.C.IdDeclarator id) -> string
Reko.Core.Hll.C.NameExtractor.VisitPointer(Reko.Core.Hll.C.PointerDeclarator pointer) -> string
Reko.Core.Hll.C.NameExtractor.VisitReference(Reko.Core.Hll.C.ReferenceDeclarator reference) -> string
Reko.Core.Hll.C.ParamDecl
Reko.Core.Hll.C.ParamDecl.Attributes -> System.Collections.Generic.List<Reko.Core.Hll.C.CAttribute>
Reko.Core.Hll.C.ParamDecl.Declarator -> Reko.Core.Hll.C.Declarator
Reko.Core.Hll.C.ParamDecl.DeclSpecs -> System.Collections.Generic.List<Reko.Core.Hll.C.DeclSpec>
Reko.Core.Hll.C.ParamDecl.IsEllipsis -> bool
Reko.Core.Hll.C.ParamDecl.ParamDecl() -> void
Reko.Core.Hll.C.ParseResult
Reko.Core.Hll.C.ParseResult<T>
Reko.Core.Hll.C.ParseResult<T>.ParseResult(string error) -> void
Reko.Core.Hll.C.ParseResult<T>.ParseResult(T result) -> void
Reko.Core.Hll.C.ParseResult<T>.Result.get -> T
Reko.Core.Hll.C.ParserState
Reko.Core.Hll.C.ParserState.Alignment.get -> int
Reko.Core.Hll.C.ParserState.ParserState() -> void
Reko.Core.Hll.C.ParserState.ParserState(Reko.Core.Hll.C.SymbolTable symbolTable) -> void
Reko.Core.Hll.C.ParserState.PopAlignment() -> void
Reko.Core.Hll.C.ParserState.PushAlignment(int align) -> void
Reko.Core.Hll.C.ParserState.Typedefs.get -> System.Collections.Generic.HashSet<string>
Reko.Core.Hll.C.PointerDeclarator
Reko.Core.Hll.C.PointerDeclarator.Pointee -> Reko.Core.Hll.C.Declarator
Reko.Core.Hll.C.PointerDeclarator.PointerDeclarator() -> void
Reko.Core.Hll.C.PointerDeclarator.TypeQualifierList -> System.Collections.Generic.List<Reko.Core.Hll.C.TypeQualifier>
Reko.Core.Hll.C.QualifiedName
Reko.Core.Hll.C.QualifiedName.Components -> string[]
Reko.Core.Hll.C.QualifiedName.QualifiedName() -> void
Reko.Core.Hll.C.QualifiedName.QualifiedName(params string[] components) -> void
Reko.Core.Hll.C.ReferenceDeclarator
Reko.Core.Hll.C.ReferenceDeclarator.ReferenceDeclarator() -> void
Reko.Core.Hll.C.ReferenceDeclarator.Referent -> Reko.Core.Hll.C.Declarator
Reko.Core.Hll.C.ReferenceDeclarator.TypeQualifierList -> System.Collections.Generic.List<Reko.Core.Hll.C.TypeQualifier>
Reko.Core.Hll.C.ReturnStat
Reko.Core.Hll.C.ReturnStat.Expression -> Reko.Core.Hll.C.CExpression
Reko.Core.Hll.C.ReturnStat.ReturnStat() -> void
Reko.Core.Hll.C.SerializedTypeComparer
Reko.Core.Hll.C.SerializedTypeComparer.Equals(Reko.Core.Serialization.SerializedType x, Reko.Core.Serialization.SerializedType y) -> bool
Reko.Core.Hll.C.SerializedTypeComparer.GetHashCode(Reko.Core.Serialization.SerializedType obj) -> int
Reko.Core.Hll.C.SerializedTypeComparer.SerializedTypeComparer() -> void
Reko.Core.Hll.C.SerializedTypeComparer.VisitArray(Reko.Core.Serialization.ArrayType_v1 aX) -> bool
Reko.Core.Hll.C.SerializedTypeComparer.VisitCode(Reko.Core.Serialization.CodeType_v1 code) -> bool
Reko.Core.Hll.C.SerializedTypeComparer.VisitEnum(Reko.Core.Serialization.SerializedEnumType e) -> bool
Reko.Core.Hll.C.SerializedTypeComparer.VisitMemberPointer(Reko.Core.Serialization.MemberPointer_v1 mpX) -> bool
Reko.Core.Hll.C.SerializedTypeComparer.VisitPointer(Reko.Core.Serialization.PointerType_v1 pX) -> bool
Reko.Core.Hll.C.SerializedTypeComparer.VisitPrimitive(Reko.Core.Serialization.PrimitiveType_v1 pX) -> bool
Reko.Core.Hll.C.SerializedTypeComparer.VisitReference(Reko.Core.Serialization.ReferenceType_v1 rX) -> bool
Reko.Core.Hll.C.SerializedTypeComparer.VisitSignature(Reko.Core.Serialization.SerializedSignature signature) -> bool
Reko.Core.Hll.C.SerializedTypeComparer.VisitString(Reko.Core.Serialization.StringType_v2 typedef) -> bool
Reko.Core.Hll.C.SerializedTypeComparer.VisitStructure(Reko.Core.Serialization.StructType_v1 sX) -> bool
Reko.Core.Hll.C.SerializedTypeComparer.VisitTemplate(Reko.Core.Serialization.SerializedTemplate template) -> bool
Reko.Core.Hll.C.SerializedTypeComparer.VisitTypedef(Reko.Core.Serialization.SerializedTypedef typedef) -> bool
Reko.Core.Hll.C.SerializedTypeComparer.VisitTypeReference(Reko.Core.Serialization.TypeReference_v1 typeReference) -> bool
Reko.Core.Hll.C.SerializedTypeComparer.VisitUnion(Reko.Core.Serialization.UnionType_v1 uX) -> bool
Reko.Core.Hll.C.SerializedTypeComparer.VisitVoidType(Reko.Core.Serialization.VoidType_v1 vX) -> bool
Reko.Core.Hll.C.ServiceAttributeParser
Reko.Core.Hll.C.ServiceAttributeParser.Parse() -> Reko.Core.Serialization.SyscallInfo_v1
Reko.Core.Hll.C.ServiceAttributeParser.ServiceAttributeParser(Reko.Core.Hll.C.CAttribute attrService) -> void
Reko.Core.Hll.C.SimpleTypeSpec
Reko.Core.Hll.C.SimpleTypeSpec.SimpleTypeSpec() -> void
Reko.Core.Hll.C.SimpleTypeSpec.Type -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.SizeofExpression
Reko.Core.Hll.C.SizeofExpression.Expression -> Reko.Core.Hll.C.CExpression
Reko.Core.Hll.C.SizeofExpression.SizeofExpression() -> void
Reko.Core.Hll.C.SizeofExpression.Type -> Reko.Core.Hll.C.CType
Reko.Core.Hll.C.Stat
Reko.Core.Hll.C.Stat.Stat() -> void
Reko.Core.Hll.C.StorageClassSpec
Reko.Core.Hll.C.StorageClassSpec.StorageClassSpec() -> void
Reko.Core.Hll.C.StorageClassSpec.Type -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.StringConcatenator
Reko.Core.Hll.C.StringConcatenator.LineNumber.get -> int
Reko.Core.Hll.C.StringConcatenator.Read() -> Reko.Core.Hll.C.CToken
Reko.Core.Hll.C.StringConcatenator.StringConcatenator(Reko.Core.Hll.C.CDirectiveLexer lexer) -> void
Reko.Core.Hll.C.StructDecl
Reko.Core.Hll.C.StructDecl.AttributeList -> System.Collections.Generic.List<Reko.Core.Hll.C.CAttribute>
Reko.Core.Hll.C.StructDecl.FieldDeclarators -> System.Collections.Generic.List<Reko.Core.Hll.C.FieldDeclarator>
Reko.Core.Hll.C.StructDecl.SpecQualifierList -> System.Collections.Generic.List<Reko.Core.Hll.C.DeclSpec>
Reko.Core.Hll.C.StructDecl.StructDecl() -> void
Reko.Core.Hll.C.SymbolTable
Reko.Core.Hll.C.SymbolTable.AddDeclaration(Reko.Core.Hll.C.Decl decl) -> System.Collections.Generic.List<Reko.Core.Serialization.SerializedType>
Reko.Core.Hll.C.SymbolTable.Constants.get -> System.Collections.Generic.Dictionary<string, int>
Reko.Core.Hll.C.SymbolTable.EnumsSeen.get -> System.Collections.Generic.Dictionary<string, Reko.Core.Serialization.SerializedEnumType>
Reko.Core.Hll.C.SymbolTable.NamedTypes.get -> System.Collections.Generic.Dictionary<string, Reko.Core.Serialization.SerializedType>
Reko.Core.Hll.C.SymbolTable.PrimitiveTypes.get -> System.Collections.Generic.Dictionary<string, Reko.Core.Serialization.PrimitiveType_v1>
Reko.Core.Hll.C.SymbolTable.Procedures.get -> System.Collections.Generic.List<Reko.Core.Serialization.ProcedureBase_v1>
Reko.Core.Hll.C.SymbolTable.Sizer.get -> Reko.Core.Hll.C.TypeSizer
Reko.Core.Hll.C.SymbolTable.StructsSeen.get -> System.Collections.Generic.Dictionary<string, Reko.Core.Serialization.StructType_v1>
Reko.Core.Hll.C.SymbolTable.SymbolTable(Reko.Core.IPlatform platform) -> void
Reko.Core.Hll.C.SymbolTable.SymbolTable(Reko.Core.IPlatform platform, int pointerSize) -> void
Reko.Core.Hll.C.SymbolTable.SymbolTable(Reko.Core.IPlatform platform, System.Collections.Generic.Dictionary<string, Reko.Core.Serialization.PrimitiveType_v1> primitiveTypes, System.Collections.Generic.Dictionary<string, Reko.Core.Serialization.SerializedType> namedTypes) -> void
Reko.Core.Hll.C.SymbolTable.Types.get -> System.Collections.Generic.List<Reko.Core.Serialization.SerializedType>
Reko.Core.Hll.C.SymbolTable.UnionsSeen.get -> System.Collections.Generic.Dictionary<string, Reko.Core.Serialization.UnionType_v1>
Reko.Core.Hll.C.SymbolTable.Variables.get -> System.Collections.Generic.List<Reko.Core.Serialization.GlobalDataItem_v2>
Reko.Core.Hll.C.TypeDefName
Reko.Core.Hll.C.TypeDefName.Name -> string
Reko.Core.Hll.C.TypeDefName.TypeDefName() -> void
Reko.Core.Hll.C.TypeQualifier
Reko.Core.Hll.C.TypeQualifier.Qualifier -> Reko.Core.Hll.C.CTokenType
Reko.Core.Hll.C.TypeQualifier.TypeQualifier() -> void
Reko.Core.Hll.C.TypeSizer
Reko.Core.Hll.C.TypeSizer.SetSize(Reko.Core.Serialization.SerializedTaggedType str, int structureAlignment) -> void
Reko.Core.Hll.C.TypeSizer.TypeSizer(Reko.Core.IPlatform platform, System.Collections.Generic.IDictionary<string, Reko.Core.Serialization.SerializedType> typedefs) -> void
Reko.Core.Hll.C.TypeSizer.VisitArray(Reko.Core.Serialization.ArrayType_v1 array) -> (int, int)
Reko.Core.Hll.C.TypeSizer.VisitCode(Reko.Core.Serialization.CodeType_v1 code) -> (int, int)
Reko.Core.Hll.C.TypeSizer.VisitEnum(Reko.Core.Serialization.SerializedEnumType e) -> (int, int)
Reko.Core.Hll.C.TypeSizer.VisitMemberPointer(Reko.Core.Serialization.MemberPointer_v1 memptr) -> (int, int)
Reko.Core.Hll.C.TypeSizer.VisitPointer(Reko.Core.Serialization.PointerType_v1 pointer) -> (int, int)
Reko.Core.Hll.C.TypeSizer.VisitPrimitive(Reko.Core.Serialization.PrimitiveType_v1 primitive) -> (int, int)
Reko.Core.Hll.C.TypeSizer.VisitReference(Reko.Core.Serialization.ReferenceType_v1 pointer) -> (int, int)
Reko.Core.Hll.C.TypeSizer.VisitSignature(Reko.Core.Serialization.SerializedSignature signature) -> (int, int)
Reko.Core.Hll.C.TypeSizer.VisitString(Reko.Core.Serialization.StringType_v2 str) -> (int, int)
Reko.Core.Hll.C.TypeSizer.VisitStructure(Reko.Core.Serialization.StructType_v1 structure) -> (int, int)
Reko.Core.Hll.C.TypeSizer.VisitTemplate(Reko.Core.Serialization.SerializedTemplate template) -> (int, int)
Reko.Core.Hll.C.TypeSizer.VisitTypedef(Reko.Core.Serialization.SerializedTypedef typedef) -> (int, int)
Reko.Core.Hll.C.TypeSizer.VisitTypeReference(Reko.Core.Serialization.TypeReference_v1 typeReference) -> (int, int)
Reko.Core.Hll.C.TypeSizer.VisitUnion(Reko.Core.Serialization.UnionType_v1 union) -> (int, int)
Reko.Core.Hll.C.TypeSizer.VisitVoidType(Reko.Core.Serialization.VoidType_v1 voidType) -> (int, int)
Reko.Core.Hll.C.TypeSpec
Reko.Core.Hll.C.TypeSpec.TypeSpec() -> void
Reko.Core.Hll.C.UserSignatureBuilder
Reko.Core.Hll.C.UserSignatureBuilder.BuildSignature(Reko.Core.Address addr, Reko.Core.Procedure proc) -> void
Reko.Core.Hll.C.UserSignatureBuilder.BuildSignatures(Reko.Core.Services.DecompilerEventListener listener) -> void
Reko.Core.Hll.C.UserSignatureBuilder.DeserializeSignature(Reko.Core.UserProcedure userProc, Reko.Core.Procedure proc) -> Reko.Core.Serialization.ProcedureBase_v1
Reko.Core.Hll.C.UserSignatureBuilder.ParseFunctionDeclaration(string fnDecl) -> Reko.Core.Serialization.ProcedureBase_v1
Reko.Core.Hll.C.UserSignatureBuilder.ParseGlobalDeclaration(string txtGlobal) -> Reko.Core.Serialization.GlobalDataItem_v2
Reko.Core.Hll.C.UserSignatureBuilder.UserSignatureBuilder(Reko.Core.Program program) -> void
Reko.Core.Hll.C.WhileStat
Reko.Core.Hll.C.WhileStat.Body -> Reko.Core.Hll.C.Stat
Reko.Core.Hll.C.WhileStat.Expression -> Reko.Core.Hll.C.CExpression
Reko.Core.Hll.C.WhileStat.WhileStat() -> void
Reko.Core.Hll.Pascal.Array
Reko.Core.Hll.Pascal.Array.Array(Reko.Core.Hll.Pascal.PascalType elemType, System.Collections.Generic.List<Reko.Core.Hll.Pascal.ArrayDimension> dims) -> void
Reko.Core.Hll.Pascal.Array.Dimensions.get -> System.Collections.Generic.List<Reko.Core.Hll.Pascal.ArrayDimension>
Reko.Core.Hll.Pascal.Array.ElementType.get -> Reko.Core.Hll.Pascal.PascalType
Reko.Core.Hll.Pascal.Array.Packed -> bool
Reko.Core.Hll.Pascal.ArrayDimension
Reko.Core.Hll.Pascal.ArrayDimension.ArrayDimension() -> void
Reko.Core.Hll.Pascal.ArrayDimension.High -> Reko.Core.Hll.Pascal.Exp
Reko.Core.Hll.Pascal.ArrayDimension.Low -> Reko.Core.Hll.Pascal.Exp
Reko.Core.Hll.Pascal.BinExp
Reko.Core.Hll.Pascal.BinExp.BinExp(Reko.Core.Hll.Pascal.TokenType op, Reko.Core.Hll.Pascal.Exp left, Reko.Core.Hll.Pascal.Exp right) -> void
Reko.Core.Hll.Pascal.BinExp.Left -> Reko.Core.Hll.Pascal.Exp
Reko.Core.Hll.Pascal.BinExp.Op -> Reko.Core.Hll.Pascal.TokenType
Reko.Core.Hll.Pascal.BinExp.Right -> Reko.Core.Hll.Pascal.Exp
Reko.Core.Hll.Pascal.Block
Reko.Core.Hll.Pascal.Block.Block() -> void
Reko.Core.Hll.Pascal.BooleanLiteral
Reko.Core.Hll.Pascal.BooleanLiteral.BooleanLiteral(bool value) -> void
Reko.Core.Hll.Pascal.BooleanLiteral.Value -> bool
Reko.Core.Hll.Pascal.CallableDeclaration
Reko.Core.Hll.Pascal.CallableDeclaration.Body.get -> Reko.Core.Hll.Pascal.Block
Reko.Core.Hll.Pascal.CallableDeclaration.Body.set -> void
Reko.Core.Hll.Pascal.CallableDeclaration.CallableDeclaration(string name, Reko.Core.Hll.Pascal.PascalType retType, System.Collections.Generic.List<Reko.Core.Hll.Pascal.ParameterDeclaration> parameters) -> void
Reko.Core.Hll.Pascal.CallableDeclaration.CallingConvention.get -> string
Reko.Core.Hll.Pascal.CallableDeclaration.CallingConvention.set -> void
Reko.Core.Hll.Pascal.CallableDeclaration.Parameters -> System.Collections.Generic.List<Reko.Core.Hll.Pascal.ParameterDeclaration>
Reko.Core.Hll.Pascal.CallableDeclaration.ReturnType -> Reko.Core.Hll.Pascal.PascalType
Reko.Core.Hll.Pascal.CallableType
Reko.Core.Hll.Pascal.CallableType.CallableType(System.Collections.Generic.List<Reko.Core.Hll.Pascal.ParameterDeclaration> procParameters, Reko.Core.Hll.Pascal.PascalType returnType = null) -> void
Reko.Core.Hll.Pascal.CallableType.CallingConvention.get -> string
Reko.Core.Hll.Pascal.CallableType.CallingConvention.set -> void
Reko.Core.Hll.Pascal.CallableType.Parameters.get -> System.Collections.Generic.List<Reko.Core.Hll.Pascal.ParameterDeclaration>
Reko.Core.Hll.Pascal.CallableType.ReturnType.get -> Reko.Core.Hll.Pascal.PascalType
Reko.Core.Hll.Pascal.ConstantDeclaration
Reko.Core.Hll.Pascal.ConstantDeclaration.ConstantDeclaration(string name, Reko.Core.Hll.Pascal.Exp exp, Reko.Core.Hll.Pascal.PascalType type = null) -> void
Reko.Core.Hll.Pascal.ConstantDeclaration.Exp.get -> Reko.Core.Hll.Pascal.Exp
Reko.Core.Hll.Pascal.ConstantDeclaration.Type.get -> Reko.Core.Hll.Pascal.PascalType
Reko.Core.Hll.Pascal.Declaration
Reko.Core.Hll.Pascal.Declaration.Declaration(string name) -> void
Reko.Core.Hll.Pascal.Declaration.Name -> string
Reko.Core.Hll.Pascal.EnumType
Reko.Core.Hll.Pascal.EnumType.EnumType() -> void
Reko.Core.Hll.Pascal.EnumType.Names -> System.Collections.Generic.List<string>
Reko.Core.Hll.Pascal.Exp
Reko.Core.Hll.Pascal.Exp.Exp() -> void
Reko.Core.Hll.Pascal.Field
Reko.Core.Hll.Pascal.Field.Field(System.Collections.Generic.List<string> names, Reko.Core.Hll.Pascal.PascalType type) -> void
Reko.Core.Hll.Pascal.Field.Names -> System.Collections.Generic.List<string>
Reko.Core.Hll.Pascal.Field.Type -> Reko.Core.Hll.Pascal.PascalType
Reko.Core.Hll.Pascal.File
Reko.Core.Hll.Pascal.File.File() -> void
Reko.Core.Hll.Pascal.Id
Reko.Core.Hll.Pascal.Id.Id(string name) -> void
Reko.Core.Hll.Pascal.Id.Name -> string
Reko.Core.Hll.Pascal.InlineMachineCode
Reko.Core.Hll.Pascal.InlineMachineCode.InlineMachineCode() -> void
Reko.Core.Hll.Pascal.InlineMachineCode.Opcodes.get -> System.Collections.Generic.List<Reko.Core.Hll.Pascal.Exp>
Reko.Core.Hll.Pascal.InlineMachineCode.Opcodes.set -> void
Reko.Core.Hll.Pascal.IPascalSyntaxVisitor<T>
Reko.Core.Hll.Pascal.IPascalSyntaxVisitor<T>.VisitArrayType(Reko.Core.Hll.Pascal.Array array) -> T
Reko.Core.Hll.Pascal.IPascalSyntaxVisitor<T>.VisitBinExp(Reko.Core.Hll.Pascal.BinExp binExp) -> T
Reko.Core.Hll.Pascal.IPascalSyntaxVisitor<T>.VisitBooleanLiteral(Reko.Core.Hll.Pascal.BooleanLiteral booleanLiteral) -> T
Reko.Core.Hll.Pascal.IPascalSyntaxVisitor<T>.VisitCallableDeclaration(Reko.Core.Hll.Pascal.CallableDeclaration cd) -> T
Reko.Core.Hll.Pascal.IPascalSyntaxVisitor<T>.VisitCallableType(Reko.Core.Hll.Pascal.CallableType callableType) -> T
Reko.Core.Hll.Pascal.IPascalSyntaxVisitor<T>.VisitConstantDeclaration(Reko.Core.Hll.Pascal.ConstantDeclaration cd) -> T
Reko.Core.Hll.Pascal.IPascalSyntaxVisitor<T>.VisitEnumType(Reko.Core.Hll.Pascal.EnumType enumType) -> T
Reko.Core.Hll.Pascal.IPascalSyntaxVisitor<T>.VisitFile(Reko.Core.Hll.Pascal.File file) -> T
Reko.Core.Hll.Pascal.IPascalSyntaxVisitor<T>.VisitIdentifier(Reko.Core.Hll.Pascal.Id id) -> T
Reko.Core.Hll.Pascal.IPascalSyntaxVisitor<T>.VisitInlineMachineCode(Reko.Core.Hll.Pascal.InlineMachineCode code) -> T
Reko.Core.Hll.Pascal.IPascalSyntaxVisitor<T>.VisitNumericLiteral(Reko.Core.Hll.Pascal.NumericLiteral number) -> T
Reko.Core.Hll.Pascal.IPascalSyntaxVisitor<T>.VisitObject(Reko.Core.Hll.Pascal.ObjectType objectType) -> T
Reko.Core.Hll.Pascal.IPascalSyntaxVisitor<T>.VisitPointerType(Reko.Core.Hll.Pascal.Pointer pointer) -> T
Reko.Core.Hll.Pascal.IPascalSyntaxVisitor<T>.VisitPrimitiveType(Reko.Core.Hll.Pascal.Primitive primitive) -> T
Reko.Core.Hll.Pascal.IPascalSyntaxVisitor<T>.VisitRangeType(Reko.Core.Hll.Pascal.RangeType rangeType) -> T
Reko.Core.Hll.Pascal.IPascalSyntaxVisitor<T>.VisitRealLiteral(Reko.Core.Hll.Pascal.RealLiteral realLiteral) -> T
Reko.Core.Hll.Pascal.IPascalSyntaxVisitor<T>.VisitRecord(Reko.Core.Hll.Pascal.Record record) -> T
Reko.Core.Hll.Pascal.IPascalSyntaxVisitor<T>.VisitSetType(Reko.Core.Hll.Pascal.SetType setType) -> T
Reko.Core.Hll.Pascal.IPascalSyntaxVisitor<T>.VisitStringLiteral(Reko.Core.Hll.Pascal.StringLiteral str) -> T
Reko.Core.Hll.Pascal.IPascalSyntaxVisitor<T>.VisitStringType(Reko.Core.Hll.Pascal.StringType strType) -> T
Reko.Core.Hll.Pascal.IPascalSyntaxVisitor<T>.VisitTypeDeclaration(Reko.Core.Hll.Pascal.TypeDeclaration td) -> T
Reko.Core.Hll.Pascal.IPascalSyntaxVisitor<T>.VisitTypeReference(Reko.Core.Hll.Pascal.TypeReference typeref) -> T
Reko.Core.Hll.Pascal.IPascalSyntaxVisitor<T>.VisitUnaryExp(Reko.Core.Hll.Pascal.UnaryExp unaryExp) -> T
Reko.Core.Hll.Pascal.NumericLiteral
Reko.Core.Hll.Pascal.NumericLiteral.NumericLiteral(long n) -> void
Reko.Core.Hll.Pascal.NumericLiteral.ToList() -> Reko.Core.Hll.Pascal.Exp
Reko.Core.Hll.Pascal.NumericLiteral.Value -> long
Reko.Core.Hll.Pascal.ObjectType
Reko.Core.Hll.Pascal.ObjectType.Members.get -> System.Collections.Generic.List<Reko.Core.Hll.Pascal.Declaration>
Reko.Core.Hll.Pascal.ObjectType.ObjectType(System.Collections.Generic.List<Reko.Core.Hll.Pascal.Declaration> members) -> void
Reko.Core.Hll.Pascal.ParameterDeclaration
Reko.Core.Hll.Pascal.ParameterDeclaration.ByReference -> bool
Reko.Core.Hll.Pascal.ParameterDeclaration.ParameterDeclaration() -> void
Reko.Core.Hll.Pascal.ParameterDeclaration.ParameterNames.get -> System.Collections.Generic.List<string>
Reko.Core.Hll.Pascal.ParameterDeclaration.Type.get -> Reko.Core.Hll.Pascal.PascalType
Reko.Core.Hll.Pascal.PascalLexer
Reko.Core.Hll.Pascal.PascalLexer.PascalLexer(System.IO.TextReader rdr, bool allowNestedComments) -> void
Reko.Core.Hll.Pascal.PascalLexer.Peek() -> Reko.Core.Hll.Pascal.Token
Reko.Core.Hll.Pascal.PascalLexer.Read() -> Reko.Core.Hll.Pascal.Token
Reko.Core.Hll.Pascal.PascalParser
Reko.Core.Hll.Pascal.PascalParser.Parse() -> System.Collections.Generic.List<Reko.Core.Hll.Pascal.Declaration>
Reko.Core.Hll.Pascal.PascalParser.ParseExp() -> Reko.Core.Hll.Pascal.Exp
Reko.Core.Hll.Pascal.PascalParser.ParseObject() -> Reko.Core.Hll.Pascal.ObjectType
Reko.Core.Hll.Pascal.PascalParser.ParseRecord() -> Reko.Core.Hll.Pascal.Record
Reko.Core.Hll.Pascal.PascalParser.ParseType() -> Reko.Core.Hll.Pascal.PascalType
Reko.Core.Hll.Pascal.PascalParser.ParseUnit() -> System.Collections.Generic.List<Reko.Core.Hll.Pascal.Declaration>
Reko.Core.Hll.Pascal.PascalParser.PascalParser(Reko.Core.Hll.Pascal.PascalLexer lexer) -> void
Reko.Core.Hll.Pascal.PascalSyntax
Reko.Core.Hll.Pascal.PascalSyntax.PascalSyntax() -> void
Reko.Core.Hll.Pascal.PascalType
Reko.Core.Hll.Pascal.PascalType.PascalType() -> void
Reko.Core.Hll.Pascal.Pointer
Reko.Core.Hll.Pascal.Pointer.pointee -> Reko.Core.Hll.Pascal.PascalType
Reko.Core.Hll.Pascal.Pointer.Pointer(Reko.Core.Hll.Pascal.PascalType type) -> void
Reko.Core.Hll.Pascal.Primitive
Reko.Core.Hll.Pascal.Primitive.Primitive(Reko.Core.Serialization.SerializedType type) -> void
Reko.Core.Hll.Pascal.RangeType
Reko.Core.Hll.Pascal.RangeType.High -> Reko.Core.Hll.Pascal.Exp
Reko.Core.Hll.Pascal.RangeType.Low -> Reko.Core.Hll.Pascal.Exp
Reko.Core.Hll.Pascal.RangeType.RangeType() -> void
Reko.Core.Hll.Pascal.RealLiteral
Reko.Core.Hll.Pascal.RealLiteral.RealLiteral(double real) -> void
Reko.Core.Hll.Pascal.RealLiteral.Value -> double
Reko.Core.Hll.Pascal.Record
Reko.Core.Hll.Pascal.Record.Fields -> System.Collections.Generic.List<Reko.Core.Hll.Pascal.Field>
Reko.Core.Hll.Pascal.Record.Packed -> bool
Reko.Core.Hll.Pascal.Record.Record() -> void
Reko.Core.Hll.Pascal.Record.VariantPart -> Reko.Core.Hll.Pascal.VariantPart
Reko.Core.Hll.Pascal.SetType
Reko.Core.Hll.Pascal.SetType.EnumName.get -> string
Reko.Core.Hll.Pascal.SetType.Names.get -> System.Collections.Generic.List<string>
Reko.Core.Hll.Pascal.SetType.SetType() -> void
Reko.Core.Hll.Pascal.StringLiteral
Reko.Core.Hll.Pascal.StringLiteral.String -> string
Reko.Core.Hll.Pascal.StringLiteral.StringLiteral(string s) -> void
Reko.Core.Hll.Pascal.StringType
Reko.Core.Hll.Pascal.StringType.Size -> Reko.Core.Hll.Pascal.Exp
Reko.Core.Hll.Pascal.StringType.StringType() -> void
Reko.Core.Hll.Pascal.SymbolTable
Reko.Core.Hll.Pascal.SymbolTable.Add(Reko.Core.Hll.Pascal.Declaration decl) -> void
Reko.Core.Hll.Pascal.SymbolTable.SymbolTable(Reko.Core.IPlatform platform) -> void
Reko.Core.Hll.Pascal.Token
Reko.Core.Hll.Pascal.Token.Token() -> void
Reko.Core.Hll.Pascal.Token.Type -> Reko.Core.Hll.Pascal.TokenType
Reko.Core.Hll.Pascal.Token.Value -> object
Reko.Core.Hll.Pascal.TokenType
Reko.Core.Hll.Pascal.TokenType.Array = 21 -> Reko.Core.Hll.Pascal.TokenType
Reko.Core.Hll.Pascal.TokenType.Boolean = 22 -> Reko.Core.Hll.Pascal.TokenType
Reko.Core.Hll.Pascal.TokenType.Case = 23 -> Reko.Core.Hll.Pascal.TokenType
Reko.Core.Hll.Pascal.TokenType.Char = 24 -> Reko.Core.Hll.Pascal.TokenType
Reko.Core.Hll.Pascal.TokenType.Colon = 1 -> Reko.Core.Hll.Pascal.TokenType
Reko.Core.Hll.Pascal.TokenType.Comma = 2 -> Reko.Core.Hll.Pascal.TokenType
Reko.Core.Hll.Pascal.TokenType.Const = 25 -> Reko.Core.Hll.Pascal.TokenType
Reko.Core.Hll.Pascal.TokenType.Dot = 3 -> Reko.Core.Hll.Pascal.TokenType
Reko.Core.Hll.Pascal.TokenType.DotDot = 4 -> Reko.Core.Hll.Pascal.TokenType
Reko.Core.Hll.Pascal.TokenType.DotDotDot = 5 -> Reko.Core.Hll.Pascal.TokenType
Reko.Core.Hll.Pascal.TokenType.End = 26 -> Reko.Core.Hll.Pascal.TokenType
Reko.Core.Hll.Pascal.TokenType.EOF = 0 -> Reko.Core.Hll.Pascal.TokenType
Reko.Core.Hll.Pascal.TokenType.Eq = 6 -> Reko.Core.Hll.Pascal.TokenType
Reko.Core.Hll.Pascal.TokenType.Extended = 27 -> Reko.Core.Hll.Pascal.TokenType
Reko.Core.Hll.Pascal.TokenType.False = 28 -> Reko.Core.Hll.Pascal.TokenType
Reko.Core.Hll.Pascal.TokenType.File = 29 -> Reko.Core.Hll.Pascal.TokenType
Reko.Core.Hll.Pascal.TokenType.Function = 30 -> Reko.Core.Hll.Pascal.TokenType
Reko.Core.Hll.Pascal.TokenType.Id = 7 -> Reko.Core.Hll.Pascal.TokenType
Reko.Core.Hll.Pascal.TokenType.Inline = 32 -> Reko.Core.Hll.Pascal.TokenType
Reko.Core.Hll.Pascal.TokenType.Integer = 33 -> Reko.Core.Hll.Pascal.TokenType
Reko.Core.Hll.Pascal.TokenType.Interface = 31 -> Reko.Core.Hll.Pascal.TokenType
Reko.Core.Hll.Pascal.TokenType.LBracket = 8 -> Reko.Core.Hll.Pascal.TokenType
Reko.Core.Hll.Pascal.TokenType.Longint = 34 -> Reko.Core.Hll.Pascal.TokenType
Reko.Core.Hll.Pascal.TokenType.LParen = 9 -> Reko.Core.Hll.Pascal.TokenType
Reko.Core.Hll.Pascal.TokenType.Minus = 11 -> Reko.Core.Hll.Pascal.TokenType
Reko.Core.Hll.Pascal.TokenType.Number = 14 -> Reko.Core.Hll.Pascal.TokenType
Reko.Core.Hll.Pascal.TokenType.Of = 35 -> Reko.Core.Hll.Pascal.TokenType
Reko.Core.Hll.Pascal.TokenType.Packed = 36 -> Reko.Core.Hll.Pascal.TokenType
Reko.Core.Hll.Pascal.TokenType.Plus = 10 -> Reko.Core.Hll.Pascal.TokenType
Reko.Core.Hll.Pascal.TokenType.Procedure = 37 -> Reko.Core.Hll.Pascal.TokenType
Reko.Core.Hll.Pascal.TokenType.Ptr = 15 -> Reko.Core.Hll.Pascal.TokenType
Reko.Core.Hll.Pascal.TokenType.RBracket = 16 -> Reko.Core.Hll.Pascal.TokenType
Reko.Core.Hll.Pascal.TokenType.RealLiteral = 18 -> Reko.Core.Hll.Pascal.TokenType
Reko.Core.Hll.Pascal.TokenType.Record = 38 -> Reko.Core.Hll.Pascal.TokenType
Reko.Core.Hll.Pascal.TokenType.RParen = 17 -> Reko.Core.Hll.Pascal.TokenType
Reko.Core.Hll.Pascal.TokenType.Semi = 19 -> Reko.Core.Hll.Pascal.TokenType
Reko.Core.Hll.Pascal.TokenType.Set = 39 -> Reko.Core.Hll.Pascal.TokenType
Reko.Core.Hll.Pascal.TokenType.Slash = 13 -> Reko.Core.Hll.Pascal.TokenType
Reko.Core.Hll.Pascal.TokenType.Star = 12 -> Reko.Core.Hll.Pascal.TokenType
Reko.Core.Hll.Pascal.TokenType.String = 40 -> Reko.Core.Hll.Pascal.TokenType
Reko.Core.Hll.Pascal.TokenType.StringLiteral = 20 -> Reko.Core.Hll.Pascal.TokenType
Reko.Core.Hll.Pascal.TokenType.True = 41 -> Reko.Core.Hll.Pascal.TokenType
Reko.Core.Hll.Pascal.TokenType.Type = 42 -> Reko.Core.Hll.Pascal.TokenType
Reko.Core.Hll.Pascal.TokenType.Unit = 43 -> Reko.Core.Hll.Pascal.TokenType
Reko.Core.Hll.Pascal.TokenType.Univ = 44 -> Reko.Core.Hll.Pascal.TokenType
Reko.Core.Hll.Pascal.TokenType.Var = 45 -> Reko.Core.Hll.Pascal.TokenType
Reko.Core.Hll.Pascal.TypeDeclaration
Reko.Core.Hll.Pascal.TypeDeclaration.Type -> Reko.Core.Hll.Pascal.PascalType
Reko.Core.Hll.Pascal.TypeDeclaration.TypeDeclaration(string name, Reko.Core.Hll.Pascal.PascalType type) -> void
Reko.Core.Hll.Pascal.TypeReference
Reko.Core.Hll.Pascal.TypeReference.TypeName -> string
Reko.Core.Hll.Pascal.TypeReference.TypeReference(string name) -> void
Reko.Core.Hll.Pascal.UnaryExp
Reko.Core.Hll.Pascal.UnaryExp.exp -> Reko.Core.Hll.Pascal.Exp
Reko.Core.Hll.Pascal.UnaryExp.op -> Reko.Core.Hll.Pascal.TokenType
Reko.Core.Hll.Pascal.UnaryExp.UnaryExp(Reko.Core.Hll.Pascal.TokenType op, Reko.Core.Hll.Pascal.Exp exp) -> void
Reko.Core.Hll.Pascal.Variant
Reko.Core.Hll.Pascal.Variant.Fields -> System.Collections.Generic.List<Reko.Core.Hll.Pascal.Field>
Reko.Core.Hll.Pascal.Variant.TagValues -> System.Collections.Generic.List<Reko.Core.Hll.Pascal.Exp>
Reko.Core.Hll.Pascal.Variant.Variant() -> void
Reko.Core.Hll.Pascal.Variant.VariantPart -> Reko.Core.Hll.Pascal.VariantPart
Reko.Core.Hll.Pascal.VariantPart
Reko.Core.Hll.Pascal.VariantPart.TagType -> Reko.Core.Hll.Pascal.PascalType
Reko.Core.Hll.Pascal.VariantPart.VariantPart() -> void
Reko.Core.Hll.Pascal.VariantPart.Variants -> System.Collections.Generic.List<Reko.Core.Hll.Pascal.Variant>
Reko.Core.Hll.Pascal.VariantPart.VariantTag -> string
Reko.Core.Hll.Pascal.VariantPart.Write(System.IO.TextWriter writer) -> void
Reko.Core.IAddressable
Reko.Core.IAddressable.Address.get -> Reko.Core.Address
Reko.Core.IBackWalkHost<TBlock, TInstr>
Reko.Core.IBackWalkHost<TBlock, TInstr>.Architecture.get -> Reko.Core.IProcessorArchitecture
Reko.Core.IBackWalkHost<TBlock, TInstr>.AsAssignment(TInstr instr) -> (Reko.Core.Expressions.Expression, Reko.Core.Expressions.Expression)
Reko.Core.IBackWalkHost<TBlock, TInstr>.AsBranch(TInstr instr) -> Reko.Core.Expressions.Expression
Reko.Core.IBackWalkHost<TBlock, TInstr>.BlockInstructionCount(TBlock rtlBlock) -> int
Reko.Core.IBackWalkHost<TBlock, TInstr>.GetBlockInstructions(TBlock block) -> System.Collections.Generic.IEnumerable<TInstr>
Reko.Core.IBackWalkHost<TBlock, TInstr>.GetPredecessors(TBlock block) -> System.Collections.Generic.List<TBlock>
Reko.Core.IBackWalkHost<TBlock, TInstr>.GetSinglePredecessor(TBlock block) -> TBlock
Reko.Core.IBackWalkHost<TBlock, TInstr>.GetSubregister(Reko.Core.RegisterStorage rIdx, Reko.Core.BitRange range) -> Reko.Core.RegisterStorage
Reko.Core.IBackWalkHost<TBlock, TInstr>.IsFallthrough(TInstr instr, TBlock block) -> bool
Reko.Core.IBackWalkHost<TBlock, TInstr>.IsStackRegister(Reko.Core.Storage storage) -> bool
Reko.Core.IBackWalkHost<TBlock, TInstr>.IsValidAddress(Reko.Core.Address addr) -> bool
Reko.Core.IBackWalkHost<TBlock, TInstr>.MakeAddressFromConstant(Reko.Core.Expressions.Constant c) -> Reko.Core.Address
Reko.Core.IBackWalkHost<TBlock, TInstr>.MakeSegmentedAddress(Reko.Core.Expressions.Constant selector, Reko.Core.Expressions.Constant offset) -> Reko.Core.Address
Reko.Core.IBackWalkHost<TBlock, TInstr>.Program.get -> Reko.Core.Program
Reko.Core.IBackWalkHost<TBlock, TInstr>.SegmentMap.get -> Reko.Core.SegmentMap
Reko.Core.IByteSource
Reko.Core.ICallingConventionEmitter
Reko.Core.ICallingConventionEmitter.CalleeCleanup() -> void
Reko.Core.ICallingConventionEmitter.CallerCleanup(int retAddressOnStack) -> void
Reko.Core.ICallingConventionEmitter.FpuReturn(int depth, Reko.Core.Types.DataType dt) -> void
Reko.Core.ICallingConventionEmitter.ImplicitThisRegister(Reko.Core.Storage dtThis) -> void
Reko.Core.ICallingConventionEmitter.ImplicitThisStack(Reko.Core.Types.DataType dtThis) -> void
Reko.Core.ICallingConventionEmitter.LowLevelDetails(int stackAlignment, int parameterStackSaveOffset) -> void
Reko.Core.ICallingConventionEmitter.RegParam(Reko.Core.RegisterStorage stg) -> void
Reko.Core.ICallingConventionEmitter.RegReturn(Reko.Core.RegisterStorage stg) -> void
Reko.Core.ICallingConventionEmitter.ReverseParameters() -> void
Reko.Core.ICallingConventionEmitter.SequenceParam(Reko.Core.RegisterStorage stgHi, Reko.Core.RegisterStorage stgLo) -> void
Reko.Core.ICallingConventionEmitter.SequenceParam(Reko.Core.SequenceStorage seq) -> void
Reko.Core.ICallingConventionEmitter.SequenceReturn(Reko.Core.RegisterStorage stgHi, Reko.Core.RegisterStorage stgLo) -> void
Reko.Core.ICallingConventionEmitter.SequenceReturn(Reko.Core.SequenceStorage seq) -> void
Reko.Core.ICallingConventionEmitter.StackParam(Reko.Core.Types.DataType dt) -> void
Reko.Core.ICallingConventionEmitter.StackReturn(Reko.Core.Types.DataType dtRet) -> void
Reko.Core.ICodeLocation
Reko.Core.ICodeLocation.NavigateTo() -> System.Threading.Tasks.ValueTask
Reko.Core.ICodeLocation.Text.get -> string
Reko.Core.IDynamicLinker
Reko.Core.IDynamicLinker.ResolveImport(string moduleName, int ordinal, Reko.Core.IPlatform platform) -> Reko.Core.Expressions.Expression
Reko.Core.IDynamicLinker.ResolveImport(string moduleName, string globalName, Reko.Core.IPlatform platform) -> Reko.Core.Expressions.Expression
Reko.Core.IDynamicLinker.ResolveProcedure(string moduleName, int ordinal, Reko.Core.IPlatform platform) -> Reko.Core.ExternalProcedure
Reko.Core.IDynamicLinker.ResolveProcedure(string moduleName, string importName, Reko.Core.IPlatform platform) -> Reko.Core.ExternalProcedure
Reko.Core.IDynamicLinker.ResolveToImportedValue(Reko.Core.Statement stm, Reko.Core.Expressions.Constant c) -> Reko.Core.Expressions.Expression
Reko.Core.ImageLocation
Reko.Core.ImageLocation.AppendFragment(string name) -> Reko.Core.ImageLocation
Reko.Core.ImageLocation.Combine(string relativeUri) -> Reko.Core.ImageLocation
Reko.Core.ImageLocation.CompareTo(Reko.Core.ImageLocation that) -> int
Reko.Core.ImageLocation.EndsWith(string s) -> bool
Reko.Core.ImageLocation.EndsWith(string s, System.StringComparison c) -> bool
Reko.Core.ImageLocation.FilesystemPath.get -> string
Reko.Core.ImageLocation.Fragments.get -> string[]
Reko.Core.ImageLocation.GetExtension() -> string
Reko.Core.ImageLocation.GetFilename() -> string
Reko.Core.ImageLocation.HasFragments.get -> bool
Reko.Core.ImageLocation.MakeRelativeUri(Reko.Core.ImageLocation imageLocation) -> string
Reko.Core.ImageMap
Reko.Core.ImageMap.AddItem(Reko.Core.Address addr, Reko.Core.ImageMapItem itemNew) -> Reko.Core.ImageMapItem
Reko.Core.ImageMap.AddItemWithSize(Reko.Core.Address addr, Reko.Core.ImageMapItem itemNew) -> void
Reko.Core.ImageMap.BaseAddress.get -> Reko.Core.Address
Reko.Core.ImageMap.Clone() -> Reko.Core.ImageMap
Reko.Core.ImageMap.Dump() -> void
Reko.Core.ImageMap.ImageMap(Reko.Core.Address addrBase) -> void
Reko.Core.ImageMap.ImageMap(Reko.Core.ImageMap that) -> void
Reko.Core.ImageMap.Items.get -> Reko.Core.Collections.ConcurrentBTreeDictionary<Reko.Core.Address, Reko.Core.ImageMapItem>
Reko.Core.ImageMap.MapChanged -> System.EventHandler
Reko.Core.ImageMap.PauseEventHandler() -> void
Reko.Core.ImageMap.RemoveItem(Reko.Core.Address addr) -> void
Reko.Core.ImageMap.TerminateItem(Reko.Core.Address addr) -> void
Reko.Core.ImageMap.TryFindItem(Reko.Core.Address addr, out Reko.Core.ImageMapItem item) -> bool
Reko.Core.ImageMap.TryFindItemExact(Reko.Core.Address addr, out Reko.Core.ImageMapItem item) -> bool
Reko.Core.ImageMap.UnpauseEventHandler() -> void
Reko.Core.ImageMapBlock
Reko.Core.ImageMapBlock.Block.get -> Reko.Core.Block
Reko.Core.ImageMapBlock.Block.set -> void
Reko.Core.ImageMapBlock.ImageMapBlock(Reko.Core.Address addr) -> void
Reko.Core.ImageMapItem
Reko.Core.ImageMapItem.Address.get -> Reko.Core.Address
Reko.Core.ImageMapItem.Address.set -> void
Reko.Core.ImageMapItem.DataType -> Reko.Core.Types.DataType
Reko.Core.ImageMapItem.EndAddress.get -> Reko.Core.Address
Reko.Core.ImageMapItem.ImageMapItem(Reko.Core.Address addr) -> void
Reko.Core.ImageMapItem.ImageMapItem(Reko.Core.Address addr, uint size) -> void
Reko.Core.ImageMapItem.IsInRange(Reko.Core.Address addr) -> bool
Reko.Core.ImageMapItem.IsInRange(ulong linearAddress) -> bool
Reko.Core.ImageMapItem.Name -> string
Reko.Core.ImageMapItem.Size.get -> uint
Reko.Core.ImageMapItem.Size.set -> void
Reko.Core.ImageMapVectorTable
Reko.Core.ImageMapVectorTable.Addresses.get -> System.Collections.Generic.List<Reko.Core.Address>
Reko.Core.ImageMapVectorTable.ImageMapVectorTable(Reko.Core.Address addr, Reko.Core.Address[] vector, int size) -> void
Reko.Core.ImageSegment
Reko.Core.ImageSegment.Access.get -> Reko.Core.AccessMode
Reko.Core.ImageSegment.Access.set -> void
Reko.Core.ImageSegment.Address.get -> Reko.Core.Address
Reko.Core.ImageSegment.ContentSize.get -> uint
Reko.Core.ImageSegment.ContentSize.set -> void
Reko.Core.ImageSegment.CreateImageReader(Reko.Core.IProcessorArchitecture arch) -> Reko.Core.Memory.EndianImageReader
Reko.Core.ImageSegment.Designer.get -> Reko.Core.ImageSegmentRenderer
Reko.Core.ImageSegment.Designer.set -> void
Reko.Core.ImageSegment.EndAddress.get -> Reko.Core.Address
Reko.Core.ImageSegment.Fields.get -> Reko.Core.Types.StructureType
Reko.Core.ImageSegment.FileOffset.get -> ulong
Reko.Core.ImageSegment.FileOffset.set -> void
Reko.Core.ImageSegment.Identifier.get -> Reko.Core.Expressions.Identifier
Reko.Core.ImageSegment.Identifier.set -> void
Reko.Core.ImageSegment.ImageSegment(string name, Reko.Core.Address addr, Reko.Core.Memory.MemoryArea mem, Reko.Core.AccessMode access) -> void
Reko.Core.ImageSegment.ImageSegment(string name, Reko.Core.Address addr, uint size, Reko.Core.AccessMode access) -> void
Reko.Core.ImageSegment.ImageSegment(string name, Reko.Core.Memory.MemoryArea mem, Reko.Core.AccessMode access) -> void
Reko.Core.ImageSegment.IsDiscardable.get -> bool
Reko.Core.ImageSegment.IsDiscardable.set -> void
Reko.Core.ImageSegment.IsExecutable.get -> bool
Reko.Core.ImageSegment.IsHidden.get -> bool
Reko.Core.ImageSegment.IsHidden.set -> void
Reko.Core.ImageSegment.IsInRange(Reko.Core.Address addr) -> bool
Reko.Core.ImageSegment.IsWriteable.get -> bool
Reko.Core.ImageSegment.MemoryArea.get -> Reko.Core.Memory.MemoryArea
Reko.Core.ImageSegment.MemoryArea.set -> void
Reko.Core.ImageSegment.Name.get -> string
Reko.Core.ImageSegment.Name.set -> void
Reko.Core.ImageSegment.Provenance.get -> Reko.Core.ProvenanceType
Reko.Core.ImageSegment.Provenance.set -> void
Reko.Core.ImageSegment.Size.get -> uint
Reko.Core.ImageSegment.Size.set -> void
Reko.Core.ImageSegmentRenderer
Reko.Core.ImageSegmentRenderer.ImageSegmentRenderer() -> void
Reko.Core.ImageSymbol
Reko.Core.ImageSymbol.Address.get -> Reko.Core.Address
Reko.Core.ImageSymbol.Architecture.get -> Reko.Core.IProcessorArchitecture
Reko.Core.ImageSymbol.Architecture.set -> void
Reko.Core.ImageSymbol.DataType.get -> Reko.Core.Types.DataType
Reko.Core.ImageSymbol.DataType.set -> void
Reko.Core.ImageSymbol.Name.get -> string
Reko.Core.ImageSymbol.Name.set -> void
Reko.Core.ImageSymbol.NoDecompile.get -> bool
Reko.Core.ImageSymbol.NoDecompile.set -> void
Reko.Core.ImageSymbol.Ordinal.get -> int?
Reko.Core.ImageSymbol.Ordinal.set -> void
Reko.Core.ImageSymbol.ProcessorState.get -> Reko.Core.ProcessorState
Reko.Core.ImageSymbol.ProcessorState.set -> void
Reko.Core.ImageSymbol.Signature.get -> Reko.Core.Serialization.SerializedSignature
Reko.Core.ImageSymbol.Signature.set -> void
Reko.Core.ImageSymbol.Type.get -> Reko.Core.SymbolType
Reko.Core.ImageSymbol.Type.set -> void
Reko.Core.ImportReference
Reko.Core.ImportReference.CompareModuleNames(Reko.Core.ImportReference that) -> int
Reko.Core.ImportReference.EntryName.get -> string
Reko.Core.ImportReference.ImportReference(Reko.Core.Address addr, string moduleName, string entryName, Reko.Core.SymbolType symType) -> void
Reko.Core.ImportReference.ModuleName.get -> string
Reko.Core.ImportReference.ReferenceAddress.get -> Reko.Core.Address
Reko.Core.ImportReference.SymbolType.get -> Reko.Core.SymbolType
Reko.Core.InformationalDiagnostic
Reko.Core.InformationalDiagnostic.InformationalDiagnostic(string message) -> void
Reko.Core.InstrClass
Reko.Core.InstrClass.Annul = 512 -> Reko.Core.InstrClass
Reko.Core.InstrClass.Call = 32 -> Reko.Core.InstrClass
Reko.Core.InstrClass.Conditional = 8 -> Reko.Core.InstrClass
Reko.Core.InstrClass.ConditionalTransfer = Reko.Core.InstrClass.Transfer | Reko.Core.InstrClass.Conditional -> Reko.Core.InstrClass
Reko.Core.InstrClass.Delay = 256 -> Reko.Core.InstrClass
Reko.Core.InstrClass.Indirect = 128 -> Reko.Core.InstrClass
Reko.Core.InstrClass.Invalid = 2048 -> Reko.Core.InstrClass
Reko.Core.InstrClass.Linear = 1 -> Reko.Core.InstrClass
Reko.Core.InstrClass.None = 0 -> Reko.Core.InstrClass
Reko.Core.InstrClass.Padding = 1024 -> Reko.Core.InstrClass
Reko.Core.InstrClass.Privileged = 16 -> Reko.Core.InstrClass
Reko.Core.InstrClass.Return = 64 -> Reko.Core.InstrClass
Reko.Core.InstrClass.System = 16 -> Reko.Core.InstrClass
Reko.Core.InstrClass.Terminates = 4 -> Reko.Core.InstrClass
Reko.Core.InstrClass.Transfer = 2 -> Reko.Core.InstrClass
Reko.Core.InstrClass.Zero = 4096 -> Reko.Core.InstrClass
Reko.Core.IntrinsicProcedure
Reko.Core.IntrinsicProcedure.ApplyConstants.get -> System.Func<Reko.Core.Expressions.Constant[], Reko.Core.Expressions.Constant>
Reko.Core.IntrinsicProcedure.ApplyConstants.set -> void
Reko.Core.IntrinsicProcedure.Arity.get -> int
Reko.Core.IntrinsicProcedure.IntrinsicProcedure(string name, bool hasSideEffect, Reko.Core.Types.DataType returnType, int arity) -> void
Reko.Core.IntrinsicProcedure.IntrinsicProcedure(string name, bool hasSideEffect, Reko.Core.Types.FunctionType sig) -> void
Reko.Core.IntrinsicProcedure.IntrinsicProcedure(string name, Reko.Core.Types.DataType[] genericTypes, bool isConcrete, bool hasSideEffect, Reko.Core.Types.FunctionType sig) -> void
Reko.Core.IntrinsicProcedure.MakeInstance(int ptrSize, params Reko.Core.Types.DataType[] concreteTypes) -> Reko.Core.IntrinsicProcedure
Reko.Core.IntrinsicProcedure.MakeInstance(params Reko.Core.Types.DataType[] concreteTypes) -> Reko.Core.IntrinsicProcedure
Reko.Core.IntrinsicProcedure.ReturnType.get -> Reko.Core.Types.DataType
Reko.Core.Intrinsics.AtomicOps
Reko.Core.Intrinsics.AtomicOps.AtomicOps() -> void
Reko.Core.Intrinsics.CommonOps
Reko.Core.Intrinsics.FpOps
Reko.Core.Intrinsics.IntrinsicBuilder
Reko.Core.Intrinsics.IntrinsicBuilder.ApplyConstants(System.Func<Reko.Core.Expressions.Constant[], Reko.Core.Expressions.Constant> fn) -> Reko.Core.Intrinsics.IntrinsicBuilder
Reko.Core.Intrinsics.IntrinsicBuilder.GenericTypes(params string[] typenames) -> Reko.Core.Intrinsics.IntrinsicBuilder
Reko.Core.Intrinsics.IntrinsicBuilder.IntrinsicBuilder(string intrinsicName, bool hasSideEffect) -> void
Reko.Core.Intrinsics.IntrinsicBuilder.IntrinsicBuilder(string intrinsicName, bool hasSideEffect, Reko.Core.Serialization.ProcedureCharacteristics characteristics) -> void
Reko.Core.Intrinsics.IntrinsicBuilder.OutParam(Reko.Core.Types.DataType dt) -> Reko.Core.Intrinsics.IntrinsicBuilder
Reko.Core.Intrinsics.IntrinsicBuilder.OutParam(string genericType) -> Reko.Core.Intrinsics.IntrinsicBuilder
Reko.Core.Intrinsics.IntrinsicBuilder.Param(Reko.Core.Types.DataType dt) -> Reko.Core.Intrinsics.IntrinsicBuilder
Reko.Core.Intrinsics.IntrinsicBuilder.Param(string genericType) -> Reko.Core.Intrinsics.IntrinsicBuilder
Reko.Core.Intrinsics.IntrinsicBuilder.Params(params string[] genericTypes) -> Reko.Core.Intrinsics.IntrinsicBuilder
Reko.Core.Intrinsics.IntrinsicBuilder.PtrParam(Reko.Core.Types.DataType dt) -> Reko.Core.Intrinsics.IntrinsicBuilder
Reko.Core.Intrinsics.IntrinsicBuilder.PtrParam(string genericType) -> Reko.Core.Intrinsics.IntrinsicBuilder
Reko.Core.Intrinsics.IntrinsicBuilder.Returns(Reko.Core.Types.DataType dt) -> Reko.Core.IntrinsicProcedure
Reko.Core.Intrinsics.IntrinsicBuilder.Returns(string genericType) -> Reko.Core.IntrinsicProcedure
Reko.Core.Intrinsics.IntrinsicBuilder.Void() -> Reko.Core.IntrinsicProcedure
Reko.Core.IO.EndianAttribute
Reko.Core.IO.EndianAttribute.EndianAttribute(Reko.Core.IO.Endianness endianness) -> void
Reko.Core.IO.EndianAttribute.Endianness.get -> Reko.Core.IO.Endianness
Reko.Core.IO.Endianness
Reko.Core.IO.Endianness.BigEndian = 0 -> Reko.Core.IO.Endianness
Reko.Core.IO.Endianness.LittleEndian = 1 -> Reko.Core.IO.Endianness
Reko.Core.IO.SpanExtensions
Reko.Core.IO.SpanStream
Reko.Core.IO.SpanStream.AlignStream(uint alignment) -> int
Reko.Core.IO.SpanStream.Endianness.get -> Reko.Core.IO.Endianness
Reko.Core.IO.SpanStream.Endianness.set -> void
Reko.Core.IO.SpanStream.Mark() -> void
Reko.Core.IO.SpanStream.Memory.get -> System.Memory<byte>
Reko.Core.IO.SpanStream.PerformAt(long offset, System.Action action) -> void
Reko.Core.IO.SpanStream.PerformAt<T>(long offset, System.Func<T> action) -> T
Reko.Core.IO.SpanStream.Read<T>() -> T
Reko.Core.IO.SpanStream.ReadAll<T>(System.Func<Reko.Core.IO.SpanStream, T> reader) -> System.Collections.Generic.IEnumerable<T>
Reko.Core.IO.SpanStream.ReadByte() -> byte
Reko.Core.IO.SpanStream.ReadBytes(int count) -> byte[]
Reko.Core.IO.SpanStream.ReadCString() -> string
Reko.Core.IO.SpanStream.ReadCString(System.Text.Encoding encoding) -> string
Reko.Core.IO.SpanStream.ReadDouble() -> double
Reko.Core.IO.SpanStream.ReadEnum<T>() -> T
Reko.Core.IO.SpanStream.ReadFlagsEnum<T>() -> T
Reko.Core.IO.SpanStream.ReadInt16() -> short
Reko.Core.IO.SpanStream.ReadInt32() -> int
Reko.Core.IO.SpanStream.ReadInt64() -> long
Reko.Core.IO.SpanStream.ReadSingle() -> float
Reko.Core.IO.SpanStream.ReadString(int length, System.Text.Encoding encoding = null) -> string
Reko.Core.IO.SpanStream.ReadStruct<T>() -> T
Reko.Core.IO.SpanStream.ReadUInt16() -> ushort
Reko.Core.IO.SpanStream.ReadUInt32() -> uint
Reko.Core.IO.SpanStream.ReadUInt64() -> ulong
Reko.Core.IO.SpanStream.Remaining.get -> long
Reko.Core.IO.SpanStream.Replace(byte[] newData) -> void
Reko.Core.IO.SpanStream.SizeOf() -> int
Reko.Core.IO.SpanStream.SliceHere() -> Reko.Core.IO.SpanStream
Reko.Core.IO.SpanStream.SliceHere(int length) -> Reko.Core.IO.SpanStream
Reko.Core.IO.SpanStream.SliceHereMemory() -> System.Memory<byte>
Reko.Core.IO.SpanStream.SliceHereMemory(int length) -> System.Memory<byte>
Reko.Core.IO.SpanStream.Span.get -> System.Span<byte>
Reko.Core.IO.SpanStream.SpanStream(Reko.Core.IO.SpanStream other) -> void
Reko.Core.IO.SpanStream.SpanStream(System.Memory<byte> data, Reko.Core.IO.Endianness endianness = Reko.Core.IO.Endianness.LittleEndian) -> void
Reko.Core.IO.SpanStream.Write<T>(T value) -> void
Reko.Core.IO.SpanStream.WriteAt<T>(long offset, T value) -> void
Reko.Core.IO.SpanStream.WriteByte(byte value) -> void
Reko.Core.IO.SpanStream.WriteBytes(byte[] data) -> void
Reko.Core.IO.SpanStream.WriteCString(string str) -> void
Reko.Core.IO.SpanStream.WriteDouble(double value) -> void
Reko.Core.IO.SpanStream.WriteInt16(short value) -> void
Reko.Core.IO.SpanStream.WriteInt32(int value) -> void
Reko.Core.IO.SpanStream.WriteInt64(long value) -> void
Reko.Core.IO.SpanStream.WriteMemory<T>(System.Memory<T> data) -> void
Reko.Core.IO.SpanStream.WriteSingle(float value) -> void
Reko.Core.IO.SpanStream.WriteSpan<T>(System.Span<T> data) -> void
Reko.Core.IO.SpanStream.WriteString(string str, bool lengthPrefix = false, int prefixLength = 4, bool nullTerminator = false, System.Text.Encoding encoding = null) -> void
Reko.Core.IO.SpanStream.WriteUInt16(ushort value) -> void
Reko.Core.IO.SpanStream.WriteUInt32(uint value) -> void
Reko.Core.IO.SpanStream.WriteUInt64(ulong value) -> void
Reko.Core.IPlatform
Reko.Core.IPlatform.AdjustProcedureAddress(Reko.Core.Address addrCode) -> Reko.Core.Address
Reko.Core.IPlatform.Architecture.get -> Reko.Core.IProcessorArchitecture
Reko.Core.IPlatform.CreateAbsoluteMemoryMap() -> Reko.Core.SegmentMap
Reko.Core.IPlatform.CreateCParser(System.IO.TextReader rdr, Reko.Core.Hll.C.ParserState state = null) -> Reko.Core.Hll.C.CParser
Reko.Core.IPlatform.CreateEmulator(Reko.Core.SegmentMap segmentMap, System.Collections.Generic.Dictionary<Reko.Core.Address, Reko.Core.ImportReference> importReferences) -> Reko.Core.Emulation.IPlatformEmulator
Reko.Core.IPlatform.CreateMetadata() -> Reko.Core.TypeLibrary
Reko.Core.IPlatform.CreatePointerScanner(Reko.Core.SegmentMap map, Reko.Core.Memory.EndianImageReader rdr, System.Collections.Generic.IEnumerable<Reko.Core.Address> addr, Reko.Core.PointerScannerFlags flags) -> System.Collections.Generic.IEnumerable<Reko.Core.Address>
Reko.Core.IPlatform.CreateTrashedRegisters() -> System.Collections.Generic.HashSet<Reko.Core.RegisterStorage>
Reko.Core.IPlatform.DataTypeFromImportName(string importName) -> (string, Reko.Core.Serialization.SerializedType, Reko.Core.Serialization.SerializedType)?
Reko.Core.IPlatform.DefaultCallingConvention.get -> string
Reko.Core.IPlatform.DefaultTextEncoding.get -> System.Text.Encoding
Reko.Core.IPlatform.DefaultTextEncoding.set -> void
Reko.Core.IPlatform.Description.get -> string
Reko.Core.IPlatform.Description.set -> void
Reko.Core.IPlatform.DetermineCallingConvention(Reko.Core.Types.FunctionType signature) -> string
Reko.Core.IPlatform.FindDispatcherProcedureByAddress(Reko.Core.Address! addr) -> Reko.Core.Serialization.DispatchProcedure_v1?
Reko.Core.IPlatform.FindMainProcedure(Reko.Core.Program! program, Reko.Core.Address! addrStart) -> Reko.Core.ImageSymbol?
Reko.Core.IPlatform.FindService(int vector, Reko.Core.ProcessorState? state, Reko.Core.SegmentMap? segmentMap) -> Reko.Core.SystemService?
Reko.Core.IPlatform.FindService(Reko.Core.Rtl.RtlInstruction! call, Reko.Core.ProcessorState? state, Reko.Core.SegmentMap? segmentMap) -> Reko.Core.SystemService?
Reko.Core.IPlatform.FormatProcedureName(Reko.Core.Program! program, Reko.Core.Procedure! proc) -> string!
Reko.Core.IPlatform.FramePointerType.get -> Reko.Core.Types.PrimitiveType
Reko.Core.IPlatform.GetBitSizeFromCBasicType(Reko.Core.Hll.C.CBasicType cb) -> int
Reko.Core.IPlatform.GetCallingConvention(string ccName) -> Reko.Core.CallingConvention
Reko.Core.IPlatform.GetPrimitiveTypeName(Reko.Core.Types.PrimitiveType t, string language) -> string
Reko.Core.IPlatform.GetTrampolineDestination(Reko.Core.Address! addrInstr, System.Collections.Generic.IEnumerable<Reko.Core.Rtl.RtlInstruction!>! instrs, Reko.Core.IRewriterHost! host) -> Reko.Core.ProcedureBase?
Reko.Core.IPlatform.Heuristics.get -> Reko.Core.PlatformHeuristics
Reko.Core.IPlatform.InjectProcedureEntryStatements(Reko.Core.Procedure! proc, Reko.Core.Address! addr, Reko.Core.CodeEmitter! emitter) -> void
Reko.Core.IPlatform.IsImplicitArgumentRegister(Reko.Core.RegisterStorage! reg) -> bool
Reko.Core.IPlatform.IsPossibleArgumentRegister(Reko.Core.RegisterStorage! reg) -> bool
Reko.Core.IPlatform.LoadUserOptions(System.Collections.Generic.Dictionary<string, object> options) -> void
Reko.Core.IPlatform.LookupCharacteristicsByName(string procName) -> Reko.Core.Serialization.ProcedureCharacteristics
Reko.Core.IPlatform.LookupProcedureByAddress(Reko.Core.Address address) -> Reko.Core.ExternalProcedure
Reko.Core.IPlatform.LookupProcedureByName(string moduleName, string procName) -> Reko.Core.ExternalProcedure
Reko.Core.IPlatform.LookupProcedureByOrdinal(string moduleName, int ordinal) -> Reko.Core.ExternalProcedure
Reko.Core.IPlatform.MakeAddressFromConstant(Reko.Core.Expressions.Constant c, bool codeAlign) -> Reko.Core.Address
Reko.Core.IPlatform.MakeAddressFromLinear(ulong uAddr, bool codeAlign) -> Reko.Core.Address
Reko.Core.IPlatform.MemoryMap.get -> Reko.Core.Serialization.MemoryMap_v1
Reko.Core.IPlatform.MemoryMap.set -> void
Reko.Core.IPlatform.Name.get -> string
Reko.Core.IPlatform.PlatformIdentifier.get -> string
Reko.Core.IPlatform.PointerType.get -> Reko.Core.Types.PrimitiveType
Reko.Core.IPlatform.PossibleReturnValue(System.Collections.Generic.IEnumerable<Reko.Core.Storage> storages) -> Reko.Core.Storage
Reko.Core.IPlatform.ResolveImportByName(string moduleName, string globalName) -> Reko.Core.Expressions.Expression
Reko.Core.IPlatform.ResolveImportByOrdinal(string moduleName, int ordinal) -> Reko.Core.Expressions.Expression
Reko.Core.IPlatform.ResolveIndirectCall(Reko.Core.Rtl.RtlCall instr) -> Reko.Core.Address
Reko.Core.IPlatform.SaveUserOptions() -> System.Collections.Generic.Dictionary<string, object>
Reko.Core.IPlatform.SignatureFromName(string importName) -> Reko.Core.Serialization.ProcedureBase_v1
Reko.Core.IPlatform.StructureMemberAlignment.get -> int
Reko.Core.IPlatform.TryParseAddress(string sAddress, out Reko.Core.Address addr) -> bool
Reko.Core.IPlatform.WriteMetadata(Reko.Core.Program program, string path) -> void
Reko.Core.IProcessorArchitecture
Reko.Core.IProcessorArchitecture.CarryFlagMask.get -> uint
Reko.Core.IProcessorArchitecture.CreateAssembler(string asmDialect) -> Reko.Core.Assemblers.IAssembler
Reko.Core.IProcessorArchitecture.CreateDisassembler(Reko.Core.Memory.EndianImageReader imageReader) -> System.Collections.Generic.IEnumerable<Reko.Core.Machine.MachineInstruction>
Reko.Core.IProcessorArchitecture.CreateEmulator(Reko.Core.SegmentMap segmentMap, Reko.Core.Emulation.IPlatformEmulator envEmulator) -> Reko.Core.Emulation.IProcessorEmulator
Reko.Core.IProcessorArchitecture.CreateFpuStackAccess(Reko.Core.IStorageBinder binder, int offset, Reko.Core.Types.DataType dataType) -> Reko.Core.Expressions.Expression
Reko.Core.IProcessorArchitecture.CreateFrame() -> Reko.Core.Frame
Reko.Core.IProcessorArchitecture.CreateFrameApplicationBuilder(Reko.Core.IStorageBinder binder, Reko.Core.Code.CallSite site, Reko.Core.Expressions.Expression callee) -> Reko.Core.FrameApplicationBuilder
Reko.Core.IProcessorArchitecture.CreateImageReader(Reko.Core.Memory.MemoryArea memoryArea, long off) -> Reko.Core.Memory.EndianImageReader
Reko.Core.IProcessorArchitecture.CreateImageReader(Reko.Core.Memory.MemoryArea memoryArea, long offsetBegin, long offsetEnd) -> Reko.Core.Memory.EndianImageReader
Reko.Core.IProcessorArchitecture.CreateImageReader(Reko.Core.Memory.MemoryArea memoryArea, Reko.Core.Address addr) -> Reko.Core.Memory.EndianImageReader
Reko.Core.IProcessorArchitecture.CreateImageReader(Reko.Core.Memory.MemoryArea memoryArea, Reko.Core.Address addr, long cbUnits) -> Reko.Core.Memory.EndianImageReader
Reko.Core.IProcessorArchitecture.CreateImageWriter() -> Reko.Core.Memory.ImageWriter
Reko.Core.IProcessorArchitecture.CreateImageWriter(Reko.Core.Memory.MemoryArea memoryArea, Reko.Core.Address addr) -> Reko.Core.Memory.ImageWriter
Reko.Core.IProcessorArchitecture.CreateInstructionComparer(Reko.Core.Normalize norm) -> System.Collections.Generic.IEqualityComparer<Reko.Core.Machine.MachineInstruction>
Reko.Core.IProcessorArchitecture.CreateMemoryArea(Reko.Core.Address baseAddress, byte[] bytes) -> Reko.Core.Memory.MemoryArea
Reko.Core.IProcessorArchitecture.CreatePointerScanner(Reko.Core.SegmentMap map, Reko.Core.Memory.EndianImageReader rdr, System.Collections.Generic.IEnumerable<Reko.Core.Address> knownAddresses, Reko.Core.PointerScannerFlags flags) -> System.Collections.Generic.IEnumerable<Reko.Core.Address>
Reko.Core.IProcessorArchitecture.CreateProcessorState() -> Reko.Core.ProcessorState
Reko.Core.IProcessorArchitecture.CreateRewriter(Reko.Core.Memory.EndianImageReader rdr, Reko.Core.ProcessorState state, Reko.Core.IStorageBinder binder, Reko.Core.IRewriterHost host) -> System.Collections.Generic.IEnumerable<Reko.Core.Rtl.RtlInstructionCluster>
Reko.Core.IProcessorArchitecture.CreateStackAccess(Reko.Core.IStorageBinder binder, int cbOffset, Reko.Core.Types.DataType dataType) -> Reko.Core.Expressions.Expression
Reko.Core.IProcessorArchitecture.DefaultBase.get -> int
Reko.Core.IProcessorArchitecture.Description.get -> string
Reko.Core.IProcessorArchitecture.Description.set -> void
Reko.Core.IProcessorArchitecture.Endianness.get -> Reko.Core.EndianServices
Reko.Core.IProcessorArchitecture.FpuStackRegister.get -> Reko.Core.RegisterStorage
Reko.Core.IProcessorArchitecture.FramePointerType.get -> Reko.Core.Types.PrimitiveType
Reko.Core.IProcessorArchitecture.GetCallingConvention(string ccName) -> Reko.Core.CallingConvention
Reko.Core.IProcessorArchitecture.GetFlagGroup(Reko.Core.RegisterStorage flagRegister, uint grf) -> Reko.Core.FlagGroupStorage
Reko.Core.IProcessorArchitecture.GetFlagGroup(string name) -> Reko.Core.FlagGroupStorage
Reko.Core.IProcessorArchitecture.GetFlags() -> Reko.Core.FlagGroupStorage[]
Reko.Core.IProcessorArchitecture.GetMnemonicNames() -> System.Collections.Generic.SortedList<string, int>
Reko.Core.IProcessorArchitecture.GetMnemonicNumber(string sMnemonic) -> int?
Reko.Core.IProcessorArchitecture.GetRegister(Reko.Core.StorageDomain domain, Reko.Core.BitRange range) -> Reko.Core.RegisterStorage
Reko.Core.IProcessorArchitecture.GetRegister(string name) -> Reko.Core.RegisterStorage
Reko.Core.IProcessorArchitecture.GetRegisters() -> Reko.Core.RegisterStorage[]
Reko.Core.IProcessorArchitecture.GetSubFlags(Reko.Core.FlagGroupStorage flags) -> System.Collections.Generic.IEnumerable<Reko.Core.FlagGroupStorage>
Reko.Core.IProcessorArchitecture.GrfToString(Reko.Core.RegisterStorage flagRegister, string prefix, uint grf) -> string
Reko.Core.IProcessorArchitecture.InlineCall(Reko.Core.Address addrCallee, Reko.Core.Address addrContinuation, Reko.Core.Memory.EndianImageReader rdr, Reko.Core.IStorageBinder binder) -> System.Collections.Generic.List<Reko.Core.Rtl.RtlInstruction>
Reko.Core.IProcessorArchitecture.InstructionBitSize.get -> int
Reko.Core.IProcessorArchitecture.IsStackArgumentOffset(long frameOffset) -> bool
Reko.Core.IProcessorArchitecture.LoadUserOptions(System.Collections.Generic.Dictionary<string, object> options) -> void
Reko.Core.IProcessorArchitecture.MakeAddressFromConstant(Reko.Core.Expressions.Constant c, bool codeAlign) -> Reko.Core.Address
Reko.Core.IProcessorArchitecture.MakeSegmentedAddress(Reko.Core.Expressions.Constant seg, Reko.Core.Expressions.Constant offset) -> Reko.Core.Address
Reko.Core.IProcessorArchitecture.MemoryGranularity.get -> int
Reko.Core.IProcessorArchitecture.Name.get -> string
Reko.Core.IProcessorArchitecture.PointerType.get -> Reko.Core.Types.PrimitiveType
Reko.Core.IProcessorArchitecture.PostprocessProgram(Reko.Core.Program program) -> void
Reko.Core.IProcessorArchitecture.ReadCodeAddress(int size, Reko.Core.Memory.EndianImageReader rdr, Reko.Core.ProcessorState state) -> Reko.Core.Address
Reko.Core.IProcessorArchitecture.ReinterpretAsFloat(Reko.Core.Expressions.Constant rawBits) -> Reko.Core.Expressions.Constant
Reko.Core.IProcessorArchitecture.RenderInstructionOpcode(Reko.Core.Machine.MachineInstruction instr, Reko.Core.Memory.EndianImageReader rdr) -> string
Reko.Core.IProcessorArchitecture.ReturnAddressOnStack.get -> int
Reko.Core.IProcessorArchitecture.SaveUserOptions() -> System.Collections.Generic.Dictionary<string, object>
Reko.Core.IProcessorArchitecture.Services.get -> System.IServiceProvider
Reko.Core.IProcessorArchitecture.StackRegister.get -> Reko.Core.RegisterStorage
Reko.Core.IProcessorArchitecture.StackRegister.set -> void
Reko.Core.IProcessorArchitecture.TryGetRegister(string name, out Reko.Core.RegisterStorage reg) -> bool
Reko.Core.IProcessorArchitecture.TryParseAddress(string txtAddr, out Reko.Core.Address addr) -> bool
Reko.Core.IProcessorArchitecture.TryRead(Reko.Core.Memory.EndianImageReader rdr, Reko.Core.Types.PrimitiveType dt, out Reko.Core.Expressions.Constant value) -> bool
Reko.Core.IProcessorArchitecture.TryRead(Reko.Core.Memory.MemoryArea mem, Reko.Core.Address addr, Reko.Core.Types.PrimitiveType dt, out Reko.Core.Expressions.Constant value) -> bool
Reko.Core.IProcessorArchitecture.WordWidth.get -> Reko.Core.Types.PrimitiveType
Reko.Core.IProjectFileVisitor<T>
Reko.Core.IProjectFileVisitor<T>.VisitMetadataFile(Reko.Core.MetadataFile metadataFile) -> T
Reko.Core.IRewriterHost
Reko.Core.IRewriterHost.EnsureIntrinsic(string name, bool hasSideEffect, Reko.Core.Types.DataType returnType, int arity) -> Reko.Core.IntrinsicProcedure
Reko.Core.IRewriterHost.Error(Reko.Core.Address address, string format, params object[] args) -> void
Reko.Core.IRewriterHost.GetArchitecture(string archMoniker) -> Reko.Core.IProcessorArchitecture
Reko.Core.IRewriterHost.GetImport(Reko.Core.Address addrThunk, Reko.Core.Address addrInstr) -> Reko.Core.Expressions.Expression
Reko.Core.IRewriterHost.GetImportedProcedure(Reko.Core.IProcessorArchitecture arch, Reko.Core.Address addrThunk, Reko.Core.Address addrInstr) -> Reko.Core.ExternalProcedure
Reko.Core.IRewriterHost.GetInterceptedCall(Reko.Core.IProcessorArchitecture arch, Reko.Core.Address addrImportThunk) -> Reko.Core.ExternalProcedure
Reko.Core.IRewriterHost.Intrinsic(string name, bool hasSideEffect, Reko.Core.Types.DataType returnType, params Reko.Core.Expressions.Expression[] args) -> Reko.Core.Expressions.Expression
Reko.Core.IRewriterHost.TryRead(Reko.Core.IProcessorArchitecture arch, Reko.Core.Address addr, Reko.Core.Types.PrimitiveType dt, out Reko.Core.Expressions.Constant value) -> bool
Reko.Core.IRewriterHost.Warn(Reko.Core.Address address, string format, params object[] args) -> void
Reko.Core.IRFormat.IRFormatLexer
Reko.Core.IRFormat.IRFormatLexer.Get() -> Reko.Core.IRFormat.Token
Reko.Core.IRFormat.IRFormatLexer.IRFormatLexer(System.IO.TextReader rdr) -> void
Reko.Core.IRFormat.IRFormatParser
Reko.Core.IRFormat.IRFormatParser.IRFormatParser(System.IO.TextReader rdr) -> void
Reko.Core.IRFormat.IRFormatParser.Parse() -> Reko.Core.Program
Reko.Core.IRFormat.IRFormatParser.ParseProcedureDefinition() -> void
Reko.Core.IRFormat.IRFormatParser.ParseProgramItem() -> void
Reko.Core.IRFormat.IRProcedureBuilder
Reko.Core.IRFormat.IRProcedureBuilder.IRProcedureBuilder(string name, object arch) -> void
Reko.Core.IRFormat.IRTokenType
Reko.Core.IRFormat.IRTokenType.Define = 2 -> Reko.Core.IRFormat.IRTokenType
Reko.Core.IRFormat.IRTokenType.EOF = 1 -> Reko.Core.IRFormat.IRTokenType
Reko.Core.IRFormat.IRTokenType.ID = 3 -> Reko.Core.IRFormat.IRTokenType
Reko.Core.IRFormat.IRTokenType.None = 0 -> Reko.Core.IRFormat.IRTokenType
Reko.Core.IRFormat.Token
Reko.Core.IRFormat.Token.Token() -> void
Reko.Core.IRFormat.Token.Token(Reko.Core.IRFormat.IRTokenType type) -> void
Reko.Core.IRFormat.Token.Type -> Reko.Core.IRFormat.IRTokenType
Reko.Core.IRFormat.Token.Value -> object
Reko.Core.IScriptInterpreter
Reko.Core.IScriptInterpreter.LoadFromFile(string filename, Reko.Core.Program program, string currentDir) -> void
Reko.Core.IScriptInterpreter.LoadFromString(string script, Reko.Core.Program program, string currentDir) -> void
Reko.Core.IScriptInterpreter.Run() -> void
Reko.Core.IStorageBinder
Reko.Core.IStorageBinder.CreateTemporary(Reko.Core.Types.DataType dt) -> Reko.Core.Expressions.Identifier
Reko.Core.IStorageBinder.CreateTemporary(string name, Reko.Core.Types.DataType dt) -> Reko.Core.Expressions.Identifier
Reko.Core.IStorageBinder.EnsureFlagGroup(Reko.Core.FlagGroupStorage grf) -> Reko.Core.Expressions.Identifier
Reko.Core.IStorageBinder.EnsureFlagGroup(Reko.Core.RegisterStorage flagRegister, uint flagGroupBits, string name, Reko.Core.Types.DataType dataType) -> Reko.Core.Expressions.Identifier
Reko.Core.IStorageBinder.EnsureFpuStackVariable(int v, Reko.Core.Types.DataType dataType) -> Reko.Core.Expressions.Identifier
Reko.Core.IStorageBinder.EnsureIdentifier(Reko.Core.Storage stgForeign) -> Reko.Core.Expressions.Identifier
Reko.Core.IStorageBinder.EnsureOutArgument(Reko.Core.Expressions.Identifier idOrig, Reko.Core.Types.DataType outArgumentPointer) -> Reko.Core.Expressions.Identifier
Reko.Core.IStorageBinder.EnsureRegister(Reko.Core.RegisterStorage reg) -> Reko.Core.Expressions.Identifier
Reko.Core.IStorageBinder.EnsureSequence(Reko.Core.SequenceStorage sequence) -> Reko.Core.Expressions.Identifier
Reko.Core.IStorageBinder.EnsureSequence(Reko.Core.Types.DataType dataType, params Reko.Core.Storage[] elements) -> Reko.Core.Expressions.Identifier
Reko.Core.IStorageBinder.EnsureSequence(Reko.Core.Types.DataType dataType, string name, params Reko.Core.Storage[] elements) -> Reko.Core.Expressions.Identifier
Reko.Core.IStorageBinder.EnsureStackVariable(int offset, Reko.Core.Types.DataType dataType) -> Reko.Core.Expressions.Identifier
Reko.Core.Lib.Bitfield
Reko.Core.Lib.Bitfield.Bitfield() -> void
Reko.Core.Lib.Bitfield.Bitfield(int position, int length) -> void
Reko.Core.Lib.Bitfield.Bitfield(int position, int length, uint mask) -> void
Reko.Core.Lib.Bitfield.Read(uint u) -> uint
Reko.Core.Lib.Bitfield.Read(ulong u) -> uint
Reko.Core.Lib.Bitfield.ReadSigned(uint u) -> int
Reko.Core.Lib.Bitfield.ReadSigned(ulong u) -> long
Reko.Core.Lib.Bits
Reko.Core.Lib.Float16
Reko.Core.Lib.Float16.Float16() -> void
Reko.Core.Lib.Float16.Float16(double d) -> void
Reko.Core.Lib.Float16.Float16(ushort binary16) -> void
Reko.Core.Lib.Float16.ToDouble(System.IFormatProvider formatProvider) -> double
Reko.Core.Lib.Float16.ToString(string format, System.IFormatProvider formatProvider) -> string
Reko.Core.Lib.Float80
Reko.Core.Lib.Float80.Float80() -> void
Reko.Core.Lib.Float80.Float80(ushort expSign, ulong significand) -> void
Reko.Core.Lib.Float80.ToDouble(System.IFormatProvider formatProvider) -> double
Reko.Core.Lib.Float80.ToString(string format, System.IFormatProvider formatProvider) -> string
Reko.Core.Lib.Float96
Reko.Core.Lib.Float96.Float96() -> void
Reko.Core.Lib.Float96.Float96(ushort expSign, ulong significand) -> void
Reko.Core.Lib.Float96.ToDouble(System.IFormatProvider formatProvider) -> double
Reko.Core.Lib.Float96.ToString(string format, System.IFormatProvider formatProvider) -> string
Reko.Core.Lib.HASHENTRY
Reko.Core.Lib.HASHENTRY.HASHENTRY() -> void
Reko.Core.Lib.HASHENTRY.name -> string
Reko.Core.Lib.HASHENTRY.offset -> ushort?
Reko.Core.Lib.HASHENTRY.pat -> byte[]
Reko.Core.Lib.MBFFloat32
Reko.Core.Lib.MBFFloat32.GetTypeCode() -> System.TypeCode
Reko.Core.Lib.MBFFloat32.MBFFloat32() -> void
Reko.Core.Lib.MBFFloat32.MBFFloat32(uint value) -> void
Reko.Core.Lib.MBFFloat32.ToBoolean(System.IFormatProvider provider) -> bool
Reko.Core.Lib.MBFFloat32.ToByte(System.IFormatProvider provider) -> byte
Reko.Core.Lib.MBFFloat32.ToChar(System.IFormatProvider provider) -> char
Reko.Core.Lib.MBFFloat32.ToDateTime(System.IFormatProvider provider) -> System.DateTime
Reko.Core.Lib.MBFFloat32.ToDecimal(System.IFormatProvider provider) -> decimal
Reko.Core.Lib.MBFFloat32.ToDouble(System.IFormatProvider provider) -> double
Reko.Core.Lib.MBFFloat32.ToInt16(System.IFormatProvider provider) -> short
Reko.Core.Lib.MBFFloat32.ToInt32(System.IFormatProvider provider) -> int
Reko.Core.Lib.MBFFloat32.ToInt64(System.IFormatProvider provider) -> long
Reko.Core.Lib.MBFFloat32.ToSByte(System.IFormatProvider provider) -> sbyte
Reko.Core.Lib.MBFFloat32.ToSingle(System.IFormatProvider provider) -> float
Reko.Core.Lib.MBFFloat32.ToString(string format, System.IFormatProvider formatProvider) -> string
Reko.Core.Lib.MBFFloat32.ToString(System.IFormatProvider provider) -> string
Reko.Core.Lib.MBFFloat32.ToType(System.Type conversionType, System.IFormatProvider provider) -> object
Reko.Core.Lib.MBFFloat32.ToUInt16(System.IFormatProvider provider) -> ushort
Reko.Core.Lib.MBFFloat32.ToUInt32(System.IFormatProvider provider) -> uint
Reko.Core.Lib.MBFFloat32.ToUInt64(System.IFormatProvider provider) -> ulong
Reko.Core.Lib.PatternCollector
Reko.Core.Lib.PatternCollector.dispKey(int i) -> void
Reko.Core.Lib.PatternCollector.getKey(int i) -> byte[]
Reko.Core.Lib.PatternCollector.PatternCollector() -> void
Reko.Core.Lib.PerfectHash
Reko.Core.Lib.PerfectHash.hash(byte[] string) -> int
Reko.Core.Lib.PerfectHash.map(Reko.Core.Lib.PatternCollector collector) -> void
Reko.Core.Lib.PerfectHash.PerfectHash() -> void
Reko.Core.Lib.PerfectHash.readG() -> short[]
Reko.Core.Lib.PerfectHash.readT1() -> ushort[]
Reko.Core.Lib.PerfectHash.readT2() -> ushort[]
Reko.Core.Lib.PerfectHash.setHashParams(int _NumEntry, int _EntryLen, int _SetSize, char _SetMin, int _NumVert) -> void
Reko.Core.Lib.Rational
Reko.Core.Lib.Rational.Rational() -> void
Reko.Core.Lib.Rational.Rational(long num, long den) -> void
Reko.Core.Lib.Rational.Reciprocal() -> Reko.Core.Lib.Rational
Reko.Core.Lib.Rational.ToDouble() -> double
Reko.Core.Lib.SuffixArray
Reko.Core.Lib.SuffixArray2
Reko.Core.Lib.SuffixArray2.Lcp.get -> int[]
Reko.Core.Lib.SuffixArray2.SuffixArray.get -> int[]
Reko.Core.Lib.SuffixArray2.SuffixArray2(int[] sa, int[] lcp) -> void
Reko.Core.Lib.SuffixArray<T>
Reko.Core.Lib.SuffixArray<T>.FindOccurences(T[] substr) -> System.Collections.Generic.IEnumerable<int>
Reko.Core.Lib.SuffixArray<T>.IndexOf(T[] substr) -> int
Reko.Core.Lib.SuffixArray<T>.Lcp.get -> int[]
Reko.Core.Lib.SuffixArray<T>.Length.get -> int
Reko.Core.Lib.SuffixArray<T>.Save() -> int[]
Reko.Core.Lib.SuffixArray<T>.Str.get -> T[]
Reko.Core.Lib.SuffixArray<T>.SuffixArray(T[] str) -> void
Reko.Core.Lib.SuffixArray<T>.SuffixArray(T[] str, int[] sa) -> void
Reko.Core.Lib.SuffixArray<T>.this[int index].get -> int
Reko.Core.Lib.TextWriterStream
Reko.Core.Lib.TextWriterStream.TextWriterStream(System.IO.TextWriter writer) -> void
Reko.Core.Lib.UbjsonMarker
Reko.Core.Lib.UbjsonMarker.Array = 91 -> Reko.Core.Lib.UbjsonMarker
Reko.Core.Lib.UbjsonMarker.ArrayEnd = 93 -> Reko.Core.Lib.UbjsonMarker
Reko.Core.Lib.UbjsonMarker.Char = 67 -> Reko.Core.Lib.UbjsonMarker
Reko.Core.Lib.UbjsonMarker.ElementCount = 35 -> Reko.Core.Lib.UbjsonMarker
Reko.Core.Lib.UbjsonMarker.ElementType = 36 -> Reko.Core.Lib.UbjsonMarker
Reko.Core.Lib.UbjsonMarker.False = 70 -> Reko.Core.Lib.UbjsonMarker
Reko.Core.Lib.UbjsonMarker.Float32 = 100 -> Reko.Core.Lib.UbjsonMarker
Reko.Core.Lib.UbjsonMarker.Float64 = 68 -> Reko.Core.Lib.UbjsonMarker
Reko.Core.Lib.UbjsonMarker.Int16 = 73 -> Reko.Core.Lib.UbjsonMarker
Reko.Core.Lib.UbjsonMarker.Int32 = 108 -> Reko.Core.Lib.UbjsonMarker
Reko.Core.Lib.UbjsonMarker.Int64 = 76 -> Reko.Core.Lib.UbjsonMarker
Reko.Core.Lib.UbjsonMarker.Int8 = 105 -> Reko.Core.Lib.UbjsonMarker
Reko.Core.Lib.UbjsonMarker.None = 0 -> Reko.Core.Lib.UbjsonMarker
Reko.Core.Lib.UbjsonMarker.Noop = 78 -> Reko.Core.Lib.UbjsonMarker
Reko.Core.Lib.UbjsonMarker.Null = 90 -> Reko.Core.Lib.UbjsonMarker
Reko.Core.Lib.UbjsonMarker.Object = 123 -> Reko.Core.Lib.UbjsonMarker
Reko.Core.Lib.UbjsonMarker.ObjectEnd = 125 -> Reko.Core.Lib.UbjsonMarker
Reko.Core.Lib.UbjsonMarker.String = 83 -> Reko.Core.Lib.UbjsonMarker
Reko.Core.Lib.UbjsonMarker.True = 84 -> Reko.Core.Lib.UbjsonMarker
Reko.Core.Lib.UbjsonMarker.UInt8 = 85 -> Reko.Core.Lib.UbjsonMarker
Reko.Core.Lib.UbjsonReader
Reko.Core.Lib.UbjsonReader.Read() -> object
Reko.Core.Lib.UbjsonReader.UbjsonReader(byte[] bytes) -> void
Reko.Core.Lib.UbjsonReader.UbjsonReader(System.IO.Stream stm) -> void
Reko.Core.Lib.UbjsonWriter
Reko.Core.Lib.UbjsonWriter.UbjsonWriter(System.IO.Stream stm) -> void
Reko.Core.Lib.UbjsonWriter.Write(object o) -> void
Reko.Core.Lib.WildPatternMatcher
Reko.Core.Lib.WildPatternMatcher.FindDcp(string T, string P) -> System.Collections.Generic.IEnumerable<int>
Reko.Core.Lib.WildPatternMatcher.FindIdcp(string T, string P) -> System.Collections.Generic.IEnumerable<int>
Reko.Core.Lib.WildPatternMatcher.WildPatternMatcher() -> void
Reko.Core.LinearInductionVariable
Reko.Core.LinearInductionVariable.AddIncrement(Reko.Core.Expressions.Constant c) -> void
Reko.Core.LinearInductionVariable.Delta.get -> Reko.Core.Expressions.Constant
Reko.Core.LinearInductionVariable.Final.get -> Reko.Core.Expressions.Constant
Reko.Core.LinearInductionVariable.Initial.get -> Reko.Core.Expressions.Constant
Reko.Core.LinearInductionVariable.IsSigned.get -> bool
Reko.Core.LinearInductionVariable.IterationCount.get -> int
Reko.Core.LinearInductionVariable.LinearInductionVariable(Reko.Core.Expressions.Constant initial, Reko.Core.Expressions.Constant delta, Reko.Core.Expressions.Constant final, bool isSigned) -> void
Reko.Core.LinearInductionVariable.Scale(Reko.Core.Expressions.Constant c) -> Reko.Core.LinearInductionVariable
Reko.Core.Loading.AbstractHierarchicalArchive
Reko.Core.Loading.AbstractHierarchicalArchive.AbstractHierarchicalArchive(Reko.Core.ImageLocation! location, char pathSeparator, System.Collections.Generic.IComparer<string!>! comparer) -> void
Reko.Core.Loading.AbstractHierarchicalArchive.Accept<T, C>(Reko.Core.Loading.ILoadedImageVisitor<T, C>! visitor, C context) -> T
Reko.Core.Loading.AbstractHierarchicalArchive.ArchiveDictionary
Reko.Core.Loading.AbstractHierarchicalArchive.ArchiveDictionary.AddEntry(string! name, Reko.Core.Loading.ArchiveDirectoryEntry! entry) -> void
Reko.Core.Loading.AbstractHierarchicalArchive.ArchiveDictionary.ArchiveDictionary(Reko.Core.Loading.AbstractHierarchicalArchive! archive, string! name, Reko.Core.Loading.ArchivedFolder? parent) -> void
Reko.Core.Loading.AbstractHierarchicalArchive.ArchiveDictionary.Entries.get -> System.Collections.Generic.ICollection<Reko.Core.Loading.ArchiveDirectoryEntry!>!
Reko.Core.Loading.AbstractHierarchicalArchive.ArchiveDictionary.Name.get -> string!
Reko.Core.Loading.AbstractHierarchicalArchive.ArchiveDictionary.Parent.get -> Reko.Core.Loading.ArchiveDirectoryEntry?
Reko.Core.Loading.AbstractHierarchicalArchive.Load(System.IO.Stream! stm) -> System.Collections.Generic.List<Reko.Core.Loading.ArchiveDirectoryEntry!>!
Reko.Core.Loading.AbstractHierarchicalArchive.Location.get -> Reko.Core.ImageLocation!
Reko.Core.Loading.AbstractHierarchicalArchive.RootEntries.get -> System.Collections.Generic.List<Reko.Core.Loading.ArchiveDirectoryEntry!>!
Reko.Core.Loading.AbstractHierarchicalArchive.this[string! path].get -> Reko.Core.Loading.ArchiveDirectoryEntry?
Reko.Core.Loading.ArchivedFile
Reko.Core.Loading.ArchivedFile.GetBytes() -> byte[]
Reko.Core.Loading.ArchivedFile.Length.get -> long
Reko.Core.Loading.ArchivedFile.LoadImage(System.IServiceProvider services, Reko.Core.Address addrPreferred) -> Reko.Core.Loading.ILoadedImage
Reko.Core.Loading.ArchivedFolder
Reko.Core.Loading.ArchivedFolder.Entries.get -> System.Collections.Generic.ICollection<Reko.Core.Loading.ArchiveDirectoryEntry>
Reko.Core.Loading.ArchiveDirectoryEntry
Reko.Core.Loading.ArchiveDirectoryEntry.Name.get -> string
Reko.Core.Loading.ArchiveDirectoryEntry.Parent.get -> Reko.Core.Loading.ArchiveDirectoryEntry
Reko.Core.Loading.Blob
Reko.Core.Loading.Blob.Accept<T, C>(Reko.Core.Loading.ILoadedImageVisitor<T, C> visitor, C context) -> T
Reko.Core.Loading.Blob.Blob(Reko.Core.ImageLocation location, byte[] image) -> void
Reko.Core.Loading.Blob.Image.get -> byte[]
Reko.Core.Loading.Blob.Location.get -> Reko.Core.ImageLocation
Reko.Core.Loading.IArchive
Reko.Core.Loading.IArchive.GetRootPath(Reko.Core.Loading.ArchiveDirectoryEntry entry) -> string
Reko.Core.Loading.IArchive.RootEntries.get -> System.Collections.Generic.List<Reko.Core.Loading.ArchiveDirectoryEntry>
Reko.Core.Loading.IArchive.this[string path].get -> Reko.Core.Loading.ArchiveDirectoryEntry
Reko.Core.Loading.ILoadedImage
Reko.Core.Loading.ILoadedImage.Accept<T, C>(Reko.Core.Loading.ILoadedImageVisitor<T, C> visitor, C context) -> T
Reko.Core.Loading.ILoadedImage.Location.get -> Reko.Core.ImageLocation
Reko.Core.Loading.ILoadedImageVisitor<T, C>
Reko.Core.Loading.ILoadedImageVisitor<T, C>.VisitArchive(Reko.Core.Loading.IArchive archive, C context) -> T
Reko.Core.Loading.ILoadedImageVisitor<T, C>.VisitBlob(Reko.Core.Loading.Blob blob, C context) -> T
Reko.Core.Loading.ILoadedImageVisitor<T, C>.VisitProgram(Reko.Core.Program program, C context) -> T
Reko.Core.Loading.ILoadedImageVisitor<T, C>.VisitProject(Reko.Core.Project project, C context) -> T
Reko.Core.Loading.ILoader
Reko.Core.Loading.ILoader.AssembleExecutable(Reko.Core.ImageLocation asmfileLocation, byte[] bytes, Reko.Core.Assemblers.IAssembler asm, Reko.Core.IPlatform platform, Reko.Core.Address loadAddress) -> Reko.Core.Program
Reko.Core.Loading.ILoader.AssembleExecutable(Reko.Core.ImageLocation asmfileLocation, Reko.Core.Assemblers.IAssembler asm, Reko.Core.IPlatform platform, Reko.Core.Address loadAddress) -> Reko.Core.Program
Reko.Core.Loading.ILoader.DefaultToFormat.get -> string
Reko.Core.Loading.ILoader.DefaultToFormat.set -> void
Reko.Core.Loading.ILoader.Load(Reko.Core.ImageLocation imageLocation, string loader = null, Reko.Core.Address addrLoad = null) -> Reko.Core.Loading.ILoadedImage
Reko.Core.Loading.ILoader.LoadBinaryImage(Reko.Core.ImageLocation imageLocation, byte[] bytes, string loader, Reko.Core.Address loadAddress) -> Reko.Core.Loading.ILoadedImage
Reko.Core.Loading.ILoader.LoadFileBytes(string filename) -> byte[]
Reko.Core.Loading.ILoader.LoadMetadata(Reko.Core.ImageLocation metadataLocation, Reko.Core.IPlatform platform, Reko.Core.TypeLibrary typeLib) -> Reko.Core.TypeLibrary
Reko.Core.Loading.ILoader.LoadRawImage(byte[] bytes, Reko.Core.Loading.LoadDetails raw) -> Reko.Core.Program
Reko.Core.Loading.ILoader.LoadRawImage(Reko.Core.ImageLocation imageLocation, byte[] image, Reko.Core.Address loadAddress, Reko.Core.Loading.LoadDetails details) -> Reko.Core.Program
Reko.Core.Loading.ILoader.LoadRawImage(Reko.Core.ImageLocation imageLocation, Reko.Core.Loading.LoadDetails raw) -> Reko.Core.Program
Reko.Core.Loading.ILoader.LoadScript(Reko.Core.ImageLocation scriptLocation) -> Reko.Core.Scripts.ScriptFile
Reko.Core.Loading.ImageHeader
Reko.Core.Loading.ImageHeader.ImageHeader() -> void
Reko.Core.Loading.ImageLoader
Reko.Core.Loading.ImageLoader.Argument.get -> string
Reko.Core.Loading.ImageLoader.Argument.set -> void
Reko.Core.Loading.ImageLoader.ImageLoader(System.IServiceProvider services, Reko.Core.ImageLocation imageLocation, byte[] imgRaw) -> void
Reko.Core.Loading.ImageLoader.ImageLocation.get -> Reko.Core.ImageLocation
Reko.Core.Loading.ImageLoader.LoadHeader(string argument) -> Reko.Core.Loading.ImageHeader
Reko.Core.Loading.ImageLoader.RawImage.get -> byte[]
Reko.Core.Loading.ImageLoader.Services.get -> System.IServiceProvider
Reko.Core.Loading.ISymbolSource
Reko.Core.Loading.ISymbolSource.CanLoad(string filename, byte[] fileContents) -> bool
Reko.Core.Loading.ISymbolSource.GetAllSymbols() -> System.Collections.Generic.List<Reko.Core.ImageSymbol>
Reko.Core.Loading.LoadDetails
Reko.Core.Loading.LoadDetails.ArchitectureName -> string?
Reko.Core.Loading.LoadDetails.ArchitectureOptions -> System.Collections.Generic.Dictionary<string, object>
Reko.Core.Loading.LoadDetails.EntryPoint -> Reko.Core.Configuration.EntryPointDefinition
Reko.Core.Loading.LoadDetails.LoadAddress -> string
Reko.Core.Loading.LoadDetails.LoadDetails() -> void
Reko.Core.Loading.LoadDetails.LoaderName -> string?
Reko.Core.Loading.LoadDetails.Offset -> long
Reko.Core.Loading.LoadDetails.PlatformName -> string
Reko.Core.Loading.ProgramImageLoader
Reko.Core.Loading.ProgramImageLoader.ProgramImageLoader(System.IServiceProvider services, Reko.Core.ImageLocation imageLocation, byte[] imgRaw) -> void
Reko.Core.Loading.ResourceType
Reko.Core.Loading.ResourceType.FileExtension.get -> string
Reko.Core.Loading.ResourceType.Name.get -> string
Reko.Core.Loading.ResourceType.ResourceType() -> void
Reko.Core.Loading.ResourceType.ResourceType(int id, string name, string fileExtension) -> void
Reko.Core.Loading.ResourceType.Value.get -> int
Reko.Core.Machine.AbstractMachineOperand
Reko.Core.Machine.AbstractMachineOperand.AbstractMachineOperand(Reko.Core.Types.DataType! width) -> void
Reko.Core.Machine.AbstractMachineOperand.Render(Reko.Core.Machine.MachineInstructionRenderer! renderer, Reko.Core.Machine.MachineInstructionRendererOptions! options) -> void
Reko.Core.Machine.AbstractMachineOperand.ToString(Reko.Core.Machine.MachineInstructionRendererOptions! options) -> string!
Reko.Core.Machine.AbstractMachineOperand.Width.get -> Reko.Core.Types.DataType!
Reko.Core.Machine.AbstractMachineOperand.Width.set -> void
Reko.Core.Machine.AddressOperand
Reko.Core.Machine.AddressOperand.Address -> Reko.Core.Address
Reko.Core.Machine.AddressOperand.AddressOperand(Reko.Core.Address addr, Reko.Core.Types.PrimitiveType type) -> void
Reko.Core.Machine.BitfieldDecoder<TDasm, TMnemonic, TInstr>
Reko.Core.Machine.BitfieldDecoder<TDasm, TMnemonic, TInstr>.BitfieldDecoder(Reko.Core.Lib.Bitfield[] bitfields, string tag, Reko.Core.Machine.Decoder<TDasm, TMnemonic, TInstr>[] decoders) -> void
Reko.Core.Machine.BitfieldDecoder<TDasm, TMnemonic, TInstr>.TraceDecoder(uint wInstr, string tag = "") -> void
Reko.Core.Machine.ConditionalDecoder<TDasm, TMnemonic, TInstr>
Reko.Core.Machine.ConditionalDecoder<TDasm, TMnemonic, TInstr>.ConditionalDecoder(Reko.Core.Lib.Bitfield[] bitfields, System.Predicate<uint> predicate, string tag, Reko.Core.Machine.Decoder<TDasm, TMnemonic, TInstr> trueDecoder, Reko.Core.Machine.Decoder<TDasm, TMnemonic, TInstr> falseDecoder) -> void
Reko.Core.Machine.Decoder
Reko.Core.Machine.Decoder.Decoder() -> void
Reko.Core.Machine.Decoder<TDasm, TMnemonic, TInstr>
Reko.Core.Machine.Decoder<TDasm, TMnemonic, TInstr>.Decoder() -> void
Reko.Core.Machine.DisassemblerBase
Reko.Core.Machine.DisassemblerBase.DisassemblerBase() -> void
Reko.Core.Machine.DisassemblerBase.Dispose() -> void
Reko.Core.Machine.DisassemblerBase.~DisassemblerBase() -> void
Reko.Core.Machine.DisassemblerBase<TInstr, TMnemonic>
Reko.Core.Machine.DisassemblerBase<TInstr, TMnemonic>.DisassemblerBase() -> void
Reko.Core.Machine.FlagGroupOperand
Reko.Core.Machine.FlagGroupOperand.FlagGroup.get -> Reko.Core.FlagGroupStorage
Reko.Core.Machine.FlagGroupOperand.FlagGroupOperand(Reko.Core.FlagGroupStorage grf) -> void
Reko.Core.Machine.FpuOperand
Reko.Core.Machine.FpuOperand.FpuOperand(int f) -> void
Reko.Core.Machine.FpuOperand.StNumber.get -> int
Reko.Core.Machine.IfDecoder<TDasm, TMnemonic, TInstr>
Reko.Core.Machine.IfDecoder<TDasm, TMnemonic, TInstr>.IfDecoder(Reko.Core.Lib.Bitfield bf, System.Predicate<uint> predicate, Reko.Core.Machine.Decoder<TDasm, TMnemonic, TInstr> trueDecoder) -> void
Reko.Core.Machine.ImmediateOperand
Reko.Core.Machine.ImmediateOperand.ImmediateOperand(Reko.Core.Expressions.Constant! c) -> void
Reko.Core.Machine.ImmediateOperand.Value.get -> Reko.Core.Expressions.Constant!
Reko.Core.Machine.InstrDecoder<TDasm, TMnemonic, TInstr>
Reko.Core.Machine.InstrDecoder<TDasm, TMnemonic, TInstr>.InstrDecoder(Reko.Core.InstrClass iclass, TMnemonic mnemonic, params Reko.Core.Machine.Mutator<TDasm>[] mutators) -> void
Reko.Core.Machine.InstructionComparer
Reko.Core.Machine.InstructionComparer.CompareRegisters(Reko.Core.RegisterStorage regA, Reko.Core.RegisterStorage regB) -> bool
Reko.Core.Machine.InstructionComparer.CompareValues(Reko.Core.Expressions.Constant constA, Reko.Core.Expressions.Constant constB) -> bool
Reko.Core.Machine.InstructionComparer.GetConstantHash(Reko.Core.Expressions.Constant c) -> int
Reko.Core.Machine.InstructionComparer.GetHashCode(Reko.Core.Machine.MachineInstruction instr) -> int
Reko.Core.Machine.InstructionComparer.GetRegisterHash(Reko.Core.RegisterStorage r) -> int
Reko.Core.Machine.InstructionComparer.InstructionComparer(Reko.Core.Normalize norm) -> void
Reko.Core.Machine.InstructionComparer.NormalizeConstants.get -> bool
Reko.Core.Machine.InstructionComparer.NormalizeRegisters.get -> bool
Reko.Core.Machine.MachineInstruction
Reko.Core.Machine.MachineInstruction.Address.get -> Reko.Core.Address
Reko.Core.Machine.MachineInstruction.Address.set -> void
Reko.Core.Machine.MachineInstruction.Contains(Reko.Core.Address addr) -> bool
Reko.Core.Machine.MachineInstruction.InstructionClass.get -> Reko.Core.InstrClass
Reko.Core.Machine.MachineInstruction.InstructionClass.set -> void
Reko.Core.Machine.MachineInstruction.IsValid.get -> bool
Reko.Core.Machine.MachineInstruction.Length.get -> int
Reko.Core.Machine.MachineInstruction.Length.set -> void
Reko.Core.Machine.MachineInstruction.MachineInstruction() -> void
Reko.Core.Machine.MachineInstruction.Operands.get -> Reko.Core.Machine.MachineOperand[]
Reko.Core.Machine.MachineInstruction.Operands.set -> void
Reko.Core.Machine.MachineInstruction.Render(Reko.Core.Machine.MachineInstructionRenderer renderer, Reko.Core.Machine.MachineInstructionRendererOptions options) -> void
Reko.Core.Machine.MachineInstruction.RenderOperands(Reko.Core.Machine.MachineInstructionRenderer renderer, Reko.Core.Machine.MachineInstructionRendererOptions options) -> void
Reko.Core.Machine.MachineInstruction.ToString(Reko.Core.Machine.MachineInstructionRendererOptions options) -> string
Reko.Core.Machine.MachineInstructionRenderer
Reko.Core.Machine.MachineInstructionRenderer.Address.get -> Reko.Core.Address
Reko.Core.Machine.MachineInstructionRenderer.BeginInstruction(Reko.Core.Address addr) -> void
Reko.Core.Machine.MachineInstructionRenderer.BeginOperand() -> void
Reko.Core.Machine.MachineInstructionRenderer.EndInstruction() -> void
Reko.Core.Machine.MachineInstructionRenderer.EndOperand() -> void
Reko.Core.Machine.MachineInstructionRenderer.WriteAddress(string formattedAddress, Reko.Core.Address addr) -> void
Reko.Core.Machine.MachineInstructionRenderer.WriteFormat(string fmt, params object[] parms) -> void
Reko.Core.Machine.MachineInstructionRendererFlags
Reko.Core.Machine.MachineInstructionRendererFlags.ExplicitOperandSize = 1 -> Reko.Core.Machine.MachineInstructionRendererFlags
Reko.Core.Machine.MachineInstructionRendererFlags.None = 0 -> Reko.Core.Machine.MachineInstructionRendererFlags
Reko.Core.Machine.MachineInstructionRendererFlags.ResolvePcRelativeAddress = 2 -> Reko.Core.Machine.MachineInstructionRendererFlags
Reko.Core.Machine.MachineInstructionRendererOptions
Reko.Core.Machine.MachineInstructionRendererOptions.Flags.get -> Reko.Core.Machine.MachineInstructionRendererFlags
Reko.Core.Machine.MachineInstructionRendererOptions.MachineInstructionRendererOptions(string syntax = "", Reko.Core.Machine.MachineInstructionRendererFlags flags = Reko.Core.Machine.MachineInstructionRendererFlags.None, string operandSeparator = ",", Reko.Core.IPlatform platform = null) -> void
Reko.Core.Machine.MachineInstructionRendererOptions.NullSymbolResolver(Reko.Core.Address addr, out string symbolName, out long offset) -> bool
Reko.Core.Machine.MachineInstructionRendererOptions.OperandSeparator.get -> string
Reko.Core.Machine.MachineInstructionRendererOptions.Platform.get -> Reko.Core.IPlatform
Reko.Core.Machine.MachineInstructionRendererOptions.SymbolResolver.get -> Reko.Core.Machine.SymbolResolver
Reko.Core.Machine.MachineInstructionRendererOptions.SymbolResolver.set -> void
Reko.Core.Machine.MachineInstructionRendererOptions.Syntax.get -> string
Reko.Core.Machine.MachineOperand
Reko.Core.Machine.MachineOperand.Render(Reko.Core.Machine.MachineInstructionRenderer! renderer, Reko.Core.Machine.MachineInstructionRendererOptions! options) -> void
Reko.Core.Machine.MachineOperand.ToString(Reko.Core.Machine.MachineInstructionRendererOptions! options) -> string!
Reko.Core.Machine.MachineOperand.Width.get -> Reko.Core.Types.DataType!
Reko.Core.Machine.MachineOperand.Width.set -> void
Reko.Core.Machine.MaskDecoder<TDasm, TMnemonic, TInstr>
Reko.Core.Machine.MaskDecoder<TDasm, TMnemonic, TInstr>.MaskDecoder(int bitPos, int bitSize, string tag, params Reko.Core.Machine.Decoder<TDasm, TMnemonic, TInstr>[] decoders) -> void
Reko.Core.Machine.MaskDecoder<TDasm, TMnemonic, TInstr>.TraceDecoder(uint wInstr) -> void
Reko.Core.Machine.Mutator<TDasm>
Reko.Core.Machine.NyiDecoder<TDasm, TMnemonic, TInstr>
Reko.Core.Machine.NyiDecoder<TDasm, TMnemonic, TInstr>.NyiDecoder(string message) -> void
Reko.Core.Machine.StringRenderer
Reko.Core.Machine.StringRenderer.AddAnnotation(string annotation) -> void
Reko.Core.Machine.StringRenderer.Address.get -> Reko.Core.Address
Reko.Core.Machine.StringRenderer.BeginInstruction(Reko.Core.Address addr) -> void
Reko.Core.Machine.StringRenderer.BeginOperand() -> void
Reko.Core.Machine.StringRenderer.EndInstruction() -> void
Reko.Core.Machine.StringRenderer.EndOperand() -> void
Reko.Core.Machine.StringRenderer.StringRenderer() -> void
Reko.Core.Machine.StringRenderer.Tab() -> void
Reko.Core.Machine.StringRenderer.WriteAddress(string formattedAddress, Reko.Core.Address addr) -> void
Reko.Core.Machine.StringRenderer.WriteAddress(string formattedAddress, ulong uAddr) -> void
Reko.Core.Machine.StringRenderer.WriteChar(char c) -> void
Reko.Core.Machine.StringRenderer.WriteFormat(string fmt, params object[] parms) -> void
Reko.Core.Machine.StringRenderer.WriteMnemonic(string sMnemonic) -> void
Reko.Core.Machine.StringRenderer.WriteString(string s) -> void
Reko.Core.Machine.StringRenderer.WriteUInt32(uint u) -> void
Reko.Core.Machine.SymbolResolver
Reko.Core.Machine.WideDecoder<TDasm, TMnemonic, TInstr>
Reko.Core.Machine.WideDecoder<TDasm, TMnemonic, TInstr>.WideDecoder() -> void
Reko.Core.Machine.WideInstrDecoder<TDasm, TMnemonic, TInstr>
Reko.Core.Machine.WideInstrDecoder<TDasm, TMnemonic, TInstr>.WideInstrDecoder(Reko.Core.InstrClass iclass, TMnemonic mnemonic, params Reko.Core.Machine.WideMutator<TDasm>[] mutators) -> void
Reko.Core.Machine.WideMaskDecoder<TDasm, TMnemonic, TInstr>
Reko.Core.Machine.WideMaskDecoder<TDasm, TMnemonic, TInstr>.TraceDecoder(uint wInstr) -> void
Reko.Core.Machine.WideMaskDecoder<TDasm, TMnemonic, TInstr>.TraceDecoder(ulong wInstr) -> void
Reko.Core.Machine.WideMaskDecoder<TDasm, TMnemonic, TInstr>.WideMaskDecoder(int bitPos, int bitSize, string tag, params Reko.Core.Machine.WideDecoder<TDasm, TMnemonic, TInstr>[] decoders) -> void
Reko.Core.Machine.WideMaskDecoder<TDasm, TMnemonic, TInstr>.WideMaskDecoder(Reko.Core.Lib.Bitfield bitfield, string tag, params Reko.Core.Machine.WideDecoder<TDasm, TMnemonic, TInstr>[] decoders) -> void
Reko.Core.Machine.WideMutator<TDasm>
Reko.Core.Machine.WideNyiDecoder<TDasm, TMnemonic, TInstr>
Reko.Core.Machine.WideNyiDecoder<TDasm, TMnemonic, TInstr>.WideNyiDecoder(string message) -> void
Reko.Core.MaskedPattern
Reko.Core.MaskedPattern.Bytes -> byte[]?
Reko.Core.MaskedPattern.Mask -> byte[]?
Reko.Core.MaskedPattern.MaskedPattern() -> void
Reko.Core.Memory.BeImageReader
Reko.Core.Memory.BeImageReader.BeImageReader(byte[] bytes, long offset = 0) -> void
Reko.Core.Memory.BeImageReader.BeImageReader(byte[] bytes, long offset, long offsetEnd) -> void
Reko.Core.Memory.BeImageReader.BeImageReader(Reko.Core.Memory.ByteMemoryArea image, long offset) -> void
Reko.Core.Memory.BeImageReader.BeImageReader(Reko.Core.Memory.ByteMemoryArea image, long offsetBegin, long offsetEnd) -> void
Reko.Core.Memory.BeImageReader.BeImageReader(Reko.Core.Memory.ByteMemoryArea image, Reko.Core.Address addr) -> void
Reko.Core.Memory.BeImageReader.BeImageReader(Reko.Core.Memory.ByteMemoryArea image, Reko.Core.Address addr, long cUnits) -> void
Reko.Core.Memory.BeImageReader.BeImageReader(Reko.Core.Memory.ByteMemoryArea image, Reko.Core.Address addrBegin, Reko.Core.Address addrEnd) -> void
Reko.Core.Memory.BeImageReader.ReadAt<T>(long offset, System.Func<Reko.Core.Memory.BeImageReader, T> action) -> T
Reko.Core.Memory.BeImageWriter
Reko.Core.Memory.BeImageWriter.BeImageWriter() -> void
Reko.Core.Memory.BeImageWriter.BeImageWriter(byte[] image) -> void
Reko.Core.Memory.BeImageWriter.BeImageWriter(byte[] image, uint offset) -> void
Reko.Core.Memory.BeImageWriter.BeImageWriter(Reko.Core.Memory.ByteMemoryArea mem, long offset) -> void
Reko.Core.Memory.BeImageWriter.BeImageWriter(Reko.Core.Memory.ByteMemoryArea mem, Reko.Core.Address addr) -> void
Reko.Core.Memory.ByteImageReader
Reko.Core.Memory.ByteImageReader.Address.get -> Reko.Core.Address!
Reko.Core.Memory.ByteImageReader.addrStart -> Reko.Core.Address?
Reko.Core.Memory.ByteImageReader.ByteImageReader(byte[]! img, long off = 0) -> void
Reko.Core.Memory.ByteImageReader.ByteImageReader(byte[]! img, long off, long offEnd) -> void
Reko.Core.Memory.ByteImageReader.ByteImageReader(Reko.Core.Memory.ByteMemoryArea mem, long off) -> void
Reko.Core.Memory.ByteImageReader.ByteImageReader(Reko.Core.Memory.ByteMemoryArea mem, long offStart, long offEnd) -> void
Reko.Core.Memory.ByteImageReader.ByteImageReader(Reko.Core.Memory.ByteMemoryArea! mem, Reko.Core.Address! addr) -> void
Reko.Core.Memory.ByteImageReader.ByteImageReader(Reko.Core.Memory.ByteMemoryArea! mem, Reko.Core.Address! addr, long cUnits) -> void
Reko.Core.Memory.ByteImageReader.ByteImageReader(Reko.Core.Memory.ByteMemoryArea! mem, Reko.Core.Address! addrBegin, Reko.Core.Address! addrEnd) -> void
Reko.Core.Memory.ByteImageReader.bytes -> byte[]!
Reko.Core.Memory.ByteImageReader.Bytes.get -> byte[]!
Reko.Core.Memory.ByteImageReader.Clone() -> Reko.Core.Memory.ByteImageReader!
Reko.Core.Memory.ByteImageReader.CreateBinaryReader() -> System.IO.BinaryReader!
Reko.Core.Memory.ByteImageReader.IsValid.get -> bool
Reko.Core.Memory.ByteImageReader.IsValidOffset(long offset) -> bool
Reko.Core.Memory.ByteImageReader.mem -> Reko.Core.Memory.MemoryArea?
Reko.Core.Memory.ByteImageReader.off -> long
Reko.Core.Memory.ByteImageReader.offEnd -> long
Reko.Core.Memory.ByteImageReader.Offset.get -> long
Reko.Core.Memory.ByteImageReader.Offset.set -> void
Reko.Core.Memory.ByteImageReader.offStart -> long
Reko.Core.Memory.ByteImageReader.PeekBeInt16(int offset) -> short
Reko.Core.Memory.ByteImageReader.PeekBeInt32(int offset) -> int
Reko.Core.Memory.ByteImageReader.PeekBeInt64(int offset) -> long
Reko.Core.Memory.ByteImageReader.PeekBeUInt16(int offset) -> ushort
Reko.Core.Memory.ByteImageReader.PeekBeUInt32(int offset) -> uint
Reko.Core.Memory.ByteImageReader.PeekBeUInt64(int offset) -> ulong
Reko.Core.Memory.ByteImageReader.PeekByte(int offset) -> byte
Reko.Core.Memory.ByteImageReader.PeekLeInt16(int offset) -> short
Reko.Core.Memory.ByteImageReader.PeekLeInt32(int offset) -> int
Reko.Core.Memory.ByteImageReader.PeekLeInt64(int offset) -> long
Reko.Core.Memory.ByteImageReader.PeekLeUInt16(int offset) -> ushort
Reko.Core.Memory.ByteImageReader.PeekLeUInt32(int offset) -> uint
Reko.Core.Memory.ByteImageReader.PeekLeUInt64(int offset) -> ulong
Reko.Core.Memory.ByteImageReader.PeekSByte(int offset) -> sbyte
Reko.Core.Memory.ByteImageReader.Read(byte[]! buffer, int offset, int count) -> int
Reko.Core.Memory.ByteImageReader.ReadBeInt16() -> short
Reko.Core.Memory.ByteImageReader.ReadBeInt32() -> int
Reko.Core.Memory.ByteImageReader.ReadBeInt64() -> long
Reko.Core.Memory.ByteImageReader.ReadBeUInt16() -> ushort
Reko.Core.Memory.ByteImageReader.ReadBeUInt32() -> uint
Reko.Core.Memory.ByteImageReader.ReadBeUInt64() -> ulong
Reko.Core.Memory.ByteImageReader.ReadByte() -> byte
Reko.Core.Memory.ByteImageReader.ReadBytes(byte[]! dst, int offset, uint length) -> int
Reko.Core.Memory.ByteImageReader.ReadBytes(int length) -> byte[]!
Reko.Core.Memory.ByteImageReader.ReadBytes(uint length) -> byte[]!
Reko.Core.Memory.ByteImageReader.ReadLeInt16() -> short
Reko.Core.Memory.ByteImageReader.ReadLeInt32() -> int
Reko.Core.Memory.ByteImageReader.ReadLeInt64() -> long
Reko.Core.Memory.ByteImageReader.ReadLeUInt16() -> ushort
Reko.Core.Memory.ByteImageReader.ReadLeUInt32() -> uint
Reko.Core.Memory.ByteImageReader.ReadLeUInt64() -> ulong
Reko.Core.Memory.ByteImageReader.ReadSByte() -> sbyte
Reko.Core.Memory.ByteImageReader.ReadToEnd() -> byte[]!
Reko.Core.Memory.ByteImageReader.Seek(long offset, System.IO.SeekOrigin origin = System.IO.SeekOrigin.Current) -> long
Reko.Core.Memory.ByteImageReader.TryPeekBeUInt16(int offset, out ushort value) -> bool
Reko.Core.Memory.ByteImageReader.TryPeekBeUInt32(int offset, out uint value) -> bool
Reko.Core.Memory.ByteImageReader.TryPeekBeUInt64(int offset, out ulong value) -> bool
Reko.Core.Memory.ByteImageReader.TryPeekByte(int offset, out byte value) -> bool
Reko.Core.Memory.ByteImageReader.TryPeekLeUInt16(int offset, out ushort value) -> bool
Reko.Core.Memory.ByteImageReader.TryPeekLeUInt32(int offset, out uint value) -> bool
Reko.Core.Memory.ByteImageReader.TryPeekLeUInt64(int offset, out ulong value) -> bool
Reko.Core.Memory.ByteImageReader.TryReadBe(Reko.Core.Types.DataType! dataType, out Reko.Core.Expressions.Constant! c) -> bool
Reko.Core.Memory.ByteImageReader.TryReadBeInt16(out short s) -> bool
Reko.Core.Memory.ByteImageReader.TryReadBeInt32(out int i32) -> bool
Reko.Core.Memory.ByteImageReader.TryReadBeInt64(out long value) -> bool
Reko.Core.Memory.ByteImageReader.TryReadBeUInt16(out ushort us) -> bool
Reko.Core.Memory.ByteImageReader.TryReadBeUInt32(out uint ui32) -> bool
Reko.Core.Memory.ByteImageReader.TryReadBeUInt64(out ulong value) -> bool
Reko.Core.Memory.ByteImageReader.TryReadByte(out byte b) -> bool
Reko.Core.Memory.ByteImageReader.TryReadLe(Reko.Core.Types.DataType! dataType, out Reko.Core.Expressions.Constant! c) -> bool
Reko.Core.Memory.ByteImageReader.TryReadLeInt16(out short i16) -> bool
Reko.Core.Memory.ByteImageReader.TryReadLeInt32(out int i32) -> bool
Reko.Core.Memory.ByteImageReader.TryReadLeInt64(out long value) -> bool
Reko.Core.Memory.ByteImageReader.TryReadLeSigned(Reko.Core.Types.DataType! w, out long value) -> bool
Reko.Core.Memory.ByteImageReader.TryReadLeUInt16(out ushort us) -> bool
Reko.Core.Memory.ByteImageReader.TryReadLeUInt32(out uint ui32) -> bool
Reko.Core.Memory.ByteImageReader.TryReadLeUInt64(out ulong value) -> bool
Reko.Core.Memory.ByteMemoryArea
Reko.Core.Memory.ByteMemoryArea.ByteMemoryArea(Reko.Core.Address addrBase, byte[] bytes) -> void
Reko.Core.Memory.ByteMemoryArea.Bytes.get -> byte[]
Reko.Core.Memory.ByteMemoryArea.FixupLeUInt16(uint imageOffset, ushort delta) -> ushort
Reko.Core.Memory.ByteMemoryArea.ReadBeInt16(uint off) -> short
Reko.Core.Memory.ByteMemoryArea.ReadBeInt32(uint off) -> int
Reko.Core.Memory.ByteMemoryArea.ReadBeUInt16(uint off) -> ushort
Reko.Core.Memory.ByteMemoryArea.ReadBeUInt32(uint off) -> uint
Reko.Core.Memory.ByteMemoryArea.ReadByte(Reko.Core.Address addr) -> byte
Reko.Core.Memory.ByteMemoryArea.ReadLeDouble(long off) -> Reko.Core.Expressions.Constant
Reko.Core.Memory.ByteMemoryArea.ReadLeDouble(Reko.Core.Address addr) -> Reko.Core.Expressions.Constant
Reko.Core.Memory.ByteMemoryArea.ReadLeFloat(long off) -> Reko.Core.Expressions.Constant
Reko.Core.Memory.ByteMemoryArea.ReadLeFloat(Reko.Core.Address addr) -> Reko.Core.Expressions.Constant
Reko.Core.Memory.ByteMemoryArea.ReadLeInt16(Reko.Core.Address addr) -> short
Reko.Core.Memory.ByteMemoryArea.ReadLeInt16(uint off) -> short
Reko.Core.Memory.ByteMemoryArea.ReadLeInt32(Reko.Core.Address addr) -> int
Reko.Core.Memory.ByteMemoryArea.ReadLeInt32(uint off) -> int
Reko.Core.Memory.ByteMemoryArea.ReadLeInt64(Reko.Core.Address addr) -> long
Reko.Core.Memory.ByteMemoryArea.ReadLeInt64(uint off) -> long
Reko.Core.Memory.ByteMemoryArea.ReadLeUInt16(Reko.Core.Address addr) -> ushort
Reko.Core.Memory.ByteMemoryArea.ReadLeUInt16(uint off) -> ushort
Reko.Core.Memory.ByteMemoryArea.ReadLeUInt32(Reko.Core.Address addr) -> uint
Reko.Core.Memory.ByteMemoryArea.ReadLeUInt32(uint off) -> uint
Reko.Core.Memory.ByteMemoryArea.ReadLeUint64(Reko.Core.Address addr) -> ulong
Reko.Core.Memory.ByteMemoryArea.ReadLeUint64(uint off) -> ulong
Reko.Core.Memory.ByteMemoryArea.ReadRelocation(long imageOffset) -> Reko.Core.Expressions.Constant
Reko.Core.Memory.ByteMemoryArea.TryReadByte(Reko.Core.Address addr, out byte b) -> bool
Reko.Core.Memory.ByteMemoryArea.TryReadBytes(long off, int length, byte[] membuf) -> bool
Reko.Core.Memory.ByteMemoryArea.TryReadBytes(Reko.Core.Address addr, int length, byte[] membuf) -> bool
Reko.Core.Memory.ByteMemoryArea.WriteByte(Reko.Core.Address addr, byte b) -> void
Reko.Core.Memory.ByteMemoryArea.WriteBytes(byte[] srcBytes, long offset, int count) -> void
Reko.Core.Memory.ByteMemoryArea.WriteLeUInt16(Reko.Core.Address addr, ushort w) -> void
Reko.Core.Memory.EndianByteImageReader
Reko.Core.Memory.EndianByteImageReader.EndianByteImageReader(byte[] img, long off = 0) -> void
Reko.Core.Memory.EndianByteImageReader.EndianByteImageReader(byte[] img, long off, long offEnd) -> void
Reko.Core.Memory.EndianByteImageReader.EndianByteImageReader(Reko.Core.Memory.ByteMemoryArea img, long off) -> void
Reko.Core.Memory.EndianByteImageReader.EndianByteImageReader(Reko.Core.Memory.ByteMemoryArea img, long offsetBegin, long offsetEnd) -> void
Reko.Core.Memory.EndianByteImageReader.EndianByteImageReader(Reko.Core.Memory.ByteMemoryArea img, Reko.Core.Address addr) -> void
Reko.Core.Memory.EndianByteImageReader.EndianByteImageReader(Reko.Core.Memory.ByteMemoryArea img, Reko.Core.Address addr, long cUnits) -> void
Reko.Core.Memory.EndianByteImageReader.EndianByteImageReader(Reko.Core.Memory.ByteMemoryArea img, Reko.Core.Address addrBegin, Reko.Core.Address addrEnd) -> void
Reko.Core.Memory.EndianByteImageReader.ReadAt<T>(long offset, System.Func<Reko.Core.Memory.EndianImageReader, T> action) -> T
Reko.Core.Memory.EndianByteImageReader.ReadCString(Reko.Core.Types.DataType charType, System.Text.Encoding encoding) -> Reko.Core.Expressions.StringConstant
Reko.Core.Memory.EndianByteImageReader.ReadLengthPrefixedString(Reko.Core.Types.PrimitiveType lengthType, Reko.Core.Types.PrimitiveType charType, System.Text.Encoding encoding) -> Reko.Core.Expressions.StringConstant
Reko.Core.Memory.EndianByteImageReader.ReadNullCharTerminator(Reko.Core.Types.DataType charType) -> bool
Reko.Core.Memory.EndianImageReader
Reko.Core.Memory.EndianImageReader.Clone() -> Reko.Core.Memory.EndianImageReader
Reko.Core.Memory.EndianImageReader.CreateNew(Reko.Core.Memory.MemoryArea image, Reko.Core.Address addr) -> Reko.Core.Memory.EndianImageReader
Reko.Core.Memory.EndianImageReader.ReadCString(Reko.Core.Types.DataType charType, System.Text.Encoding encoding) -> Reko.Core.Expressions.StringConstant
Reko.Core.Memory.EndianImageReader.ReadInt16() -> short
Reko.Core.Memory.EndianImageReader.ReadInt32() -> int
Reko.Core.Memory.EndianImageReader.ReadInt64() -> long
Reko.Core.Memory.EndianImageReader.ReadNullCharTerminator(Reko.Core.Types.DataType dtChar) -> bool
Reko.Core.Memory.EndianImageReader.ReadUInt16() -> ushort
Reko.Core.Memory.EndianImageReader.ReadUInt32() -> uint
Reko.Core.Memory.EndianImageReader.ReadUInt64() -> ulong
Reko.Core.Memory.EndianImageReader.TryPeekUInt32(int offset, out uint value) -> bool
Reko.Core.Memory.EndianImageReader.TryPeekUInt64(int offset, out ulong value) -> bool
Reko.Core.Memory.EndianImageReader.TryRead(Reko.Core.Types.PrimitiveType dataType, out Reko.Core.Expressions.Constant value) -> bool
Reko.Core.Memory.EndianImageReader.TryReadInt16(out short value) -> bool
Reko.Core.Memory.EndianImageReader.TryReadInt32(out int value) -> bool
Reko.Core.Memory.EndianImageReader.TryReadInt64(out long value) -> bool
Reko.Core.Memory.EndianImageReader.TryReadUInt16(out ushort value) -> bool
Reko.Core.Memory.EndianImageReader.TryReadUInt32(out uint value) -> bool
Reko.Core.Memory.EndianImageReader.TryReadUInt64(out ulong value) -> bool
Reko.Core.Memory.ImageReader
Reko.Core.Memory.ImageReader.Address.get -> Reko.Core.Address
Reko.Core.Memory.ImageReader.CreateBinaryReader() -> System.IO.BinaryReader
Reko.Core.Memory.ImageReader.IsValid.get -> bool
Reko.Core.Memory.ImageReader.IsValidOffset(long offset) -> bool
Reko.Core.Memory.ImageReader.Offset.get -> long
Reko.Core.Memory.ImageReader.Offset.set -> void
Reko.Core.Memory.ImageReader.PeekBeInt16(int offset) -> short
Reko.Core.Memory.ImageReader.PeekBeInt32(int offset) -> int
Reko.Core.Memory.ImageReader.PeekBeUInt32(int offset) -> uint
Reko.Core.Memory.ImageReader.PeekBeUInt64(int offset) -> ulong
Reko.Core.Memory.ImageReader.PeekByte(int offset) -> byte
Reko.Core.Memory.ImageReader.PeekLeInt16(int offset) -> short
Reko.Core.Memory.ImageReader.PeekLeInt32(int offset) -> int
Reko.Core.Memory.ImageReader.PeekLeUInt16(int offset) -> ushort
Reko.Core.Memory.ImageReader.PeekLeUInt32(int offset) -> uint
Reko.Core.Memory.ImageReader.PeekLeUInt64(int offset) -> ulong
Reko.Core.Memory.ImageReader.PeekSByte(int offset) -> sbyte
Reko.Core.Memory.ImageReader.ReadBeInt16() -> short
Reko.Core.Memory.ImageReader.ReadBeInt32() -> int
Reko.Core.Memory.ImageReader.ReadBeUInt16() -> ushort
Reko.Core.Memory.ImageReader.ReadBeUInt32() -> uint
Reko.Core.Memory.ImageReader.ReadBeUInt64() -> ulong
Reko.Core.Memory.ImageReader.ReadByte() -> byte
Reko.Core.Memory.ImageReader.ReadBytes(int addressUnits) -> byte[]
Reko.Core.Memory.ImageReader.ReadBytes(uint addressUnits) -> byte[]
Reko.Core.Memory.ImageReader.ReadLeInt16() -> short
Reko.Core.Memory.ImageReader.ReadLeInt32() -> int
Reko.Core.Memory.ImageReader.ReadLeInt64() -> long
Reko.Core.Memory.ImageReader.ReadLeUInt16() -> ushort
Reko.Core.Memory.ImageReader.ReadLeUInt32() -> uint
Reko.Core.Memory.ImageReader.ReadLeUInt64() -> ulong
Reko.Core.Memory.ImageReader.ReadSByte() -> sbyte
Reko.Core.Memory.ImageReader.Seek(long offset, System.IO.SeekOrigin origin = System.IO.SeekOrigin.Current) -> long
Reko.Core.Memory.ImageReader.TryPeekBeUInt16(int offset, out ushort value) -> bool
Reko.Core.Memory.ImageReader.TryPeekBeUInt32(int offset, out uint value) -> bool
Reko.Core.Memory.ImageReader.TryPeekBeUInt64(int offset, out ulong value) -> bool
Reko.Core.Memory.ImageReader.TryPeekByte(int offset, out byte value) -> bool
Reko.Core.Memory.ImageReader.TryPeekLeUInt16(int offset, out ushort value) -> bool
Reko.Core.Memory.ImageReader.TryPeekLeUInt32(int offset, out uint value) -> bool
Reko.Core.Memory.ImageReader.TryReadBe(Reko.Core.Types.DataType dataType, out Reko.Core.Expressions.Constant value) -> bool
Reko.Core.Memory.ImageReader.TryReadBeInt16(out short value) -> bool
Reko.Core.Memory.ImageReader.TryReadBeInt32(out int value) -> bool
Reko.Core.Memory.ImageReader.TryReadBeUInt16(out ushort value) -> bool
Reko.Core.Memory.ImageReader.TryReadBeUInt32(out uint value) -> bool
Reko.Core.Memory.ImageReader.TryReadByte(out byte value) -> bool
Reko.Core.Memory.ImageReader.TryReadLe(Reko.Core.Types.DataType dataType, out Reko.Core.Expressions.Constant value) -> bool
Reko.Core.Memory.ImageReader.TryReadLeInt16(out short value) -> bool
Reko.Core.Memory.ImageReader.TryReadLeSigned(Reko.Core.Types.DataType dataType, out long value) -> bool
Reko.Core.Memory.ImageReader.TryReadLeUInt16(out ushort value) -> bool
Reko.Core.Memory.ImageReader.TryReadLeUInt32(out uint value) -> bool
Reko.Core.Memory.ImageReader.TryReadLeUInt64(out ulong value) -> bool
Reko.Core.Memory.ImageWriter
Reko.Core.Memory.ImageWriter.Bytes.get -> byte[]
Reko.Core.Memory.ImageWriter.ImageWriter() -> void
Reko.Core.Memory.ImageWriter.ImageWriter(byte[] image) -> void
Reko.Core.Memory.ImageWriter.ImageWriter(byte[] image, uint offset) -> void
Reko.Core.Memory.ImageWriter.ImageWriter(Reko.Core.Memory.ByteMemoryArea mem, long offset) -> void
Reko.Core.Memory.ImageWriter.ImageWriter(Reko.Core.Memory.ByteMemoryArea mem, Reko.Core.Address addr) -> void
Reko.Core.Memory.ImageWriter.Position.get -> int
Reko.Core.Memory.ImageWriter.Position.set -> void
Reko.Core.Memory.ImageWriter.ToArray() -> byte[]
Reko.Core.Memory.ImageWriter.WriteBeUInt16(ushort us) -> Reko.Core.Memory.ImageWriter
Reko.Core.Memory.ImageWriter.WriteBeUInt32(uint offset, uint ui) -> Reko.Core.Memory.ImageWriter
Reko.Core.Memory.ImageWriter.WriteBeUInt32(uint ui) -> Reko.Core.Memory.ImageWriter
Reko.Core.Memory.ImageWriter.WriteBeUInt64(ulong qw) -> Reko.Core.Memory.ImageWriter
Reko.Core.Memory.ImageWriter.WriteByte(byte b) -> Reko.Core.Memory.ImageWriter
Reko.Core.Memory.ImageWriter.WriteBytes(byte b, uint count) -> Reko.Core.Memory.ImageWriter
Reko.Core.Memory.ImageWriter.WriteBytes(byte[] bytes) -> Reko.Core.Memory.ImageWriter
Reko.Core.Memory.ImageWriter.WriteBytes(byte[] bytes, int offset, int count) -> Reko.Core.Memory.ImageWriter
Reko.Core.Memory.ImageWriter.WriteBytes(byte[] bytes, uint offset, uint count) -> Reko.Core.Memory.ImageWriter
Reko.Core.Memory.ImageWriter.WriteLeInt16(short us) -> Reko.Core.Memory.ImageWriter
Reko.Core.Memory.ImageWriter.WriteLeInt32(int i) -> Reko.Core.Memory.ImageWriter
Reko.Core.Memory.ImageWriter.WriteLeInt64(long qw) -> Reko.Core.Memory.ImageWriter
Reko.Core.Memory.ImageWriter.WriteLeUInt16(ushort us) -> Reko.Core.Memory.ImageWriter
Reko.Core.Memory.ImageWriter.WriteLeUInt32(uint offset, uint ui) -> Reko.Core.Memory.ImageWriter
Reko.Core.Memory.ImageWriter.WriteLeUInt32(uint ui) -> Reko.Core.Memory.ImageWriter
Reko.Core.Memory.ImageWriter.WriteLeUInt64(uint offset, ulong qw) -> Reko.Core.Memory.ImageWriter
Reko.Core.Memory.ImageWriter.WriteLeUInt64(ulong qw) -> Reko.Core.Memory.ImageWriter
Reko.Core.Memory.ImageWriter.WriteString(string str, System.Text.Encoding enc) -> Reko.Core.Memory.ImageWriter
Reko.Core.Memory.LeImageReader
Reko.Core.Memory.LeImageReader.LeImageReader(byte[] bytes, long offset = 0) -> void
Reko.Core.Memory.LeImageReader.LeImageReader(byte[] bytes, long offsetBegin, long offsetEnd) -> void
Reko.Core.Memory.LeImageReader.LeImageReader(Reko.Core.Memory.ByteMemoryArea image, long offset) -> void
Reko.Core.Memory.LeImageReader.LeImageReader(Reko.Core.Memory.ByteMemoryArea image, long offsetBegin, long offsetEnd) -> void
Reko.Core.Memory.LeImageReader.LeImageReader(Reko.Core.Memory.ByteMemoryArea image, Reko.Core.Address addr) -> void
Reko.Core.Memory.LeImageReader.LeImageReader(Reko.Core.Memory.ByteMemoryArea image, Reko.Core.Address addr, long cUnits) -> void
Reko.Core.Memory.LeImageReader.LeImageReader(Reko.Core.Memory.ByteMemoryArea image, Reko.Core.Address addrBegin, Reko.Core.Address addrEnd) -> void
Reko.Core.Memory.LeImageReader.ReadAt<T>(long offset, System.Func<Reko.Core.Memory.LeImageReader, T> action) -> T
Reko.Core.Memory.LeImageWriter
Reko.Core.Memory.LeImageWriter.LeImageWriter() -> void
Reko.Core.Memory.LeImageWriter.LeImageWriter(byte[] image) -> void
Reko.Core.Memory.LeImageWriter.LeImageWriter(byte[] image, uint offset) -> void
Reko.Core.Memory.LeImageWriter.LeImageWriter(Reko.Core.Memory.ByteMemoryArea mem, long offset) -> void
Reko.Core.Memory.LeImageWriter.LeImageWriter(Reko.Core.Memory.ByteMemoryArea mem, Reko.Core.Address addr) -> void
Reko.Core.Memory.MemoryArea
Reko.Core.Memory.MemoryArea.BaseAddress.get -> Reko.Core.Address
Reko.Core.Memory.MemoryArea.CellBitSize.get -> int
Reko.Core.Memory.MemoryArea.Formatter.get -> Reko.Core.Output.MemoryFormatter
Reko.Core.Memory.MemoryArea.Formatter.set -> void
Reko.Core.Memory.MemoryArea.IsValidAddress(Reko.Core.Address addr) -> bool
Reko.Core.Memory.MemoryArea.IsValidLinearAddress(ulong linearAddr) -> bool
Reko.Core.Memory.MemoryArea.Length.get -> long
Reko.Core.Memory.MemoryArea.MemoryArea(Reko.Core.Address addrBase, int length, int cellBitSize, Reko.Core.Output.MemoryFormatter formatter) -> void
Reko.Core.Memory.MemoryArea.Relocations.get -> Reko.Core.RelocationDictionary
Reko.Core.Memory.MemoryArea.TryReadBe(Reko.Core.Address addr, Reko.Core.Types.PrimitiveType type, out Reko.Core.Expressions.Constant c) -> bool
Reko.Core.Memory.MemoryArea.TryReadBeDouble(long off, out double retvalue) -> bool
Reko.Core.Memory.MemoryArea.TryReadBeUInt16(Reko.Core.Address off, out ushort retvalue) -> bool
Reko.Core.Memory.MemoryArea.TryReadBeUInt32(Reko.Core.Address off, out uint retvalue) -> bool
Reko.Core.Memory.MemoryArea.TryReadBeUInt64(Reko.Core.Address off, out ulong retvalue) -> bool
Reko.Core.Memory.MemoryArea.TryReadLe(Reko.Core.Address addr, Reko.Core.Types.PrimitiveType type, out Reko.Core.Expressions.Constant c) -> bool
Reko.Core.Memory.MemoryArea.TryReadLeDouble(long off, out double retvalue) -> bool
Reko.Core.Memory.MemoryArea.TryReadLeUInt16(Reko.Core.Address off, out ushort retvalue) -> bool
Reko.Core.Memory.MemoryArea.TryReadLeUInt32(Reko.Core.Address off, out uint retvalue) -> bool
Reko.Core.Memory.MemoryArea.TryReadLeUInt64(Reko.Core.Address off, out ulong retvalue) -> bool
Reko.Core.Memory.MemoryArea.WriteLeUInt32(Reko.Core.Address ea, uint value) -> void
Reko.Core.Memory.Word16BeImageReader
Reko.Core.Memory.Word16BeImageReader.Clone() -> Reko.Core.Memory.EndianImageReader
Reko.Core.Memory.Word16BeImageReader.CreateNew(Reko.Core.Memory.MemoryArea image, Reko.Core.Address addr) -> Reko.Core.Memory.EndianImageReader
Reko.Core.Memory.Word16BeImageReader.ReadCString(Reko.Core.Types.DataType charType, System.Text.Encoding encoding) -> Reko.Core.Expressions.StringConstant
Reko.Core.Memory.Word16BeImageReader.ReadInt16() -> short
Reko.Core.Memory.Word16BeImageReader.ReadInt32() -> int
Reko.Core.Memory.Word16BeImageReader.ReadInt64() -> long
Reko.Core.Memory.Word16BeImageReader.ReadNullCharTerminator(Reko.Core.Types.DataType dtChar) -> bool
Reko.Core.Memory.Word16BeImageReader.ReadUInt16() -> ushort
Reko.Core.Memory.Word16BeImageReader.ReadUInt32() -> uint
Reko.Core.Memory.Word16BeImageReader.ReadUInt64() -> ulong
Reko.Core.Memory.Word16BeImageReader.TryPeekUInt32(int offset, out uint value) -> bool
Reko.Core.Memory.Word16BeImageReader.TryPeekUInt64(int offset, out ulong value) -> bool
Reko.Core.Memory.Word16BeImageReader.TryRead(Reko.Core.Types.PrimitiveType dataType, out Reko.Core.Expressions.Constant value) -> bool
Reko.Core.Memory.Word16BeImageReader.TryReadInt16(out short value) -> bool
Reko.Core.Memory.Word16BeImageReader.TryReadInt32(out int value) -> bool
Reko.Core.Memory.Word16BeImageReader.TryReadInt64(out long value) -> bool
Reko.Core.Memory.Word16BeImageReader.TryReadUInt16(out ushort value) -> bool
Reko.Core.Memory.Word16BeImageReader.TryReadUInt32(out uint value) -> bool
Reko.Core.Memory.Word16BeImageReader.TryReadUInt64(out ulong value) -> bool
Reko.Core.Memory.Word16BeImageReader.Word16BeImageReader(Reko.Core.Memory.Word16MemoryArea mem, long offset) -> void
Reko.Core.Memory.Word16BeImageReader.Word16BeImageReader(Reko.Core.Memory.Word16MemoryArea mem, long offset, long endOffset) -> void
Reko.Core.Memory.Word16BeImageReader.Word16BeImageReader(Reko.Core.Memory.Word16MemoryArea mem, Reko.Core.Address addr) -> void
Reko.Core.Memory.Word16BeImageReader.Word16BeImageReader(Reko.Core.Memory.Word16MemoryArea mem, Reko.Core.Address addr, long cUnits) -> void
Reko.Core.Memory.Word16ImageReader
Reko.Core.Memory.Word16ImageReader.Address.get -> Reko.Core.Address
Reko.Core.Memory.Word16ImageReader.CreateBinaryReader() -> System.IO.BinaryReader
Reko.Core.Memory.Word16ImageReader.IsValid.get -> bool
Reko.Core.Memory.Word16ImageReader.IsValidOffset(long offset) -> bool
Reko.Core.Memory.Word16ImageReader.Offset.get -> long
Reko.Core.Memory.Word16ImageReader.Offset.set -> void
Reko.Core.Memory.Word16ImageReader.PeekBeInt16(int offset) -> short
Reko.Core.Memory.Word16ImageReader.PeekBeInt32(int offset) -> int
Reko.Core.Memory.Word16ImageReader.PeekBeUInt32(int offset) -> uint
Reko.Core.Memory.Word16ImageReader.PeekBeUInt64(int offset) -> ulong
Reko.Core.Memory.Word16ImageReader.PeekByte(int offset) -> byte
Reko.Core.Memory.Word16ImageReader.PeekLeInt16(int offset) -> short
Reko.Core.Memory.Word16ImageReader.PeekLeInt32(int offset) -> int
Reko.Core.Memory.Word16ImageReader.PeekLeUInt16(int offset) -> ushort
Reko.Core.Memory.Word16ImageReader.PeekLeUInt32(int offset) -> uint
Reko.Core.Memory.Word16ImageReader.PeekLeUInt64(int offset) -> ulong
Reko.Core.Memory.Word16ImageReader.PeekSByte(int offset) -> sbyte
Reko.Core.Memory.Word16ImageReader.ReadBeInt16() -> short
Reko.Core.Memory.Word16ImageReader.ReadBeInt32() -> int
Reko.Core.Memory.Word16ImageReader.ReadBeInt64() -> long
Reko.Core.Memory.Word16ImageReader.ReadBeUInt16() -> ushort
Reko.Core.Memory.Word16ImageReader.ReadBeUInt32() -> uint
Reko.Core.Memory.Word16ImageReader.ReadBeUInt64() -> ulong
Reko.Core.Memory.Word16ImageReader.ReadByte() -> byte
Reko.Core.Memory.Word16ImageReader.ReadBytes(int addressUnits) -> byte[]
Reko.Core.Memory.Word16ImageReader.ReadBytes(uint addressUnits) -> byte[]
Reko.Core.Memory.Word16ImageReader.ReadLeInt16() -> short
Reko.Core.Memory.Word16ImageReader.ReadLeInt32() -> int
Reko.Core.Memory.Word16ImageReader.ReadLeInt64() -> long
Reko.Core.Memory.Word16ImageReader.ReadLeUInt16() -> ushort
Reko.Core.Memory.Word16ImageReader.ReadLeUInt32() -> uint
Reko.Core.Memory.Word16ImageReader.ReadLeUInt64() -> ulong
Reko.Core.Memory.Word16ImageReader.ReadSByte() -> sbyte
Reko.Core.Memory.Word16ImageReader.Seek(long offset, System.IO.SeekOrigin origin = System.IO.SeekOrigin.Current) -> long
Reko.Core.Memory.Word16ImageReader.TryPeekBeUInt16(int offset, out ushort value) -> bool
Reko.Core.Memory.Word16ImageReader.TryPeekBeUInt32(int offset, out uint value) -> bool
Reko.Core.Memory.Word16ImageReader.TryPeekBeUInt64(int offset, out ulong value) -> bool
Reko.Core.Memory.Word16ImageReader.TryPeekByte(int offset, out byte value) -> bool
Reko.Core.Memory.Word16ImageReader.TryPeekLeUInt16(int offset, out ushort value) -> bool
Reko.Core.Memory.Word16ImageReader.TryPeekLeUInt32(int offset, out uint value) -> bool
Reko.Core.Memory.Word16ImageReader.TryReadBe(Reko.Core.Types.DataType dataType, out Reko.Core.Expressions.Constant value) -> bool
Reko.Core.Memory.Word16ImageReader.TryReadBeInt16(out short value) -> bool
Reko.Core.Memory.Word16ImageReader.TryReadBeInt32(out int value) -> bool
Reko.Core.Memory.Word16ImageReader.TryReadBeInt64(out long value) -> bool
Reko.Core.Memory.Word16ImageReader.TryReadBeUInt16(out ushort value) -> bool
Reko.Core.Memory.Word16ImageReader.TryReadBeUInt32(out uint value) -> bool
Reko.Core.Memory.Word16ImageReader.TryReadBeUInt64(out ulong value) -> bool
Reko.Core.Memory.Word16ImageReader.TryReadByte(out byte value) -> bool
Reko.Core.Memory.Word16ImageReader.TryReadLe(Reko.Core.Types.DataType dataType, out Reko.Core.Expressions.Constant value) -> bool
Reko.Core.Memory.Word16ImageReader.TryReadLeInt16(out short value) -> bool
Reko.Core.Memory.Word16ImageReader.TryReadLeSigned(Reko.Core.Types.DataType dataType, out long value) -> bool
Reko.Core.Memory.Word16ImageReader.TryReadLeUInt16(out ushort value) -> bool
Reko.Core.Memory.Word16ImageReader.TryReadLeUInt32(out uint value) -> bool
Reko.Core.Memory.Word16ImageReader.TryReadLeUInt64(out ulong value) -> bool
Reko.Core.Memory.Word16ImageReader.Word16ImageReader(Reko.Core.Memory.Word16MemoryArea mem, long beginOffset) -> void
Reko.Core.Memory.Word16ImageReader.Word16ImageReader(Reko.Core.Memory.Word16MemoryArea mem, long beginOffset, long endOffset) -> void
Reko.Core.Memory.Word16MemoryArea
Reko.Core.Memory.Word16MemoryArea.ReadBeUInt32(long offset) -> uint
Reko.Core.Memory.Word16MemoryArea.ReadBeUInt64(long offset) -> ulong
Reko.Core.Memory.Word16MemoryArea.Word16MemoryArea(Reko.Core.Address addrBase, ushort[] words) -> void
Reko.Core.Memory.Word16MemoryArea.Words.get -> ushort[]
Reko.Core.Memory.Word64BeReader
Reko.Core.Memory.Word64BeReader.Clone() -> Reko.Core.Memory.EndianImageReader
Reko.Core.Memory.Word64BeReader.CreateNew(Reko.Core.Memory.MemoryArea image, Reko.Core.Address addr) -> Reko.Core.Memory.EndianImageReader
Reko.Core.Memory.Word64BeReader.ReadCString(Reko.Core.Types.DataType charType, System.Text.Encoding encoding) -> Reko.Core.Expressions.StringConstant
Reko.Core.Memory.Word64BeReader.ReadInt16() -> short
Reko.Core.Memory.Word64BeReader.ReadInt32() -> int
Reko.Core.Memory.Word64BeReader.ReadInt64() -> long
Reko.Core.Memory.Word64BeReader.ReadNullCharTerminator(Reko.Core.Types.DataType dtChar) -> bool
Reko.Core.Memory.Word64BeReader.ReadUInt16() -> ushort
Reko.Core.Memory.Word64BeReader.ReadUInt32() -> uint
Reko.Core.Memory.Word64BeReader.ReadUInt64() -> ulong
Reko.Core.Memory.Word64BeReader.TryPeekUInt32(int offset, out uint value) -> bool
Reko.Core.Memory.Word64BeReader.TryPeekUInt64(int offset, out ulong value) -> bool
Reko.Core.Memory.Word64BeReader.TryRead(Reko.Core.Types.PrimitiveType dataType, out Reko.Core.Expressions.Constant value) -> bool
Reko.Core.Memory.Word64BeReader.TryReadInt16(out short _) -> bool
Reko.Core.Memory.Word64BeReader.TryReadInt32(out int value) -> bool
Reko.Core.Memory.Word64BeReader.TryReadInt64(out long value) -> bool
Reko.Core.Memory.Word64BeReader.TryReadUInt16(out ushort value) -> bool
Reko.Core.Memory.Word64BeReader.TryReadUInt32(out uint value) -> bool
Reko.Core.Memory.Word64BeReader.TryReadUInt64(out ulong value) -> bool
Reko.Core.Memory.Word64BeReader.Word64BeReader(Reko.Core.Memory.Word64MemoryArea mem, long offset = 0) -> void
Reko.Core.Memory.Word64BeReader.Word64BeReader(Reko.Core.Memory.Word64MemoryArea mem, Reko.Core.Address addr) -> void
Reko.Core.Memory.Word64BeReader.Word64BeReader(Reko.Core.Memory.Word64MemoryArea mem, Reko.Core.Address addr, long cUnits) -> void
Reko.Core.Memory.Word64ImageReader
Reko.Core.Memory.Word64ImageReader.Address.get -> Reko.Core.Address
Reko.Core.Memory.Word64ImageReader.CreateBinaryReader() -> System.IO.BinaryReader
Reko.Core.Memory.Word64ImageReader.IsValid.get -> bool
Reko.Core.Memory.Word64ImageReader.IsValidOffset(long offset) -> bool
Reko.Core.Memory.Word64ImageReader.MemoryArea.get -> Reko.Core.Memory.Word64MemoryArea
Reko.Core.Memory.Word64ImageReader.Offset.get -> long
Reko.Core.Memory.Word64ImageReader.Offset.set -> void
Reko.Core.Memory.Word64ImageReader.PeekBeInt16(int offset) -> short
Reko.Core.Memory.Word64ImageReader.PeekBeInt32(int offset) -> int
Reko.Core.Memory.Word64ImageReader.PeekBeUInt32(int offset) -> uint
Reko.Core.Memory.Word64ImageReader.PeekBeUInt64(int offset) -> ulong
Reko.Core.Memory.Word64ImageReader.PeekByte(int offset) -> byte
Reko.Core.Memory.Word64ImageReader.PeekLeInt16(int offset) -> short
Reko.Core.Memory.Word64ImageReader.PeekLeInt32(int offset) -> int
Reko.Core.Memory.Word64ImageReader.PeekLeUInt16(int offset) -> ushort
Reko.Core.Memory.Word64ImageReader.PeekLeUInt32(int offset) -> uint
Reko.Core.Memory.Word64ImageReader.PeekLeUInt64(int offset) -> ulong
Reko.Core.Memory.Word64ImageReader.PeekSByte(int offset) -> sbyte
Reko.Core.Memory.Word64ImageReader.ReadBeInt16() -> short
Reko.Core.Memory.Word64ImageReader.ReadBeInt32() -> int
Reko.Core.Memory.Word64ImageReader.ReadBeUInt16() -> ushort
Reko.Core.Memory.Word64ImageReader.ReadBeUInt32() -> uint
Reko.Core.Memory.Word64ImageReader.ReadBeUInt64() -> ulong
Reko.Core.Memory.Word64ImageReader.ReadByte() -> byte
Reko.Core.Memory.Word64ImageReader.ReadBytes(int addressUnits) -> byte[]
Reko.Core.Memory.Word64ImageReader.ReadBytes(uint addressUnits) -> byte[]
Reko.Core.Memory.Word64ImageReader.ReadLeInt16() -> short
Reko.Core.Memory.Word64ImageReader.ReadLeInt32() -> int
Reko.Core.Memory.Word64ImageReader.ReadLeInt64() -> long
Reko.Core.Memory.Word64ImageReader.ReadLeUInt16() -> ushort
Reko.Core.Memory.Word64ImageReader.ReadLeUInt32() -> uint
Reko.Core.Memory.Word64ImageReader.ReadLeUInt64() -> ulong
Reko.Core.Memory.Word64ImageReader.ReadSByte() -> sbyte
Reko.Core.Memory.Word64ImageReader.Seek(long offset, System.IO.SeekOrigin origin = System.IO.SeekOrigin.Current) -> long
Reko.Core.Memory.Word64ImageReader.TryPeekBeUInt16(int offset, out ushort value) -> bool
Reko.Core.Memory.Word64ImageReader.TryPeekBeUInt32(int offset, out uint value) -> bool
Reko.Core.Memory.Word64ImageReader.TryPeekBeUInt64(int offset, out ulong value) -> bool
Reko.Core.Memory.Word64ImageReader.TryPeekByte(int offset, out byte value) -> bool
Reko.Core.Memory.Word64ImageReader.TryPeekLeUInt16(int offset, out ushort value) -> bool
Reko.Core.Memory.Word64ImageReader.TryPeekLeUInt32(int offset, out uint value) -> bool
Reko.Core.Memory.Word64ImageReader.TryReadBe(Reko.Core.Types.DataType dataType, out Reko.Core.Expressions.Constant value) -> bool
Reko.Core.Memory.Word64ImageReader.TryReadBeInt16(out short value) -> bool
Reko.Core.Memory.Word64ImageReader.TryReadBeInt32(out int value) -> bool
Reko.Core.Memory.Word64ImageReader.TryReadBeUInt16(out ushort value) -> bool
Reko.Core.Memory.Word64ImageReader.TryReadBeUInt32(out uint value) -> bool
Reko.Core.Memory.Word64ImageReader.TryReadByte(out byte value) -> bool
Reko.Core.Memory.Word64ImageReader.TryReadLe(Reko.Core.Types.DataType dataType, out Reko.Core.Expressions.Constant value) -> bool
Reko.Core.Memory.Word64ImageReader.TryReadLeInt16(out short value) -> bool
Reko.Core.Memory.Word64ImageReader.TryReadLeSigned(Reko.Core.Types.DataType dataType, out long value) -> bool
Reko.Core.Memory.Word64ImageReader.TryReadLeUInt16(out ushort value) -> bool
Reko.Core.Memory.Word64ImageReader.TryReadLeUInt32(out uint value) -> bool
Reko.Core.Memory.Word64ImageReader.TryReadLeUInt64(out ulong value) -> bool
Reko.Core.Memory.Word64ImageReader.Word64ImageReader(Reko.Core.Memory.Word64MemoryArea mem, long beginOffset) -> void
Reko.Core.Memory.Word64ImageReader.Word64ImageReader(Reko.Core.Memory.Word64MemoryArea mem, long beginOffset, long endOffset) -> void
Reko.Core.Memory.Word64ImageReader.Word64ImageReader(Reko.Core.Memory.Word64MemoryArea mem, Reko.Core.Address addr) -> void
Reko.Core.Memory.Word64ImageReader.Word64ImageReader(Reko.Core.Memory.Word64MemoryArea mem, Reko.Core.Address addr, long cUnits) -> void
Reko.Core.Memory.Word64MemoryArea
Reko.Core.Memory.Word64MemoryArea.Word64MemoryArea(Reko.Core.Address addr, ulong[] words) -> void
Reko.Core.Memory.Word64MemoryArea.Words.get -> ulong[]
Reko.Core.MemoryStorage
Reko.Core.MemoryStorage.MemoryStorage(string name, Reko.Core.StorageDomain domain) -> void
Reko.Core.MetadataFile
Reko.Core.MetadataFile.MetadataFile() -> void
Reko.Core.MetadataFile.ModuleName.get -> string
Reko.Core.MetadataFile.ModuleName.set -> void
Reko.Core.MetadataLoader
Reko.Core.MetadataLoader.Location.get -> Reko.Core.ImageLocation
Reko.Core.MetadataLoader.MetadataLoader(System.IServiceProvider services, Reko.Core.ImageLocation imagelocation, byte[] bytes) -> void
Reko.Core.MetadataLoader.Services.get -> System.IServiceProvider
Reko.Core.ModuleDescriptor
Reko.Core.ModuleDescriptor.Clone() -> Reko.Core.ModuleDescriptor
Reko.Core.ModuleDescriptor.GlobalsByName.get -> System.Collections.Generic.IDictionary<string, Reko.Core.ImageSymbol>
Reko.Core.ModuleDescriptor.GlobalsByOrdinal.get -> System.Collections.Generic.IDictionary<int, Reko.Core.ImageSymbol>
Reko.Core.ModuleDescriptor.ModuleDescriptor(Reko.Core.ModuleDescriptor other) -> void
Reko.Core.ModuleDescriptor.ModuleDescriptor(string name) -> void
Reko.Core.ModuleDescriptor.ModuleName.get -> string
Reko.Core.ModuleDescriptor.ServicesByName.get -> System.Collections.Generic.IDictionary<string, Reko.Core.SystemService>
Reko.Core.ModuleDescriptor.ServicesByOrdinal.get -> System.Collections.Generic.IDictionary<int, Reko.Core.SystemService>
Reko.Core.ModuleDescriptor.ServicesByVector.get -> System.Collections.Generic.IDictionary<int, System.Collections.Generic.List<Reko.Core.SystemService>>
Reko.Core.NamedImportReference
Reko.Core.NamedImportReference.ImportName.get -> string
Reko.Core.NamedImportReference.NamedImportReference(Reko.Core.Address addr, string moduleName, string importName, Reko.Core.SymbolType symType) -> void
Reko.Core.NamingPolicy
Reko.Core.NamingPolicy.NamingPolicy() -> void
Reko.Core.NamingPolicy.Types.get -> Reko.Core.TypeNamingPolicy
Reko.Core.NativeInterface.BaseType
Reko.Core.NativeInterface.BaseType.Bool = 1 -> Reko.Core.NativeInterface.BaseType
Reko.Core.NativeInterface.BaseType.Byte = 2 -> Reko.Core.NativeInterface.BaseType
Reko.Core.NativeInterface.BaseType.Char8 = 4 -> Reko.Core.NativeInterface.BaseType
Reko.Core.NativeInterface.BaseType.Int16 = 5 -> Reko.Core.NativeInterface.BaseType
Reko.Core.NativeInterface.BaseType.Int32 = 9 -> Reko.Core.NativeInterface.BaseType
Reko.Core.NativeInterface.BaseType.Int64 = 13 -> Reko.Core.NativeInterface.BaseType
Reko.Core.NativeInterface.BaseType.Ptr16 = 7 -> Reko.Core.NativeInterface.BaseType
Reko.Core.NativeInterface.BaseType.Ptr32 = 11 -> Reko.Core.NativeInterface.BaseType
Reko.Core.NativeInterface.BaseType.Ptr64 = 15 -> Reko.Core.NativeInterface.BaseType
Reko.Core.NativeInterface.BaseType.Real32 = 18 -> Reko.Core.NativeInterface.BaseType
Reko.Core.NativeInterface.BaseType.Real64 = 19 -> Reko.Core.NativeInterface.BaseType
Reko.Core.NativeInterface.BaseType.SByte = 3 -> Reko.Core.NativeInterface.BaseType
Reko.Core.NativeInterface.BaseType.UInt16 = 6 -> Reko.Core.NativeInterface.BaseType
Reko.Core.NativeInterface.BaseType.UInt32 = 10 -> Reko.Core.NativeInterface.BaseType
Reko.Core.NativeInterface.BaseType.UInt64 = 14 -> Reko.Core.NativeInterface.BaseType
Reko.Core.NativeInterface.BaseType.Void = 0 -> Reko.Core.NativeInterface.BaseType
Reko.Core.NativeInterface.BaseType.Word128 = 17 -> Reko.Core.NativeInterface.BaseType
Reko.Core.NativeInterface.BaseType.Word16 = 8 -> Reko.Core.NativeInterface.BaseType
Reko.Core.NativeInterface.BaseType.Word32 = 12 -> Reko.Core.NativeInterface.BaseType
Reko.Core.NativeInterface.BaseType.Word64 = 16 -> Reko.Core.NativeInterface.BaseType
Reko.Core.NativeInterface.CustomAnsiStringMarshaler
Reko.Core.NativeInterface.CustomAnsiStringMarshaler.CleanUpManagedData(object ManagedObj) -> void
Reko.Core.NativeInterface.CustomAnsiStringMarshaler.CleanUpNativeData(System.IntPtr pNativeData) -> void
Reko.Core.NativeInterface.CustomAnsiStringMarshaler.CustomAnsiStringMarshaler() -> void
Reko.Core.NativeInterface.CustomAnsiStringMarshaler.GetNativeDataSize() -> int
Reko.Core.NativeInterface.CustomAnsiStringMarshaler.MarshalManagedToNative(object ManagedObj) -> System.IntPtr
Reko.Core.NativeInterface.CustomAnsiStringMarshaler.MarshalNativeToManaged(System.IntPtr pNativeData) -> object
Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.ILibraryLoader
Reko.Core.NativeInterface.ILibraryLoader.GetSymbol(System.IntPtr handle, string symName) -> System.IntPtr
Reko.Core.NativeInterface.ILibraryLoader.LoadLibrary(string libPath) -> System.IntPtr
Reko.Core.NativeInterface.ILibraryLoader.Unload(System.IntPtr handle) -> int
Reko.Core.NativeInterface.INativeArchitecture
Reko.Core.NativeInterface.INativeArchitecture.CreateDisassembler(System.IntPtr bytes, int length, int offset, ulong uAddr) -> Reko.Core.NativeInterface.INativeDisassembler
Reko.Core.NativeInterface.INativeArchitecture.CreateRewriter(System.IntPtr rawBytes, int length, int offset, ulong uAddress, Reko.Core.NativeInterface.INativeRtlEmitter m, Reko.Core.NativeInterface.INativeTypeFactory typeFactory, Reko.Core.NativeInterface.INativeRewriterHost host) -> Reko.Core.NativeInterface.INativeRewriter
Reko.Core.NativeInterface.INativeArchitecture.GetAllRegisters(int registerType, out int n, out System.IntPtr aregs) -> void
Reko.Core.NativeInterface.INativeDisassembler
Reko.Core.NativeInterface.INativeDisassembler.NextInstruction() -> Reko.Core.NativeInterface.INativeInstruction
Reko.Core.NativeInterface.INativeInstruction
Reko.Core.NativeInterface.INativeInstruction.GetInfo(out Reko.Core.NativeInterface.NativeInstructionInfo info) -> void
Reko.Core.NativeInterface.INativeInstruction.Render(Reko.Core.NativeInterface.INativeInstructionRenderer renderer, Reko.Core.Machine.MachineInstructionRendererFlags options) -> void
Reko.Core.NativeInterface.INativeInstructionRenderer
Reko.Core.NativeInterface.INativeInstructionRenderer.AddAnnotation(string a) -> void
Reko.Core.NativeInterface.INativeInstructionRenderer.Tab() -> void
Reko.Core.NativeInterface.INativeInstructionRenderer.WriteAddress(string formattedAddress, ulong uAddr) -> void
Reko.Core.NativeInterface.INativeInstructionRenderer.WriteChar(char c) -> void
Reko.Core.NativeInterface.INativeInstructionRenderer.WriteMnemonic(string sMnemonic) -> void
Reko.Core.NativeInterface.INativeInstructionRenderer.WriteString(string s) -> void
Reko.Core.NativeInterface.INativeInstructionRenderer.WriteUInt32(uint n) -> void
Reko.Core.NativeInterface.INativeRewriter
Reko.Core.NativeInterface.INativeRewriter.GetCount() -> int
Reko.Core.NativeInterface.INativeRewriter.Next() -> int
Reko.Core.NativeInterface.INativeRewriterHost
Reko.Core.NativeInterface.INativeRewriterHost.CreateTemporary(Reko.Core.NativeInterface.BaseType type) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.INativeRewriterHost.EnsureFlagGroup(int baseReg, int bitmask, string name, Reko.Core.NativeInterface.BaseType size) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.INativeRewriterHost.EnsureIntrinsicProcedure(string name, int isIdempotent, Reko.Core.NativeInterface.BaseType dt, int arity) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.INativeRewriterHost.EnsureRegister(int regKind, int reg) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.INativeRewriterHost.EnsureSequence(int regHi, int regLo, Reko.Core.NativeInterface.BaseType size) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.INativeRewriterHost.Error(ulong uAddress, string error) -> void
Reko.Core.NativeInterface.INativeRtlEmitter
Reko.Core.NativeInterface.INativeRtlEmitter.AddArg(Reko.Core.NativeInterface.HExpr a) -> void
Reko.Core.NativeInterface.INativeRtlEmitter.And(Reko.Core.NativeInterface.HExpr a, Reko.Core.NativeInterface.HExpr b) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.INativeRtlEmitter.Assign(Reko.Core.NativeInterface.HExpr dst, Reko.Core.NativeInterface.HExpr src) -> void
Reko.Core.NativeInterface.INativeRtlEmitter.Branch(Reko.Core.NativeInterface.HExpr exp, Reko.Core.NativeInterface.HExpr dst, Reko.Core.InstrClass rtlClass) -> void
Reko.Core.NativeInterface.INativeRtlEmitter.BranchInMiddleOfInstruction(Reko.Core.NativeInterface.HExpr exp, Reko.Core.NativeInterface.HExpr dst, Reko.Core.InstrClass rtlClass) -> void
Reko.Core.NativeInterface.INativeRtlEmitter.Byte(byte b) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.INativeRtlEmitter.Call(Reko.Core.NativeInterface.HExpr dst, int bytesOnStack) -> void
Reko.Core.NativeInterface.INativeRtlEmitter.Cast(Reko.Core.NativeInterface.BaseType type, Reko.Core.NativeInterface.HExpr a) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.INativeRtlEmitter.Comp(Reko.Core.NativeInterface.HExpr a) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.INativeRtlEmitter.Cond(Reko.Core.NativeInterface.HExpr a) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.INativeRtlEmitter.Dpb(Reko.Core.NativeInterface.HExpr idDst, Reko.Core.NativeInterface.HExpr src, int pos) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.INativeRtlEmitter.Eq0(Reko.Core.NativeInterface.HExpr e) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.INativeRtlEmitter.FAdd(Reko.Core.NativeInterface.HExpr a, Reko.Core.NativeInterface.HExpr b) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.INativeRtlEmitter.FDiv(Reko.Core.NativeInterface.HExpr a, Reko.Core.NativeInterface.HExpr b) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.INativeRtlEmitter.FinishCluster(Reko.Core.InstrClass rtlClass, ulong address, int mcLength) -> void
Reko.Core.NativeInterface.INativeRtlEmitter.FMul(Reko.Core.NativeInterface.HExpr a, Reko.Core.NativeInterface.HExpr b) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.INativeRtlEmitter.Fn(Reko.Core.NativeInterface.HExpr fn) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.INativeRtlEmitter.FSub(Reko.Core.NativeInterface.HExpr a, Reko.Core.NativeInterface.HExpr b) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.INativeRtlEmitter.Goto(Reko.Core.NativeInterface.HExpr dst) -> void
Reko.Core.NativeInterface.INativeRtlEmitter.IAdc(Reko.Core.NativeInterface.HExpr a, Reko.Core.NativeInterface.HExpr b, Reko.Core.NativeInterface.HExpr c) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.INativeRtlEmitter.IAdd(Reko.Core.NativeInterface.HExpr a, Reko.Core.NativeInterface.HExpr b) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.INativeRtlEmitter.IMul(Reko.Core.NativeInterface.HExpr a, Reko.Core.NativeInterface.HExpr b) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.INativeRtlEmitter.Int16(short s) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.INativeRtlEmitter.Int32(int i) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.INativeRtlEmitter.Int64(long l) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.INativeRtlEmitter.Invalid() -> void
Reko.Core.NativeInterface.INativeRtlEmitter.ISub(Reko.Core.NativeInterface.HExpr a, Reko.Core.NativeInterface.HExpr b) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.INativeRtlEmitter.Mem(Reko.Core.NativeInterface.BaseType dt, Reko.Core.NativeInterface.HExpr ea) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.INativeRtlEmitter.Mem16(Reko.Core.NativeInterface.HExpr ea) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.INativeRtlEmitter.Mem32(Reko.Core.NativeInterface.HExpr ea) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.INativeRtlEmitter.Mem64(Reko.Core.NativeInterface.HExpr ea) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.INativeRtlEmitter.Mem8(Reko.Core.NativeInterface.HExpr ea) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.INativeRtlEmitter.Ne0(Reko.Core.NativeInterface.HExpr e) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.INativeRtlEmitter.Nop() -> void
Reko.Core.NativeInterface.INativeRtlEmitter.Not(Reko.Core.NativeInterface.HExpr a) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.INativeRtlEmitter.Or(Reko.Core.NativeInterface.HExpr a, Reko.Core.NativeInterface.HExpr b) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.INativeRtlEmitter.Ptr16(ushort p) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.INativeRtlEmitter.Ptr32(uint p) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.INativeRtlEmitter.Ptr64(ulong p) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.INativeRtlEmitter.Return(int x, int y) -> void
Reko.Core.NativeInterface.INativeRtlEmitter.Ror(Reko.Core.NativeInterface.HExpr a, Reko.Core.NativeInterface.HExpr b) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.INativeRtlEmitter.Rrc(Reko.Core.NativeInterface.HExpr a, Reko.Core.NativeInterface.HExpr b, Reko.Core.NativeInterface.HExpr c) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.INativeRtlEmitter.Sar(Reko.Core.NativeInterface.HExpr a, Reko.Core.NativeInterface.HExpr b) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.INativeRtlEmitter.SDiv(Reko.Core.NativeInterface.HExpr a, Reko.Core.NativeInterface.HExpr b) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.INativeRtlEmitter.Seq(Reko.Core.NativeInterface.HExpr dt) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.INativeRtlEmitter.Shl(Reko.Core.NativeInterface.HExpr a, Reko.Core.NativeInterface.HExpr b) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.INativeRtlEmitter.Shr(Reko.Core.NativeInterface.HExpr a, Reko.Core.NativeInterface.HExpr b) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.INativeRtlEmitter.SideEffect(Reko.Core.NativeInterface.HExpr exp) -> void
Reko.Core.NativeInterface.INativeRtlEmitter.Slice(Reko.Core.NativeInterface.HExpr a, int pos, int bits) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.INativeRtlEmitter.SMul(Reko.Core.NativeInterface.HExpr a, Reko.Core.NativeInterface.HExpr b) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.INativeRtlEmitter.Test(Reko.Core.Expressions.ConditionCode cc, Reko.Core.NativeInterface.HExpr exp) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.INativeRtlEmitter.UDiv(Reko.Core.NativeInterface.HExpr a, Reko.Core.NativeInterface.HExpr b) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.INativeRtlEmitter.UInt16(ushort us) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.INativeRtlEmitter.UInt32(uint u) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.INativeRtlEmitter.UInt64(ulong ul) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.INativeRtlEmitter.UMul(Reko.Core.NativeInterface.HExpr a, Reko.Core.NativeInterface.HExpr b) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.INativeRtlEmitter.Word16(ushort us) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.INativeRtlEmitter.Word32(uint u) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.INativeRtlEmitter.Word64(ulong ul) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.INativeRtlEmitter.Xor(Reko.Core.NativeInterface.HExpr a, Reko.Core.NativeInterface.HExpr b) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.INativeTypeFactory
Reko.Core.NativeInterface.INativeTypeFactory.ArrayOf(Reko.Core.NativeInterface.HExpr dt, int length) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.INativeTypeFactory.BeginFunc(Reko.Core.NativeInterface.HExpr dt, int byte_size) -> void
Reko.Core.NativeInterface.INativeTypeFactory.BeginStruct(Reko.Core.NativeInterface.HExpr dt, int byte_size) -> void
Reko.Core.NativeInterface.INativeTypeFactory.EndFunc() -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.INativeTypeFactory.EndStruct() -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.INativeTypeFactory.Field(Reko.Core.NativeInterface.HExpr dt, int offset, string name) -> void
Reko.Core.NativeInterface.INativeTypeFactory.Parameter(Reko.Core.NativeInterface.HExpr dt, string name) -> void
Reko.Core.NativeInterface.INativeTypeFactory.PtrTo(Reko.Core.NativeInterface.HExpr dt, int byte_size) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.Interfaces.DisposeDelegate
Reko.Core.NativeInterface.Interfaces.DisposeSymbolDelegate
Reko.Core.NativeInterface.Interfaces.GetNameDelegate
Reko.Core.NativeInterface.Interfaces.GetStringDelegate
Reko.Core.NativeInterface.Interfaces.GetSymbolDelegate
Reko.Core.NativeInterface.Interfaces.GetSymbolEndDelegate
Reko.Core.NativeInterface.Interfaces.GetSymbolLengthDelegate
Reko.Core.NativeInterface.Interfaces.GetSymbolNameDelegate
Reko.Core.NativeInterface.Interfaces.GetSymbolsDelegate
Reko.Core.NativeInterface.Interfaces.GetSymbolStartDelegate
Reko.Core.NativeInterface.Interfaces.INativeSymbolSource
Reko.Core.NativeInterface.Interfaces.LoadDelegate
Reko.Core.NativeInterface.Interfaces.NativeProcessorArchitectureProvider
Reko.Core.NativeInterface.Interfaces.NativeProcessorArchitectureProvider.GetCpuName -> Reko.Core.NativeInterface.Interfaces.GetStringDelegate
Reko.Core.NativeInterface.Interfaces.NativeProcessorArchitectureProvider.GetDescription -> Reko.Core.NativeInterface.Interfaces.GetStringDelegate
Reko.Core.NativeInterface.Interfaces.NativeProcessorArchitectureProvider.NativeProcessorArchitectureProvider() -> void
Reko.Core.NativeInterface.Interfaces.NativeSymbolSourceProvider
Reko.Core.NativeInterface.Interfaces.NativeSymbolSourceProvider.Dispose -> Reko.Core.NativeInterface.Interfaces.DisposeDelegate
Reko.Core.NativeInterface.Interfaces.NativeSymbolSourceProvider.DisposeSymbol -> Reko.Core.NativeInterface.Interfaces.DisposeSymbolDelegate
Reko.Core.NativeInterface.Interfaces.NativeSymbolSourceProvider.GetName -> Reko.Core.NativeInterface.Interfaces.GetNameDelegate
Reko.Core.NativeInterface.Interfaces.NativeSymbolSourceProvider.GetSymbol -> Reko.Core.NativeInterface.Interfaces.GetSymbolDelegate
Reko.Core.NativeInterface.Interfaces.NativeSymbolSourceProvider.GetSymbolEnd -> Reko.Core.NativeInterface.Interfaces.GetSymbolEndDelegate
Reko.Core.NativeInterface.Interfaces.NativeSymbolSourceProvider.GetSymbolLength -> Reko.Core.NativeInterface.Interfaces.GetSymbolLengthDelegate
Reko.Core.NativeInterface.Interfaces.NativeSymbolSourceProvider.GetSymbolName -> Reko.Core.NativeInterface.Interfaces.GetSymbolNameDelegate
Reko.Core.NativeInterface.Interfaces.NativeSymbolSourceProvider.GetSymbols -> Reko.Core.NativeInterface.Interfaces.GetSymbolsDelegate
Reko.Core.NativeInterface.Interfaces.NativeSymbolSourceProvider.GetSymbolStart -> Reko.Core.NativeInterface.Interfaces.GetSymbolStartDelegate
Reko.Core.NativeInterface.Interfaces.NativeSymbolSourceProvider.Load -> Reko.Core.NativeInterface.Interfaces.LoadDelegate
Reko.Core.NativeInterface.Interfaces.NativeSymbolSourceProvider.NativeSymbolSourceProvider() -> void
Reko.Core.NativeInterface.Interfaces.NativeSymbolSourceProvider.NextSymbol -> Reko.Core.NativeInterface.Interfaces.NextSymbolDelegate
Reko.Core.NativeInterface.Interfaces.NativeSymbolSourceProvider.PreviousSymbol -> Reko.Core.NativeInterface.Interfaces.PreviousSymbolDelegate
Reko.Core.NativeInterface.Interfaces.NextSymbolDelegate
Reko.Core.NativeInterface.Interfaces.PreviousSymbolDelegate
Reko.Core.NativeInterface.Interop
Reko.Core.NativeInterface.NativeInstructionInfo
Reko.Core.NativeInterface.NativeInstructionInfo.InstructionClass -> uint
Reko.Core.NativeInterface.NativeInstructionInfo.Length -> uint
Reko.Core.NativeInterface.NativeInstructionInfo.LinearAddress -> ulong
Reko.Core.NativeInterface.NativeInstructionInfo.Mnemonic -> int
Reko.Core.NativeInterface.NativeInstructionInfo.NativeInstructionInfo() -> void
Reko.Core.NativeInterface.NativeInteropAttribute
Reko.Core.NativeInterface.NativeInteropAttribute.NativeInteropAttribute() -> void
Reko.Core.NativeInterface.NativeMachineInstruction
Reko.Core.NativeInterface.NativeMachineInstruction.NativeMachineInstruction() -> void
Reko.Core.NativeInterface.NativeProcessorArchitecture
Reko.Core.NativeInterface.NativeProcessorArchitecture.Description.get -> string
Reko.Core.NativeInterface.NativeProcessorArchitecture.Name.get -> string
Reko.Core.NativeInterface.NativeProcessorArchitecture.NativeProcessorArchitecture(System.IServiceProvider services, string archID, string libPath, Reko.Core.NativeInterface.ILibraryLoader ldr, System.Collections.Generic.Dictionary<string, object> options) -> void
Reko.Core.NativeInterface.NativeRegister
Reko.Core.NativeInterface.NativeRegister.BitOffset -> int
Reko.Core.NativeInterface.NativeRegister.BitSize -> int
Reko.Core.NativeInterface.NativeRegister.Domain -> int
Reko.Core.NativeInterface.NativeRegister.Name -> string
Reko.Core.NativeInterface.NativeRegister.NativeRegister() -> void
Reko.Core.NativeInterface.NativeRegister.Number -> int
Reko.Core.NativeInterface.NativeRtlEmitter
Reko.Core.NativeInterface.NativeRtlEmitter.AddArg(Reko.Core.NativeInterface.HExpr a) -> void
Reko.Core.NativeInterface.NativeRtlEmitter.And(Reko.Core.NativeInterface.HExpr a, Reko.Core.NativeInterface.HExpr b) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.NativeRtlEmitter.Assign(Reko.Core.NativeInterface.HExpr dst, Reko.Core.NativeInterface.HExpr src) -> void
Reko.Core.NativeInterface.NativeRtlEmitter.Branch(Reko.Core.NativeInterface.HExpr exp, Reko.Core.NativeInterface.HExpr dst, Reko.Core.InstrClass rtlClass) -> void
Reko.Core.NativeInterface.NativeRtlEmitter.BranchInMiddleOfInstruction(Reko.Core.NativeInterface.HExpr exp, Reko.Core.NativeInterface.HExpr dst, Reko.Core.InstrClass rtlClass) -> void
Reko.Core.NativeInterface.NativeRtlEmitter.Byte(byte b) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.NativeRtlEmitter.Call(Reko.Core.NativeInterface.HExpr dst, int bytesOnStack) -> void
Reko.Core.NativeInterface.NativeRtlEmitter.Cast(Reko.Core.NativeInterface.BaseType type, Reko.Core.NativeInterface.HExpr a) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.NativeRtlEmitter.Comp(Reko.Core.NativeInterface.HExpr a) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.NativeRtlEmitter.Cond(Reko.Core.NativeInterface.HExpr a) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.NativeRtlEmitter.Dpb(Reko.Core.NativeInterface.HExpr dst, Reko.Core.NativeInterface.HExpr src, int pos) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.NativeRtlEmitter.Eq0(Reko.Core.NativeInterface.HExpr e) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.NativeRtlEmitter.ExtractCluster() -> Reko.Core.Rtl.RtlInstructionCluster
Reko.Core.NativeInterface.NativeRtlEmitter.FAdd(Reko.Core.NativeInterface.HExpr a, Reko.Core.NativeInterface.HExpr b) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.NativeRtlEmitter.FDiv(Reko.Core.NativeInterface.HExpr a, Reko.Core.NativeInterface.HExpr b) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.NativeRtlEmitter.FinishCluster(Reko.Core.InstrClass rtlClass, ulong address, int mcLength) -> void
Reko.Core.NativeInterface.NativeRtlEmitter.FMul(Reko.Core.NativeInterface.HExpr a, Reko.Core.NativeInterface.HExpr b) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.NativeRtlEmitter.Fn(Reko.Core.NativeInterface.HExpr fn) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.NativeRtlEmitter.FSub(Reko.Core.NativeInterface.HExpr a, Reko.Core.NativeInterface.HExpr b) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.NativeRtlEmitter.GetExpression(Reko.Core.NativeInterface.HExpr hExp) -> Reko.Core.Expressions.Expression
Reko.Core.NativeInterface.NativeRtlEmitter.Goto(Reko.Core.NativeInterface.HExpr dst) -> void
Reko.Core.NativeInterface.NativeRtlEmitter.IAdc(Reko.Core.NativeInterface.HExpr a, Reko.Core.NativeInterface.HExpr b, Reko.Core.NativeInterface.HExpr c) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.NativeRtlEmitter.IAdd(Reko.Core.NativeInterface.HExpr a, Reko.Core.NativeInterface.HExpr b) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.NativeRtlEmitter.IMul(Reko.Core.NativeInterface.HExpr a, Reko.Core.NativeInterface.HExpr b) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.NativeRtlEmitter.Int16(short s) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.NativeRtlEmitter.Int32(int i) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.NativeRtlEmitter.Int64(long l) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.NativeRtlEmitter.Invalid() -> void
Reko.Core.NativeInterface.NativeRtlEmitter.ISub(Reko.Core.NativeInterface.HExpr a, Reko.Core.NativeInterface.HExpr b) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.NativeRtlEmitter.MapToHandle(Reko.Core.Expressions.Expression exp) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.NativeRtlEmitter.Mem(Reko.Core.NativeInterface.BaseType dt, Reko.Core.NativeInterface.HExpr ea) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.NativeRtlEmitter.Mem16(Reko.Core.NativeInterface.HExpr ea) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.NativeRtlEmitter.Mem32(Reko.Core.NativeInterface.HExpr ea) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.NativeRtlEmitter.Mem64(Reko.Core.NativeInterface.HExpr ea) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.NativeRtlEmitter.Mem8(Reko.Core.NativeInterface.HExpr ea) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.NativeRtlEmitter.NativeRtlEmitter(Reko.Core.Rtl.RtlEmitter m, Reko.Core.NativeInterface.NativeTypeFactory ntf, Reko.Core.IRewriterHost host) -> void
Reko.Core.NativeInterface.NativeRtlEmitter.Ne0(Reko.Core.NativeInterface.HExpr e) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.NativeRtlEmitter.Nop() -> void
Reko.Core.NativeInterface.NativeRtlEmitter.Not(Reko.Core.NativeInterface.HExpr a) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.NativeRtlEmitter.Or(Reko.Core.NativeInterface.HExpr a, Reko.Core.NativeInterface.HExpr b) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.NativeRtlEmitter.Ptr16(ushort p) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.NativeRtlEmitter.Ptr32(uint p) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.NativeRtlEmitter.Ptr64(ulong p) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.NativeRtlEmitter.Return(int returnAddressBytes, int extraBytesPopped) -> void
Reko.Core.NativeInterface.NativeRtlEmitter.Ror(Reko.Core.NativeInterface.HExpr a, Reko.Core.NativeInterface.HExpr b) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.NativeRtlEmitter.Rrc(Reko.Core.NativeInterface.HExpr a, Reko.Core.NativeInterface.HExpr b, Reko.Core.NativeInterface.HExpr c) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.NativeRtlEmitter.Sar(Reko.Core.NativeInterface.HExpr a, Reko.Core.NativeInterface.HExpr b) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.NativeRtlEmitter.SDiv(Reko.Core.NativeInterface.HExpr a, Reko.Core.NativeInterface.HExpr b) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.NativeRtlEmitter.Seq(Reko.Core.NativeInterface.HExpr dt) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.NativeRtlEmitter.Shl(Reko.Core.NativeInterface.HExpr a, Reko.Core.NativeInterface.HExpr b) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.NativeRtlEmitter.Shr(Reko.Core.NativeInterface.HExpr a, Reko.Core.NativeInterface.HExpr b) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.NativeRtlEmitter.SideEffect(Reko.Core.NativeInterface.HExpr exp) -> void
Reko.Core.NativeInterface.NativeRtlEmitter.Slice(Reko.Core.NativeInterface.HExpr a, int pos, int bits) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.NativeRtlEmitter.SMul(Reko.Core.NativeInterface.HExpr a, Reko.Core.NativeInterface.HExpr b) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.NativeRtlEmitter.Test(Reko.Core.Expressions.ConditionCode cc, Reko.Core.NativeInterface.HExpr exp) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.NativeRtlEmitter.UDiv(Reko.Core.NativeInterface.HExpr a, Reko.Core.NativeInterface.HExpr b) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.NativeRtlEmitter.UInt16(ushort us) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.NativeRtlEmitter.UInt32(uint u) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.NativeRtlEmitter.UInt64(ulong ul) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.NativeRtlEmitter.UMul(Reko.Core.NativeInterface.HExpr a, Reko.Core.NativeInterface.HExpr b) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.NativeRtlEmitter.Word16(ushort us) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.NativeRtlEmitter.Word32(uint u) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.NativeRtlEmitter.Word64(ulong ul) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.NativeRtlEmitter.Xor(Reko.Core.NativeInterface.HExpr a, Reko.Core.NativeInterface.HExpr b) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.NativeSymbolSource
Reko.Core.NativeInterface.NativeSymbolSource.CanLoad(string filename, byte[] fileContents) -> bool
Reko.Core.NativeInterface.NativeSymbolSource.Dispose() -> void
Reko.Core.NativeInterface.NativeSymbolSource.GetAllSymbols() -> System.Collections.Generic.List<Reko.Core.ImageSymbol>
Reko.Core.NativeInterface.NativeSymbolSource.NativeSymbolSource(Reko.Core.IProcessorArchitecture arch, string libPath, Reko.Core.NativeInterface.ILibraryLoader ldr) -> void
Reko.Core.NativeInterface.NativeTypeFactory
Reko.Core.NativeInterface.NativeTypeFactory.ArrayOf(Reko.Core.NativeInterface.HExpr dt, int length) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.NativeTypeFactory.BeginFunc(Reko.Core.NativeInterface.HExpr dt, int byte_size) -> void
Reko.Core.NativeInterface.NativeTypeFactory.BeginStruct(Reko.Core.NativeInterface.HExpr dt, int byte_size) -> void
Reko.Core.NativeInterface.NativeTypeFactory.EndFunc() -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.NativeTypeFactory.EndStruct() -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.NativeTypeFactory.Field(Reko.Core.NativeInterface.HExpr dt, int offset, string name) -> void
Reko.Core.NativeInterface.NativeTypeFactory.GetRekoType(Reko.Core.NativeInterface.HExpr a) -> Reko.Core.Types.DataType
Reko.Core.NativeInterface.NativeTypeFactory.NativeTypeFactory() -> void
Reko.Core.NativeInterface.NativeTypeFactory.Parameter(Reko.Core.NativeInterface.HExpr dt, string name) -> void
Reko.Core.NativeInterface.NativeTypeFactory.PtrTo(Reko.Core.NativeInterface.HExpr dt, int byte_size) -> Reko.Core.NativeInterface.HExpr
Reko.Core.NativeInterface.PosixLibraryLoader
Reko.Core.NativeInterface.PosixLibraryLoader.GetSymbol(System.IntPtr handle, string symName) -> System.IntPtr
Reko.Core.NativeInterface.PosixLibraryLoader.LoadLibrary(string libPath) -> System.IntPtr
Reko.Core.NativeInterface.PosixLibraryLoader.PosixLibraryLoader() -> void
Reko.Core.NativeInterface.PosixLibraryLoader.Unload(System.IntPtr handle) -> int
Reko.Core.NativeInterface.WindowsLibraryLoader
Reko.Core.NativeInterface.WindowsLibraryLoader.GetSymbol(System.IntPtr handle, string symName) -> System.IntPtr
Reko.Core.NativeInterface.WindowsLibraryLoader.LoadLibrary(string libPath) -> System.IntPtr
Reko.Core.NativeInterface.WindowsLibraryLoader.Unload(System.IntPtr handle) -> int
Reko.Core.NativeInterface.WindowsLibraryLoader.WindowsLibraryLoader() -> void
Reko.Core.Normalize
Reko.Core.Normalize.Constants = 1 -> Reko.Core.Normalize
Reko.Core.Normalize.Nothing = 0 -> Reko.Core.Normalize
Reko.Core.Normalize.Registers = 2 -> Reko.Core.Normalize
Reko.Core.NullMetadataLoader
Reko.Core.NullMetadataLoader.NullMetadataLoader() -> void
Reko.Core.NullRewriterHost
Reko.Core.NullRewriterHost.EnsureIntrinsic(string name, bool hasSideEffect, Reko.Core.Types.DataType returnType, int arity) -> Reko.Core.IntrinsicProcedure
Reko.Core.NullRewriterHost.Error(Reko.Core.Address address, string format, params object[] args) -> void
Reko.Core.NullRewriterHost.GetArchitecture(string archMoniker) -> Reko.Core.IProcessorArchitecture
Reko.Core.NullRewriterHost.GetImport(Reko.Core.Address addrThunk, Reko.Core.Address addrInstr) -> Reko.Core.Expressions.Expression
Reko.Core.NullRewriterHost.GetImportedProcedure(Reko.Core.IProcessorArchitecture arch, Reko.Core.Address addrThunk, Reko.Core.Address addrInstr) -> Reko.Core.ExternalProcedure
Reko.Core.NullRewriterHost.GetInterceptedCall(Reko.Core.IProcessorArchitecture arch, Reko.Core.Address addrImportThunk) -> Reko.Core.ExternalProcedure
Reko.Core.NullRewriterHost.Intrinsic(string name, bool hasSideEffect, Reko.Core.Types.DataType returnType, params Reko.Core.Expressions.Expression[] args) -> Reko.Core.Expressions.Expression
Reko.Core.NullRewriterHost.NullRewriterHost() -> void
Reko.Core.NullRewriterHost.TryRead(Reko.Core.IProcessorArchitecture arch, Reko.Core.Address addr, Reko.Core.Types.PrimitiveType dt, out Reko.Core.Expressions.Constant value) -> bool
Reko.Core.NullRewriterHost.Warn(Reko.Core.Address address, string format, params object[] args) -> void
Reko.Core.Operators.AddressOfOperator
Reko.Core.Operators.AddressOfOperator.AddressOfOperator() -> void
Reko.Core.Operators.AndOperator
Reko.Core.Operators.AndOperator.AndOperator() -> void
Reko.Core.Operators.BinaryOperator
Reko.Core.Operators.BinaryOperator.BinaryOperator() -> void
Reko.Core.Operators.BinaryOperator.BuildConstant(Reko.Core.Types.DataType t1, Reko.Core.Types.DataType t2, double val) -> Reko.Core.Expressions.Constant
Reko.Core.Operators.BinaryOperator.BuildConstant(Reko.Core.Types.DataType! t1, Reko.Core.Types.DataType! t2, long val) -> Reko.Core.Expressions.Constant!
Reko.Core.Operators.BinaryOperator.BuildConstant(Reko.Core.Types.DataType t1, Reko.Core.Types.DataType t2, System.Numerics.BigInteger value) -> Reko.Core.Expressions.Constant
Reko.Core.Operators.BinaryOperator.BuildConstant(Reko.Core.Types.DataType! t1, Reko.Core.Types.DataType! t2, ulong val) -> Reko.Core.Expressions.Constant!
Reko.Core.Operators.BinaryOperator.ValidArgs(Reko.Core.Expressions.Constant c1, Reko.Core.Expressions.Constant c2) -> bool
Reko.Core.Operators.CandOperator
Reko.Core.Operators.CandOperator.CandOperator() -> void
Reko.Core.Operators.CommaOperator
Reko.Core.Operators.CommaOperator.CommaOperator() -> void
Reko.Core.Operators.ComplementOperator
Reko.Core.Operators.ComplementOperator.ComplementOperator() -> void
Reko.Core.Operators.ConditionalOperator
Reko.Core.Operators.ConditionalOperator.ConditionalOperator() -> void
Reko.Core.Operators.CorOperator
Reko.Core.Operators.CorOperator.CorOperator() -> void
Reko.Core.Operators.EqOperator
Reko.Core.Operators.EqOperator.EqOperator() -> void
Reko.Core.Operators.FAddOperator
Reko.Core.Operators.FAddOperator.FAddOperator() -> void
Reko.Core.Operators.FDivOperator
Reko.Core.Operators.FDivOperator.FDivOperator() -> void
Reko.Core.Operators.FModOperator
Reko.Core.Operators.FModOperator.FModOperator() -> void
Reko.Core.Operators.FMulOperator
Reko.Core.Operators.FMulOperator.FMulOperator() -> void
Reko.Core.Operators.FNegOperator
Reko.Core.Operators.FNegOperator.FNegOperator() -> void
Reko.Core.Operators.FSubOperator
Reko.Core.Operators.FSubOperator.FSubOperator() -> void
Reko.Core.Operators.GeOperator
Reko.Core.Operators.GeOperator.GeOperator() -> void
Reko.Core.Operators.GtOperator
Reko.Core.Operators.GtOperator.GtOperator() -> void
Reko.Core.Operators.IAddOperator
Reko.Core.Operators.IAddOperator.IAddOperator() -> void
Reko.Core.Operators.IModOperator
Reko.Core.Operators.IModOperator.IModOperator() -> void
Reko.Core.Operators.IMulOperator
Reko.Core.Operators.IMulOperator.IMulOperator() -> void
Reko.Core.Operators.ISubOperator
Reko.Core.Operators.ISubOperator.ISubOperator() -> void
Reko.Core.Operators.LeOperator
Reko.Core.Operators.LeOperator.LeOperator() -> void
Reko.Core.Operators.LtOperator
Reko.Core.Operators.LtOperator.LtOperator() -> void
Reko.Core.Operators.NegateOperator
Reko.Core.Operators.NegateOperator.NegateOperator() -> void
Reko.Core.Operators.NeOperator
Reko.Core.Operators.NeOperator.NeOperator() -> void
Reko.Core.Operators.NotOperator
Reko.Core.Operators.NotOperator.NotOperator() -> void
Reko.Core.Operators.Operator
Reko.Core.Operators.Operator.Operator() -> void
Reko.Core.Operators.OrOperator
Reko.Core.Operators.OrOperator.OrOperator() -> void
Reko.Core.Operators.RealConditionalOperator
Reko.Core.Operators.RealConditionalOperator.RealConditionalOperator() -> void
Reko.Core.Operators.ReqOperator
Reko.Core.Operators.ReqOperator.ReqOperator() -> void
Reko.Core.Operators.RgeOperator
Reko.Core.Operators.RgeOperator.RgeOperator() -> void
Reko.Core.Operators.RgtOperator
Reko.Core.Operators.RgtOperator.RgtOperator() -> void
Reko.Core.Operators.RleOperator
Reko.Core.Operators.RleOperator.RleOperator() -> void
Reko.Core.Operators.RltOperator
Reko.Core.Operators.RltOperator.RltOperator() -> void
Reko.Core.Operators.RneOperator
Reko.Core.Operators.RneOperator.RneOperator() -> void
Reko.Core.Operators.SarOperator
Reko.Core.Operators.SarOperator.SarOperator() -> void
Reko.Core.Operators.SDivOperator
Reko.Core.Operators.SDivOperator.SDivOperator() -> void
Reko.Core.Operators.ShlOperator
Reko.Core.Operators.ShlOperator.ShlOperator() -> void
Reko.Core.Operators.ShrOperator
Reko.Core.Operators.ShrOperator.ShrOperator() -> void
Reko.Core.Operators.SignedIntOperator
Reko.Core.Operators.SignedIntOperator.SignedIntOperator() -> void
Reko.Core.Operators.SModOperator
Reko.Core.Operators.SModOperator.SModOperator() -> void
Reko.Core.Operators.SMulOperator
Reko.Core.Operators.SMulOperator.SMulOperator() -> void
Reko.Core.Operators.UDivOperator
Reko.Core.Operators.UDivOperator.BuildConstant(Reko.Core.Types.DataType dtN, Reko.Core.Types.DataType dtD, System.Numerics.BigInteger value) -> Reko.Core.Expressions.Constant
Reko.Core.Operators.UDivOperator.UDivOperator() -> void
Reko.Core.Operators.UgeOperator
Reko.Core.Operators.UgeOperator.UgeOperator() -> void
Reko.Core.Operators.UgtOperator
Reko.Core.Operators.UgtOperator.UgtOperator() -> void
Reko.Core.Operators.UleOperator
Reko.Core.Operators.UleOperator.UleOperator() -> void
Reko.Core.Operators.UltOperator
Reko.Core.Operators.UltOperator.UltOperator() -> void
Reko.Core.Operators.UModOperator
Reko.Core.Operators.UModOperator.UModOperator() -> void
Reko.Core.Operators.UMulOperator
Reko.Core.Operators.UMulOperator.UMulOperator() -> void
Reko.Core.Operators.UnaryOperator
Reko.Core.Operators.UnaryOperator.UnaryOperator() -> void
Reko.Core.Operators.UnsignedIntOperator
Reko.Core.Operators.UnsignedIntOperator.UnsignedIntOperator() -> void
Reko.Core.Operators.USubOperator
Reko.Core.Operators.USubOperator.USubOperator() -> void
Reko.Core.Operators.XorOperator
Reko.Core.Operators.XorOperator.XorOperator() -> void
Reko.Core.OrdinalImportReference
Reko.Core.OrdinalImportReference.Ordinal -> int
Reko.Core.OrdinalImportReference.OrdinalImportReference(Reko.Core.Address addr, string moduleName, int ordinal, Reko.Core.SymbolType symType) -> void
Reko.Core.OutArgumentStorage
Reko.Core.OutArgumentStorage.OriginalIdentifier.get -> Reko.Core.Expressions.Identifier
Reko.Core.OutArgumentStorage.OutArgumentStorage(Reko.Core.Expressions.Identifier originalId) -> void
Reko.Core.Output.AbsynCodeFormatter
Reko.Core.Output.AbsynCodeFormatter.AbsynCodeFormatter(Reko.Core.Output.Formatter! writer) -> void
Reko.Core.Output.BlockDecorator
Reko.Core.Output.BlockDecorator.BlockDecorator() -> void
Reko.Core.Output.BlockDecorator.ShowEdges.get -> bool
Reko.Core.Output.BlockDecorator.ShowEdges.set -> void
Reko.Core.Output.CodeFormatter
Reko.Core.Output.CodeFormatter.CodeFormatter(Reko.Core.Output.Formatter writer) -> void
Reko.Core.Output.CodeFormatter.InnerFormatter.get -> Reko.Core.Output.Formatter
Reko.Core.Output.CodeFormatter.VisitAddress(Reko.Core.Address addr) -> void
Reko.Core.Output.CodeFormatter.VisitApplication(Reko.Core.Expressions.Application appl) -> void
Reko.Core.Output.CodeFormatter.VisitArrayAccess(Reko.Core.Expressions.ArrayAccess acc) -> void
Reko.Core.Output.CodeFormatter.VisitAssignment(Reko.Core.Absyn.AbsynAssignment a) -> void
Reko.Core.Output.CodeFormatter.VisitAssignment(Reko.Core.Code.Assignment a) -> void
Reko.Core.Output.CodeFormatter.VisitBinaryExpression(Reko.Core.Expressions.BinaryExpression binExp) -> void
Reko.Core.Output.CodeFormatter.VisitBranch(Reko.Core.Code.Branch b) -> void
Reko.Core.Output.CodeFormatter.VisitBreak(Reko.Core.Absyn.AbsynBreak brk) -> void
Reko.Core.Output.CodeFormatter.VisitCallInstruction(Reko.Core.Code.CallInstruction ci) -> void
Reko.Core.Output.CodeFormatter.VisitCase(Reko.Core.Absyn.AbsynCase c) -> void
Reko.Core.Output.CodeFormatter.VisitCast(Reko.Core.Expressions.Cast cast) -> void
Reko.Core.Output.CodeFormatter.VisitComment(Reko.Core.Code.CodeComment comment) -> void
Reko.Core.Output.CodeFormatter.VisitCompoundAssignment(Reko.Core.Absyn.AbsynCompoundAssignment compound) -> void
Reko.Core.Output.CodeFormatter.VisitConditionalExpression(Reko.Core.Expressions.ConditionalExpression cond) -> void
Reko.Core.Output.CodeFormatter.VisitConditionOf(Reko.Core.Expressions.ConditionOf cond) -> void
Reko.Core.Output.CodeFormatter.VisitContinue(Reko.Core.Absyn.AbsynContinue cont) -> void
Reko.Core.Output.CodeFormatter.VisitConversion(Reko.Core.Expressions.Conversion conversion) -> void
Reko.Core.Output.CodeFormatter.VisitDeclaration(Reko.Core.Absyn.AbsynDeclaration decl) -> void
Reko.Core.Output.CodeFormatter.VisitDeclaration(Reko.Core.Code.Declaration decl) -> void
Reko.Core.Output.CodeFormatter.VisitDefault(Reko.Core.Absyn.AbsynDefault d) -> void
Reko.Core.Output.CodeFormatter.VisitDefInstruction(Reko.Core.Code.DefInstruction def) -> void
Reko.Core.Output.CodeFormatter.VisitDereference(Reko.Core.Expressions.Dereference deref) -> void
Reko.Core.Output.CodeFormatter.VisitDoWhile(Reko.Core.Absyn.AbsynDoWhile loop) -> void
Reko.Core.Output.CodeFormatter.VisitFieldAccess(Reko.Core.Expressions.FieldAccess acc) -> void
Reko.Core.Output.CodeFormatter.VisitFor(Reko.Core.Absyn.AbsynFor forLoop) -> void
Reko.Core.Output.CodeFormatter.VisitGoto(Reko.Core.Absyn.AbsynGoto g) -> void
Reko.Core.Output.CodeFormatter.VisitGotoInstruction(Reko.Core.Code.GotoInstruction g) -> void
Reko.Core.Output.CodeFormatter.VisitIdentifier(Reko.Core.Expressions.Identifier id) -> void
Reko.Core.Output.CodeFormatter.VisitIf(Reko.Core.Absyn.AbsynIf ifs) -> void
Reko.Core.Output.CodeFormatter.VisitLabel(Reko.Core.Absyn.AbsynLabel lbl) -> void
Reko.Core.Output.CodeFormatter.VisitLineComment(Reko.Core.Absyn.AbsynLineComment comment) -> void
Reko.Core.Output.CodeFormatter.VisitMemberPointerSelector(Reko.Core.Expressions.MemberPointerSelector mps) -> void
Reko.Core.Output.CodeFormatter.VisitMemoryAccess(Reko.Core.Expressions.MemoryAccess access) -> void
Reko.Core.Output.CodeFormatter.VisitMkSequence(Reko.Core.Expressions.MkSequence seq) -> void
Reko.Core.Output.CodeFormatter.VisitOutArgument(Reko.Core.Expressions.OutArgument outArg) -> void
Reko.Core.Output.CodeFormatter.VisitPhiAssignment(Reko.Core.Code.PhiAssignment phi) -> void
Reko.Core.Output.CodeFormatter.VisitPhiFunction(Reko.Core.Expressions.PhiFunction phi) -> void
Reko.Core.Output.CodeFormatter.VisitPointerAddition(Reko.Core.Expressions.PointerAddition pa) -> void
Reko.Core.Output.CodeFormatter.VisitReturn(Reko.Core.Absyn.AbsynReturn ret) -> void
Reko.Core.Output.CodeFormatter.VisitReturnInstruction(Reko.Core.Code.ReturnInstruction ret) -> void
Reko.Core.Output.CodeFormatter.VisitScopeResolution(Reko.Core.Expressions.ScopeResolution scope) -> void
Reko.Core.Output.CodeFormatter.VisitSegmentedAccess(Reko.Core.Expressions.SegmentedAccess access) -> void
Reko.Core.Output.CodeFormatter.VisitSideEffect(Reko.Core.Absyn.AbsynSideEffect side) -> void
Reko.Core.Output.CodeFormatter.VisitSideEffect(Reko.Core.Code.SideEffect side) -> void
Reko.Core.Output.CodeFormatter.VisitSlice(Reko.Core.Expressions.Slice slice) -> void
Reko.Core.Output.CodeFormatter.VisitStore(Reko.Core.Code.Store store) -> void
Reko.Core.Output.CodeFormatter.VisitSwitch(Reko.Core.Absyn.AbsynSwitch s) -> void
Reko.Core.Output.CodeFormatter.VisitSwitchInstruction(Reko.Core.Code.SwitchInstruction si) -> void
Reko.Core.Output.CodeFormatter.VisitTestCondition(Reko.Core.Expressions.TestCondition tc) -> void
Reko.Core.Output.CodeFormatter.VisitUnaryExpression(Reko.Core.Expressions.UnaryExpression unary) -> void
Reko.Core.Output.CodeFormatter.VisitUseInstruction(Reko.Core.Code.UseInstruction u) -> void
Reko.Core.Output.CodeFormatter.VisitWhile(Reko.Core.Absyn.AbsynWhile loop) -> void
Reko.Core.Output.CodeFormatter.Write(Reko.Core.Procedure proc) -> void
Reko.Core.Output.CodeFormatter.WriteCompoundAssignment(Reko.Core.Absyn.AbsynCompoundAssignment compound) -> void
Reko.Core.Output.CodeFormatter.WriteExpression(Reko.Core.Expressions.Expression expr) -> void
Reko.Core.Output.CodeFormatter.WriteFormalArgument(Reko.Core.Expressions.Identifier arg, bool writeStorage, Reko.Core.Output.TypeReferenceFormatter t) -> void
Reko.Core.Output.CodeFormatter.WriteFormalArgumentType(Reko.Core.Expressions.Identifier arg, bool writeStorage) -> void
Reko.Core.Output.CodeFormatter.WriteIndentedStatement(Reko.Core.Absyn.AbsynStatement stm) -> void
Reko.Core.Output.CodeFormatter.WriteIndentedStatements(System.Collections.Generic.List<Reko.Core.Absyn.AbsynStatement> stms, bool suppressNewline) -> void
Reko.Core.Output.CodeFormatter.WriteNull() -> void
Reko.Core.Output.CodeFormatter.WriteStatementList(System.Collections.Generic.List<Reko.Core.Absyn.AbsynStatement> list) -> void
Reko.Core.Output.CTypeReferenceFormatter
Reko.Core.Output.CTypeReferenceFormatter.CTypeReferenceFormatter(Reko.Core.IPlatform platform, Reko.Core.Output.Formatter writer) -> void
Reko.Core.Output.Dumper
Reko.Core.Output.Dumper.Dump(Reko.Core.Output.Formatter formatter) -> void
Reko.Core.Output.Dumper.Dump(System.Collections.Generic.Dictionary<Reko.Core.ImageSegment, System.Collections.Generic.List<Reko.Core.ImageMapItem>> segmentItems, Reko.Core.Output.Formatter formatter) -> void
Reko.Core.Output.Dumper.DumpAssembler(Reko.Core.IProcessorArchitecture arch, Reko.Core.Memory.MemoryArea mem, Reko.Core.Address addrStart, long cbBytes, Reko.Core.Output.Formatter formatter) -> void
Reko.Core.Output.Dumper.DumpAssemblerLine(Reko.Core.Memory.MemoryArea mem, Reko.Core.IProcessorArchitecture arch, Reko.Core.Machine.MachineInstruction instr, Reko.Core.Output.FormatterInstructionWriter writer, Reko.Core.Machine.MachineInstructionRendererOptions options) -> bool
Reko.Core.Output.Dumper.DumpData(Reko.Core.IProcessorArchitecture arch, Reko.Core.Memory.MemoryArea mem, Reko.Core.Address address, long cUnits, Reko.Core.Output.Formatter stm) -> void
Reko.Core.Output.Dumper.DumpData(Reko.Core.SegmentMap map, Reko.Core.IProcessorArchitecture arch, Reko.Core.Address address, int cbBytes, Reko.Core.Output.Formatter stm) -> void
Reko.Core.Output.Dumper.DumpData(Reko.Core.SegmentMap map, Reko.Core.IProcessorArchitecture arch, Reko.Core.Address address, long cbBytes, Reko.Core.Output.Formatter stm) -> void
Reko.Core.Output.Dumper.DumpData(Reko.Core.SegmentMap map, Reko.Core.IProcessorArchitecture arch, Reko.Core.AddressRange range, Reko.Core.Output.Formatter stm) -> void
Reko.Core.Output.Dumper.Dumper(Reko.Core.Program program) -> void
Reko.Core.Output.Dumper.ShowAddresses.get -> bool
Reko.Core.Output.Dumper.ShowAddresses.set -> void
Reko.Core.Output.Dumper.ShowCodeBytes.get -> bool
Reko.Core.Output.Dumper.ShowCodeBytes.set -> void
Reko.Core.Output.Dumper.WriteOpcodes(Reko.Core.Memory.MemoryArea image, Reko.Core.IProcessorArchitecture arch, Reko.Core.Address begin, Reko.Core.Address addrEnd, Reko.Core.Output.FormatterInstructionWriter writer) -> void
Reko.Core.Output.Formatter
Reko.Core.Output.Formatter.Formatter() -> void
Reko.Core.Output.Formatter.Indentation.get -> int
Reko.Core.Output.Formatter.Indentation.set -> void
Reko.Core.Output.Formatter.TabSize.get -> int
Reko.Core.Output.Formatter.TabSize.set -> void
Reko.Core.Output.Formatter.Terminate(string s) -> void
Reko.Core.Output.Formatter.UseTabs.get -> bool
Reko.Core.Output.Formatter.UseTabs.set -> void
Reko.Core.Output.Formatter.Write(object o) -> void
Reko.Core.Output.Formatter.WriteLine(object o) -> void
Reko.Core.Output.Formatter.WriteSpaces(int n) -> void
Reko.Core.Output.FormatterInstructionWriter
Reko.Core.Output.FormatterInstructionWriter.AddAnnotation(string annotation) -> void
Reko.Core.Output.FormatterInstructionWriter.Address.get -> Reko.Core.Address
Reko.Core.Output.FormatterInstructionWriter.BeginInstruction(Reko.Core.Address addr) -> void
Reko.Core.Output.FormatterInstructionWriter.BeginOperand() -> void
Reko.Core.Output.FormatterInstructionWriter.EndInstruction() -> void
Reko.Core.Output.FormatterInstructionWriter.EndOperand() -> void
Reko.Core.Output.FormatterInstructionWriter.FormatterInstructionWriter(Reko.Core.Output.Formatter formatter, bool separateWithTab) -> void
Reko.Core.Output.FormatterInstructionWriter.Tab() -> void
Reko.Core.Output.FormatterInstructionWriter.WriteAddress(string formattedAddress, Reko.Core.Address addr) -> void
Reko.Core.Output.FormatterInstructionWriter.WriteAddress(string formattedAddress, ulong uAddr) -> void
Reko.Core.Output.FormatterInstructionWriter.WriteChar(char c) -> void
Reko.Core.Output.FormatterInstructionWriter.WriteFormat(string fmt, params object[] parms) -> void
Reko.Core.Output.FormatterInstructionWriter.WriteLine() -> void
Reko.Core.Output.FormatterInstructionWriter.WriteMnemonic(string sMnemonic) -> void
Reko.Core.Output.FormatterInstructionWriter.WriteString(string s) -> void
Reko.Core.Output.FormatterInstructionWriter.WriteUInt32(uint n) -> void
Reko.Core.Output.GlobalDataWriter
Reko.Core.Output.GlobalDataWriter.GlobalDataWriter(Reko.Core.Program program, Reko.Core.Output.Formatter formatter, bool chasePointers, bool showAddressInComment, System.IServiceProvider services) -> void
Reko.Core.Output.GlobalDataWriter.VisitArray(Reko.Core.Types.ArrayType at) -> Reko.Core.Output.CodeFormatter
Reko.Core.Output.GlobalDataWriter.VisitClass(Reko.Core.Types.ClassType ct) -> Reko.Core.Output.CodeFormatter
Reko.Core.Output.GlobalDataWriter.VisitCode(Reko.Core.Types.CodeType c) -> Reko.Core.Output.CodeFormatter
Reko.Core.Output.GlobalDataWriter.VisitEnum(Reko.Core.Types.EnumType e) -> Reko.Core.Output.CodeFormatter
Reko.Core.Output.GlobalDataWriter.VisitEquivalenceClass(Reko.Core.Types.EquivalenceClass eq) -> Reko.Core.Output.CodeFormatter
Reko.Core.Output.GlobalDataWriter.VisitFunctionType(Reko.Core.Types.FunctionType ft) -> Reko.Core.Output.CodeFormatter
Reko.Core.Output.GlobalDataWriter.VisitMemberPointer(Reko.Core.Types.MemberPointer memptr) -> Reko.Core.Output.CodeFormatter
Reko.Core.Output.GlobalDataWriter.VisitPointer(Reko.Core.Types.Pointer ptr) -> Reko.Core.Output.CodeFormatter
Reko.Core.Output.GlobalDataWriter.VisitPrimitive(Reko.Core.Types.PrimitiveType pt) -> Reko.Core.Output.CodeFormatter
Reko.Core.Output.GlobalDataWriter.VisitReference(Reko.Core.Types.ReferenceTo refTo) -> Reko.Core.Output.CodeFormatter
Reko.Core.Output.GlobalDataWriter.VisitString(Reko.Core.Types.StringType str) -> Reko.Core.Output.CodeFormatter
Reko.Core.Output.GlobalDataWriter.VisitStructure(Reko.Core.Types.StructureType str) -> Reko.Core.Output.CodeFormatter
Reko.Core.Output.GlobalDataWriter.VisitTypeReference(Reko.Core.Types.TypeReference typeref) -> Reko.Core.Output.CodeFormatter
Reko.Core.Output.GlobalDataWriter.VisitTypeVariable(Reko.Core.Types.TypeVariable tv) -> Reko.Core.Output.CodeFormatter
Reko.Core.Output.GlobalDataWriter.VisitUnion(Reko.Core.Types.UnionType ut) -> Reko.Core.Output.CodeFormatter
Reko.Core.Output.GlobalDataWriter.VisitUnknownType(Reko.Core.Types.UnknownType ut) -> Reko.Core.Output.CodeFormatter
Reko.Core.Output.GlobalDataWriter.VisitVoidType(Reko.Core.Types.VoidType! voidType) -> Reko.Core.Output.CodeFormatter!
Reko.Core.Output.GlobalDataWriter.Write() -> void
Reko.Core.Output.GlobalDataWriter.WriteGlobalVariable(Reko.Core.Address address, Reko.Core.Types.DataType dataType, string name) -> void
Reko.Core.Output.GlobalObjectTracer
Reko.Core.Output.GlobalObjectTracer.GlobalObjectTracer(Reko.Core.Program program, Reko.Core.WorkList<(Reko.Core.Types.StructureField, Reko.Core.Address)> wl, Reko.Core.Services.DecompilerEventListener eventListener) -> void
Reko.Core.Output.GlobalObjectTracer.TraceObject(Reko.Core.Types.DataType dataType, Reko.Core.Address addr) -> void
Reko.Core.Output.GlobalObjectTracer.VisitArray(Reko.Core.Types.ArrayType at) -> int
Reko.Core.Output.GlobalObjectTracer.VisitClass(Reko.Core.Types.ClassType ct) -> int
Reko.Core.Output.GlobalObjectTracer.VisitCode(Reko.Core.Types.CodeType c) -> int
Reko.Core.Output.GlobalObjectTracer.VisitEnum(Reko.Core.Types.EnumType e) -> int
Reko.Core.Output.GlobalObjectTracer.VisitEquivalenceClass(Reko.Core.Types.EquivalenceClass eq) -> int
Reko.Core.Output.GlobalObjectTracer.VisitFunctionType(Reko.Core.Types.FunctionType ft) -> int
Reko.Core.Output.GlobalObjectTracer.VisitMemberPointer(Reko.Core.Types.MemberPointer memptr) -> int
Reko.Core.Output.GlobalObjectTracer.VisitPointer(Reko.Core.Types.Pointer ptr) -> int
Reko.Core.Output.GlobalObjectTracer.VisitPrimitive(Reko.Core.Types.PrimitiveType pt) -> int
Reko.Core.Output.GlobalObjectTracer.VisitReference(Reko.Core.Types.ReferenceTo refTo) -> int
Reko.Core.Output.GlobalObjectTracer.VisitString(Reko.Core.Types.StringType str) -> int
Reko.Core.Output.GlobalObjectTracer.VisitStructure(Reko.Core.Types.StructureType str) -> int
Reko.Core.Output.GlobalObjectTracer.VisitTypeReference(Reko.Core.Types.TypeReference typeref) -> int
Reko.Core.Output.GlobalObjectTracer.VisitTypeVariable(Reko.Core.Types.TypeVariable tv) -> int
Reko.Core.Output.GlobalObjectTracer.VisitUnion(Reko.Core.Types.UnionType ut) -> int
Reko.Core.Output.GlobalObjectTracer.VisitUnknownType(Reko.Core.Types.UnknownType ut) -> int
Reko.Core.Output.GlobalObjectTracer.VisitVoidType(Reko.Core.Types.VoidType voidType) -> int
Reko.Core.Output.IMemoryFormatterOutput
Reko.Core.Output.IMemoryFormatterOutput.BeginLine() -> void
Reko.Core.Output.IMemoryFormatterOutput.EndLine(Reko.Core.Expressions.Constant[] units) -> void
Reko.Core.Output.IMemoryFormatterOutput.RenderAddress(Reko.Core.Address addr) -> void
Reko.Core.Output.IMemoryFormatterOutput.RenderFillerSpan(int nCells) -> void
Reko.Core.Output.IMemoryFormatterOutput.RenderUnit(Reko.Core.Address addr, string sUnit) -> void
Reko.Core.Output.IMemoryFormatterOutput.RenderUnitsAsText(int prePadding, string sBytes, int postPadding) -> void
Reko.Core.Output.IndentingTextWriter
Reko.Core.Output.IndentingTextWriter.Indent() -> void
Reko.Core.Output.IndentingTextWriter.IndentingTextWriter(System.IO.TextWriter writer, bool useTabs, int tabWidth) -> void
Reko.Core.Output.IndentingTextWriter.InnerTextWriter.get -> System.IO.TextWriter
Reko.Core.Output.IndentingTextWriter.Outdent() -> void
Reko.Core.Output.IndentingTextWriter.SuspendIndent.get -> bool
Reko.Core.Output.IndentingTextWriter.SuspendIndent.set -> void
Reko.Core.Output.IndentingTextWriter.Write(string formatString, params object[] objs) -> void
Reko.Core.Output.IndentingTextWriter.Write(string s) -> void
Reko.Core.Output.IndentingTextWriter.WriteLine() -> void
Reko.Core.Output.IndentingTextWriter.WriteLine(string formatString, params object[] objs) -> void
Reko.Core.Output.IndentingTextWriter.WriteLine(string s) -> void
Reko.Core.Output.IRFormatter
Reko.Core.Output.IRFormatter.IRFormatter(System.IO.TextWriter w) -> void
Reko.Core.Output.IRFormatter.WriteProcedure(Reko.Core.Procedure procedure) -> void
Reko.Core.Output.IRFormatter.WriteProgram(Reko.Core.Program program) -> void
Reko.Core.Output.JsonFormatter
Reko.Core.Output.JsonFormatter.Flush() -> void
Reko.Core.Output.JsonFormatter.JsonFormatter(System.IO.TextWriter w) -> void
Reko.Core.Output.JsonFormatter.VisitAssignment(Reko.Core.Code.Assignment ass) -> void
Reko.Core.Output.JsonFormatter.VisitBranch(Reko.Core.Code.Branch branch) -> void
Reko.Core.Output.JsonFormatter.VisitCallInstruction(Reko.Core.Code.CallInstruction ci) -> void
Reko.Core.Output.JsonFormatter.VisitComment(Reko.Core.Code.CodeComment comment) -> void
Reko.Core.Output.JsonFormatter.VisitDeclaration(Reko.Core.Code.Declaration decl) -> void
Reko.Core.Output.JsonFormatter.VisitDefInstruction(Reko.Core.Code.DefInstruction def) -> void
Reko.Core.Output.JsonFormatter.VisitGotoInstruction(Reko.Core.Code.GotoInstruction g) -> void
Reko.Core.Output.JsonFormatter.VisitPhiAssignment(Reko.Core.Code.PhiAssignment phi) -> void
Reko.Core.Output.JsonFormatter.VisitReturnInstruction(Reko.Core.Code.ReturnInstruction ret) -> void
Reko.Core.Output.JsonFormatter.VisitSideEffect(Reko.Core.Code.SideEffect side) -> void
Reko.Core.Output.JsonFormatter.VisitStore(Reko.Core.Code.Store store) -> void
Reko.Core.Output.JsonFormatter.VisitSwitchInstruction(Reko.Core.Code.SwitchInstruction si) -> void
Reko.Core.Output.JsonFormatter.VisitUseInstruction(Reko.Core.Code.UseInstruction use) -> void
Reko.Core.Output.JsonFormatter.WriteProcedure(System.Collections.Generic.KeyValuePair<Reko.Core.Address, Reko.Core.Procedure> de) -> void
Reko.Core.Output.JsonFormatter.WriteProgram(Reko.Core.Program program) -> void
Reko.Core.Output.JsonWriter
Reko.Core.Output.JsonWriter.Flush() -> void
Reko.Core.Output.JsonWriter.JsonWriter(System.IO.TextWriter w) -> void
Reko.Core.Output.JsonWriter.Write(string s) -> void
Reko.Core.Output.JsonWriter.WriteEnd() -> void
Reko.Core.Output.JsonWriter.WritePropertyName(string n) -> void
Reko.Core.Output.JsonWriter.WriteStartArray() -> void
Reko.Core.Output.JsonWriter.WriteStartObject() -> void
Reko.Core.Output.LlvmFormatter
Reko.Core.Output.LlvmFormatter.LlvmFormatter(System.IO.TextWriter writer) -> void
Reko.Core.Output.LlvmFormatter.VisitAssignment(Reko.Core.Code.Assignment ass) -> void
Reko.Core.Output.LlvmFormatter.VisitBranch(Reko.Core.Code.Branch branch) -> void
Reko.Core.Output.LlvmFormatter.VisitCallInstruction(Reko.Core.Code.CallInstruction ci) -> void
Reko.Core.Output.LlvmFormatter.VisitComment(Reko.Core.Code.CodeComment comment) -> void
Reko.Core.Output.LlvmFormatter.VisitDeclaration(Reko.Core.Code.Declaration decl) -> void
Reko.Core.Output.LlvmFormatter.VisitDefInstruction(Reko.Core.Code.DefInstruction def) -> void
Reko.Core.Output.LlvmFormatter.VisitGotoInstruction(Reko.Core.Code.GotoInstruction gotoInstruction) -> void
Reko.Core.Output.LlvmFormatter.VisitPhiAssignment(Reko.Core.Code.PhiAssignment phi) -> void
Reko.Core.Output.LlvmFormatter.VisitReturnInstruction(Reko.Core.Code.ReturnInstruction ret) -> void
Reko.Core.Output.LlvmFormatter.VisitSideEffect(Reko.Core.Code.SideEffect side) -> void
Reko.Core.Output.LlvmFormatter.VisitStore(Reko.Core.Code.Store store) -> void
Reko.Core.Output.LlvmFormatter.VisitSwitchInstruction(Reko.Core.Code.SwitchInstruction si) -> void
Reko.Core.Output.LlvmFormatter.VisitUseInstruction(Reko.Core.Code.UseInstruction use) -> void
Reko.Core.Output.LlvmFormatter.Write(Reko.Core.Program program) -> void
Reko.Core.Output.LlvmFormatter.WriteProcedure(Reko.Core.Procedure proc) -> void
Reko.Core.Output.MemoryFormatter
Reko.Core.Output.MemoryFormatter.MemoryFormatter(Reko.Core.Types.PrimitiveType dtChunk, int chunksPerLine, int unitsPerChunk) -> void
Reko.Core.Output.MemoryFormatter.RenderLine(Reko.Core.Memory.EndianImageReader rdr, System.Text.Encoding enc, Reko.Core.Output.IMemoryFormatterOutput output) -> bool
Reko.Core.Output.MemoryFormatter.RenderMemory(Reko.Core.Memory.EndianImageReader rdr, System.Text.Encoding enc, Reko.Core.Output.IMemoryFormatterOutput output) -> void
Reko.Core.Output.MockGenerator
Reko.Core.Output.MockGenerator.MockGenerator(System.IO.TextWriter writer, string prefix) -> void
Reko.Core.Output.MockGenerator.VisitArray(Reko.Core.Types.ArrayType at) -> int
Reko.Core.Output.MockGenerator.VisitClass(Reko.Core.Types.ClassType ct) -> int
Reko.Core.Output.MockGenerator.VisitCode(Reko.Core.Types.CodeType c) -> int
Reko.Core.Output.MockGenerator.VisitEnum(Reko.Core.Types.EnumType e) -> int
Reko.Core.Output.MockGenerator.VisitEquivalenceClass(Reko.Core.Types.EquivalenceClass eq) -> int
Reko.Core.Output.MockGenerator.VisitFunctionType(Reko.Core.Types.FunctionType ft) -> int
Reko.Core.Output.MockGenerator.VisitMemberPointer(Reko.Core.Types.MemberPointer memptr) -> int
Reko.Core.Output.MockGenerator.VisitPointer(Reko.Core.Types.Pointer ptr) -> int
Reko.Core.Output.MockGenerator.VisitPrimitive(Reko.Core.Types.PrimitiveType pt) -> int
Reko.Core.Output.MockGenerator.VisitReference(Reko.Core.Types.ReferenceTo ptr) -> int
Reko.Core.Output.MockGenerator.VisitString(Reko.Core.Types.StringType str) -> int
Reko.Core.Output.MockGenerator.VisitStructure(Reko.Core.Types.StructureType str) -> int
Reko.Core.Output.MockGenerator.VisitTypeReference(Reko.Core.Types.TypeReference typeref) -> int
Reko.Core.Output.MockGenerator.VisitTypeVariable(Reko.Core.Types.TypeVariable tv) -> int
Reko.Core.Output.MockGenerator.VisitUnion(Reko.Core.Types.UnionType ut) -> int
Reko.Core.Output.MockGenerator.VisitUnknownType(Reko.Core.Types.UnknownType ut) -> int
Reko.Core.Output.MockGenerator.VisitVoidType(Reko.Core.Types.VoidType vt) -> int
Reko.Core.Output.MockGenerator.WriteClass(Reko.Core.Procedure proc) -> void
Reko.Core.Output.MockGenerator.WriteMethod(Reko.Core.Procedure proc) -> void
Reko.Core.Output.NullFormatter
Reko.Core.Output.NullFormatter.NullFormatter() -> void
Reko.Core.Output.OutputFilePolicy
Reko.Core.Output.OutputFilePolicy.MakeGlobalWorkItems() -> System.Collections.Generic.IEnumerable<(Reko.Core.Types.StructureField, Reko.Core.Address)>
Reko.Core.Output.OutputFilePolicy.MakeSegmentWorkitems() -> System.Collections.Generic.IEnumerable<(Reko.Core.Types.StructureField, Reko.Core.Address)>
Reko.Core.Output.OutputFilePolicy.OutputFilePolicy(Reko.Core.Program program) -> void
Reko.Core.Output.OutputFilePolicy.PlaceObject(Reko.Core.IAddressable addressable, string filename, System.Collections.Generic.Dictionary<string, System.Collections.Generic.IDictionary<Reko.Core.Address, Reko.Core.IAddressable>> result) -> void
Reko.Core.Output.PrettyPrinter
Reko.Core.Output.PrettyPrinter.BeginGroup() -> void
Reko.Core.Output.PrettyPrinter.Break
Reko.Core.Output.PrettyPrinter.Break.Break(int count, int level, bool connected) -> void
Reko.Core.Output.PrettyPrinter.Break.IsConnected.get -> bool
Reko.Core.Output.PrettyPrinter.Break.Level.get -> int
Reko.Core.Output.PrettyPrinter.Break.TokensEnqueued.get -> int
Reko.Core.Output.PrettyPrinter.ConnectedLineBreak() -> void
Reko.Core.Output.PrettyPrinter.EndGroup() -> void
Reko.Core.Output.PrettyPrinter.Flush() -> void
Reko.Core.Output.PrettyPrinter.ForceLineBreak() -> void
Reko.Core.Output.PrettyPrinter.Indent(int indentWidth) -> void
Reko.Core.Output.PrettyPrinter.OptionalLineBreak() -> void
Reko.Core.Output.PrettyPrinter.Outdent(int indentWidth) -> void
Reko.Core.Output.PrettyPrinter.PrettyPrinter(System.IO.TextWriter writer, int width) -> void
Reko.Core.Output.PrettyPrinter.PrintCharacter(char ch) -> void
Reko.Core.Output.PrettyPrinter.PrintString(string s) -> void
Reko.Core.Output.PrettyPrinterOutput
Reko.Core.Output.PrettyPrinterOutput.Indent(int indentAmount) -> void
Reko.Core.Output.PrettyPrinterOutput.MustSplitLine.get -> bool
Reko.Core.Output.PrettyPrinterOutput.PrettyPrinterOutput(System.IO.TextWriter writer, int width) -> void
Reko.Core.Output.PrettyPrinterOutput.PrintCharacter(char c) -> void
Reko.Core.Output.PrettyPrinterOutput.PrintLine() -> void
Reko.Core.Output.PrettyPrinterOutput.total_pchars_enqueued.get -> int
Reko.Core.Output.PrettyPrinterOutput.total_pchars_enqueued.set -> void
Reko.Core.Output.ProcedureFormatter
Reko.Core.Output.ProcedureFormatter.ProcedureFormatter(Reko.Core.Procedure procedure, Reko.Core.Output.BlockDecorator decorator, Reko.Core.Output.CodeFormatter formatter) -> void
Reko.Core.Output.ProcedureFormatter.ProcedureFormatter(Reko.Core.Procedure procedure, Reko.Core.Output.CodeFormatter formatter) -> void
Reko.Core.Output.ProcedureFormatter.WriteBlock(Reko.Core.Block block, Reko.Core.Output.CodeFormatter writer) -> void
Reko.Core.Output.ProcedureFormatter.WriteProcedureBlocks() -> void
Reko.Core.Output.SegmentFilePolicy
Reko.Core.Output.SegmentFilePolicy.SegmentFilePolicy(Reko.Core.Program program) -> void
Reko.Core.Output.SingleFilePolicy
Reko.Core.Output.SingleFilePolicy.SingleFilePolicy(Reko.Core.Program program) -> void
Reko.Core.Output.TextFormatter
Reko.Core.Output.TextFormatter.Terminator.get -> string
Reko.Core.Output.TextFormatter.Terminator.set -> void
Reko.Core.Output.TextFormatter.TextFormatter(System.IO.TextWriter writer) -> void
Reko.Core.Output.TextFormatter.TextWriter.get -> System.IO.TextWriter
Reko.Core.Output.TypedDataDumper
Reko.Core.Output.TypedDataDumper.TypedDataDumper(Reko.Core.Memory.EndianImageReader rdr, uint cbSize, Reko.Core.Output.Formatter stm) -> void
Reko.Core.Output.TypedDataDumper.VisitArray(Reko.Core.Types.ArrayType at) -> void
Reko.Core.Output.TypedDataDumper.VisitClass(Reko.Core.Types.ClassType ct) -> void
Reko.Core.Output.TypedDataDumper.VisitCode(Reko.Core.Types.CodeType c) -> void
Reko.Core.Output.TypedDataDumper.VisitEnum(Reko.Core.Types.EnumType e) -> void
Reko.Core.Output.TypedDataDumper.VisitEquivalenceClass(Reko.Core.Types.EquivalenceClass eq) -> void
Reko.Core.Output.TypedDataDumper.VisitFunctionType(Reko.Core.Types.FunctionType ft) -> void
Reko.Core.Output.TypedDataDumper.VisitMemberPointer(Reko.Core.Types.MemberPointer memptr) -> void
Reko.Core.Output.TypedDataDumper.VisitPointer(Reko.Core.Types.Pointer ptr) -> void
Reko.Core.Output.TypedDataDumper.VisitPrimitive(Reko.Core.Types.PrimitiveType pt) -> void
Reko.Core.Output.TypedDataDumper.VisitReference(Reko.Core.Types.ReferenceTo refTo) -> void
Reko.Core.Output.TypedDataDumper.VisitString(Reko.Core.Types.StringType str) -> void
Reko.Core.Output.TypedDataDumper.VisitStructure(Reko.Core.Types.StructureType str) -> void
Reko.Core.Output.TypedDataDumper.VisitTypeReference(Reko.Core.Types.TypeReference typeref) -> void
Reko.Core.Output.TypedDataDumper.VisitTypeVariable(Reko.Core.Types.TypeVariable tv) -> void
Reko.Core.Output.TypedDataDumper.VisitUnion(Reko.Core.Types.UnionType ut) -> void
Reko.Core.Output.TypedDataDumper.VisitUnknownType(Reko.Core.Types.UnknownType ut) -> void
Reko.Core.Output.TypedDataDumper.VisitVoidType(Reko.Core.Types.VoidType voidType) -> void
Reko.Core.Output.TypeFormatter
Reko.Core.Output.TypeFormatter.BeginLine() -> void
Reko.Core.Output.TypeFormatter.BeginLine(string s) -> void
Reko.Core.Output.TypeFormatter.CloseBrace() -> void
Reko.Core.Output.TypeFormatter.EndLine() -> void
Reko.Core.Output.TypeFormatter.EndLine(string terminator) -> void
Reko.Core.Output.TypeFormatter.EndLine(string terminator, string comment) -> void
Reko.Core.Output.TypeFormatter.LineEndComment(string comment) -> void
Reko.Core.Output.TypeFormatter.Mode
Reko.Core.Output.TypeFormatter.Mode.Scanning = 1 -> Reko.Core.Output.TypeFormatter.Mode
Reko.Core.Output.TypeFormatter.Mode.Writing = 0 -> Reko.Core.Output.TypeFormatter.Mode
Reko.Core.Output.TypeFormatter.OpenBrace() -> void
Reko.Core.Output.TypeFormatter.OpenBrace(string trailingComment) -> void
Reko.Core.Output.TypeFormatter.ScanFields(Reko.Core.Types.ClassType ct) -> void
Reko.Core.Output.TypeFormatter.ScanFields(Reko.Core.Types.StructureType str) -> void
Reko.Core.Output.TypeFormatter.ScanMethods(Reko.Core.Types.ClassType ct) -> void
Reko.Core.Output.TypeFormatter.TypeFormatter(Reko.Core.Output.Formatter writer) -> void
Reko.Core.Output.TypeFormatter.VisitArray(Reko.Core.Types.ArrayType at) -> Reko.Core.Output.Formatter
Reko.Core.Output.TypeFormatter.VisitClass(Reko.Core.Types.ClassType ct) -> Reko.Core.Output.Formatter
Reko.Core.Output.TypeFormatter.VisitCode(Reko.Core.Types.CodeType c) -> Reko.Core.Output.Formatter
Reko.Core.Output.TypeFormatter.VisitEnum(Reko.Core.Types.EnumType e) -> Reko.Core.Output.Formatter
Reko.Core.Output.TypeFormatter.VisitEquivalenceClass(Reko.Core.Types.EquivalenceClass eq) -> Reko.Core.Output.Formatter
Reko.Core.Output.TypeFormatter.VisitFunctionType(Reko.Core.Types.FunctionType ft) -> Reko.Core.Output.Formatter
Reko.Core.Output.TypeFormatter.VisitMemberPointer(Reko.Core.Types.MemberPointer memptr) -> Reko.Core.Output.Formatter
Reko.Core.Output.TypeFormatter.VisitPointer(Reko.Core.Types.Pointer pt) -> Reko.Core.Output.Formatter
Reko.Core.Output.TypeFormatter.VisitPrimitive(Reko.Core.Types.PrimitiveType pt) -> Reko.Core.Output.Formatter
Reko.Core.Output.TypeFormatter.VisitReference(Reko.Core.Types.ReferenceTo refTo) -> Reko.Core.Output.Formatter
Reko.Core.Output.TypeFormatter.VisitString(Reko.Core.Types.StringType str) -> Reko.Core.Output.Formatter
Reko.Core.Output.TypeFormatter.VisitStructure(Reko.Core.Types.StructureType str) -> Reko.Core.Output.Formatter
Reko.Core.Output.TypeFormatter.VisitTypeReference(Reko.Core.Types.TypeReference typeref) -> Reko.Core.Output.Formatter
Reko.Core.Output.TypeFormatter.VisitTypeVariable(Reko.Core.Types.TypeVariable t) -> Reko.Core.Output.Formatter
Reko.Core.Output.TypeFormatter.VisitUnion(Reko.Core.Types.UnionType ut) -> Reko.Core.Output.Formatter
Reko.Core.Output.TypeFormatter.VisitUnknownType(Reko.Core.Types.UnknownType ut) -> Reko.Core.Output.Formatter
Reko.Core.Output.TypeFormatter.VisitVoidType(Reko.Core.Types.VoidType vt) -> Reko.Core.Output.Formatter
Reko.Core.Output.TypeFormatter.Write(Reko.Core.Types.DataType dt, string name) -> void
Reko.Core.Output.TypeFormatter.WriteTypes(System.Collections.Generic.IEnumerable<Reko.Core.Types.DataType> datatypes) -> void
Reko.Core.Output.TypeReferenceFormatter
Reko.Core.Output.TypeReferenceFormatter.Formatter.get -> Reko.Core.Output.Formatter
Reko.Core.Output.TypeReferenceFormatter.TypeReferenceFormatter(Reko.Core.Output.Formatter writer) -> void
Reko.Core.Output.TypeReferenceFormatter.WriteDeclaration(Reko.Core.Types.DataType dt, string name) -> void
Reko.Core.Output.TypeReferenceFormatter.WriteTypeReference(Reko.Core.Types.DataType dt) -> void
Reko.Core.Platform
Reko.Core.Platform.Architecture.get -> Reko.Core.IProcessorArchitecture
Reko.Core.Platform.CharacteristicsLibs.get -> Reko.Core.CharacteristicsLibrary[]
Reko.Core.Platform.CharacteristicsLibs.set -> void
Reko.Core.Platform.CreateMetadata() -> Reko.Core.TypeLibrary!
Reko.Core.Platform.CreatePointerScanner(Reko.Core.SegmentMap! segmentMap, Reko.Core.Memory.EndianImageReader! rdr, System.Collections.Generic.IEnumerable<Reko.Core.Address!>! address, Reko.Core.PointerScannerFlags pointerScannerFlags) -> System.Collections.Generic.IEnumerable<Reko.Core.Address!>!
Reko.Core.Platform.Description.get -> string
Reko.Core.Platform.Description.set -> void
Reko.Core.Platform.Heuristics.get -> Reko.Core.PlatformHeuristics
Reko.Core.Platform.Heuristics.set -> void
Reko.Core.Platform.Name.get -> string
Reko.Core.Platform.Name.set -> void
Reko.Core.Platform.Platform(System.IServiceProvider services, Reko.Core.IProcessorArchitecture arch, string platformId) -> void
Reko.Core.Platform.PlatformIdentifier.get -> string
Reko.Core.Platform.PlatformProcedures.get -> System.Collections.Generic.Dictionary<Reko.Core.Address, Reko.Core.ExternalProcedure>
Reko.Core.Platform.PlatformProcedures.set -> void
Reko.Core.Platform.Services.get -> System.IServiceProvider
Reko.Core.Platform.StructureMemberAlignment.get -> int
Reko.Core.Platform.StructureMemberAlignment.set -> void
Reko.Core.PlatformHeuristics
Reko.Core.PlatformHeuristics.PlatformHeuristics() -> void
Reko.Core.PlatformHeuristics.ProcedurePrologs -> Reko.Core.MaskedPattern![]?
Reko.Core.PointerScanner<T>
Reko.Core.PointerScanner<T>.GetEnumerator() -> System.Collections.Generic.IEnumerator<T>
Reko.Core.PointerScanner<T>.PointerScanner(Reko.Core.Memory.EndianImageReader rdr, System.Collections.Generic.HashSet<T> knownLinAddresses, Reko.Core.PointerScannerFlags flags) -> void
Reko.Core.PointerScannerFlags
Reko.Core.PointerScannerFlags.All = Reko.Core.PointerScannerFlags.Pointers | Reko.Core.PointerScannerFlags.Calls | Reko.Core.PointerScannerFlags.Jumps -> Reko.Core.PointerScannerFlags
Reko.Core.PointerScannerFlags.Calls = 2 -> Reko.Core.PointerScannerFlags
Reko.Core.PointerScannerFlags.Jumps = 4 -> Reko.Core.PointerScannerFlags
Reko.Core.PointerScannerFlags.Pointers = 1 -> Reko.Core.PointerScannerFlags
Reko.Core.Procedure
Reko.Core.Procedure.AddBlock(Reko.Core.Address addr, string name) -> Reko.Core.Block
Reko.Core.Procedure.AddBlock(Reko.Core.Block block) -> void
Reko.Core.Procedure.AddSyntheticBlock(Reko.Core.Address addr, string name) -> Reko.Core.Block
Reko.Core.Procedure.Architecture.get -> Reko.Core.IProcessorArchitecture
Reko.Core.Procedure.BlockComparer
Reko.Core.Procedure.BlockComparer.BlockComparer() -> void
Reko.Core.Procedure.BlockComparer.Compare(Reko.Core.Block x, Reko.Core.Block y) -> int
Reko.Core.Procedure.Body.get -> System.Collections.Generic.List<Reko.Core.Absyn.AbsynStatement>
Reko.Core.Procedure.Body.set -> void
Reko.Core.Procedure.ControlGraph.get -> Reko.Core.Graphs.BlockGraph
Reko.Core.Procedure.CreateBlockDominatorGraph() -> Reko.Core.Graphs.BlockDominatorGraph
Reko.Core.Procedure.CreateCodeFormatter(Reko.Core.Output.Formatter formatter) -> Reko.Core.Output.CodeFormatter
Reko.Core.Procedure.Dump(bool dump) -> void
Reko.Core.Procedure.EntryAddress.get -> Reko.Core.Address
Reko.Core.Procedure.EntryBlock.get -> Reko.Core.Block
Reko.Core.Procedure.ExitBlock.get -> Reko.Core.Block
Reko.Core.Procedure.Frame.get -> Reko.Core.Frame
Reko.Core.Procedure.Procedure(Reko.Core.IProcessorArchitecture arch, string name, Reko.Core.Address addrEntry, Reko.Core.Frame frame) -> void
Reko.Core.Procedure.QualifiedName() -> string
Reko.Core.Procedure.RemoveBlock(Reko.Core.Block block) -> void
Reko.Core.Procedure.SortBlocksByName() -> System.Linq.IOrderedEnumerable<Reko.Core.Block>
Reko.Core.Procedure.Statements.get -> System.Collections.Generic.IEnumerable<Reko.Core.Statement>
Reko.Core.Procedure.UserSpecified.get -> bool
Reko.Core.Procedure.UserSpecified.set -> void
Reko.Core.Procedure.Write(bool emitFrame, bool showEdges, bool lowLevelInfo, System.IO.TextWriter writer) -> void
Reko.Core.Procedure.Write(bool emitFrame, Reko.Core.Output.BlockDecorator decorator, System.IO.TextWriter writer) -> void
Reko.Core.Procedure.Write(bool emitFrame, System.IO.TextWriter writer) -> void
Reko.Core.Procedure.WriteBody(bool showEdges, System.IO.TextWriter writer) -> void
Reko.Core.Procedure.WriteGraph(System.IO.TextWriter writer) -> void
Reko.Core.ProcedureBase
Reko.Core.ProcedureBase.Characteristics.get -> Reko.Core.Serialization.ProcedureCharacteristics
Reko.Core.ProcedureBase.Characteristics.set -> void
Reko.Core.ProcedureBase.EnclosingType.get -> Reko.Core.Serialization.SerializedType
Reko.Core.ProcedureBase.EnclosingType.set -> void
Reko.Core.ProcedureBase.GetGenericArguments() -> Reko.Core.Types.DataType[]
Reko.Core.ProcedureBase.HasSideEffect.get -> bool
Reko.Core.ProcedureBase.IsConcreteGeneric.get -> bool
Reko.Core.ProcedureBase.IsGeneric.get -> bool
Reko.Core.ProcedureBase.MakeConcreteSignature(int ptrSize, Reko.Core.Types.DataType[] concreteTypes) -> Reko.Core.Types.FunctionType
Reko.Core.ProcedureBase.Name.get -> string!
Reko.Core.ProcedureBase.Name.set -> void
Reko.Core.ProcedureBase.NameChanged -> System.EventHandler?
Reko.Core.ProcedureBase.ProcedureBase(string name, bool hasSideEffect) -> void
Reko.Core.ProcedureBase.ProcedureBase(string name, Reko.Core.Types.DataType[] genericArguments, bool isConcrete, bool hasSideEffect) -> void
Reko.Core.ProcessorArchitecture
Reko.Core.ProcessorArchitecture.CarryFlagMask.get -> uint
Reko.Core.ProcessorArchitecture.CarryFlagMask.set -> void
Reko.Core.ProcessorArchitecture.CreateFrame() -> Reko.Core.Frame
Reko.Core.ProcessorArchitecture.CreateImageReader(Reko.Core.Memory.MemoryArea mem, long off) -> Reko.Core.Memory.EndianImageReader
Reko.Core.ProcessorArchitecture.CreateImageReader(Reko.Core.Memory.MemoryArea mem, long offsetBegin, long offsetEnd) -> Reko.Core.Memory.EndianImageReader
Reko.Core.ProcessorArchitecture.CreateImageReader(Reko.Core.Memory.MemoryArea mem, Reko.Core.Address addr) -> Reko.Core.Memory.EndianImageReader
Reko.Core.ProcessorArchitecture.CreateImageReader(Reko.Core.Memory.MemoryArea mem, Reko.Core.Address addr, long cbUnits) -> Reko.Core.Memory.EndianImageReader
Reko.Core.ProcessorArchitecture.CreateImageWriter() -> Reko.Core.Memory.ImageWriter
Reko.Core.ProcessorArchitecture.CreateImageWriter(Reko.Core.Memory.MemoryArea mem, Reko.Core.Address addr) -> Reko.Core.Memory.ImageWriter
Reko.Core.ProcessorArchitecture.DefaultBase.get -> int
Reko.Core.ProcessorArchitecture.DefaultBase.set -> void
Reko.Core.ProcessorArchitecture.Description.get -> string
Reko.Core.ProcessorArchitecture.Description.set -> void
Reko.Core.ProcessorArchitecture.Endianness.get -> Reko.Core.EndianServices
Reko.Core.ProcessorArchitecture.Endianness.set -> void
Reko.Core.ProcessorArchitecture.FpuStackRegister.get -> Reko.Core.RegisterStorage
Reko.Core.ProcessorArchitecture.FpuStackRegister.set -> void
Reko.Core.ProcessorArchitecture.FramePointerType.get -> Reko.Core.Types.PrimitiveType
Reko.Core.ProcessorArchitecture.FramePointerType.set -> void
Reko.Core.ProcessorArchitecture.InstructionBitSize.get -> int
Reko.Core.ProcessorArchitecture.InstructionBitSize.set -> void
Reko.Core.ProcessorArchitecture.MemoryGranularity.get -> int
Reko.Core.ProcessorArchitecture.MemoryGranularity.set -> void
Reko.Core.ProcessorArchitecture.Name.get -> string
Reko.Core.ProcessorArchitecture.Options.get -> System.Collections.Generic.Dictionary<string, object>
Reko.Core.ProcessorArchitecture.Options.set -> void
Reko.Core.ProcessorArchitecture.PointerType.get -> Reko.Core.Types.PrimitiveType
Reko.Core.ProcessorArchitecture.PointerType.set -> void
Reko.Core.ProcessorArchitecture.ProcessorArchitecture(System.IServiceProvider services, string archId, System.Collections.Generic.Dictionary<string, object> options) -> void
Reko.Core.ProcessorArchitecture.Services.get -> System.IServiceProvider
Reko.Core.ProcessorArchitecture.StackRegister.get -> Reko.Core.RegisterStorage
Reko.Core.ProcessorArchitecture.StackRegister.set -> void
Reko.Core.ProcessorArchitecture.TryRead(Reko.Core.Memory.MemoryArea mem, Reko.Core.Address addr, Reko.Core.Types.PrimitiveType dt, out Reko.Core.Expressions.Constant value) -> bool
Reko.Core.ProcessorArchitecture.WordWidth.get -> Reko.Core.Types.PrimitiveType
Reko.Core.ProcessorArchitecture.WordWidth.set -> void
Reko.Core.ProcessorOption
Reko.Core.ProcessorState
Reko.Core.ProcessorState.Endianness.get -> Reko.Core.EndianServices
Reko.Core.ProcessorState.ErrorListener.get -> System.Action<string>
Reko.Core.ProcessorState.ErrorListener.set -> void
Reko.Core.ProcessorState.GetDefiningExpression(Reko.Core.Expressions.Identifier id) -> Reko.Core.Expressions.Expression
Reko.Core.ProcessorState.GetDefiningStatementClosure(Reko.Core.Expressions.Identifier id) -> System.Collections.Generic.List<Reko.Core.Statement>
Reko.Core.ProcessorState.GetMemoryValue(Reko.Core.Address addr, Reko.Core.Types.DataType dt, Reko.Core.SegmentMap segmentMap) -> Reko.Core.Expressions.Expression
Reko.Core.ProcessorState.GetStackValue(int offset) -> Reko.Core.Expressions.Expression
Reko.Core.ProcessorState.GetValue(Reko.Core.Expressions.Application appl) -> Reko.Core.Expressions.Expression
Reko.Core.ProcessorState.GetValue(Reko.Core.Expressions.Identifier id) -> Reko.Core.Expressions.Expression
Reko.Core.ProcessorState.GetValue(Reko.Core.Expressions.MemoryAccess access, Reko.Core.SegmentMap segmentMap) -> Reko.Core.Expressions.Expression
Reko.Core.ProcessorState.GetValue(Reko.Core.Expressions.SegmentedAccess access, Reko.Core.SegmentMap segmentMap) -> Reko.Core.Expressions.Expression
Reko.Core.ProcessorState.GetValue(Reko.Core.RegisterStorage reg) -> Reko.Core.Expressions.Expression
Reko.Core.ProcessorState.IsUsedInPhi(Reko.Core.Expressions.Identifier id) -> bool
Reko.Core.ProcessorState.MakeSegmentedAddress(Reko.Core.Expressions.Constant seg, Reko.Core.Expressions.Constant off) -> Reko.Core.Expressions.Expression
Reko.Core.ProcessorState.MemoryGranularity.get -> int
Reko.Core.ProcessorState.ProcessorState() -> void
Reko.Core.ProcessorState.ProcessorState(Reko.Core.ProcessorState orig) -> void
Reko.Core.ProcessorState.ReinterpretAsFloat(Reko.Core.Expressions.Constant rawBits) -> Reko.Core.Expressions.Constant
Reko.Core.ProcessorState.RemoveExpressionUse(Reko.Core.Expressions.Expression expr) -> void
Reko.Core.ProcessorState.RemoveIdentifierUse(Reko.Core.Expressions.Identifier id) -> void
Reko.Core.ProcessorState.SetValue(Reko.Core.Expressions.Identifier id, Reko.Core.Expressions.Expression value) -> void
Reko.Core.ProcessorState.SetValue(Reko.Core.RegisterStorage reg, Reko.Core.Expressions.Expression value) -> Reko.Core.Expressions.Constant
Reko.Core.ProcessorState.SetValueEa(Reko.Core.Expressions.Expression basePtr, Reko.Core.Expressions.Expression ea, Reko.Core.Expressions.Expression value) -> void
Reko.Core.ProcessorState.SetValueEa(Reko.Core.Expressions.Expression ea, Reko.Core.Expressions.Expression value) -> void
Reko.Core.ProcessorState.UseExpression(Reko.Core.Expressions.Expression expr) -> void
Reko.Core.Program
Reko.Core.Program.Accept<T, C>(Reko.Core.Loading.ILoadedImageVisitor<T, C> visitor, C context) -> T
Reko.Core.Program.AddUserGlobalItem(Reko.Core.IProcessorArchitecture arch, Reko.Core.Address address, Reko.Core.Types.DataType dataType) -> Reko.Core.ImageMapItem
Reko.Core.Program.Architecture.get -> Reko.Core.IProcessorArchitecture
Reko.Core.Program.Architecture.set -> void
Reko.Core.Program.Architectures.get -> System.Collections.Generic.Dictionary<string, Reko.Core.IProcessorArchitecture>
Reko.Core.Program.BuildImageMap() -> void
Reko.Core.Program.CallGraph.get -> Reko.Core.CallGraph
Reko.Core.Program.CreateDisassembler(Reko.Core.IProcessorArchitecture arch, Reko.Core.Address addr) -> System.Collections.Generic.IEnumerable<Reko.Core.Machine.MachineInstruction>
Reko.Core.Program.CreateImageReader(Reko.Core.Address addr) -> Reko.Core.Memory.EndianImageReader
Reko.Core.Program.CreateImageReader(Reko.Core.Address addrBegin, Reko.Core.Address addrEnd) -> Reko.Core.Memory.EndianImageReader
Reko.Core.Program.CreateImageReader(Reko.Core.IProcessorArchitecture arch, Reko.Core.Address addr) -> Reko.Core.Memory.EndianImageReader
Reko.Core.Program.CreateImageReader(Reko.Core.IProcessorArchitecture arch, Reko.Core.Address addrBegin, Reko.Core.Address addrEnd) -> Reko.Core.Memory.EndianImageReader
Reko.Core.Program.CreateImageWriter(Reko.Core.IProcessorArchitecture arch, Reko.Core.Address addr) -> Reko.Core.Memory.ImageWriter
Reko.Core.Program.CreateProcedureSerializer() -> Reko.Core.Serialization.ProcedureSerializer
Reko.Core.Program.CreateTypeLibraryDeserializer() -> Reko.Core.TypeLibraryDeserializer
Reko.Core.Program.DebugProcedureRange.get -> (int, int)
Reko.Core.Program.DebugProcedureRange.set -> void
Reko.Core.Program.DisassemblyDirectory.get -> string
Reko.Core.Program.DisassemblyDirectory.set -> void
Reko.Core.Program.EnsureArchitecture(string archLabel, System.Func<string, Reko.Core.IProcessorArchitecture> getter) -> Reko.Core.IProcessorArchitecture
Reko.Core.Program.EnsureDirectoryNames(Reko.Core.ImageLocation imageLocation) -> void
Reko.Core.Program.EnsureIntrinsicProcedure(string name, bool hasSideEffect, Reko.Core.Types.DataType returnType, params Reko.Core.Expressions.Expression[] args) -> Reko.Core.IntrinsicProcedure
Reko.Core.Program.EnsureIntrinsicProcedure(string name, bool isIdempotent, Reko.Core.Types.FunctionType sig) -> Reko.Core.IntrinsicProcedure
Reko.Core.Program.EnsureProcedure(Reko.Core.IProcessorArchitecture arch, Reko.Core.Address addr, string procedureName) -> Reko.Core.Procedure
Reko.Core.Program.EnsureUserProcedure(Reko.Core.Address address, string name, bool decompile = true) -> Reko.Core.UserProcedure
Reko.Core.Program.EntryPoints.get -> System.Collections.Generic.SortedList<Reko.Core.Address, Reko.Core.ImageSymbol>
Reko.Core.Program.EntryPoints.set -> void
Reko.Core.Program.EnvironmentMetadata.get -> Reko.Core.TypeLibrary
Reko.Core.Program.EnvironmentMetadata.set -> void
Reko.Core.Program.GetDataSize(Reko.Core.IProcessorArchitecture arch, Reko.Core.Address addr, Reko.Core.Types.DataType dt) -> uint
Reko.Core.Program.GetItemsBySegment() -> System.Collections.Generic.Dictionary<Reko.Core.ImageSegment, System.Collections.Generic.List<Reko.Core.ImageMapItem>>
Reko.Core.Program.GlobalFields.get -> Reko.Core.Types.StructureType
Reko.Core.Program.GlobalRegister.get -> Reko.Core.RegisterStorage
Reko.Core.Program.GlobalRegister.set -> void
Reko.Core.Program.GlobalRegisterValue.get -> Reko.Core.Expressions.Constant
Reko.Core.Program.GlobalRegisterValue.set -> void
Reko.Core.Program.Globals.get -> Reko.Core.Expressions.Identifier
Reko.Core.Program.ImageMap.get -> Reko.Core.ImageMap
Reko.Core.Program.ImageMap.set -> void
Reko.Core.Program.ImageSymbols.get -> System.Collections.Generic.SortedList<Reko.Core.Address, Reko.Core.ImageSymbol>
Reko.Core.Program.ImportReferences.get -> System.Collections.Generic.Dictionary<Reko.Core.Address, Reko.Core.ImportReference>
Reko.Core.Program.IncludeDirectory.get -> string
Reko.Core.Program.IncludeDirectory.set -> void
Reko.Core.Program.InductionVariables.get -> System.Collections.Generic.Dictionary<Reko.Core.Expressions.Identifier, Reko.Core.LinearInductionVariable>
Reko.Core.Program.InterceptedCalls.get -> System.Collections.Generic.Dictionary<Reko.Core.Address, Reko.Core.ExternalProcedure>
Reko.Core.Program.Intrinsics.get -> System.Collections.Generic.Dictionary<string, System.Collections.Generic.Dictionary<Reko.Core.Types.FunctionType, Reko.Core.IntrinsicProcedure>>
Reko.Core.Program.Location.get -> Reko.Core.ImageLocation
Reko.Core.Program.Location.set -> void
Reko.Core.Program.ModifyUserGlobal(Reko.Core.IProcessorArchitecture arch, Reko.Core.Address address, Reko.Core.Serialization.SerializedType dataType, string name) -> Reko.Core.UserGlobal
Reko.Core.Program.Name.get -> string
Reko.Core.Program.Name.set -> void
Reko.Core.Program.NamingPolicy.get -> Reko.Core.NamingPolicy
Reko.Core.Program.NamingPolicy.set -> void
Reko.Core.Program.NeedsScanning.get -> bool
Reko.Core.Program.NeedsScanning.set -> void
Reko.Core.Program.NeedsSsaTransform.get -> bool
Reko.Core.Program.NeedsSsaTransform.set -> void
Reko.Core.Program.NeedsTypeReconstruction.get -> bool
Reko.Core.Program.NeedsTypeReconstruction.set -> void
Reko.Core.Program.Platform.get -> Reko.Core.IPlatform
Reko.Core.Program.Platform.set -> void
Reko.Core.Program.Procedures.get -> Reko.Core.Collections.BTreeDictionary<Reko.Core.Address, Reko.Core.Procedure>
Reko.Core.Program.Program() -> void
Reko.Core.Program.Program(Reko.Core.SegmentMap segmentMap, Reko.Core.IProcessorArchitecture arch, Reko.Core.IPlatform platform) -> void
Reko.Core.Program.Program(Reko.Core.SegmentMap segmentMap, Reko.Core.IProcessorArchitecture arch, Reko.Core.IPlatform platform, System.Collections.Generic.SortedList<Reko.Core.Address, Reko.Core.ImageSymbol> symbols, System.Collections.Generic.SortedList<Reko.Core.Address, Reko.Core.ImageSymbol> entryPoints) -> void
Reko.Core.Program.PropertyChanged -> System.ComponentModel.PropertyChangedEventHandler
Reko.Core.Program.RemoveUserGlobal(Reko.Core.Address address) -> void
Reko.Core.Program.Reset() -> void
Reko.Core.Program.Resources.get -> System.Collections.Generic.List<Reko.Core.ProgramResource>
Reko.Core.Program.ResourcesDirectory.get -> string
Reko.Core.Program.ResourcesDirectory.set -> void
Reko.Core.Program.SegmentMap.get -> Reko.Core.SegmentMap
Reko.Core.Program.SegmentMap.set -> void
Reko.Core.Program.SourceDirectory.get -> string
Reko.Core.Program.SourceDirectory.set -> void
Reko.Core.Program.TextEncoding.get -> System.Text.Encoding
Reko.Core.Program.TypeFactory.get -> Reko.Core.Types.TypeFactory
Reko.Core.Program.TypeStore.get -> Reko.Core.Types.TypeStore
Reko.Core.Program.User.get -> Reko.Core.UserData
Reko.Core.Program.User.set -> void
Reko.Core.ProgramAddress
Reko.Core.ProgramAddress.ProgramAddress(Reko.Core.Program program, Reko.Core.Address addr) -> void
Reko.Core.ProgramResource
Reko.Core.ProgramResource.Name.get -> string
Reko.Core.ProgramResource.Name.set -> void
Reko.Core.ProgramResource.ProgramResource() -> void
Reko.Core.ProgramResourceGroup
Reko.Core.ProgramResourceGroup.ProgramResourceGroup() -> void
Reko.Core.ProgramResourceGroup.Resources.get -> System.Collections.Generic.List<Reko.Core.ProgramResource>
Reko.Core.ProgramResourceInstance
Reko.Core.ProgramResourceInstance.Bytes.get -> byte[]
Reko.Core.ProgramResourceInstance.Bytes.set -> void
Reko.Core.ProgramResourceInstance.FileExtension.get -> string
Reko.Core.ProgramResourceInstance.FileExtension.set -> void
Reko.Core.ProgramResourceInstance.ProgramResourceInstance() -> void
Reko.Core.ProgramResourceInstance.TextEncoding.get -> string
Reko.Core.ProgramResourceInstance.TextEncoding.set -> void
Reko.Core.ProgramResourceInstance.Type.get -> string
Reko.Core.ProgramResourceInstance.Type.set -> void
Reko.Core.Project
Reko.Core.Project.Accept<T, C>(Reko.Core.Loading.ILoadedImageVisitor<T, C> visitor, C context) -> T
Reko.Core.Project.AddProgram(Reko.Core.ImageLocation programLocation, Reko.Core.Program program) -> void
Reko.Core.Project.FireScriptEvent(Reko.Core.Scripts.ScriptEvent event) -> void
Reko.Core.Project.LoadedMetadata.get -> Reko.Core.TypeLibrary
Reko.Core.Project.LoadedMetadata.set -> void
Reko.Core.Project.Location.get -> Reko.Core.ImageLocation
Reko.Core.Project.MetadataFiles.get -> Reko.Core.Collections.ObservableRangeCollection<Reko.Core.MetadataFile>
Reko.Core.Project.Programs.get -> Reko.Core.Collections.ObservableRangeCollection<Reko.Core.Program>
Reko.Core.Project.Project() -> void
Reko.Core.Project.Project(Reko.Core.ImageLocation location) -> void
Reko.Core.Project.ScriptFiles.get -> Reko.Core.Collections.ConcurrentObservableCollection<Reko.Core.Scripts.ScriptFile>
Reko.Core.ProjectFile
Reko.Core.ProjectFile.Location.get -> Reko.Core.ImageLocation
Reko.Core.ProjectFile.Location.set -> void
Reko.Core.ProjectFile.ProjectFile() -> void
Reko.Core.ProtectedSegmentedAddress
Reko.Core.ProtectedSegmentedAddress.ProtectedSegmentedAddress(ushort segment, ushort offset) -> void
Reko.Core.Provenance
Reko.Core.Provenance.Comment -> string
Reko.Core.Provenance.Provenance() -> void
Reko.Core.Provenance.ProvenanceType -> Reko.Core.ProvenanceType
Reko.Core.Provenance<T>
Reko.Core.Provenance<T>.Provenance(T from) -> void
Reko.Core.ProvenanceType
Reko.Core.ProvenanceType.Environment = 2 -> Reko.Core.ProvenanceType
Reko.Core.ProvenanceType.Heuristic = 5 -> Reko.Core.ProvenanceType
Reko.Core.ProvenanceType.Image = 1 -> Reko.Core.ProvenanceType
Reko.Core.ProvenanceType.None = 0 -> Reko.Core.ProvenanceType
Reko.Core.ProvenanceType.Scanning = 4 -> Reko.Core.ProvenanceType
Reko.Core.ProvenanceType.UserInput = 3 -> Reko.Core.ProvenanceType
Reko.Core.ReaderContext
Reko.Core.ReaderContext.GetValue(string valueName) -> object
Reko.Core.ReaderContext.ReaderContext(object obj, System.Reflection.FieldInfo[] fields) -> void
Reko.Core.RealSegmentedAddress
Reko.Core.RealSegmentedAddress.RealSegmentedAddress(ushort segment, ushort offset) -> void
Reko.Core.RegisterStorage
Reko.Core.RegisterStorage.BitMask.get -> ulong
Reko.Core.RegisterStorage.CompareTo(Reko.Core.RegisterStorage that) -> int
Reko.Core.RegisterStorage.DataType.get -> Reko.Core.Types.PrimitiveType
Reko.Core.RegisterStorage.GetSlice(Reko.Core.Expressions.Expression value) -> Reko.Core.Expressions.Expression
Reko.Core.RegisterStorage.IsSubRegisterOf(Reko.Core.RegisterStorage reg2) -> bool
Reko.Core.RegisterStorage.IsSystemRegister.get -> bool
Reko.Core.RegisterStorage.Number.get -> int
Reko.Core.RegisterStorage.RegisterStorage(string regName, int number, uint bitAddress, Reko.Core.Types.PrimitiveType dataType) -> void
Reko.Core.RegisterStorage.SubregisterOffset(Reko.Core.RegisterStorage subReg) -> int
Reko.Core.RegisterStorage.Width.get -> Reko.Core.Types.DataType
Reko.Core.RegisterStorage.Width.set -> void
Reko.Core.RegValue
Reko.Core.RegValue.Register -> Reko.Core.RegisterStorage
Reko.Core.RegValue.RegValue() -> void
Reko.Core.RegValue.Value -> int
Reko.Core.RelocationDictionary
Reko.Core.RelocationDictionary.AddPointerReference(ulong linAddress, uint pointer) -> void
Reko.Core.RelocationDictionary.AddSegmentReference(ulong linAddress, ushort segmentSelector) -> void
Reko.Core.RelocationDictionary.Contains(uint linAddress) -> bool
Reko.Core.RelocationDictionary.Count.get -> int
Reko.Core.RelocationDictionary.Dump(Reko.Core.Address addrBase) -> void
Reko.Core.RelocationDictionary.Overlaps(Reko.Core.Address addr, uint length) -> bool
Reko.Core.RelocationDictionary.RelocationDictionary() -> void
Reko.Core.RelocationDictionary.this[ulong linAddress].get -> Reko.Core.Expressions.Constant
Reko.Core.Rtl.RtlAssignment
Reko.Core.Rtl.RtlAssignment.Dst.get -> Reko.Core.Expressions.Expression
Reko.Core.Rtl.RtlAssignment.RtlAssignment(Reko.Core.Expressions.Expression dst, Reko.Core.Expressions.Expression src) -> void
Reko.Core.Rtl.RtlAssignment.Src.get -> Reko.Core.Expressions.Expression
Reko.Core.Rtl.RtlBranch
Reko.Core.Rtl.RtlBranch.Condition.get -> Reko.Core.Expressions.Expression
Reko.Core.Rtl.RtlBranch.RtlBranch(Reko.Core.Expressions.Expression condition, Reko.Core.Address target, Reko.Core.InstrClass rtlClass) -> void
Reko.Core.Rtl.RtlCall
Reko.Core.Rtl.RtlCall.Architecture.get -> Reko.Core.IProcessorArchitecture
Reko.Core.Rtl.RtlCall.ReturnAddressSize.get -> int
Reko.Core.Rtl.RtlCall.RtlCall(Reko.Core.Expressions.Expression target, byte stackPushedReturnAddressSize, Reko.Core.InstrClass rtlClass, Reko.Core.IProcessorArchitecture arch = null) -> void
Reko.Core.Rtl.RtlEmitter
Reko.Core.Rtl.RtlEmitter.Assign(Reko.Core.Expressions.Expression dst, int src) -> Reko.Core.Rtl.RtlEmitter
Reko.Core.Rtl.RtlEmitter.Assign(Reko.Core.Expressions.Expression dst, Reko.Core.Expressions.Expression src) -> Reko.Core.Rtl.RtlEmitter
Reko.Core.Rtl.RtlEmitter.Branch(Reko.Core.Expressions.Expression condition, Reko.Core.Address target) -> Reko.Core.Rtl.RtlEmitter
Reko.Core.Rtl.RtlEmitter.Branch(Reko.Core.Expressions.Expression condition, Reko.Core.Address target, Reko.Core.InstrClass rtlClass) -> Reko.Core.Rtl.RtlEmitter
Reko.Core.Rtl.RtlEmitter.BranchInMiddleOfInstruction(Reko.Core.Expressions.Expression condition, Reko.Core.Address target, Reko.Core.InstrClass rtlClass) -> Reko.Core.Rtl.RtlBranch
Reko.Core.Rtl.RtlEmitter.Call(Reko.Core.Expressions.Expression target, byte retSize) -> Reko.Core.Rtl.RtlEmitter
Reko.Core.Rtl.RtlEmitter.Call(Reko.Core.Expressions.Expression target, byte retSize, Reko.Core.InstrClass iclass) -> Reko.Core.Rtl.RtlEmitter
Reko.Core.Rtl.RtlEmitter.CallD(Reko.Core.Expressions.Expression target, byte retSize) -> Reko.Core.Rtl.RtlEmitter
Reko.Core.Rtl.RtlEmitter.CallX(Reko.Core.Expressions.Expression target, byte retSize, Reko.Core.IProcessorArchitecture arch) -> Reko.Core.Rtl.RtlEmitter
Reko.Core.Rtl.RtlEmitter.CallXD(Reko.Core.Expressions.Expression target, byte retSize, Reko.Core.IProcessorArchitecture arch) -> Reko.Core.Rtl.RtlEmitter
Reko.Core.Rtl.RtlEmitter.Const(Reko.Core.Types.DataType dataType, long p) -> Reko.Core.Expressions.Expression
Reko.Core.Rtl.RtlEmitter.Emit(Reko.Core.Rtl.RtlInstruction instr) -> void
Reko.Core.Rtl.RtlEmitter.Goto(Reko.Core.Expressions.Expression target) -> Reko.Core.Rtl.RtlEmitter
Reko.Core.Rtl.RtlEmitter.Goto(Reko.Core.Expressions.Expression target, Reko.Core.InstrClass rtlClass) -> Reko.Core.Rtl.RtlEmitter
Reko.Core.Rtl.RtlEmitter.GotoD(Reko.Core.Expressions.Expression target) -> Reko.Core.Rtl.RtlEmitter
Reko.Core.Rtl.RtlEmitter.If(Reko.Core.Expressions.Expression test, Reko.Core.Rtl.RtlInstruction rtl) -> Reko.Core.Rtl.RtlEmitter
Reko.Core.Rtl.RtlEmitter.Instructions.get -> System.Collections.Generic.List<Reko.Core.Rtl.RtlInstruction>
Reko.Core.Rtl.RtlEmitter.Instructions.set -> void
Reko.Core.Rtl.RtlEmitter.Invalid() -> Reko.Core.Rtl.RtlEmitter
Reko.Core.Rtl.RtlEmitter.MakeCluster(Reko.Core.Address address, int instrLength, Reko.Core.InstrClass iclass) -> Reko.Core.Rtl.RtlInstructionCluster
Reko.Core.Rtl.RtlEmitter.MicroBranch(Reko.Core.Expressions.Expression cond, string microLabel) -> Reko.Core.Rtl.RtlEmitter
Reko.Core.Rtl.RtlEmitter.MicroGoto(string microLabel) -> Reko.Core.Rtl.RtlEmitter
Reko.Core.Rtl.RtlEmitter.MicroLabel(string name) -> Reko.Core.Rtl.RtlEmitter
Reko.Core.Rtl.RtlEmitter.Nop() -> Reko.Core.Rtl.RtlEmitter
Reko.Core.Rtl.RtlEmitter.Return(int returnAddressBytes, int extraBytesPopped) -> Reko.Core.Rtl.RtlEmitter
Reko.Core.Rtl.RtlEmitter.Return(int returnAddressBytes, int extraBytesPopped, Reko.Core.InstrClass iclass) -> Reko.Core.Rtl.RtlEmitter
Reko.Core.Rtl.RtlEmitter.ReturnD(int returnAddressBytes, int extraBytesPopped) -> Reko.Core.Rtl.RtlEmitter
Reko.Core.Rtl.RtlEmitter.RtlEmitter(System.Collections.Generic.List<Reko.Core.Rtl.RtlInstruction> instrs) -> void
Reko.Core.Rtl.RtlEmitter.SideEffect(Reko.Core.Expressions.Expression sideEffect, Reko.Core.InstrClass iclass = Reko.Core.InstrClass.Linear) -> Reko.Core.Rtl.RtlEmitter
Reko.Core.Rtl.RtlGoto
Reko.Core.Rtl.RtlGoto.RtlGoto(Reko.Core.Expressions.Expression target, Reko.Core.InstrClass rtlClass) -> void
Reko.Core.Rtl.RtlIf
Reko.Core.Rtl.RtlIf.Condition.get -> Reko.Core.Expressions.Expression
Reko.Core.Rtl.RtlIf.Instruction.get -> Reko.Core.Rtl.RtlInstruction
Reko.Core.Rtl.RtlIf.RtlIf(Reko.Core.Expressions.Expression condition, Reko.Core.Rtl.RtlInstruction instr) -> void
Reko.Core.Rtl.RtlInstruction
Reko.Core.Rtl.RtlInstruction.NextStatementRequiresLabel.get -> bool
Reko.Core.Rtl.RtlInstruction.NextStatementRequiresLabel.set -> void
Reko.Core.Rtl.RtlInstruction.RtlInstruction() -> void
Reko.Core.Rtl.RtlInstruction.Write(System.IO.TextWriter writer) -> void
Reko.Core.Rtl.RtlInstructionCluster
Reko.Core.Rtl.RtlInstructionCluster.Address.get -> Reko.Core.Address
Reko.Core.Rtl.RtlInstructionCluster.Class.get -> Reko.Core.InstrClass
Reko.Core.Rtl.RtlInstructionCluster.Class.set -> void
Reko.Core.Rtl.RtlInstructionCluster.Instructions.get -> Reko.Core.Rtl.RtlInstruction[]
Reko.Core.Rtl.RtlInstructionCluster.Length.get -> int
Reko.Core.Rtl.RtlInstructionCluster.RtlInstructionCluster(Reko.Core.Address addr, int instrLength, params Reko.Core.Rtl.RtlInstruction[] instrs) -> void
Reko.Core.Rtl.RtlInstructionCluster.Write(System.IO.TextWriter writer) -> void
Reko.Core.Rtl.RtlInstructionMatcher
Reko.Core.Rtl.RtlInstructionMatcher.CapturedExpressions(string label) -> Reko.Core.Expressions.Expression
Reko.Core.Rtl.RtlInstructionMatcher.CapturedOperators(string label) -> Reko.Core.Operators.Operator
Reko.Core.Rtl.RtlInstructionMatcher.Match(Reko.Core.Rtl.RtlInstruction instr) -> bool
Reko.Core.Rtl.RtlInstructionMatcher.RtlInstructionMatcher(Reko.Core.Rtl.RtlInstruction pattern) -> void
Reko.Core.Rtl.RtlInstructionMatcher.VisitAssignment(Reko.Core.Rtl.RtlAssignment ass) -> bool
Reko.Core.Rtl.RtlInstructionMatcher.VisitBranch(Reko.Core.Rtl.RtlBranch branch) -> bool
Reko.Core.Rtl.RtlInstructionMatcher.VisitCall(Reko.Core.Rtl.RtlCall call) -> bool
Reko.Core.Rtl.RtlInstructionMatcher.VisitGoto(Reko.Core.Rtl.RtlGoto go) -> bool
Reko.Core.Rtl.RtlInstructionMatcher.VisitIf(Reko.Core.Rtl.RtlIf rtlIf) -> bool
Reko.Core.Rtl.RtlInstructionMatcher.VisitInvalid(Reko.Core.Rtl.RtlInvalid invalid) -> bool
Reko.Core.Rtl.RtlInstructionMatcher.VisitMicroGoto(Reko.Core.Rtl.RtlMicroGoto mgo) -> bool
Reko.Core.Rtl.RtlInstructionMatcher.VisitMicroLabel(Reko.Core.Rtl.RtlMicroLabel mlabel) -> bool
Reko.Core.Rtl.RtlInstructionMatcher.VisitNop(Reko.Core.Rtl.RtlNop nop) -> bool
Reko.Core.Rtl.RtlInstructionMatcher.VisitReturn(Reko.Core.Rtl.RtlReturn ret) -> bool
Reko.Core.Rtl.RtlInstructionMatcher.VisitSideEffect(Reko.Core.Rtl.RtlSideEffect side) -> bool
Reko.Core.Rtl.RtlInstructionMatcher.VisitSwitch(Reko.Core.Rtl.RtlSwitch sw) -> bool
Reko.Core.Rtl.RtlInstructionVisitor<T>
Reko.Core.Rtl.RtlInstructionVisitor<T>.VisitAssignment(Reko.Core.Rtl.RtlAssignment ass) -> T
Reko.Core.Rtl.RtlInstructionVisitor<T>.VisitBranch(Reko.Core.Rtl.RtlBranch branch) -> T
Reko.Core.Rtl.RtlInstructionVisitor<T>.VisitCall(Reko.Core.Rtl.RtlCall call) -> T
Reko.Core.Rtl.RtlInstructionVisitor<T>.VisitGoto(Reko.Core.Rtl.RtlGoto go) -> T
Reko.Core.Rtl.RtlInstructionVisitor<T>.VisitIf(Reko.Core.Rtl.RtlIf rtlIf) -> T
Reko.Core.Rtl.RtlInstructionVisitor<T>.VisitInvalid(Reko.Core.Rtl.RtlInvalid invalid) -> T
Reko.Core.Rtl.RtlInstructionVisitor<T>.VisitMicroGoto(Reko.Core.Rtl.RtlMicroGoto uGoto) -> T
Reko.Core.Rtl.RtlInstructionVisitor<T>.VisitMicroLabel(Reko.Core.Rtl.RtlMicroLabel uLabel) -> T
Reko.Core.Rtl.RtlInstructionVisitor<T>.VisitNop(Reko.Core.Rtl.RtlNop rtlNop) -> T
Reko.Core.Rtl.RtlInstructionVisitor<T>.VisitReturn(Reko.Core.Rtl.RtlReturn ret) -> T
Reko.Core.Rtl.RtlInstructionVisitor<T>.VisitSideEffect(Reko.Core.Rtl.RtlSideEffect side) -> T
Reko.Core.Rtl.RtlInstructionVisitor<T>.VisitSwitch(Reko.Core.Rtl.RtlSwitch sw) -> T
Reko.Core.Rtl.RtlInvalid
Reko.Core.Rtl.RtlInvalid.RtlInvalid() -> void
Reko.Core.Rtl.RtlLocation
Reko.Core.Rtl.RtlLocation.Address.get -> Reko.Core.Address
Reko.Core.Rtl.RtlLocation.CompareTo(Reko.Core.Rtl.RtlLocation that) -> int
Reko.Core.Rtl.RtlLocation.Index.get -> int
Reko.Core.Rtl.RtlLocation.RtlLocation() -> void
Reko.Core.Rtl.RtlLocation.RtlLocation(Reko.Core.Address addr, int index) -> void
Reko.Core.Rtl.RtlMicroGoto
Reko.Core.Rtl.RtlMicroGoto.Condition.get -> Reko.Core.Expressions.Expression
Reko.Core.Rtl.RtlMicroGoto.RtlMicroGoto(object microTarget) -> void
Reko.Core.Rtl.RtlMicroGoto.RtlMicroGoto(Reko.Core.Expressions.Expression condition, object microTarget) -> void
Reko.Core.Rtl.RtlMicroGoto.Target.get -> object
Reko.Core.Rtl.RtlMicroLabel
Reko.Core.Rtl.RtlMicroLabel.Name.get -> string
Reko.Core.Rtl.RtlMicroLabel.RtlMicroLabel(string name) -> void
Reko.Core.Rtl.RtlNop
Reko.Core.Rtl.RtlNop.RtlNop(Reko.Core.InstrClass iclass = Reko.Core.InstrClass.None) -> void
Reko.Core.Rtl.RtlReturn
Reko.Core.Rtl.RtlReturn.ExtraBytesPopped.get -> int
Reko.Core.Rtl.RtlReturn.ReturnAddressBytes.get -> int
Reko.Core.Rtl.RtlReturn.RtlReturn(int returnAddressBytes, int extraBytesPopped, Reko.Core.InstrClass rtlClass) -> void
Reko.Core.Rtl.RtlSideEffect
Reko.Core.Rtl.RtlSideEffect.Expression.get -> Reko.Core.Expressions.Expression
Reko.Core.Rtl.RtlSideEffect.RtlSideEffect(Reko.Core.Expressions.Expression sideEffect, Reko.Core.InstrClass iclass) -> void
Reko.Core.Rtl.RtlSwitch
Reko.Core.Rtl.RtlSwitch.Expression.get -> Reko.Core.Expressions.Expression
Reko.Core.Rtl.RtlSwitch.RtlSwitch(Reko.Core.Expressions.Expression expr, Reko.Core.Address[] targets) -> void
Reko.Core.Rtl.RtlSwitch.Targets.get -> Reko.Core.Address[]
Reko.Core.Rtl.RtlTransfer
Reko.Core.Rtl.RtlTransfer.RtlTransfer(Reko.Core.Expressions.Expression target, Reko.Core.InstrClass rtlClass) -> void
Reko.Core.Rtl.RtlTransfer.Target.get -> Reko.Core.Expressions.Expression
Reko.Core.Scripts.ScriptError
Reko.Core.Scripts.ScriptError.ScriptError(string fileName, System.Exception ex, string message, System.Collections.Generic.IEnumerable<Reko.Core.Scripts.ScriptStackFrame> stackFrames) -> void
Reko.Core.Scripts.ScriptEvent
Reko.Core.Scripts.ScriptEvent.OnProgramDecompiled = 3 -> Reko.Core.Scripts.ScriptEvent
Reko.Core.Scripts.ScriptEvent.OnProgramDecompiling = 1 -> Reko.Core.Scripts.ScriptEvent
Reko.Core.Scripts.ScriptEvent.OnProgramLoaded = 0 -> Reko.Core.Scripts.ScriptEvent
Reko.Core.Scripts.ScriptEvent.OnProgramScanned = 2 -> Reko.Core.Scripts.ScriptEvent
Reko.Core.Scripts.ScriptFile
Reko.Core.Scripts.ScriptFile.Location.get -> Reko.Core.ImageLocation
Reko.Core.Scripts.ScriptFile.ScriptFile(System.IServiceProvider services, Reko.Core.ImageLocation scriptLocation, byte[] bytes) -> void
Reko.Core.Scripts.ScriptStackFrame
Reko.Core.Scripts.ScriptStackFrame.ScriptStackFrame(string file, int line, string method) -> void
Reko.Core.SegmentMap
Reko.Core.SegmentMap.AddOverlappingSegment(string segmentName, Reko.Core.Memory.MemoryArea mem, Reko.Core.Address addr, Reko.Core.AccessMode mode) -> Reko.Core.ImageSegment
Reko.Core.SegmentMap.AddSegment(Reko.Core.ImageSegment segNew) -> Reko.Core.ImageSegment
Reko.Core.SegmentMap.AddSegment(Reko.Core.Memory.ByteMemoryArea mem, string segmentName, Reko.Core.AccessMode mode) -> Reko.Core.ImageSegment
Reko.Core.SegmentMap.BaseAddress.get -> Reko.Core.Address
Reko.Core.SegmentMap.CreateImageMap() -> Reko.Core.ImageMap
Reko.Core.SegmentMap.DumpSections() -> void
Reko.Core.SegmentMap.GetExtent() -> long
Reko.Core.SegmentMap.IsExecutableAddress(Reko.Core.Address addr) -> bool
Reko.Core.SegmentMap.IsReadOnlyAddress(Reko.Core.Address addr) -> bool
Reko.Core.SegmentMap.IsValidAddress(Reko.Core.Address address) -> bool
Reko.Core.SegmentMap.MapChanged -> System.EventHandler
Reko.Core.SegmentMap.MapLinearAddressToAddress(ulong linearAddress) -> Reko.Core.Address
Reko.Core.SegmentMap.SegmentMap(params Reko.Core.ImageSegment[] segments) -> void
Reko.Core.SegmentMap.SegmentMap(Reko.Core.Address addrBase, params Reko.Core.ImageSegment[] segments) -> void
Reko.Core.SegmentMap.Segments.get -> System.Collections.Generic.SortedList<Reko.Core.Address, Reko.Core.ImageSegment>
Reko.Core.SegmentMap.Selectors.get -> System.Collections.Generic.Dictionary<ushort, Reko.Core.ImageSegment>
Reko.Core.SegmentMap.TryFindSegment(Reko.Core.Address addr, out Reko.Core.ImageSegment segment) -> bool
Reko.Core.SegmentMap.TryFindSegment(string segmentName, out Reko.Core.ImageSegment segment) -> bool
Reko.Core.SegmentMap.TryFindSegment(ulong linAddress, out Reko.Core.ImageSegment segment) -> bool
Reko.Core.SequenceStorage
Reko.Core.SequenceStorage.Elements.get -> Reko.Core.Storage[]
Reko.Core.SequenceStorage.Render(Reko.Core.Machine.MachineInstructionRenderer renderer, Reko.Core.Machine.MachineInstructionRendererOptions options) -> void
Reko.Core.SequenceStorage.SequenceStorage(params Reko.Core.Storage[] elements) -> void
Reko.Core.SequenceStorage.SequenceStorage(Reko.Core.Types.DataType dt, params Reko.Core.Storage[] elements) -> void
Reko.Core.SequenceStorage.SequenceStorage(string name, Reko.Core.Types.DataType dt, params Reko.Core.Storage[] elements) -> void
Reko.Core.SequenceStorage.Width.get -> Reko.Core.Types.DataType
Reko.Core.SequenceStorage.Width.set -> void
Reko.Core.Serialization.Annotation_v3
Reko.Core.Serialization.Annotation_v3.Address -> string
Reko.Core.Serialization.Annotation_v3.Annotation_v3() -> void
Reko.Core.Serialization.Annotation_v3.Text -> string
Reko.Core.Serialization.ArgumentDeserializer
Reko.Core.Serialization.ArgumentDeserializer.ArgumentDeserializer(Reko.Core.Serialization.ProcedureSerializer procSer, Reko.Core.IProcessorArchitecture arch, Reko.Core.Frame frame, int retAddressOnStack, int stackAlign) -> void
Reko.Core.Serialization.ArgumentDeserializer.Deserialize(Reko.Core.Serialization.Argument_v1 arg) -> Reko.Core.Expressions.Identifier
Reko.Core.Serialization.ArgumentDeserializer.Deserialize(Reko.Core.Serialization.Argument_v1 arg, Reko.Core.Serialization.SerializedKind kind) -> Reko.Core.Expressions.Identifier
Reko.Core.Serialization.ArgumentDeserializer.Deserialize(Reko.Core.Serialization.FlagGroup_v1 flag) -> Reko.Core.Expressions.Identifier
Reko.Core.Serialization.ArgumentDeserializer.Deserialize(Reko.Core.Serialization.FpuStackVariable_v1 _) -> Reko.Core.Expressions.Identifier
Reko.Core.Serialization.ArgumentDeserializer.Deserialize(Reko.Core.Serialization.SerializedSequence sq) -> Reko.Core.Expressions.Identifier
Reko.Core.Serialization.ArgumentDeserializer.Deserialize(Reko.Core.Serialization.StackVariable_v1 _) -> Reko.Core.Expressions.Identifier
Reko.Core.Serialization.ArgumentDeserializer.VisitRegister(Reko.Core.Serialization.Register_v1 reg) -> Reko.Core.Expressions.Identifier
Reko.Core.Serialization.ArgumentSerializer
Reko.Core.Serialization.ArgumentSerializer.ArgumentSerializer(Reko.Core.IProcessorArchitecture arch) -> void
Reko.Core.Serialization.ArgumentSerializer.Serialize(Reko.Core.Expressions.Identifier arg) -> Reko.Core.Serialization.Argument_v1
Reko.Core.Serialization.Argument_v1
Reko.Core.Serialization.Argument_v1.Argument_v1() -> void
Reko.Core.Serialization.Argument_v1.Argument_v1(string name, Reko.Core.Serialization.SerializedType type, Reko.Core.Serialization.SerializedKind kind, bool outParameter) -> void
Reko.Core.Serialization.Argument_v1.Kind.get -> Reko.Core.Serialization.SerializedKind
Reko.Core.Serialization.Argument_v1.Kind.set -> void
Reko.Core.Serialization.Argument_v1.Name.get -> string
Reko.Core.Serialization.Argument_v1.Name.set -> void
Reko.Core.Serialization.Argument_v1.OutParameter.get -> bool
Reko.Core.Serialization.Argument_v1.OutParameter.set -> void
Reko.Core.Serialization.Argument_v1.Type -> Reko.Core.Serialization.SerializedType
Reko.Core.Serialization.ArraySizeCharacteristic
Reko.Core.Serialization.ArraySizeCharacteristic.Argument.get -> string
Reko.Core.Serialization.ArraySizeCharacteristic.Argument.set -> void
Reko.Core.Serialization.ArraySizeCharacteristic.ArraySizeCharacteristic() -> void
Reko.Core.Serialization.ArraySizeCharacteristic.Factors.get -> Reko.Core.Serialization.ArraySizeFactor[]
Reko.Core.Serialization.ArraySizeCharacteristic.Factors.set -> void
Reko.Core.Serialization.ArraySizeFactor
Reko.Core.Serialization.ArraySizeFactor.Argument.get -> string
Reko.Core.Serialization.ArraySizeFactor.Argument.set -> void
Reko.Core.Serialization.ArraySizeFactor.ArraySizeFactor() -> void
Reko.Core.Serialization.ArraySizeFactor.Constant.get -> string
Reko.Core.Serialization.ArraySizeFactor.Constant.set -> void
Reko.Core.Serialization.ArrayType_v1
Reko.Core.Serialization.ArrayType_v1.ArrayType_v1() -> void
Reko.Core.Serialization.ArrayType_v1.ElementType -> Reko.Core.Serialization.SerializedType
Reko.Core.Serialization.ArrayType_v1.Length -> int
Reko.Core.Serialization.AssemblerFile_v3
Reko.Core.Serialization.AssemblerFile_v3.Assembler -> string
Reko.Core.Serialization.AssemblerFile_v3.AssemblerFile_v3() -> void
Reko.Core.Serialization.AssemblerFile_v3.Filename -> string
Reko.Core.Serialization.BlockLabel_v1
Reko.Core.Serialization.BlockLabel_v1.BlockLabel_v1() -> void
Reko.Core.Serialization.BlockLabel_v1.Location -> string
Reko.Core.Serialization.BlockLabel_v1.Name -> string
Reko.Core.Serialization.CharacteristicsLibrary_v1
Reko.Core.Serialization.CharacteristicsLibrary_v1.CharacteristicsLibrary_v1() -> void
Reko.Core.Serialization.CharacteristicsLibrary_v1.Entries -> Reko.Core.Serialization.CharacteristicsLibrary_v1.Entry[]
Reko.Core.Serialization.CharacteristicsLibrary_v1.Entry
Reko.Core.Serialization.CharacteristicsLibrary_v1.Entry.Characteristics -> Reko.Core.Serialization.ProcedureCharacteristics
Reko.Core.Serialization.CharacteristicsLibrary_v1.Entry.Entry() -> void
Reko.Core.Serialization.CharacteristicsLibrary_v1.Entry.ProcedureName -> string
Reko.Core.Serialization.CodeType_v1
Reko.Core.Serialization.CodeType_v1.CodeType_v1() -> void
Reko.Core.Serialization.DataTypeSerializer
Reko.Core.Serialization.DataTypeSerializer.DataTypeSerializer() -> void
Reko.Core.Serialization.DataTypeSerializer.VisitArray(Reko.Core.Types.ArrayType at) -> Reko.Core.Serialization.SerializedType
Reko.Core.Serialization.DataTypeSerializer.VisitClass(Reko.Core.Types.ClassType ct) -> Reko.Core.Serialization.SerializedType
Reko.Core.Serialization.DataTypeSerializer.VisitCode(Reko.Core.Types.CodeType c) -> Reko.Core.Serialization.SerializedType
Reko.Core.Serialization.DataTypeSerializer.VisitEnum(Reko.Core.Types.EnumType e) -> Reko.Core.Serialization.SerializedType
Reko.Core.Serialization.DataTypeSerializer.VisitEquivalenceClass(Reko.Core.Types.EquivalenceClass eq) -> Reko.Core.Serialization.SerializedType
Reko.Core.Serialization.DataTypeSerializer.VisitFunctionType(Reko.Core.Types.FunctionType ft) -> Reko.Core.Serialization.SerializedType
Reko.Core.Serialization.DataTypeSerializer.VisitMemberPointer(Reko.Core.Types.MemberPointer memptr) -> Reko.Core.Serialization.SerializedType
Reko.Core.Serialization.DataTypeSerializer.VisitPointer(Reko.Core.Types.Pointer ptr) -> Reko.Core.Serialization.SerializedType
Reko.Core.Serialization.DataTypeSerializer.VisitPrimitive(Reko.Core.Types.PrimitiveType pt) -> Reko.Core.Serialization.SerializedType
Reko.Core.Serialization.DataTypeSerializer.VisitReference(Reko.Core.Types.ReferenceTo refTo) -> Reko.Core.Serialization.SerializedType
Reko.Core.Serialization.DataTypeSerializer.VisitString(Reko.Core.Types.StringType str) -> Reko.Core.Serialization.SerializedType
Reko.Core.Serialization.DataTypeSerializer.VisitStructure(Reko.Core.Types.StructureType str) -> Reko.Core.Serialization.SerializedType
Reko.Core.Serialization.DataTypeSerializer.VisitTypeReference(Reko.Core.Types.TypeReference typeref) -> Reko.Core.Serialization.SerializedType
Reko.Core.Serialization.DataTypeSerializer.VisitTypeVariable(Reko.Core.Types.TypeVariable tv) -> Reko.Core.Serialization.SerializedType
Reko.Core.Serialization.DataTypeSerializer.VisitUnion(Reko.Core.Types.UnionType ut) -> Reko.Core.Serialization.SerializedType
Reko.Core.Serialization.DataTypeSerializer.VisitUnknownType(Reko.Core.Types.UnknownType ut) -> Reko.Core.Serialization.SerializedType
Reko.Core.Serialization.DataTypeSerializer.VisitVoidType(Reko.Core.Types.VoidType ut) -> Reko.Core.Serialization.SerializedType
Reko.Core.Serialization.DecompilerInput_v4
Reko.Core.Serialization.DecompilerInput_v4.Comment -> string
Reko.Core.Serialization.DecompilerInput_v4.DecompilerInput_v4() -> void
Reko.Core.Serialization.DecompilerInput_v4.DisassemblyFilename -> string
Reko.Core.Serialization.DecompilerInput_v4.Filename -> string
Reko.Core.Serialization.DecompilerInput_v4.GlobalsFilename -> string
Reko.Core.Serialization.DecompilerInput_v4.IntermediateFilename -> string
Reko.Core.Serialization.DecompilerInput_v4.OutputFilename -> string
Reko.Core.Serialization.DecompilerInput_v4.ResourcesDirectory -> string
Reko.Core.Serialization.DecompilerInput_v4.TypesFilename -> string
Reko.Core.Serialization.DecompilerInput_v4.User -> Reko.Core.Serialization.UserData_v4
Reko.Core.Serialization.DecompilerInput_v5
Reko.Core.Serialization.DecompilerInput_v5.Comment -> string
Reko.Core.Serialization.DecompilerInput_v5.DecompilerInput_v5() -> void
Reko.Core.Serialization.DecompilerInput_v5.DisassemblyDirectory -> string
Reko.Core.Serialization.DecompilerInput_v5.Filename -> string
Reko.Core.Serialization.DecompilerInput_v5.IncludeDirectory -> string
Reko.Core.Serialization.DecompilerInput_v5.Location -> string
Reko.Core.Serialization.DecompilerInput_v5.ResourcesDirectory -> string
Reko.Core.Serialization.DecompilerInput_v5.SourceDirectory -> string
Reko.Core.Serialization.DecompilerInput_v5.User -> Reko.Core.Serialization.UserData_v4
Reko.Core.Serialization.DefaultProcedureCharacteristics
Reko.Core.Serialization.DispatchProcedure_v1
Reko.Core.Serialization.DispatchProcedure_v1.Address -> string
Reko.Core.Serialization.DispatchProcedure_v1.DispatchProcedure_v1() -> void
Reko.Core.Serialization.DispatchProcedure_v1.Services -> Reko.Core.Serialization.SerializedService[]
Reko.Core.Serialization.FlagGroup_v1
Reko.Core.Serialization.FlagGroup_v1.FlagGroup_v1() -> void
Reko.Core.Serialization.FlagGroup_v1.FlagGroup_v1(string name) -> void
Reko.Core.Serialization.FlagGroup_v1.Name -> string
Reko.Core.Serialization.FpuStackVariable_v1
Reko.Core.Serialization.FpuStackVariable_v1.ByteSize -> int
Reko.Core.Serialization.FpuStackVariable_v1.FpuStackVariable_v1() -> void
Reko.Core.Serialization.GlobalDataItem_v2
Reko.Core.Serialization.GlobalDataItem_v2.Address -> string
Reko.Core.Serialization.GlobalDataItem_v2.Comment -> string
Reko.Core.Serialization.GlobalDataItem_v2.DataType -> Reko.Core.Serialization.SerializedType
Reko.Core.Serialization.GlobalDataItem_v2.GlobalDataItem_v2() -> void
Reko.Core.Serialization.GlobalDataItem_v2.Name -> string
Reko.Core.Serialization.GlobalVariable_v1
Reko.Core.Serialization.GlobalVariable_v1.Address -> string
Reko.Core.Serialization.GlobalVariable_v1.GlobalVariable_v1() -> void
Reko.Core.Serialization.GlobalVariable_v1.Name -> string
Reko.Core.Serialization.GlobalVariable_v1.Ordinal -> int
Reko.Core.Serialization.GlobalVariable_v1.Type -> Reko.Core.Serialization.SerializedType
Reko.Core.Serialization.Heuristic_v3
Reko.Core.Serialization.Heuristic_v3.Heuristic_v3() -> void
Reko.Core.Serialization.Heuristic_v3.Name -> string
Reko.Core.Serialization.IndirectJump_v4
Reko.Core.Serialization.IndirectJump_v4.IndexRegister -> string
Reko.Core.Serialization.IndirectJump_v4.IndirectJump_v4() -> void
Reko.Core.Serialization.IndirectJump_v4.InstructionAddress -> string
Reko.Core.Serialization.IndirectJump_v4.TableAddress -> string
Reko.Core.Serialization.ISerializedProjectVisitor<T>
Reko.Core.Serialization.ISerializedProjectVisitor<T>.VisitProject_v4(Reko.Core.Serialization.Project_v4 sProject) -> T
Reko.Core.Serialization.ISerializedProjectVisitor<T>.VisitProject_v5(Reko.Core.Serialization.Project_v5 sProject) -> T
Reko.Core.Serialization.ISerializedTypeVisitor<T>
Reko.Core.Serialization.ISerializedTypeVisitor<T>.VisitArray(Reko.Core.Serialization.ArrayType_v1 array) -> T
Reko.Core.Serialization.ISerializedTypeVisitor<T>.VisitCode(Reko.Core.Serialization.CodeType_v1 code) -> T
Reko.Core.Serialization.ISerializedTypeVisitor<T>.VisitEnum(Reko.Core.Serialization.SerializedEnumType serializedEnumType) -> T
Reko.Core.Serialization.ISerializedTypeVisitor<T>.VisitMemberPointer(Reko.Core.Serialization.MemberPointer_v1 memptr) -> T
Reko.Core.Serialization.ISerializedTypeVisitor<T>.VisitPointer(Reko.Core.Serialization.PointerType_v1 pointer) -> T
Reko.Core.Serialization.ISerializedTypeVisitor<T>.VisitPrimitive(Reko.Core.Serialization.PrimitiveType_v1 primitive) -> T
Reko.Core.Serialization.ISerializedTypeVisitor<T>.VisitReference(Reko.Core.Serialization.ReferenceType_v1 referenceType_v1) -> T
Reko.Core.Serialization.ISerializedTypeVisitor<T>.VisitSignature(Reko.Core.Serialization.SerializedSignature signature) -> T
Reko.Core.Serialization.ISerializedTypeVisitor<T>.VisitString(Reko.Core.Serialization.StringType_v2 str) -> T
Reko.Core.Serialization.ISerializedTypeVisitor<T>.VisitStructure(Reko.Core.Serialization.StructType_v1 structure) -> T
Reko.Core.Serialization.ISerializedTypeVisitor<T>.VisitTemplate(Reko.Core.Serialization.SerializedTemplate serializedTemplate) -> T
Reko.Core.Serialization.ISerializedTypeVisitor<T>.VisitTypedef(Reko.Core.Serialization.SerializedTypedef typedef) -> T
Reko.Core.Serialization.ISerializedTypeVisitor<T>.VisitTypeReference(Reko.Core.Serialization.TypeReference_v1 typeReference) -> T
Reko.Core.Serialization.ISerializedTypeVisitor<T>.VisitUnion(Reko.Core.Serialization.UnionType_v1 union) -> T
Reko.Core.Serialization.ISerializedTypeVisitor<T>.VisitVoidType(Reko.Core.Serialization.VoidType_v1 serializedVoidType) -> T
Reko.Core.Serialization.Json.JsonProcedureSerializer
Reko.Core.Serialization.Json.JsonProcedureSerializer.JsonProcedureSerializer() -> void
Reko.Core.Serialization.Json.JsonProcedureSerializer.Serialize(Reko.Core.Procedure proc) -> string
Reko.Core.Serialization.Json.JsonProcedureSerializer.VisitAddress(Reko.Core.Address addr) -> void
Reko.Core.Serialization.Json.JsonProcedureSerializer.VisitApplication(Reko.Core.Expressions.Application appl) -> void
Reko.Core.Serialization.Json.JsonProcedureSerializer.VisitArrayAccess(Reko.Core.Expressions.ArrayAccess acc) -> void
Reko.Core.Serialization.Json.JsonProcedureSerializer.VisitAssignment(Reko.Core.Code.Assignment ass) -> void
Reko.Core.Serialization.Json.JsonProcedureSerializer.VisitBinaryExpression(Reko.Core.Expressions.BinaryExpression binExp) -> void
Reko.Core.Serialization.Json.JsonProcedureSerializer.VisitBranch(Reko.Core.Code.Branch branch) -> void
Reko.Core.Serialization.Json.JsonProcedureSerializer.VisitCallInstruction(Reko.Core.Code.CallInstruction ci) -> void
Reko.Core.Serialization.Json.JsonProcedureSerializer.VisitCast(Reko.Core.Expressions.Cast cast) -> void
Reko.Core.Serialization.Json.JsonProcedureSerializer.VisitComment(Reko.Core.Code.CodeComment comment) -> void
Reko.Core.Serialization.Json.JsonProcedureSerializer.VisitConditionalExpression(Reko.Core.Expressions.ConditionalExpression cond) -> void
Reko.Core.Serialization.Json.JsonProcedureSerializer.VisitConditionOf(Reko.Core.Expressions.ConditionOf cof) -> void
Reko.Core.Serialization.Json.JsonProcedureSerializer.VisitConstant(Reko.Core.Expressions.Constant c) -> void
Reko.Core.Serialization.Json.JsonProcedureSerializer.VisitConversion(Reko.Core.Expressions.Conversion conversion) -> void
Reko.Core.Serialization.Json.JsonProcedureSerializer.VisitDeclaration(Reko.Core.Code.Declaration decl) -> void
Reko.Core.Serialization.Json.JsonProcedureSerializer.VisitDefInstruction(Reko.Core.Code.DefInstruction def) -> void
Reko.Core.Serialization.Json.JsonProcedureSerializer.VisitDereference(Reko.Core.Expressions.Dereference deref) -> void
Reko.Core.Serialization.Json.JsonProcedureSerializer.VisitFieldAccess(Reko.Core.Expressions.FieldAccess acc) -> void
Reko.Core.Serialization.Json.JsonProcedureSerializer.VisitGotoInstruction(Reko.Core.Code.GotoInstruction gotoInstruction) -> void
Reko.Core.Serialization.Json.JsonProcedureSerializer.VisitIdentifier(Reko.Core.Expressions.Identifier id) -> void
Reko.Core.Serialization.Json.JsonProcedureSerializer.VisitMemberPointerSelector(Reko.Core.Expressions.MemberPointerSelector mps) -> void
Reko.Core.Serialization.Json.JsonProcedureSerializer.VisitMemoryAccess(Reko.Core.Expressions.MemoryAccess access) -> void
Reko.Core.Serialization.Json.JsonProcedureSerializer.VisitMkSequence(Reko.Core.Expressions.MkSequence seq) -> void
Reko.Core.Serialization.Json.JsonProcedureSerializer.VisitOutArgument(Reko.Core.Expressions.OutArgument outArgument) -> void
Reko.Core.Serialization.Json.JsonProcedureSerializer.VisitPhiAssignment(Reko.Core.Code.PhiAssignment phi) -> void
Reko.Core.Serialization.Json.JsonProcedureSerializer.VisitPhiFunction(Reko.Core.Expressions.PhiFunction phi) -> void
Reko.Core.Serialization.Json.JsonProcedureSerializer.VisitPointerAddition(Reko.Core.Expressions.PointerAddition pa) -> void
Reko.Core.Serialization.Json.JsonProcedureSerializer.VisitProcedureConstant(Reko.Core.Expressions.ProcedureConstant pc) -> void
Reko.Core.Serialization.Json.JsonProcedureSerializer.VisitReturnInstruction(Reko.Core.Code.ReturnInstruction ret) -> void
Reko.Core.Serialization.Json.JsonProcedureSerializer.VisitScopeResolution(Reko.Core.Expressions.ScopeResolution scopeResolution) -> void
Reko.Core.Serialization.Json.JsonProcedureSerializer.VisitSegmentedAccess(Reko.Core.Expressions.SegmentedAccess access) -> void
Reko.Core.Serialization.Json.JsonProcedureSerializer.VisitSideEffect(Reko.Core.Code.SideEffect side) -> void
Reko.Core.Serialization.Json.JsonProcedureSerializer.VisitSlice(Reko.Core.Expressions.Slice slice) -> void
Reko.Core.Serialization.Json.JsonProcedureSerializer.VisitStore(Reko.Core.Code.Store store) -> void
Reko.Core.Serialization.Json.JsonProcedureSerializer.VisitSwitchInstruction(Reko.Core.Code.SwitchInstruction si) -> void
Reko.Core.Serialization.Json.JsonProcedureSerializer.VisitTestCondition(Reko.Core.Expressions.TestCondition tc) -> void
Reko.Core.Serialization.Json.JsonProcedureSerializer.VisitUnaryExpression(Reko.Core.Expressions.UnaryExpression unary) -> void
Reko.Core.Serialization.Json.JsonProcedureSerializer.VisitUseInstruction(Reko.Core.Code.UseInstruction use) -> void
Reko.Core.Serialization.Json.JsonProjectSerializer
Reko.Core.Serialization.Json.JsonProjectSerializer.JsonProjectSerializer() -> void
Reko.Core.Serialization.Json.JsonProjectSerializer.Serialize(Reko.Core.Project project, System.IO.TextWriter writer) -> void
Reko.Core.Serialization.Json.JsonProjectSerializer.WriteProcedure(System.Collections.Generic.KeyValuePair<Reko.Core.Address, Reko.Core.Procedure> proc) -> void
Reko.Core.Serialization.Json.JsonProjectSerializer.WriteProgram(Reko.Core.Program program) -> void
Reko.Core.Serialization.Json.JsonSymbols
Reko.Core.Serialization.Json.JsonSymbols.JsonSymbols() -> void
Reko.Core.Serialization.Json.JsonWriter
Reko.Core.Serialization.Json.JsonWriter.BeginObject() -> void
Reko.Core.Serialization.Json.JsonWriter.EndObject() -> void
Reko.Core.Serialization.Json.JsonWriter.JsonWriter(System.IO.TextWriter w) -> void
Reko.Core.Serialization.Json.JsonWriter.Write(bool value) -> void
Reko.Core.Serialization.Json.JsonWriter.Write(long i64) -> void
Reko.Core.Serialization.Json.JsonWriter.Write(object o) -> void
Reko.Core.Serialization.Json.JsonWriter.Write(string s) -> void
Reko.Core.Serialization.Json.JsonWriter.Write(ulong u64) -> void
Reko.Core.Serialization.Json.JsonWriter.WriteKeyValue(string key, object value) -> void
Reko.Core.Serialization.Json.JsonWriter.WriteKeyValue(string key, System.Action valueWriter) -> void
Reko.Core.Serialization.Json.JsonWriter.WriteList<T>(System.Collections.Generic.IEnumerable<T> items, System.Action<T> itemWriter) -> void
Reko.Core.Serialization.Json.JsonWriter.WriteListContents<T>(System.Collections.Generic.IEnumerable<T> items, System.Action<T> itemWriter) -> void
Reko.Core.Serialization.JumpTable_v4
Reko.Core.Serialization.JumpTable_v4.Destinations -> string[]
Reko.Core.Serialization.JumpTable_v4.JumpTable_v4() -> void
Reko.Core.Serialization.JumpTable_v4.TableAddress -> string
Reko.Core.Serialization.MemberPointer_v1
Reko.Core.Serialization.MemberPointer_v1.DeclaringClass -> Reko.Core.Serialization.TypeReference_v1
Reko.Core.Serialization.MemberPointer_v1.MemberPointer_v1() -> void
Reko.Core.Serialization.MemberPointer_v1.MemberType -> Reko.Core.Serialization.SerializedType
Reko.Core.Serialization.MemberPointer_v1.Size -> int
Reko.Core.Serialization.MemoryMap_v1
Reko.Core.Serialization.MemoryMap_v1.MemoryMap_v1() -> void
Reko.Core.Serialization.MemoryMap_v1.Segments -> Reko.Core.Serialization.MemorySegment_v1[]
Reko.Core.Serialization.MemoryMap_v1.Types -> Reko.Core.Serialization.SerializedType[]
Reko.Core.Serialization.MemorySegment_v1
Reko.Core.Serialization.MemorySegment_v1.Address -> string
Reko.Core.Serialization.MemorySegment_v1.Attributes -> string
Reko.Core.Serialization.MemorySegment_v1.Description -> string
Reko.Core.Serialization.MemorySegment_v1.Globals -> System.Collections.Generic.List<Reko.Core.Serialization.GlobalVariable_v1>
Reko.Core.Serialization.MemorySegment_v1.MemorySegment_v1() -> void
Reko.Core.Serialization.MemorySegment_v1.Name -> string
Reko.Core.Serialization.MemorySegment_v1.Procedures -> System.Collections.Generic.List<Reko.Core.Serialization.ProcedureBase_v1>
Reko.Core.Serialization.MemorySegment_v1.Size -> string
Reko.Core.Serialization.MetadataFile_v3
Reko.Core.Serialization.MetadataFile_v3.Filename -> string
Reko.Core.Serialization.MetadataFile_v3.LoaderTypeName -> string
Reko.Core.Serialization.MetadataFile_v3.Location -> string
Reko.Core.Serialization.MetadataFile_v3.MetadataFile_v3() -> void
Reko.Core.Serialization.MetadataFile_v3.ModuleName -> string
Reko.Core.Serialization.PlatformOptions_v4
Reko.Core.Serialization.PlatformOptions_v4.Name -> string
Reko.Core.Serialization.PlatformOptions_v4.Options -> System.Xml.XmlElement[]
Reko.Core.Serialization.PlatformOptions_v4.PlatformOptions_v4() -> void
Reko.Core.Serialization.PointerType_v1
Reko.Core.Serialization.PointerType_v1.DataType -> Reko.Core.Serialization.SerializedType
Reko.Core.Serialization.PointerType_v1.PointerSize -> int
Reko.Core.Serialization.PointerType_v1.PointerType_v1() -> void
Reko.Core.Serialization.PointerType_v1.PointerType_v1(Reko.Core.Serialization.SerializedType pointee) -> void
Reko.Core.Serialization.PrimitiveType_v1
Reko.Core.Serialization.PrimitiveType_v1.ByteSize -> int
Reko.Core.Serialization.PrimitiveType_v1.Domain -> Reko.Core.Types.Domain
Reko.Core.Serialization.PrimitiveType_v1.PrimitiveType_v1() -> void
Reko.Core.Serialization.PrimitiveType_v1.PrimitiveType_v1(Reko.Core.Types.Domain domain, int byteSize) -> void
Reko.Core.Serialization.ProcedureBase_v1
Reko.Core.Serialization.ProcedureBase_v1.Characteristics -> Reko.Core.Serialization.ProcedureCharacteristics
Reko.Core.Serialization.ProcedureBase_v1.Name -> string
Reko.Core.Serialization.ProcedureBase_v1.Ordinal -> int
Reko.Core.Serialization.ProcedureBase_v1.ProcedureBase_v1() -> void
Reko.Core.Serialization.ProcedureBase_v1.Signature -> Reko.Core.Serialization.SerializedSignature
Reko.Core.Serialization.ProcedureCharacteristics
Reko.Core.Serialization.ProcedureCharacteristics.Allocator.get -> bool
Reko.Core.Serialization.ProcedureCharacteristics.Allocator.set -> void
Reko.Core.Serialization.ProcedureCharacteristics.ArraySize.get -> Reko.Core.Serialization.ArraySizeCharacteristic
Reko.Core.Serialization.ProcedureCharacteristics.ArraySize.set -> void
Reko.Core.Serialization.ProcedureCharacteristics.IsDefaultCharactaristics.get -> bool
Reko.Core.Serialization.ProcedureCharacteristics.ProcedureCharacteristics() -> void
Reko.Core.Serialization.ProcedureCharacteristics.ProcedureCharacteristics(Reko.Core.Serialization.ProcedureCharacteristics old) -> void
Reko.Core.Serialization.ProcedureCharacteristics.ReturnAddressAdjustment.get -> int
Reko.Core.Serialization.ProcedureCharacteristics.ReturnAddressAdjustment.set -> void
Reko.Core.Serialization.ProcedureSerializer
Reko.Core.Serialization.ProcedureSerializer.ApplyConvention(Reko.Core.Serialization.SerializedSignature ssig, Reko.Core.Types.FunctionType sig) -> void
Reko.Core.Serialization.ProcedureSerializer.Architecture.get -> Reko.Core.IProcessorArchitecture
Reko.Core.Serialization.ProcedureSerializer.CreateId(string name, Reko.Core.Types.DataType type, Reko.Core.Storage storage) -> Reko.Core.Expressions.Identifier
Reko.Core.Serialization.ProcedureSerializer.DefaultConvention.get -> string
Reko.Core.Serialization.ProcedureSerializer.DefaultConvention.set -> void
Reko.Core.Serialization.ProcedureSerializer.Deserialize(Reko.Core.Serialization.SerializedSignature ss, Reko.Core.Frame frame) -> Reko.Core.Types.FunctionType
Reko.Core.Serialization.ProcedureSerializer.DeserializeArgument(Reko.Core.Serialization.Argument_v1 arg, string convention) -> Reko.Core.Expressions.Identifier
Reko.Core.Serialization.ProcedureSerializer.FpuStackGrowing.get -> bool
Reko.Core.Serialization.ProcedureSerializer.FpuStackGrowing.set -> void
Reko.Core.Serialization.ProcedureSerializer.FpuStackOffset.get -> int
Reko.Core.Serialization.ProcedureSerializer.FpuStackOffset.set -> void
Reko.Core.Serialization.ProcedureSerializer.FpuStackShrinking.get -> bool
Reko.Core.Serialization.ProcedureSerializer.IsVariadic.get -> bool
Reko.Core.Serialization.ProcedureSerializer.IsVariadic.set -> void
Reko.Core.Serialization.ProcedureSerializer.ProcedureSerializer(Reko.Core.IPlatform platform, Reko.Core.Serialization.ISerializedTypeVisitor<Reko.Core.Types.DataType> typeLoader, string defaultConvention) -> void
Reko.Core.Serialization.ProcedureSerializer.Serialize(Reko.Core.Procedure proc, Reko.Core.Address addr) -> Reko.Core.Serialization.Procedure_v1
Reko.Core.Serialization.ProcedureSerializer.Serialize(Reko.Core.Types.FunctionType sig) -> Reko.Core.Serialization.SerializedSignature
Reko.Core.Serialization.ProcedureSerializer.StackOffset.get -> int
Reko.Core.Serialization.ProcedureSerializer.StackOffset.set -> void
Reko.Core.Serialization.ProcedureSerializer.TypeLoader.get -> Reko.Core.Serialization.ISerializedTypeVisitor<Reko.Core.Types.DataType>
Reko.Core.Serialization.Procedure_v1
Reko.Core.Serialization.Procedure_v1.Address -> string
Reko.Core.Serialization.Procedure_v1.Assume -> Reko.Core.Serialization.RegisterValue_v2[]
Reko.Core.Serialization.Procedure_v1.CSignature -> string
Reko.Core.Serialization.Procedure_v1.Decompile -> bool
Reko.Core.Serialization.Procedure_v1.OutputFile -> string
Reko.Core.Serialization.Procedure_v1.Procedure_v1() -> void
Reko.Core.Serialization.ProcessorOptions_v4
Reko.Core.Serialization.ProcessorOptions_v4.Name -> string
Reko.Core.Serialization.ProcessorOptions_v4.Options -> System.Xml.XmlElement[]
Reko.Core.Serialization.ProcessorOptions_v4.ProcessorOptions_v4() -> void
Reko.Core.Serialization.ProgramEventArgs
Reko.Core.Serialization.ProgramEventArgs.Program.get -> Reko.Core.Program
Reko.Core.Serialization.ProgramEventArgs.ProgramEventArgs(Reko.Core.Program program) -> void
Reko.Core.Serialization.ProgramOptions_v2
Reko.Core.Serialization.ProgramOptions_v2.HeuristicScanning -> bool
Reko.Core.Serialization.ProgramOptions_v2.ProgramOptions_v2() -> void
Reko.Core.Serialization.ProjectLoader
Reko.Core.Serialization.ProjectLoader.LoadMetadataFile(Reko.Core.ImageLocation metadataUri) -> Reko.Core.MetadataFile
Reko.Core.Serialization.ProjectLoader.LoadProject() -> Reko.Core.Project
Reko.Core.Serialization.ProjectLoader.LoadProject(byte[] image) -> Reko.Core.Project
Reko.Core.Serialization.ProjectLoader.LoadProject(Reko.Core.Serialization.Project_v4 sp) -> Reko.Core.Project
Reko.Core.Serialization.ProjectLoader.LoadProject(Reko.Core.Serialization.Project_v5 sp) -> Reko.Core.Project
Reko.Core.Serialization.ProjectLoader.LoadProject(System.IO.Stream stm) -> Reko.Core.Project
Reko.Core.Serialization.ProjectLoader.LoadUserData(Reko.Core.Serialization.UserData_v4 sUser, Reko.Core.Program program, Reko.Core.UserData user, Reko.Core.ImageLocation projectLocation) -> void
Reko.Core.Serialization.ProjectLoader.LoadUserSegment_v4(Reko.Core.Serialization.Segment_v4 sSegment) -> Reko.Core.UserSegment
Reko.Core.Serialization.ProjectLoader.ProgramLoaded -> System.EventHandler<Reko.Core.Serialization.ProgramEventArgs>
Reko.Core.Serialization.ProjectLoader.ProjectLoader(System.IServiceProvider services, Reko.Core.Loading.ILoader loader, Reko.Core.ImageLocation location, Reko.Core.Services.DecompilerEventListener listener) -> void
Reko.Core.Serialization.ProjectLoader.ProjectLoader(System.IServiceProvider services, Reko.Core.Loading.ILoader loader, Reko.Core.Project project, Reko.Core.Services.DecompilerEventListener listener) -> void
Reko.Core.Serialization.ProjectLoader.VisitAssemblerFile(Reko.Core.Serialization.AssemblerFile_v3 sAsmFile) -> Reko.Core.Program
Reko.Core.Serialization.ProjectLoader.VisitInputFile(Reko.Core.Serialization.DecompilerInput_v5 sInput) -> Reko.Core.Program
Reko.Core.Serialization.ProjectLoader.VisitMetadataFile(Reko.Core.Serialization.MetadataFile_v3 sMetadata) -> Reko.Core.MetadataFile
Reko.Core.Serialization.ProjectLoader.VisitScriptFile(Reko.Core.Serialization.ScriptFile_v5 sScript) -> Reko.Core.Scripts.ScriptFile
Reko.Core.Serialization.ProjectPersister
Reko.Core.Serialization.ProjectPersister.ConvertToProjectRelativePath(string! projectAbsPath, string! absPath) -> string!
Reko.Core.Serialization.ProjectPersister.ConvertToProjectRelativeUri(Reko.Core.ImageLocation! projectUri, Reko.Core.ImageLocation? absoluteUri) -> string?
Reko.Core.Serialization.ProjectPersister.ProjectPersister(System.IServiceProvider! services) -> void
Reko.Core.Serialization.ProjectPersister.Services.get -> System.IServiceProvider!
Reko.Core.Serialization.ProjectSaver
Reko.Core.Serialization.ProjectSaver.ProjectSaver(System.IServiceProvider services) -> void
Reko.Core.Serialization.ProjectSaver.Save(Reko.Core.Serialization.Project_v5 sProject, System.Xml.XmlWriter xw) -> void
Reko.Core.Serialization.ProjectSaver.Serialize(Reko.Core.ImageLocation projectLocation, Reko.Core.Project project) -> Reko.Core.Serialization.Project_v5
Reko.Core.Serialization.ProjectSaver.VisitMetadataFile(Reko.Core.ImageLocation projectLocation, Reko.Core.MetadataFile metadata) -> Reko.Core.Serialization.MetadataFile_v3
Reko.Core.Serialization.ProjectSaver.VisitProgram(Reko.Core.ImageLocation projectLocation, Reko.Core.Program program) -> Reko.Core.Serialization.DecompilerInput_v5
Reko.Core.Serialization.ProjectVersionMigrator
Reko.Core.Serialization.Project_v4
Reko.Core.Serialization.Project_v4.ArchitectureName -> string
Reko.Core.Serialization.Project_v4.AssemblerFiles -> System.Collections.Generic.List<Reko.Core.Serialization.AssemblerFile_v3>
Reko.Core.Serialization.Project_v4.InputFiles -> System.Collections.Generic.List<Reko.Core.Serialization.DecompilerInput_v4>
Reko.Core.Serialization.Project_v4.MetadataFiles -> System.Collections.Generic.List<Reko.Core.Serialization.MetadataFile_v3>
Reko.Core.Serialization.Project_v4.PlatformName -> string
Reko.Core.Serialization.Project_v4.Project_v4() -> void
Reko.Core.Serialization.Project_v5
Reko.Core.Serialization.Project_v5.ArchitectureName -> string
Reko.Core.Serialization.Project_v5.AssemblerFiles -> System.Collections.Generic.List<Reko.Core.Serialization.AssemblerFile_v3>
Reko.Core.Serialization.Project_v5.InputFiles -> System.Collections.Generic.List<Reko.Core.Serialization.DecompilerInput_v5>
Reko.Core.Serialization.Project_v5.MetadataFiles -> System.Collections.Generic.List<Reko.Core.Serialization.MetadataFile_v3>
Reko.Core.Serialization.Project_v5.PlatformName -> string
Reko.Core.Serialization.Project_v5.Project_v5() -> void
Reko.Core.Serialization.Project_v5.ScriptFiles -> System.Collections.Generic.List<Reko.Core.Serialization.ScriptFile_v5>
Reko.Core.Serialization.ReferenceType_v1
Reko.Core.Serialization.ReferenceType_v1.ReferenceType_v1() -> void
Reko.Core.Serialization.ReferenceType_v1.Referent -> Reko.Core.Serialization.SerializedType
Reko.Core.Serialization.ReferenceType_v1.Size -> int
Reko.Core.Serialization.RegisterValue_v2
Reko.Core.Serialization.RegisterValue_v2.Address -> string
Reko.Core.Serialization.RegisterValue_v2.Register -> string
Reko.Core.Serialization.RegisterValue_v2.RegisterValue_v2() -> void
Reko.Core.Serialization.RegisterValue_v2.Value -> string
Reko.Core.Serialization.Register_v1
Reko.Core.Serialization.Register_v1.Name -> string
Reko.Core.Serialization.Register_v1.Register_v1() -> void
Reko.Core.Serialization.Register_v1.Register_v1(string name) -> void
Reko.Core.Serialization.ScriptFile_v5
Reko.Core.Serialization.ScriptFile_v5.Filename -> string
Reko.Core.Serialization.ScriptFile_v5.Location -> string
Reko.Core.Serialization.ScriptFile_v5.ScriptFile_v5() -> void
Reko.Core.Serialization.Script_v2
Reko.Core.Serialization.Script_v2.ArchitectureId -> string
Reko.Core.Serialization.Script_v2.Enabled -> bool
Reko.Core.Serialization.Script_v2.Interpreter -> string
Reko.Core.Serialization.Script_v2.Script -> string
Reko.Core.Serialization.Script_v2.Script_v2() -> void
Reko.Core.Serialization.Segment_v4
Reko.Core.Serialization.Segment_v4.Access -> string
Reko.Core.Serialization.Segment_v4.Address -> string
Reko.Core.Serialization.Segment_v4.Architecture -> string
Reko.Core.Serialization.Segment_v4.Length -> string
Reko.Core.Serialization.Segment_v4.Name -> string
Reko.Core.Serialization.Segment_v4.Offset -> string
Reko.Core.Serialization.Segment_v4.Segment_v4() -> void
Reko.Core.Serialization.SerializedCall_v1
Reko.Core.Serialization.SerializedCall_v1.Comment -> string
Reko.Core.Serialization.SerializedCall_v1.InstructionAddress -> string
Reko.Core.Serialization.SerializedCall_v1.NoReturn -> bool
Reko.Core.Serialization.SerializedCall_v1.SerializedCall_v1() -> void
Reko.Core.Serialization.SerializedCall_v1.SerializedCall_v1(Reko.Core.Address addr, Reko.Core.Serialization.SerializedSignature sig) -> void
Reko.Core.Serialization.SerializedCall_v1.Signature -> Reko.Core.Serialization.SerializedSignature
Reko.Core.Serialization.SerializedEnumType
Reko.Core.Serialization.SerializedEnumType.Domain -> Reko.Core.Types.Domain
Reko.Core.Serialization.SerializedEnumType.SerializedEnumType() -> void
Reko.Core.Serialization.SerializedEnumType.SerializedEnumType(int size, Reko.Core.Types.Domain domain, string p) -> void
Reko.Core.Serialization.SerializedEnumType.Size -> int
Reko.Core.Serialization.SerializedEnumType.Values -> Reko.Core.Serialization.SerializedEnumValue[]
Reko.Core.Serialization.SerializedEnumValue
Reko.Core.Serialization.SerializedEnumValue.Name -> string
Reko.Core.Serialization.SerializedEnumValue.SerializedEnumValue() -> void
Reko.Core.Serialization.SerializedEnumValue.Value -> int
Reko.Core.Serialization.SerializedKind
Reko.Core.Serialization.SerializedKind.SerializedKind() -> void
Reko.Core.Serialization.SerializedLibrary
Reko.Core.Serialization.SerializedLibrary.Case -> string
Reko.Core.Serialization.SerializedLibrary.Defaults -> Reko.Core.Serialization.SerializedLibraryDefaults
Reko.Core.Serialization.SerializedLibrary.Globals -> System.Collections.Generic.List<Reko.Core.Serialization.GlobalVariable_v1>
Reko.Core.Serialization.SerializedLibrary.ModuleName -> string
Reko.Core.Serialization.SerializedLibrary.Procedures -> System.Collections.Generic.List<Reko.Core.Serialization.ProcedureBase_v1>
Reko.Core.Serialization.SerializedLibrary.SerializedLibrary() -> void
Reko.Core.Serialization.SerializedLibrary.Types -> Reko.Core.Serialization.SerializedType[]
Reko.Core.Serialization.SerializedLibraryDefaults
Reko.Core.Serialization.SerializedLibraryDefaults.SerializedLibraryDefaults() -> void
Reko.Core.Serialization.SerializedLibraryDefaults.Signature -> Reko.Core.Serialization.SerializedSignature
Reko.Core.Serialization.SerializedProject
Reko.Core.Serialization.SerializedProject.SerializedProject() -> void
Reko.Core.Serialization.SerializedRegValue
Reko.Core.Serialization.SerializedRegValue.Register -> string
Reko.Core.Serialization.SerializedRegValue.SerializedRegValue() -> void
Reko.Core.Serialization.SerializedRegValue.SerializedRegValue(string reg, string val) -> void
Reko.Core.Serialization.SerializedRegValue.Value -> string
Reko.Core.Serialization.SerializedSequence
Reko.Core.Serialization.SerializedSequence.Registers -> Reko.Core.Serialization.Register_v1[]
Reko.Core.Serialization.SerializedSequence.SerializedSequence() -> void
Reko.Core.Serialization.SerializedSequence.SerializedSequence(Reko.Core.SequenceStorage seq) -> void
Reko.Core.Serialization.SerializedService
Reko.Core.Serialization.SerializedService.Address -> string
Reko.Core.Serialization.SerializedService.Build(Reko.Core.IPlatform platform, Reko.Core.TypeLibrary library) -> Reko.Core.SystemService
Reko.Core.Serialization.SerializedService.SerializedService() -> void
Reko.Core.Serialization.SerializedService.SyscallInfo -> Reko.Core.Serialization.SyscallInfo_v1
Reko.Core.Serialization.SerializedSignature
Reko.Core.Serialization.SerializedSignature.Arguments -> Reko.Core.Serialization.Argument_v1[]
Reko.Core.Serialization.SerializedSignature.Convention -> string
Reko.Core.Serialization.SerializedSignature.EnclosingType -> Reko.Core.Serialization.SerializedType
Reko.Core.Serialization.SerializedSignature.FpuStackDelta -> int
Reko.Core.Serialization.SerializedSignature.IsInstanceMethod -> bool
Reko.Core.Serialization.SerializedSignature.ParametersValid -> bool
Reko.Core.Serialization.SerializedSignature.ReturnAddressOnStack -> int
Reko.Core.Serialization.SerializedSignature.ReturnValue -> Reko.Core.Serialization.Argument_v1
Reko.Core.Serialization.SerializedSignature.SerializedSignature() -> void
Reko.Core.Serialization.SerializedSignature.StackDelta -> int
Reko.Core.Serialization.SerializedTaggedType
Reko.Core.Serialization.SerializedTaggedType.Name -> string
Reko.Core.Serialization.SerializedTaggedType.SerializedTaggedType() -> void
Reko.Core.Serialization.SerializedTemplate
Reko.Core.Serialization.SerializedTemplate.Name -> string
Reko.Core.Serialization.SerializedTemplate.Scope -> string[]
Reko.Core.Serialization.SerializedTemplate.SerializedTemplate(string[] scope, string name, Reko.Core.Serialization.SerializedType[] typeArguments) -> void
Reko.Core.Serialization.SerializedTemplate.TypeArguments -> Reko.Core.Serialization.SerializedType[]
Reko.Core.Serialization.SerializedType
Reko.Core.Serialization.SerializedType.Qualifier -> Reko.Core.Types.Qualifier
Reko.Core.Serialization.SerializedType.SerializedType() -> void
Reko.Core.Serialization.SerializedType.WriteQualifier(Reko.Core.Types.Qualifier q, System.Text.StringBuilder sb) -> void
Reko.Core.Serialization.SerializedTypedef
Reko.Core.Serialization.SerializedTypedef.DataType -> Reko.Core.Serialization.SerializedType
Reko.Core.Serialization.SerializedTypedef.Name -> string
Reko.Core.Serialization.SerializedTypedef.SerializedTypedef() -> void
Reko.Core.Serialization.StackValue_v1
Reko.Core.Serialization.StackValue_v1.Offset -> string
Reko.Core.Serialization.StackValue_v1.StackValue_v1() -> void
Reko.Core.Serialization.StackValue_v1.Value -> string
Reko.Core.Serialization.StackVariable_v1
Reko.Core.Serialization.StackVariable_v1.StackVariable_v1() -> void
Reko.Core.Serialization.StringType_v2
Reko.Core.Serialization.StringType_v2.CharType -> Reko.Core.Serialization.SerializedType
Reko.Core.Serialization.StringType_v2.StringType_v2() -> void
Reko.Core.Serialization.StringType_v2.Termination -> string
Reko.Core.Serialization.StructField_v1
Reko.Core.Serialization.StructField_v1.Name -> string
Reko.Core.Serialization.StructField_v1.Offset -> int
Reko.Core.Serialization.StructField_v1.StructField_v1() -> void
Reko.Core.Serialization.StructField_v1.StructField_v1(int offset, string name, Reko.Core.Serialization.SerializedType type) -> void
Reko.Core.Serialization.StructField_v1.Type -> Reko.Core.Serialization.SerializedType
Reko.Core.Serialization.StructType_v1
Reko.Core.Serialization.StructType_v1.ByteSize -> int
Reko.Core.Serialization.StructType_v1.Fields -> Reko.Core.Serialization.StructField_v1[]
Reko.Core.Serialization.StructType_v1.ForceStructure -> bool
Reko.Core.Serialization.StructType_v1.StructType_v1() -> void
Reko.Core.Serialization.SyscallInfo_v1
Reko.Core.Serialization.SyscallInfo_v1.Build(Reko.Core.IPlatform platform) -> Reko.Core.SyscallInfo
Reko.Core.Serialization.SyscallInfo_v1.RegisterValues -> Reko.Core.Serialization.SerializedRegValue[]
Reko.Core.Serialization.SyscallInfo_v1.StackValues -> Reko.Core.Serialization.StackValue_v1[]
Reko.Core.Serialization.SyscallInfo_v1.SyscallInfo_v1() -> void
Reko.Core.Serialization.SyscallInfo_v1.Vector -> string
Reko.Core.Serialization.TypeLibraryEventArgs
Reko.Core.Serialization.TypeLibraryEventArgs.TypeLibrary.get -> Reko.Core.TypeLibrary
Reko.Core.Serialization.TypeLibraryEventArgs.TypeLibraryEventArgs(Reko.Core.TypeLibrary typelib) -> void
Reko.Core.Serialization.TypeReference_v1
Reko.Core.Serialization.TypeReference_v1.Scope -> string[]
Reko.Core.Serialization.TypeReference_v1.TypeArguments -> Reko.Core.Serialization.SerializedType[]
Reko.Core.Serialization.TypeReference_v1.TypeName -> string
Reko.Core.Serialization.TypeReference_v1.TypeReference_v1() -> void
Reko.Core.Serialization.TypeReference_v1.TypeReference_v1(string typeName) -> void
Reko.Core.Serialization.TypeReference_v1.TypeReference_v1(string[] scope, string typeName) -> void
Reko.Core.Serialization.TypeReference_v1.TypeReference_v1(string[] scope, string typeName, Reko.Core.Serialization.SerializedType[] typeArgs) -> void
Reko.Core.Serialization.UnionAlternative_v1
Reko.Core.Serialization.UnionAlternative_v1.Name -> string
Reko.Core.Serialization.UnionAlternative_v1.Type -> Reko.Core.Serialization.SerializedType
Reko.Core.Serialization.UnionAlternative_v1.UnionAlternative_v1() -> void
Reko.Core.Serialization.UnionAlternative_v1.UnionAlternative_v1(string name, Reko.Core.Serialization.SerializedType type) -> void
Reko.Core.Serialization.UnionType_v1
Reko.Core.Serialization.UnionType_v1.Alternatives -> Reko.Core.Serialization.UnionAlternative_v1[]
Reko.Core.Serialization.UnionType_v1.ByteSize -> int
Reko.Core.Serialization.UnionType_v1.UnionType_v1() -> void
Reko.Core.Serialization.UnpackerSignatureFile_v1
Reko.Core.Serialization.UnpackerSignatureFile_v1.Signatures -> Reko.Core.Serialization.UnpackerSignature_v1[]
Reko.Core.Serialization.UnpackerSignatureFile_v1.UnpackerSignatureFile_v1() -> void
Reko.Core.Serialization.UnpackerSignature_v1
Reko.Core.Serialization.UnpackerSignature_v1.Comments -> string
Reko.Core.Serialization.UnpackerSignature_v1.EntirePE -> string
Reko.Core.Serialization.UnpackerSignature_v1.EntryPoint -> string
Reko.Core.Serialization.UnpackerSignature_v1.Name -> string
Reko.Core.Serialization.UnpackerSignature_v1.UnpackerSignature_v1() -> void
Reko.Core.Serialization.UserData_v4
Reko.Core.Serialization.UserData_v4.AggressiveBranchRemoval -> bool
Reko.Core.Serialization.UserData_v4.Annotations -> System.Collections.Generic.List<Reko.Core.Serialization.Annotation_v3>
Reko.Core.Serialization.UserData_v4.BlockLabels -> System.Collections.Generic.List<Reko.Core.Serialization.BlockLabel_v1>
Reko.Core.Serialization.UserData_v4.Calls -> System.Collections.Generic.List<Reko.Core.Serialization.SerializedCall_v1>
Reko.Core.Serialization.UserData_v4.ExtractResources -> bool
Reko.Core.Serialization.UserData_v4.GlobalData -> System.Collections.Generic.List<Reko.Core.Serialization.GlobalDataItem_v2>
Reko.Core.Serialization.UserData_v4.Heuristics -> System.Collections.Generic.List<Reko.Core.Serialization.Heuristic_v3>
Reko.Core.Serialization.UserData_v4.IndirectJumps -> System.Collections.Generic.List<Reko.Core.Serialization.IndirectJump_v4>
Reko.Core.Serialization.UserData_v4.JumpTables -> System.Collections.Generic.List<Reko.Core.Serialization.JumpTable_v4>
Reko.Core.Serialization.UserData_v4.LoadAddress -> string
Reko.Core.Serialization.UserData_v4.Loader -> string
Reko.Core.Serialization.UserData_v4.OnLoadedScript -> Reko.Core.Serialization.Script_v2
Reko.Core.Serialization.UserData_v4.OutputFilePolicy -> string
Reko.Core.Serialization.UserData_v4.PlatformOptions -> Reko.Core.Serialization.PlatformOptions_v4
Reko.Core.Serialization.UserData_v4.Procedures -> System.Collections.Generic.List<Reko.Core.Serialization.Procedure_v1>
Reko.Core.Serialization.UserData_v4.Processor -> Reko.Core.Serialization.ProcessorOptions_v4
Reko.Core.Serialization.UserData_v4.RegisterValues -> Reko.Core.Serialization.RegisterValue_v2[]
Reko.Core.Serialization.UserData_v4.Segments -> System.Collections.Generic.List<Reko.Core.Serialization.Segment_v4>
Reko.Core.Serialization.UserData_v4.ShowAddressesInDisassembly -> bool
Reko.Core.Serialization.UserData_v4.ShowBytesInDisassembly -> bool
Reko.Core.Serialization.UserData_v4.TextEncoding -> string
Reko.Core.Serialization.UserData_v4.UserData_v4() -> void
Reko.Core.Serialization.VoidType_v1
Reko.Core.Serialization.VoidType_v1.VoidType_v1() -> void
Reko.Core.Services.DecompilerEventListener
Reko.Core.Services.DecompilerEventListener.Advance(int count) -> void
Reko.Core.Services.DecompilerEventListener.CreateAddressNavigator(Reko.Core.Program! program, Reko.Core.Address! address) -> Reko.Core.ICodeLocation!
Reko.Core.Services.DecompilerEventListener.CreateBlockNavigator(Reko.Core.Program! program, Reko.Core.Block! block) -> Reko.Core.ICodeLocation!
Reko.Core.Services.DecompilerEventListener.CreateJumpTableNavigator(Reko.Core.Program! program, Reko.Core.IProcessorArchitecture! arch, Reko.Core.Address! addrIndirectJump, Reko.Core.Address? addrVector, int stride) -> Reko.Core.ICodeLocation!
Reko.Core.Services.DecompilerEventListener.CreateProcedureNavigator(Reko.Core.Program! program, Reko.Core.Procedure! proc) -> Reko.Core.ICodeLocation!
Reko.Core.Services.DecompilerEventListener.CreateStatementNavigator(Reko.Core.Program! program, Reko.Core.Statement! stm) -> Reko.Core.ICodeLocation!
Reko.Core.Services.DecompilerEventListener.Error(Reko.Core.ICodeLocation! location, string! message) -> void
Reko.Core.Services.DecompilerEventListener.Error(Reko.Core.ICodeLocation! location, string! message, params object![]! args) -> void
Reko.Core.Services.DecompilerEventListener.Error(Reko.Core.ICodeLocation! location, System.Exception! ex, string! message) -> void
Reko.Core.Services.DecompilerEventListener.Error(Reko.Core.ICodeLocation! location, System.Exception! ex, string! message, params object![]! args) -> void
Reko.Core.Services.DecompilerEventListener.Error(Reko.Core.Scripts.ScriptError! scriptError) -> void
Reko.Core.Services.DecompilerEventListener.Error(string! message) -> void
Reko.Core.Services.DecompilerEventListener.Error(string! message, params object![]! args) -> void
Reko.Core.Services.DecompilerEventListener.Error(System.Exception! ex, string! message) -> void
Reko.Core.Services.DecompilerEventListener.Error(System.Exception! ex, string! message, params object![]! args) -> void
Reko.Core.Services.DecompilerEventListener.Info(Reko.Core.ICodeLocation! location, string! message) -> void
Reko.Core.Services.DecompilerEventListener.Info(Reko.Core.ICodeLocation! location, string! message, params object![]! args) -> void
Reko.Core.Services.DecompilerEventListener.Info(string! message) -> void
Reko.Core.Services.DecompilerEventListener.Info(string! message, params object![]! args) -> void
Reko.Core.Services.DecompilerEventListener.IsCanceled() -> bool
Reko.Core.Services.DecompilerEventListener.ShowProgress(string! caption, int numerator, int denominator) -> void
Reko.Core.Services.DecompilerEventListener.ShowStatus(string! caption) -> void
Reko.Core.Services.DecompilerEventListener.Warn(Reko.Core.ICodeLocation! location, string! message) -> void
Reko.Core.Services.DecompilerEventListener.Warn(Reko.Core.ICodeLocation! location, string! message, params object![]! args) -> void
Reko.Core.Services.DecompilerEventListener.Warn(string! message) -> void
Reko.Core.Services.DecompilerEventListener.Warn(string! message, params object![]! args) -> void
Reko.Core.Services.FileSystemServiceImpl
Reko.Core.Services.FileSystemServiceImpl.AppendAllText(string path, string contents) -> void
Reko.Core.Services.FileSystemServiceImpl.CopyFile(string sourceFileName, string destFileName, bool overwrite) -> void
Reko.Core.Services.FileSystemServiceImpl.CreateDirectory(string dirPath) -> void
Reko.Core.Services.FileSystemServiceImpl.CreateFileStream(string filename, System.IO.FileMode mode) -> System.IO.Stream
Reko.Core.Services.FileSystemServiceImpl.CreateFileStream(string filename, System.IO.FileMode mode, System.IO.FileAccess access) -> System.IO.Stream
Reko.Core.Services.FileSystemServiceImpl.CreateFileStream(string filename, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share) -> System.IO.Stream
Reko.Core.Services.FileSystemServiceImpl.CreateStreamReader(string filename, System.Text.Encoding enc) -> System.IO.TextReader
Reko.Core.Services.FileSystemServiceImpl.CreateStreamWriter(string filename, bool append, System.Text.Encoding enc) -> System.IO.TextWriter
Reko.Core.Services.FileSystemServiceImpl.CreateXmlWriter(string filename) -> System.Xml.XmlWriter
Reko.Core.Services.FileSystemServiceImpl.DeleteFile(string filePath) -> void
Reko.Core.Services.FileSystemServiceImpl.FileExists(string filePath) -> bool
Reko.Core.Services.FileSystemServiceImpl.FileSystemServiceImpl() -> void
Reko.Core.Services.FileSystemServiceImpl.FileSystemServiceImpl(char sepChar) -> void
Reko.Core.Services.FileSystemServiceImpl.GetCurrentDirectory() -> string
Reko.Core.Services.FileSystemServiceImpl.GetFiles(string directory, string pattern) -> string[]
Reko.Core.Services.FileSystemServiceImpl.IsPathRooted(string path) -> bool
Reko.Core.Services.FileSystemServiceImpl.MakeRelativePath(string fromPath, string toPath) -> string
Reko.Core.Services.FileSystemServiceImpl.ReadAllBytes(string filePath) -> byte[]
Reko.Core.Services.FileSystemServiceImpl.WriteAllBytes(string filePath, byte[] bytes) -> void
Reko.Core.Services.FileSystemServiceImpl.WriteAllText(string filePath, string contents) -> void
Reko.Core.Services.IDecompilerUIService
Reko.Core.Services.IDecompilerUIService.Prompt(string prompt) -> System.Threading.Tasks.ValueTask<bool>
Reko.Core.Services.IDecompilerUIService.ShowError(System.Exception ex, string format, params object[] args) -> System.Threading.Tasks.ValueTask
Reko.Core.Services.IDecompilerUIService.ShowMessage(string msg) -> System.Threading.Tasks.ValueTask
Reko.Core.Services.IDecompilerUIService.ShowOpenFileDialog(string fileName) -> System.Threading.Tasks.ValueTask<string>
Reko.Core.Services.IDecompilerUIService.ShowSaveFileDialog(string fileName) -> System.Threading.Tasks.ValueTask<string>
Reko.Core.Services.IFileSystemService
Reko.Core.Services.IFileSystemService.AppendAllText(string filename, string v) -> void
Reko.Core.Services.IFileSystemService.CopyFile(string sourceFileName, string destFileName, bool overwrite) -> void
Reko.Core.Services.IFileSystemService.CreateDirectory(string dirPath) -> void
Reko.Core.Services.IFileSystemService.CreateFileStream(string filename, System.IO.FileMode mode, System.IO.FileAccess access) -> System.IO.Stream
Reko.Core.Services.IFileSystemService.CreateFileStream(string filename, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share) -> System.IO.Stream
Reko.Core.Services.IFileSystemService.CreateStreamReader(string fileLocation, System.Text.Encoding enc) -> System.IO.TextReader
Reko.Core.Services.IFileSystemService.CreateStreamWriter(string filename, bool append, System.Text.Encoding enc) -> System.IO.TextWriter
Reko.Core.Services.IFileSystemService.CreateXmlWriter(string filename) -> System.Xml.XmlWriter
Reko.Core.Services.IFileSystemService.DeleteFile(string filename) -> void
Reko.Core.Services.IFileSystemService.FileExists(string filePath) -> bool
Reko.Core.Services.IFileSystemService.GetCurrentDirectory() -> string
Reko.Core.Services.IFileSystemService.GetFiles(string dir, string v) -> string[]
Reko.Core.Services.IFileSystemService.IsPathRooted(string path) -> bool
Reko.Core.Services.IFileSystemService.MakeRelativePath(string fromPath, string toPath) -> string
Reko.Core.Services.IFileSystemService.ReadAllBytes(string filePath) -> byte[]
Reko.Core.Services.IFileSystemService.WriteAllBytes(string path, byte[] bytes) -> void
Reko.Core.Services.IFileSystemService.WriteAllText(string filename, string header) -> void
Reko.Core.Services.IOutputService
Reko.Core.Services.IOutputService.EnsureOutputSource(string sourceName) -> System.IO.TextWriter
Reko.Core.Services.IPluginLoaderService
Reko.Core.Services.IPluginLoaderService.GetType(string fullyQualifiedName) -> System.Type
Reko.Core.Services.ISymbolLoadingService
Reko.Core.Services.ISymbolLoadingService.GetSymbolSource(string filename) -> Reko.Core.Loading.ISymbolSource
Reko.Core.Services.ISymbolLoadingService.GetSymbolSources() -> System.Collections.Generic.List<Reko.Core.Configuration.SymbolSourceDefinition>
Reko.Core.Services.ITestGenerationService
Reko.Core.Services.ITestGenerationService.OutputDirectory.get -> string
Reko.Core.Services.ITestGenerationService.OutputDirectory.set -> void
Reko.Core.Services.ITestGenerationService.RemoveFiles(string filePrefix) -> void
Reko.Core.Services.ITestGenerationService.ReportMissingDecoder(string testPrefix, Reko.Core.Address addrStart, Reko.Core.Memory.EndianImageReader rdr, string message, System.Func<byte[], string> hexize = null) -> void
Reko.Core.Services.ITestGenerationService.ReportMissingDecoder(string testPrefix, Reko.Core.Address addrStart, string message, string opcodeAsText) -> void
Reko.Core.Services.ITestGenerationService.ReportMissingRewriter(string testPrefix, Reko.Core.Machine.MachineInstruction instr, string mnemonic, Reko.Core.Memory.EndianImageReader rdr, string message, string opcodeAsText) -> void
Reko.Core.Services.ITestGenerationService.ReportMissingRewriter(string testPrefix, Reko.Core.Machine.MachineInstruction instr, string mnemonic, Reko.Core.Memory.EndianImageReader rdr, string message, System.Func<byte[], string> hexize = null) -> void
Reko.Core.Services.ITestGenerationService.ReportProcedure(string fileName, string testCaption, Reko.Core.Procedure proc) -> void
Reko.Core.Services.ITypeLibraryLoaderService
Reko.Core.Services.ITypeLibraryLoaderService.InstalledFileLocation(string name) -> string
Reko.Core.Services.ITypeLibraryLoaderService.LoadCharacteristics(string name) -> Reko.Core.CharacteristicsLibrary
Reko.Core.Services.ITypeLibraryLoaderService.LoadMetadataIntoLibrary(Reko.Core.IPlatform platform, Reko.Core.Configuration.TypeLibraryDefinition tlElement, Reko.Core.TypeLibrary libDst) -> Reko.Core.TypeLibrary
Reko.Core.Services.IUnpackerService
Reko.Core.Services.IUnpackerService.FindUnpackerBySignature(Reko.Core.Loading.ProgramImageLoader imageLoader, uint entryPointOffset) -> Reko.Core.Loading.ProgramImageLoader
Reko.Core.Services.NullCodeLocation
Reko.Core.Services.NullCodeLocation.NavigateTo() -> System.Threading.Tasks.ValueTask
Reko.Core.Services.NullCodeLocation.NullCodeLocation(string! text) -> void
Reko.Core.Services.NullCodeLocation.Text.get -> string!
Reko.Core.Services.NullDecompilerEventListener
Reko.Core.Services.NullDecompilerEventListener.AddDiagnostic(Reko.Core.Diagnostic d) -> void
Reko.Core.Services.NullDecompilerEventListener.AddDiagnostic(Reko.Core.ICodeLocation location, Reko.Core.Diagnostic d) -> void
Reko.Core.Services.NullDecompilerEventListener.Advance(int advance) -> void
Reko.Core.Services.NullDecompilerEventListener.CreateAddressNavigator(Reko.Core.Program program, Reko.Core.Address address) -> Reko.Core.ICodeLocation
Reko.Core.Services.NullDecompilerEventListener.CreateBlockNavigator(Reko.Core.Program program, Reko.Core.Block block) -> Reko.Core.ICodeLocation
Reko.Core.Services.NullDecompilerEventListener.CreateJumpTableNavigator(Reko.Core.Program _, Reko.Core.IProcessorArchitecture arch, Reko.Core.Address addrIndirectJump, Reko.Core.Address addrVector, int stride) -> Reko.Core.ICodeLocation
Reko.Core.Services.NullDecompilerEventListener.CreateProcedureNavigator(Reko.Core.Program program, Reko.Core.Procedure proc) -> Reko.Core.ICodeLocation
Reko.Core.Services.NullDecompilerEventListener.CreateStatementNavigator(Reko.Core.Program program, Reko.Core.Statement stm) -> Reko.Core.ICodeLocation
Reko.Core.Services.NullDecompilerEventListener.Error(Reko.Core.ICodeLocation location, string message) -> void
Reko.Core.Services.NullDecompilerEventListener.Error(Reko.Core.ICodeLocation location, string message, params object[] args) -> void
Reko.Core.Services.NullDecompilerEventListener.Error(Reko.Core.ICodeLocation location, System.Exception ex, string message) -> void
Reko.Core.Services.NullDecompilerEventListener.Error(Reko.Core.ICodeLocation location, System.Exception ex, string message, params object[] args) -> void
Reko.Core.Services.NullDecompilerEventListener.Error(Reko.Core.Scripts.ScriptError scriptError) -> void
Reko.Core.Services.NullDecompilerEventListener.Error(string message) -> void
Reko.Core.Services.NullDecompilerEventListener.Error(string message, params object[] args) -> void
Reko.Core.Services.NullDecompilerEventListener.Error(System.Exception ex, string message) -> void
Reko.Core.Services.NullDecompilerEventListener.Error(System.Exception ex, string message, params object[] args) -> void
Reko.Core.Services.NullDecompilerEventListener.Info(Reko.Core.ICodeLocation location, string message) -> void
Reko.Core.Services.NullDecompilerEventListener.Info(Reko.Core.ICodeLocation location, string message, params object[] args) -> void
Reko.Core.Services.NullDecompilerEventListener.Info(string message) -> void
Reko.Core.Services.NullDecompilerEventListener.Info(string message, params object[] args) -> void
Reko.Core.Services.NullDecompilerEventListener.IsCanceled() -> bool
Reko.Core.Services.NullDecompilerEventListener.NullDecompilerEventListener() -> void
Reko.Core.Services.NullDecompilerEventListener.ShowProgress(string caption, int numerator, int denominator) -> void
Reko.Core.Services.NullDecompilerEventListener.ShowStatus(string caption) -> void
Reko.Core.Services.NullDecompilerEventListener.Warn(Reko.Core.ICodeLocation location, string message) -> void
Reko.Core.Services.NullDecompilerEventListener.Warn(Reko.Core.ICodeLocation location, string message, params object[] args) -> void
Reko.Core.Services.NullDecompilerEventListener.Warn(string message) -> void
Reko.Core.Services.NullDecompilerEventListener.Warn(string message, params object[] args) -> void
Reko.Core.Services.PluginLoaderService
Reko.Core.Services.PluginLoaderService.GetType(string fullyQualifiedTypeName) -> System.Type
Reko.Core.Services.PluginLoaderService.PluginLoaderService() -> void
Reko.Core.Services.TypeLibraryLoaderServiceImpl
Reko.Core.Services.TypeLibraryLoaderServiceImpl.CreateLoader(Reko.Core.Configuration.TypeLibraryDefinition tlElement, Reko.Core.ImageLocation imageUri, byte[] bytes) -> Reko.Core.MetadataLoader
Reko.Core.Services.TypeLibraryLoaderServiceImpl.ImportFileLocation(string dllName) -> string
Reko.Core.Services.TypeLibraryLoaderServiceImpl.InstalledFileLocation(string name) -> string
Reko.Core.Services.TypeLibraryLoaderServiceImpl.LoadCharacteristics(string name) -> Reko.Core.CharacteristicsLibrary
Reko.Core.Services.TypeLibraryLoaderServiceImpl.LoadMetadataIntoLibrary(Reko.Core.IPlatform platform, Reko.Core.Configuration.TypeLibraryDefinition tlElement, Reko.Core.TypeLibrary libDst) -> Reko.Core.TypeLibrary
Reko.Core.Services.TypeLibraryLoaderServiceImpl.TypeLibraryLoaderServiceImpl(System.IServiceProvider services) -> void
Reko.Core.SignatureBuilder
Reko.Core.SignatureBuilder.AddFlagGroupReturnValue(System.Collections.Generic.KeyValuePair<Reko.Core.RegisterStorage, uint> bits, Reko.Core.IStorageBinder binder) -> void
Reko.Core.SignatureBuilder.AddFpuStackArgument(int x, Reko.Core.Expressions.Identifier id) -> void
Reko.Core.SignatureBuilder.AddInParam(Reko.Core.Expressions.Identifier arg) -> void
Reko.Core.SignatureBuilder.AddOutParam(Reko.Core.Expressions.Identifier idOrig) -> Reko.Core.Expressions.Identifier
Reko.Core.SignatureBuilder.AddRegisterArgument(Reko.Core.RegisterStorage reg) -> void
Reko.Core.SignatureBuilder.AddSequenceArgument(Reko.Core.SequenceStorage seq) -> void
Reko.Core.SignatureBuilder.BuildSignature() -> Reko.Core.Types.FunctionType
Reko.Core.SignatureBuilder.SignatureBuilder(Reko.Core.IStorageBinder binder, Reko.Core.IProcessorArchitecture arch) -> void
Reko.Core.StackStorage
Reko.Core.StackStorage.StackOffset.get -> int
Reko.Core.StackStorage.StackStorage(int offset, Reko.Core.Types.DataType dt) -> void
Reko.Core.StackValue
Reko.Core.StackValue.Offset -> int
Reko.Core.StackValue.StackValue() -> void
Reko.Core.StackValue.Value -> int
Reko.Core.Statement
Reko.Core.Statement.Block.get -> Reko.Core.Block
Reko.Core.Statement.Block.set -> void
Reko.Core.Statement.Instruction.get -> Reko.Core.Code.Instruction
Reko.Core.Statement.Instruction.set -> void
Reko.Core.Statement.LinearAddress.get -> ulong
Reko.Core.Statement.Statement(ulong linearAddress, Reko.Core.Code.Instruction instr, Reko.Core.Block block) -> void
Reko.Core.StatementCorrelatedException
Reko.Core.StatementCorrelatedException.Statement.get -> Reko.Core.Statement
Reko.Core.StatementCorrelatedException.StatementCorrelatedException(Reko.Core.Statement stm) -> void
Reko.Core.StatementCorrelatedException.StatementCorrelatedException(Reko.Core.Statement stm, string message) -> void
Reko.Core.StatementCorrelatedException.StatementCorrelatedException(Reko.Core.Statement stm, string message, System.Exception innerException) -> void
Reko.Core.StatementList
Reko.Core.StatementList.Add(ulong linearAddress, Reko.Core.Code.Instruction instr) -> Reko.Core.Statement
Reko.Core.StatementList.Insert(int position, ulong linearAddress, Reko.Core.Code.Instruction instr) -> Reko.Core.Statement
Reko.Core.StatementList.StatementList(Reko.Core.Block block) -> void
Reko.Core.Storage
Reko.Core.Storage.ArrayComparer
Reko.Core.Storage.ArrayComparer.ArrayComparer() -> void
Reko.Core.Storage.ArrayComparer.Equals(Reko.Core.Storage[] x, Reko.Core.Storage[] y) -> bool
Reko.Core.Storage.ArrayComparer.GetHashCode(Reko.Core.Storage[] obj) -> int
Reko.Core.Storage.BitAddress.get -> ulong
Reko.Core.Storage.BitAddress.set -> void
Reko.Core.Storage.DataType.get -> Reko.Core.Types.DataType
Reko.Core.Storage.Domain.get -> Reko.Core.StorageDomain
Reko.Core.Storage.Kind.get -> string
Reko.Core.Storage.Name.get -> string
Reko.Core.Storage.Storage(string storageKind, Reko.Core.StorageDomain domain, string name, Reko.Core.Types.DataType dataType) -> void
Reko.Core.StorageBinder
Reko.Core.StorageBinder.CreateTemporary(Reko.Core.Types.DataType dt) -> Reko.Core.Expressions.Identifier
Reko.Core.StorageBinder.CreateTemporary(string name, Reko.Core.Types.DataType dt) -> Reko.Core.Expressions.Identifier
Reko.Core.StorageBinder.EnsureFlagGroup(Reko.Core.FlagGroupStorage grf) -> Reko.Core.Expressions.Identifier
Reko.Core.StorageBinder.EnsureFlagGroup(Reko.Core.RegisterStorage flagRegister, uint flagGroupBits, string name, Reko.Core.Types.DataType dataType) -> Reko.Core.Expressions.Identifier
Reko.Core.StorageBinder.EnsureFpuStackVariable(int v, Reko.Core.Types.DataType dataType) -> Reko.Core.Expressions.Identifier
Reko.Core.StorageBinder.EnsureIdentifier(Reko.Core.Storage stg) -> Reko.Core.Expressions.Identifier
Reko.Core.StorageBinder.EnsureOutArgument(Reko.Core.Expressions.Identifier idOrig, Reko.Core.Types.DataType outArgumentPointer) -> Reko.Core.Expressions.Identifier
Reko.Core.StorageBinder.EnsureRegister(Reko.Core.RegisterStorage reg) -> Reko.Core.Expressions.Identifier
Reko.Core.StorageBinder.EnsureSequence(Reko.Core.SequenceStorage sequence) -> Reko.Core.Expressions.Identifier
Reko.Core.StorageBinder.EnsureSequence(Reko.Core.Types.DataType dataType, params Reko.Core.Storage[] elements) -> Reko.Core.Expressions.Identifier
Reko.Core.StorageBinder.EnsureSequence(Reko.Core.Types.DataType dataType, string name, params Reko.Core.Storage[] elements) -> Reko.Core.Expressions.Identifier
Reko.Core.StorageBinder.EnsureStackVariable(int offset, Reko.Core.Types.DataType dataType) -> Reko.Core.Expressions.Identifier
Reko.Core.StorageBinder.StorageBinder() -> void
Reko.Core.StorageDomain
Reko.Core.StorageDomain.FpuStack = 4098 -> Reko.Core.StorageDomain
Reko.Core.StorageDomain.Global = 8191 -> Reko.Core.StorageDomain
Reko.Core.StorageDomain.Memory = 4096 -> Reko.Core.StorageDomain
Reko.Core.StorageDomain.None = -1 -> Reko.Core.StorageDomain
Reko.Core.StorageDomain.Register = 0 -> Reko.Core.StorageDomain
Reko.Core.StorageDomain.Stack = 1073741824 -> Reko.Core.StorageDomain
Reko.Core.StorageDomain.SystemRegister = 8192 -> Reko.Core.StorageDomain
Reko.Core.StorageDomain.Temporary = -2147483648 -> Reko.Core.StorageDomain
Reko.Core.StorageFactory
Reko.Core.StorageFactory.DomainsToRegisters.get -> System.Collections.Generic.Dictionary<Reko.Core.StorageDomain, Reko.Core.RegisterStorage>
Reko.Core.StorageFactory.NamesToRegisters.get -> System.Collections.Generic.Dictionary<string, Reko.Core.RegisterStorage>
Reko.Core.StorageFactory.RangeOfReg(int count, System.Func<int, string> formatter, Reko.Core.Types.PrimitiveType size) -> Reko.Core.RegisterStorage[]
Reko.Core.StorageFactory.RangeOfReg32(int count, string format) -> Reko.Core.RegisterStorage[]
Reko.Core.StorageFactory.RangeOfReg64(int count, string format) -> Reko.Core.RegisterStorage[]
Reko.Core.StorageFactory.Reg(string format, Reko.Core.Types.PrimitiveType size) -> Reko.Core.RegisterStorage
Reko.Core.StorageFactory.Reg16(string format) -> Reko.Core.RegisterStorage
Reko.Core.StorageFactory.Reg32(string format) -> Reko.Core.RegisterStorage
Reko.Core.StorageFactory.Reg64(string format) -> Reko.Core.RegisterStorage
Reko.Core.StorageFactory.StorageFactory(Reko.Core.StorageDomain domain = Reko.Core.StorageDomain.Register) -> void
Reko.Core.StorageVisitor<T, C>
Reko.Core.StorageVisitor<T, C>.VisitFlagGroupStorage(Reko.Core.FlagGroupStorage grf, C context) -> T
Reko.Core.StorageVisitor<T, C>.VisitFpuStackStorage(Reko.Core.FpuStackStorage fpu, C context) -> T
Reko.Core.StorageVisitor<T, C>.VisitMemoryStorage(Reko.Core.MemoryStorage global, C context) -> T
Reko.Core.StorageVisitor<T, C>.VisitOutArgumentStorage(Reko.Core.OutArgumentStorage arg, C context) -> T
Reko.Core.StorageVisitor<T, C>.VisitRegisterStorage(Reko.Core.RegisterStorage reg, C context) -> T
Reko.Core.StorageVisitor<T, C>.VisitSequenceStorage(Reko.Core.SequenceStorage seq, C context) -> T
Reko.Core.StorageVisitor<T, C>.VisitStackStorage(Reko.Core.StackStorage stack, C context) -> T
Reko.Core.StorageVisitor<T, C>.VisitTemporaryStorage(Reko.Core.TemporaryStorage temp, C context) -> T
Reko.Core.StorageVisitor<T>
Reko.Core.StorageVisitor<T>.VisitFlagGroupStorage(Reko.Core.FlagGroupStorage! grf) -> T
Reko.Core.StorageVisitor<T>.VisitFpuStackStorage(Reko.Core.FpuStackStorage! fpu) -> T
Reko.Core.StorageVisitor<T>.VisitMemoryStorage(Reko.Core.MemoryStorage! global) -> T
Reko.Core.StorageVisitor<T>.VisitOutArgumentStorage(Reko.Core.OutArgumentStorage arg) -> T
Reko.Core.StorageVisitor<T>.VisitRegisterStorage(Reko.Core.RegisterStorage reg) -> T
Reko.Core.StorageVisitor<T>.VisitSequenceStorage(Reko.Core.SequenceStorage seq) -> T
Reko.Core.StorageVisitor<T>.VisitStackStorage(Reko.Core.StackStorage stack) -> T
Reko.Core.StorageVisitor<T>.VisitTemporaryStorage(Reko.Core.TemporaryStorage temp) -> T
Reko.Core.StridedInterval
Reko.Core.StridedInterval.IsEmpty.get -> bool
Reko.Core.StridedInterval.StridedInterval() -> void
Reko.Core.StringFieldAttribute
Reko.Core.StringFieldAttribute.NullTerminated -> bool
Reko.Core.StringFieldAttribute.StringFieldAttribute() -> void
Reko.Core.StructureMemberAttribute
Reko.Core.StructureMemberAttribute.MemberType.get -> System.Type
Reko.Core.StructureMemberAttribute.StructureMemberAttribute(System.Type memberType) -> void
Reko.Core.StructureReader<T>
Reko.Core.StructureReader<T>.Read() -> T
Reko.Core.StructureReader<T>.StructureReader(Reko.Core.Memory.ByteImageReader reader) -> void
Reko.Core.StructureReader<T>.StructureReader(System.Func<int, byte[]> readBytes) -> void
Reko.Core.StructureReader<T>.StructureReader(System.IO.BinaryReader reader) -> void
Reko.Core.SymbolType
Reko.Core.SymbolType.AddressSpace = 5 -> Reko.Core.SymbolType
Reko.Core.SymbolType.Code = 1 -> Reko.Core.SymbolType
Reko.Core.SymbolType.Data = 2 -> Reko.Core.SymbolType
Reko.Core.SymbolType.ExternalProcedure = 4 -> Reko.Core.SymbolType
Reko.Core.SymbolType.Procedure = 3 -> Reko.Core.SymbolType
Reko.Core.SymbolType.Table = 6 -> Reko.Core.SymbolType
Reko.Core.SymbolType.Unknown = 0 -> Reko.Core.SymbolType
Reko.Core.SyscallInfo
Reko.Core.SyscallInfo.Matches(int vector, Reko.Core.ProcessorState state) -> bool
Reko.Core.SyscallInfo.Matches(Reko.Core.ProcessorState state) -> bool
Reko.Core.SyscallInfo.RegisterValues -> Reko.Core.RegValue[]
Reko.Core.SyscallInfo.StackValues -> Reko.Core.StackValue[]
Reko.Core.SyscallInfo.SyscallInfo() -> void
Reko.Core.SyscallInfo.Vector -> int
Reko.Core.SystemService
Reko.Core.SystemService.Characteristics -> Reko.Core.Serialization.ProcedureCharacteristics
Reko.Core.SystemService.CreateExternalProcedure(Reko.Core.IProcessorArchitecture arch) -> Reko.Core.ExternalProcedure
Reko.Core.SystemService.ModuleName -> string
Reko.Core.SystemService.Name -> string
Reko.Core.SystemService.Signature -> Reko.Core.Types.FunctionType
Reko.Core.SystemService.SyscallInfo -> Reko.Core.SyscallInfo
Reko.Core.SystemService.SystemService() -> void
Reko.Core.TemporaryStorage
Reko.Core.TemporaryStorage.TemporaryStorage(string name, int number, Reko.Core.Types.DataType dt) -> void
Reko.Core.TemporaryStorage.TemporaryStorage(string name, Reko.Core.StorageDomain domain, Reko.Core.Types.DataType dt) -> void
Reko.Core.TreeMatching.TreeMatchAdapter
Reko.Core.TypedServiceProvider
Reko.Core.TypeInferenceException
Reko.Core.TypeInferenceException.TypeInferenceException(string fmt, params object[] args) -> void
Reko.Core.TypeInferenceException.TypeInferenceException(string msg) -> void
Reko.Core.TypeLibrary
Reko.Core.TypeLibrary.Characteristics.get -> System.Collections.Generic.IDictionary<string, Reko.Core.Serialization.ProcedureCharacteristics>
Reko.Core.TypeLibrary.Clone() -> Reko.Core.TypeLibrary
Reko.Core.TypeLibrary.GlobalsByAddress.get -> System.Collections.Generic.IDictionary<Reko.Core.Address!, Reko.Core.UserGlobal!>!
Reko.Core.TypeLibrary.ImportedGlobals.get -> System.Collections.Generic.IDictionary<string, Reko.Core.Types.DataType>
Reko.Core.TypeLibrary.Lookup(string procedureName) -> Reko.Core.Types.FunctionType
Reko.Core.TypeLibrary.LookupType(string typedefName) -> Reko.Core.Types.DataType
Reko.Core.TypeLibrary.Modules.get -> System.Collections.Generic.IDictionary<string, Reko.Core.ModuleDescriptor>
Reko.Core.TypeLibrary.Procedures.get -> System.Collections.Generic.IDictionary<Reko.Core.Address!, (string! Name, Reko.Core.Types.FunctionType! Signature)>!
Reko.Core.TypeLibrary.Signatures.get -> System.Collections.Generic.IDictionary<string, Reko.Core.Types.FunctionType>
Reko.Core.TypeLibrary.TypeLibrary(bool caseInsensitive = false) -> void
Reko.Core.TypeLibrary.TypeLibrary(bool caseInsensitive, System.Collections.Generic.IDictionary<string, Reko.Core.Types.DataType> types, System.Collections.Generic.IDictionary<string, Reko.Core.Types.FunctionType> procedures, System.Collections.Generic.IDictionary<string, Reko.Core.Serialization.ProcedureCharacteristics> characteristics, System.Collections.Generic.IDictionary<string, Reko.Core.Types.DataType> importedGlobals) -> void
Reko.Core.TypeLibrary.Types.get -> System.Collections.Generic.IDictionary<string!, Reko.Core.Types.DataType!>!
Reko.Core.TypeLibrary.Write(System.IO.TextWriter writer) -> void
Reko.Core.TypeLibraryDeserializer
Reko.Core.TypeLibraryDeserializer.Load(Reko.Core.Serialization.SerializedLibrary sLib) -> Reko.Core.TypeLibrary
Reko.Core.TypeLibraryDeserializer.LoadExternalProcedure(Reko.Core.Serialization.ProcedureBase_v1 sProc, Reko.Core.Serialization.ProcedureCharacteristics chr = null) -> Reko.Core.ExternalProcedure
Reko.Core.TypeLibraryDeserializer.LoadProcedure(Reko.Core.Serialization.Procedure_v1 sp) -> void
Reko.Core.TypeLibraryDeserializer.LoadService(int ordinal, Reko.Core.SystemService svc) -> void
Reko.Core.TypeLibraryDeserializer.LoadService(Reko.Core.Serialization.SerializedService ssvc) -> Reko.Core.SystemService
Reko.Core.TypeLibraryDeserializer.LoadService(string entryName, Reko.Core.SystemService svc) -> void
Reko.Core.TypeLibraryDeserializer.LoadType(Reko.Core.Serialization.SerializedType sType) -> Reko.Core.Types.DataType
Reko.Core.TypeLibraryDeserializer.ReadDefaults(Reko.Core.Serialization.SerializedLibraryDefaults defaults) -> void
Reko.Core.TypeLibraryDeserializer.SetModuleName(string libName) -> void
Reko.Core.TypeLibraryDeserializer.TypeLibraryDeserializer(Reko.Core.IPlatform platform, bool caseInsensitive, Reko.Core.TypeLibrary dstLib) -> void
Reko.Core.TypeLibraryDeserializer.VisitArray(Reko.Core.Serialization.ArrayType_v1 array) -> Reko.Core.Types.DataType
Reko.Core.TypeLibraryDeserializer.VisitCode(Reko.Core.Serialization.CodeType_v1 code) -> Reko.Core.Types.DataType
Reko.Core.TypeLibraryDeserializer.VisitEnum(Reko.Core.Serialization.SerializedEnumType enumType) -> Reko.Core.Types.DataType
Reko.Core.TypeLibraryDeserializer.VisitMemberPointer(Reko.Core.Serialization.MemberPointer_v1 memptr) -> Reko.Core.Types.DataType
Reko.Core.TypeLibraryDeserializer.VisitPointer(Reko.Core.Serialization.PointerType_v1 pointer) -> Reko.Core.Types.DataType
Reko.Core.TypeLibraryDeserializer.VisitPrimitive(Reko.Core.Serialization.PrimitiveType_v1 primitive) -> Reko.Core.Types.DataType
Reko.Core.TypeLibraryDeserializer.VisitReference(Reko.Core.Serialization.ReferenceType_v1 reference) -> Reko.Core.Types.DataType
Reko.Core.TypeLibraryDeserializer.VisitSignature(Reko.Core.Serialization.SerializedSignature sSig) -> Reko.Core.Types.DataType
Reko.Core.TypeLibraryDeserializer.VisitString(Reko.Core.Serialization.StringType_v2 str) -> Reko.Core.Types.DataType
Reko.Core.TypeLibraryDeserializer.VisitStructure(Reko.Core.Serialization.StructType_v1 structure) -> Reko.Core.Types.DataType
Reko.Core.TypeLibraryDeserializer.VisitTemplate(Reko.Core.Serialization.SerializedTemplate sTemplate) -> Reko.Core.Types.DataType
Reko.Core.TypeLibraryDeserializer.VisitTypedef(Reko.Core.Serialization.SerializedTypedef typedef) -> Reko.Core.Types.DataType
Reko.Core.TypeLibraryDeserializer.VisitTypeReference(Reko.Core.Serialization.TypeReference_v1 typeReference) -> Reko.Core.Types.DataType
Reko.Core.TypeLibraryDeserializer.VisitUnion(Reko.Core.Serialization.UnionType_v1 sUnion) -> Reko.Core.Types.DataType
Reko.Core.TypeLibraryDeserializer.VisitVoidType(Reko.Core.Serialization.VoidType_v1 voidType) -> Reko.Core.Types.DataType
Reko.Core.TypeLibraryLoader
Reko.Core.TypeLibraryLoader.TypeLibraryLoader(System.IServiceProvider services, Reko.Core.ImageLocation imageLocation, byte[] bytes) -> void
Reko.Core.TypeNamingPolicy
Reko.Core.TypeNamingPolicy.TypeNamingPolicy() -> void
Reko.Core.Types.ArrayType
Reko.Core.Types.ArrayType.ArrayType(Reko.Core.Types.DataType elType, int length) -> void
Reko.Core.Types.ArrayType.ElementType.get -> Reko.Core.Types.DataType
Reko.Core.Types.ArrayType.ElementType.set -> void
Reko.Core.Types.ArrayType.IsUnbounded.get -> bool
Reko.Core.Types.ArrayType.Length.get -> int
Reko.Core.Types.ArrayType.Length.set -> void
Reko.Core.Types.ClassBase
Reko.Core.Types.ClassBase.BaseType -> Reko.Core.Types.CompositeType
Reko.Core.Types.ClassBase.ClassBase() -> void
Reko.Core.Types.ClassBase.Protection -> Reko.Core.Types.ClassProtection
Reko.Core.Types.ClassField
Reko.Core.Types.ClassField.ClassField(Reko.Core.Types.DataType type) -> void
Reko.Core.Types.ClassField.DataType -> Reko.Core.Types.DataType
Reko.Core.Types.ClassMember
Reko.Core.Types.ClassMember.Attribute -> Reko.Core.Types.ClassMemberAttribute
Reko.Core.Types.ClassMember.ClassMember() -> void
Reko.Core.Types.ClassMember.Name.get -> string
Reko.Core.Types.ClassMember.Name.set -> void
Reko.Core.Types.ClassMember.Offset -> int
Reko.Core.Types.ClassMember.Protection -> Reko.Core.Types.ClassProtection
Reko.Core.Types.ClassMemberAttribute
Reko.Core.Types.ClassMemberAttribute.None = 0 -> Reko.Core.Types.ClassMemberAttribute
Reko.Core.Types.ClassMemberAttribute.Static = 2 -> Reko.Core.Types.ClassMemberAttribute
Reko.Core.Types.ClassMemberAttribute.Virtual = 1 -> Reko.Core.Types.ClassMemberAttribute
Reko.Core.Types.ClassMethod
Reko.Core.Types.ClassMethod.ClassMethod() -> void
Reko.Core.Types.ClassMethod.Procedure -> Reko.Core.ProcedureBase
Reko.Core.Types.ClassProtection
Reko.Core.Types.ClassProtection.Private = 0 -> Reko.Core.Types.ClassProtection
Reko.Core.Types.ClassProtection.Protected = 1 -> Reko.Core.Types.ClassProtection
Reko.Core.Types.ClassProtection.Public = 2 -> Reko.Core.Types.ClassProtection
Reko.Core.Types.ClassType
Reko.Core.Types.ClassType.Bases.get -> System.Collections.Generic.List<Reko.Core.Types.ClassBase>
Reko.Core.Types.ClassType.ClassType(string name = null) -> void
Reko.Core.Types.ClassType.Fields.get -> System.Collections.Generic.List<Reko.Core.Types.ClassField>
Reko.Core.Types.ClassType.Methods.get -> System.Collections.Generic.List<Reko.Core.Types.ClassMethod>
Reko.Core.Types.ClassType.VirtualMethods.get -> System.Collections.Generic.IEnumerable<Reko.Core.Types.ClassMethod>
Reko.Core.Types.CodeType
Reko.Core.Types.CodeType.CodeType() -> void
Reko.Core.Types.CompositeType
Reko.Core.Types.CompositeType.CompositeType(Reko.Core.Types.Domain domain, string name) -> void
Reko.Core.Types.CompositeType.UserDefined.get -> bool
Reko.Core.Types.CompositeType.UserDefined.set -> void
Reko.Core.Types.DataType
Reko.Core.Types.DataType.Clone() -> Reko.Core.Types.DataType
Reko.Core.Types.DataType.DataType(Reko.Core.Types.Domain domain) -> void
Reko.Core.Types.DataType.DataType(Reko.Core.Types.Domain domain, string name) -> void
Reko.Core.Types.DataType.Domain.get -> Reko.Core.Types.Domain
Reko.Core.Types.DataType.Domain.set -> void
Reko.Core.Types.DataType.MeasureBitSize(int bitsPerUnit) -> int
Reko.Core.Types.DataType.MeasureSize() -> int
Reko.Core.Types.DataType.Qualifier.get -> Reko.Core.Types.Qualifier
Reko.Core.Types.DataType.Qualifier.set -> void
Reko.Core.Types.DataType.ResolveAs<T>() -> T
Reko.Core.Types.DataType.ThrowBadSize() -> void
Reko.Core.Types.DataType.TypeReferenceAs<T>() -> T
Reko.Core.Types.DataTypeBuilderUnifier
Reko.Core.Types.DataTypeBuilderUnifier.DataTypeBuilderUnifier(Reko.Core.Types.TypeFactory factory, Reko.Core.Types.ITypeStore store) -> void
Reko.Core.Types.DataTypeComparer
Reko.Core.Types.DataTypeComparer.Compare(Reko.Core.Types.ArrayType x, Reko.Core.Types.ArrayType y, int count) -> int
Reko.Core.Types.DataTypeComparer.Compare(Reko.Core.Types.DataType x, Reko.Core.Types.DataType y) -> int
Reko.Core.Types.DataTypeComparer.Compare(Reko.Core.Types.DataType x, Reko.Core.Types.DataType y, int count) -> int
Reko.Core.Types.DataTypeComparer.Compare(Reko.Core.Types.FunctionType x, Reko.Core.Types.FunctionType y, int count) -> int
Reko.Core.Types.DataTypeComparer.Compare(Reko.Core.Types.StringType x, Reko.Core.Types.StringType y, int count) -> int
Reko.Core.Types.DataTypeComparer.Compare(Reko.Core.Types.StructureType x, Reko.Core.Types.StructureType y, int count) -> int
Reko.Core.Types.DataTypeComparer.Compare(Reko.Core.Types.UnionType x, Reko.Core.Types.UnionType y, int count) -> int
Reko.Core.Types.DataTypeComparer.CompareInternal(Reko.Core.Types.DataType x, Reko.Core.Types.DataType y, int count) -> int
Reko.Core.Types.DataTypeComparer.DataTypeComparer() -> void
Reko.Core.Types.DataTypeComparer.Equals(Reko.Core.Types.DataType a, Reko.Core.Types.DataType b) -> bool
Reko.Core.Types.DataTypeComparer.GetHashCode(Reko.Core.Types.DataType dt) -> int
Reko.Core.Types.DataTypeComparer.VisitArray(Reko.Core.Types.ArrayType at) -> int
Reko.Core.Types.DataTypeComparer.VisitClass(Reko.Core.Types.ClassType ct) -> int
Reko.Core.Types.DataTypeComparer.VisitCode(Reko.Core.Types.CodeType c) -> int
Reko.Core.Types.DataTypeComparer.VisitEnum(Reko.Core.Types.EnumType e) -> int
Reko.Core.Types.DataTypeComparer.VisitEquivalenceClass(Reko.Core.Types.EquivalenceClass eq) -> int
Reko.Core.Types.DataTypeComparer.VisitFunctionType(Reko.Core.Types.FunctionType ft) -> int
Reko.Core.Types.DataTypeComparer.VisitMemberPointer(Reko.Core.Types.MemberPointer memptr) -> int
Reko.Core.Types.DataTypeComparer.VisitPointer(Reko.Core.Types.Pointer ptr) -> int
Reko.Core.Types.DataTypeComparer.VisitPrimitive(Reko.Core.Types.PrimitiveType pt) -> int
Reko.Core.Types.DataTypeComparer.VisitReference(Reko.Core.Types.ReferenceTo refTo) -> int
Reko.Core.Types.DataTypeComparer.VisitString(Reko.Core.Types.StringType str) -> int
Reko.Core.Types.DataTypeComparer.VisitStructure(Reko.Core.Types.StructureType str) -> int
Reko.Core.Types.DataTypeComparer.VisitTypeReference(Reko.Core.Types.TypeReference typeref) -> int
Reko.Core.Types.DataTypeComparer.VisitTypeVariable(Reko.Core.Types.TypeVariable tv) -> int
Reko.Core.Types.DataTypeComparer.VisitUnion(Reko.Core.Types.UnionType ut) -> int
Reko.Core.Types.DataTypeComparer.VisitUnknownType(Reko.Core.Types.UnknownType ut) -> int
Reko.Core.Types.DataTypeComparer.VisitVoidType(Reko.Core.Types.VoidType vt) -> int
Reko.Core.Types.DataTypeTransformer
Reko.Core.Types.DataTypeTransformer.DataTypeTransformer() -> void
Reko.Core.Types.Domain
Reko.Core.Types.Domain.Any = 63487 -> Reko.Core.Types.Domain
Reko.Core.Types.Domain.Array = 20480 -> Reko.Core.Types.Domain
Reko.Core.Types.Domain.Bcd = 16 -> Reko.Core.Types.Domain
Reko.Core.Types.Domain.Boolean = 1 -> Reko.Core.Types.Domain
Reko.Core.Types.Domain.Character = 2 -> Reko.Core.Types.Domain
Reko.Core.Types.Domain.Class = 36864 -> Reko.Core.Types.Domain
Reko.Core.Types.Domain.Composite = 4096 -> Reko.Core.Types.Domain
Reko.Core.Types.Domain.Enum = 1024 -> Reko.Core.Types.Domain
Reko.Core.Types.Domain.Function = 45056 -> Reko.Core.Types.Domain
Reko.Core.Types.Domain.Integer = Reko.Core.Types.Domain.SignedInt | Reko.Core.Types.Domain.UnsignedInt -> Reko.Core.Types.Domain
Reko.Core.Types.Domain.None = 0 -> Reko.Core.Types.Domain
Reko.Core.Types.Domain.Offset = 128 -> Reko.Core.Types.Domain
Reko.Core.Types.Domain.Pointer = 64 -> Reko.Core.Types.Domain
Reko.Core.Types.Domain.Real = 32 -> Reko.Core.Types.Domain
Reko.Core.Types.Domain.SegPointer = 512 -> Reko.Core.Types.Domain
Reko.Core.Types.Domain.Selector = 256 -> Reko.Core.Types.Domain
Reko.Core.Types.Domain.SignedInt = 4 -> Reko.Core.Types.Domain
Reko.Core.Types.Domain.Structure = 12288 -> Reko.Core.Types.Domain
Reko.Core.Types.Domain.Union = 20480 -> Reko.Core.Types.Domain
Reko.Core.Types.Domain.UnsignedInt = 8 -> Reko.Core.Types.Domain
Reko.Core.Types.EnumType
Reko.Core.Types.EnumType.EnumType() -> void
Reko.Core.Types.EnumType.EnumType(Reko.Core.Types.EnumType other) -> void
Reko.Core.Types.EnumType.EnumType(string name) -> void
Reko.Core.Types.EnumType.Members.get -> System.Collections.Generic.SortedList<string, long>
Reko.Core.Types.EnumType.Members.set -> void
Reko.Core.Types.EquivalenceClass
Reko.Core.Types.EquivalenceClass.ClassMembers.get -> System.Collections.Generic.ISet<Reko.Core.Types.TypeVariable>
Reko.Core.Types.EquivalenceClass.DataType.get -> Reko.Core.Types.DataType
Reko.Core.Types.EquivalenceClass.DataType.set -> void
Reko.Core.Types.EquivalenceClass.EquivalenceClass(Reko.Core.Types.TypeVariable rep) -> void
Reko.Core.Types.EquivalenceClass.EquivalenceClass(Reko.Core.Types.TypeVariable rep, Reko.Core.Types.DataType dt) -> void
Reko.Core.Types.EquivalenceClass.Number.get -> int
Reko.Core.Types.EquivalenceClass.Representative.get -> Reko.Core.Types.TypeVariable
Reko.Core.Types.EquivalenceClass.WriteBody(System.IO.TextWriter writer) -> void
Reko.Core.Types.Field
Reko.Core.Types.Field.DataType.get -> Reko.Core.Types.DataType
Reko.Core.Types.Field.DataType.set -> void
Reko.Core.Types.Field.Field(Reko.Core.Types.DataType type) -> void
Reko.Core.Types.FunctionType
Reko.Core.Types.FunctionType.Emit(string fnName, Reko.Core.Types.FunctionType.EmitFlags f, Reko.Core.Output.Formatter fmt) -> void
Reko.Core.Types.FunctionType.Emit(string fnName, Reko.Core.Types.FunctionType.EmitFlags f, Reko.Core.Output.Formatter fmt, Reko.Core.Output.CodeFormatter w, Reko.Core.Output.TypeReferenceFormatter t) -> void
Reko.Core.Types.FunctionType.Emit(string fnName, Reko.Core.Types.FunctionType.EmitFlags f, System.IO.TextWriter writer) -> void
Reko.Core.Types.FunctionType.EmitFlags
Reko.Core.Types.FunctionType.EmitFlags.AllDetails = Reko.Core.Types.FunctionType.EmitFlags.ArgumentKind | Reko.Core.Types.FunctionType.EmitFlags.LowLevelInfo -> Reko.Core.Types.FunctionType.EmitFlags
Reko.Core.Types.FunctionType.EmitFlags.ArgumentKind = 1 -> Reko.Core.Types.FunctionType.EmitFlags
Reko.Core.Types.FunctionType.EmitFlags.LowLevelInfo = 2 -> Reko.Core.Types.FunctionType.EmitFlags
Reko.Core.Types.FunctionType.EmitFlags.None = 0 -> Reko.Core.Types.FunctionType.EmitFlags
Reko.Core.Types.FunctionType.FpuStackArgumentMax.get -> int
Reko.Core.Types.FunctionType.FpuStackArgumentMax.set -> void
Reko.Core.Types.FunctionType.FpuStackDelta.get -> int
Reko.Core.Types.FunctionType.FpuStackDelta.set -> void
Reko.Core.Types.FunctionType.FpuStackOutArgumentMax.get -> int
Reko.Core.Types.FunctionType.FpuStackOutArgumentMax.set -> void
Reko.Core.Types.FunctionType.FunctionType() -> void
Reko.Core.Types.FunctionType.FunctionType(Reko.Core.Expressions.Identifier returnValue, params Reko.Core.Expressions.Identifier[] parameters) -> void
Reko.Core.Types.FunctionType.HasVoidReturn.get -> bool
Reko.Core.Types.FunctionType.IsInstanceMetod.get -> bool
Reko.Core.Types.FunctionType.IsInstanceMetod.set -> void
Reko.Core.Types.FunctionType.IsVariadic.get -> bool
Reko.Core.Types.FunctionType.IsVariadic.set -> void
Reko.Core.Types.FunctionType.Parameters.get -> Reko.Core.Expressions.Identifier[]
Reko.Core.Types.FunctionType.ParametersValid.get -> bool
Reko.Core.Types.FunctionType.ReplaceParameters(params Reko.Core.Expressions.Identifier[] parameters) -> Reko.Core.Types.FunctionType
Reko.Core.Types.FunctionType.ReturnAddressOnStack.get -> int
Reko.Core.Types.FunctionType.ReturnAddressOnStack.set -> void
Reko.Core.Types.FunctionType.ReturnValue.get -> Reko.Core.Expressions.Identifier
Reko.Core.Types.FunctionType.ReturnValue.set -> void
Reko.Core.Types.FunctionType.StackDelta.get -> int
Reko.Core.Types.FunctionType.StackDelta.set -> void
Reko.Core.Types.FunctionType.ToString(string name, Reko.Core.Types.FunctionType.EmitFlags flags = Reko.Core.Types.FunctionType.EmitFlags.ArgumentKind) -> string
Reko.Core.Types.FunctionType.TypeVariable.get -> Reko.Core.Types.TypeVariable
Reko.Core.Types.FunctionType.TypeVariable.set -> void
Reko.Core.Types.IDataTypeVisitor
Reko.Core.Types.IDataTypeVisitor.VisitArray(Reko.Core.Types.ArrayType at) -> void
Reko.Core.Types.IDataTypeVisitor.VisitClass(Reko.Core.Types.ClassType ct) -> void
Reko.Core.Types.IDataTypeVisitor.VisitCode(Reko.Core.Types.CodeType c) -> void
Reko.Core.Types.IDataTypeVisitor.VisitEnum(Reko.Core.Types.EnumType e) -> void
Reko.Core.Types.IDataTypeVisitor.VisitEquivalenceClass(Reko.Core.Types.EquivalenceClass eq) -> void
Reko.Core.Types.IDataTypeVisitor.VisitFunctionType(Reko.Core.Types.FunctionType ft) -> void
Reko.Core.Types.IDataTypeVisitor.VisitMemberPointer(Reko.Core.Types.MemberPointer memptr) -> void
Reko.Core.Types.IDataTypeVisitor.VisitPointer(Reko.Core.Types.Pointer ptr) -> void
Reko.Core.Types.IDataTypeVisitor.VisitPrimitive(Reko.Core.Types.PrimitiveType pt) -> void
Reko.Core.Types.IDataTypeVisitor.VisitReference(Reko.Core.Types.ReferenceTo refTo) -> void
Reko.Core.Types.IDataTypeVisitor.VisitString(Reko.Core.Types.StringType str) -> void
Reko.Core.Types.IDataTypeVisitor.VisitStructure(Reko.Core.Types.StructureType str) -> void
Reko.Core.Types.IDataTypeVisitor.VisitTypeReference(Reko.Core.Types.TypeReference typeref) -> void
Reko.Core.Types.IDataTypeVisitor.VisitTypeVariable(Reko.Core.Types.TypeVariable tv) -> void
Reko.Core.Types.IDataTypeVisitor.VisitUnion(Reko.Core.Types.UnionType ut) -> void
Reko.Core.Types.IDataTypeVisitor.VisitUnknownType(Reko.Core.Types.UnknownType ut) -> void
Reko.Core.Types.IDataTypeVisitor.VisitVoidType(Reko.Core.Types.VoidType voidType) -> void
Reko.Core.Types.IDataTypeVisitor<T>
Reko.Core.Types.IDataTypeVisitor<T>.VisitArray(Reko.Core.Types.ArrayType at) -> T
Reko.Core.Types.IDataTypeVisitor<T>.VisitClass(Reko.Core.Types.ClassType ct) -> T
Reko.Core.Types.IDataTypeVisitor<T>.VisitCode(Reko.Core.Types.CodeType c) -> T
Reko.Core.Types.IDataTypeVisitor<T>.VisitEnum(Reko.Core.Types.EnumType e) -> T
Reko.Core.Types.IDataTypeVisitor<T>.VisitEquivalenceClass(Reko.Core.Types.EquivalenceClass eq) -> T
Reko.Core.Types.IDataTypeVisitor<T>.VisitFunctionType(Reko.Core.Types.FunctionType ft) -> T
Reko.Core.Types.IDataTypeVisitor<T>.VisitMemberPointer(Reko.Core.Types.MemberPointer memptr) -> T
Reko.Core.Types.IDataTypeVisitor<T>.VisitPointer(Reko.Core.Types.Pointer ptr) -> T
Reko.Core.Types.IDataTypeVisitor<T>.VisitPrimitive(Reko.Core.Types.PrimitiveType pt) -> T
Reko.Core.Types.IDataTypeVisitor<T>.VisitReference(Reko.Core.Types.ReferenceTo refTo) -> T
Reko.Core.Types.IDataTypeVisitor<T>.VisitString(Reko.Core.Types.StringType str) -> T
Reko.Core.Types.IDataTypeVisitor<T>.VisitStructure(Reko.Core.Types.StructureType str) -> T
Reko.Core.Types.IDataTypeVisitor<T>.VisitTypeReference(Reko.Core.Types.TypeReference typeref) -> T
Reko.Core.Types.IDataTypeVisitor<T>.VisitTypeVariable(Reko.Core.Types.TypeVariable tv) -> T
Reko.Core.Types.IDataTypeVisitor<T>.VisitUnion(Reko.Core.Types.UnionType ut) -> T
Reko.Core.Types.IDataTypeVisitor<T>.VisitUnknownType(Reko.Core.Types.UnknownType ut) -> T
Reko.Core.Types.IDataTypeVisitor<T>.VisitVoidType(Reko.Core.Types.VoidType voidType) -> T
Reko.Core.Types.ITypeStore
Reko.Core.Types.ITypeStore.BuildEquivalenceClassDataTypes(Reko.Core.Types.TypeFactory factory) -> void
Reko.Core.Types.ITypeStore.CreateTypeVariable(Reko.Core.Types.TypeFactory factory) -> Reko.Core.Types.TypeVariable
Reko.Core.Types.ITypeStore.GetDataTypeOf(Reko.Core.Expressions.Expression exp) -> Reko.Core.Types.DataType
Reko.Core.Types.ITypeStore.MergeClasses(Reko.Core.Types.TypeVariable tv1, Reko.Core.Types.TypeVariable tv2) -> Reko.Core.Types.EquivalenceClass
Reko.Core.Types.ITypeStore.SetDataTypeOf(Reko.Core.Expressions.Expression exp, Reko.Core.Types.DataType dt) -> void
Reko.Core.Types.ITypeStore.Write(bool showExprAddresses, System.IO.TextWriter writer) -> void
Reko.Core.Types.MemberPointer
Reko.Core.Types.MemberPointer.BasePointer.get -> Reko.Core.Types.DataType
Reko.Core.Types.MemberPointer.BasePointer.set -> void
Reko.Core.Types.MemberPointer.MemberPointer(Reko.Core.Types.DataType basePtr, Reko.Core.Types.DataType pointee, int bitSize) -> void
Reko.Core.Types.MemberPointer.Pointee.get -> Reko.Core.Types.DataType
Reko.Core.Types.MemberPointer.Pointee.set -> void
Reko.Core.Types.Pointer
Reko.Core.Types.Pointer.Pointee.get -> Reko.Core.Types.DataType
Reko.Core.Types.Pointer.Pointee.set -> void
Reko.Core.Types.Pointer.Pointer(Reko.Core.Types.DataType pointee, int bitSize) -> void
Reko.Core.Types.PrimitiveType
Reko.Core.Types.PrimitiveType.Compare(Reko.Core.Types.PrimitiveType that) -> int
Reko.Core.Types.PrimitiveType.MaskDomain(Reko.Core.Types.Domain domainMask) -> Reko.Core.Types.PrimitiveType
Reko.Core.Types.Qualifier
Reko.Core.Types.Qualifier.Const = 1 -> Reko.Core.Types.Qualifier
Reko.Core.Types.Qualifier.None = 0 -> Reko.Core.Types.Qualifier
Reko.Core.Types.Qualifier.Restricted = 4 -> Reko.Core.Types.Qualifier
Reko.Core.Types.Qualifier.Volatile = 2 -> Reko.Core.Types.Qualifier
Reko.Core.Types.ReferenceTo
Reko.Core.Types.ReferenceTo.ReferenceTo(Reko.Core.Types.DataType referent) -> void
Reko.Core.Types.ReferenceTo.Referent.get -> Reko.Core.Types.DataType
Reko.Core.Types.ReferenceTo.Referent.set -> void
Reko.Core.Types.StringType
Reko.Core.Types.StringType.LengthPrefixType.get -> Reko.Core.Types.PrimitiveType
Reko.Core.Types.StringType.PrefixOffset.get -> int
Reko.Core.Types.StringType.StringType(Reko.Core.Types.DataType charType, Reko.Core.Types.PrimitiveType lengthPrefixType, int prefixOffset) -> void
Reko.Core.Types.StructureField
Reko.Core.Types.StructureField.Clone(System.Collections.Generic.IDictionary<Reko.Core.Types.DataType, Reko.Core.Types.DataType> clonedTypes = null) -> Reko.Core.Types.StructureField
Reko.Core.Types.StructureField.IsNameSet.get -> bool
Reko.Core.Types.StructureField.Offset.get -> int
Reko.Core.Types.StructureField.Offset.set -> void
Reko.Core.Types.StructureField.StructureField(int offset, Reko.Core.Types.DataType type, string name = null) -> void
Reko.Core.Types.StructureFieldCollection
Reko.Core.Types.StructureFieldCollection.Add(int offset, Reko.Core.Types.DataType dt) -> Reko.Core.Types.StructureField
Reko.Core.Types.StructureFieldCollection.Add(int offset, Reko.Core.Types.DataType dt, string name) -> Reko.Core.Types.StructureField
Reko.Core.Types.StructureFieldCollection.Add(Reko.Core.Types.StructureField f) -> Reko.Core.Types.StructureField
Reko.Core.Types.StructureFieldCollection.AddRange(System.Collections.Generic.IEnumerable<Reko.Core.Types.StructureField> fields) -> void
Reko.Core.Types.StructureFieldCollection.AtOffset(int offset) -> Reko.Core.Types.StructureField
Reko.Core.Types.StructureFieldCollection.Clear() -> void
Reko.Core.Types.StructureFieldCollection.Contains(Reko.Core.Types.StructureField item) -> bool
Reko.Core.Types.StructureFieldCollection.CopyTo(Reko.Core.Types.StructureField[] array, int arrayIndex) -> void
Reko.Core.Types.StructureFieldCollection.Count.get -> int
Reko.Core.Types.StructureFieldCollection.GetEnumerator() -> System.Collections.Generic.IEnumerator<Reko.Core.Types.StructureField>
Reko.Core.Types.StructureFieldCollection.IsReadOnly.get -> bool
Reko.Core.Types.StructureFieldCollection.LowerBound(int offset) -> Reko.Core.Types.StructureField
Reko.Core.Types.StructureFieldCollection.Remove(Reko.Core.Types.StructureField item) -> bool
Reko.Core.Types.StructureFieldCollection.RemoveAt(int i) -> void
Reko.Core.Types.StructureFieldCollection.StructureFieldCollection() -> void
Reko.Core.Types.StructureFieldCollection.this[int i].get -> Reko.Core.Types.StructureField
Reko.Core.Types.StructureType
Reko.Core.Types.StructureType.Fields.get -> Reko.Core.Types.StructureFieldCollection
Reko.Core.Types.StructureType.ForceStructure.get -> bool
Reko.Core.Types.StructureType.ForceStructure.set -> void
Reko.Core.Types.StructureType.GetInferredSize() -> int
Reko.Core.Types.StructureType.IsEmpty.get -> bool
Reko.Core.Types.StructureType.IsSegment.get -> bool
Reko.Core.Types.StructureType.IsSegment.set -> void
Reko.Core.Types.StructureType.Simplify() -> Reko.Core.Types.DataType
Reko.Core.Types.StructureType.StructureType() -> void
Reko.Core.Types.StructureType.StructureType(int size) -> void
Reko.Core.Types.StructureType.StructureType(string name, int size) -> void
Reko.Core.Types.StructureType.StructureType(string name, int size, bool userDefined) -> void
Reko.Core.Types.TypeFactory
Reko.Core.Types.TypeFactory.CreateArrayType(Reko.Core.Types.DataType elType, int length) -> Reko.Core.Types.ArrayType
Reko.Core.Types.TypeFactory.CreateCodeType() -> Reko.Core.Types.DataType
Reko.Core.Types.TypeFactory.CreateEnum(int Size, Reko.Core.Types.Domain Domain, string Name, Reko.Core.Serialization.SerializedEnumValue[] Values) -> Reko.Core.Types.EnumType
Reko.Core.Types.TypeFactory.CreateFunctionType(Reko.Core.Expressions.Identifier returnType, Reko.Core.Expressions.Identifier[] parameters) -> Reko.Core.Types.FunctionType
Reko.Core.Types.TypeFactory.CreateMemberPointer(Reko.Core.Types.DataType basePointer, Reko.Core.Types.DataType pointee, int bitSize) -> Reko.Core.Types.MemberPointer
Reko.Core.Types.TypeFactory.CreatePointer(Reko.Core.Types.DataType pointee, int bitSize) -> Reko.Core.Types.Pointer
Reko.Core.Types.TypeFactory.CreatePrimitiveType(Reko.Core.Types.Domain dom, int bitSize) -> Reko.Core.Types.PrimitiveType
Reko.Core.Types.TypeFactory.CreateStructureType() -> Reko.Core.Types.StructureType
Reko.Core.Types.TypeFactory.CreateStructureType(string name, int size) -> Reko.Core.Types.StructureType
Reko.Core.Types.TypeFactory.CreateStructureType(string name, int size, Reko.Core.Types.StructureField field) -> Reko.Core.Types.StructureType
Reko.Core.Types.TypeFactory.CreateTypeVariable() -> Reko.Core.Types.TypeVariable
Reko.Core.Types.TypeFactory.CreateTypeVariable(string name) -> Reko.Core.Types.TypeVariable
Reko.Core.Types.TypeFactory.CreateUnionType(string name, Reko.Core.Types.DataType preferred) -> Reko.Core.Types.UnionType
Reko.Core.Types.TypeFactory.CreateUnionType(string name, Reko.Core.Types.DataType preferred, System.Collections.Generic.ICollection<Reko.Core.Types.DataType> alternatives) -> Reko.Core.Types.UnionType
Reko.Core.Types.TypeFactory.CreateUnknown() -> Reko.Core.Types.UnknownType
Reko.Core.Types.TypeFactory.CreateUnknown(int size) -> Reko.Core.Types.UnknownType
Reko.Core.Types.TypeFactory.CreateVoidType() -> Reko.Core.Types.VoidType
Reko.Core.Types.TypeFactory.TypeFactory() -> void
Reko.Core.Types.TypeGraphWriter
Reko.Core.Types.TypeGraphWriter.TypeGraphWriter(Reko.Core.Output.Formatter writer) -> void
Reko.Core.Types.TypeGraphWriter.VisitArray(Reko.Core.Types.ArrayType at) -> Reko.Core.Output.Formatter
Reko.Core.Types.TypeGraphWriter.VisitClass(Reko.Core.Types.ClassType ct) -> Reko.Core.Output.Formatter
Reko.Core.Types.TypeGraphWriter.VisitCode(Reko.Core.Types.CodeType c) -> Reko.Core.Output.Formatter
Reko.Core.Types.TypeGraphWriter.VisitEnum(Reko.Core.Types.EnumType e) -> Reko.Core.Output.Formatter
Reko.Core.Types.TypeGraphWriter.VisitEquivalenceClass(Reko.Core.Types.EquivalenceClass eq) -> Reko.Core.Output.Formatter
Reko.Core.Types.TypeGraphWriter.VisitFunctionType(Reko.Core.Types.FunctionType ft) -> Reko.Core.Output.Formatter
Reko.Core.Types.TypeGraphWriter.VisitMemberPointer(Reko.Core.Types.MemberPointer memptr) -> Reko.Core.Output.Formatter
Reko.Core.Types.TypeGraphWriter.VisitPointer(Reko.Core.Types.Pointer ptr) -> Reko.Core.Output.Formatter
Reko.Core.Types.TypeGraphWriter.VisitPrimitive(Reko.Core.Types.PrimitiveType pt) -> Reko.Core.Output.Formatter
Reko.Core.Types.TypeGraphWriter.VisitReference(Reko.Core.Types.ReferenceTo refTo) -> Reko.Core.Output.Formatter
Reko.Core.Types.TypeGraphWriter.VisitString(Reko.Core.Types.StringType str) -> Reko.Core.Output.Formatter
Reko.Core.Types.TypeGraphWriter.VisitStructure(Reko.Core.Types.StructureType str) -> Reko.Core.Output.Formatter
Reko.Core.Types.TypeGraphWriter.VisitTypeReference(Reko.Core.Types.TypeReference typeref) -> Reko.Core.Output.Formatter
Reko.Core.Types.TypeGraphWriter.VisitTypeVariable(Reko.Core.Types.TypeVariable tv) -> Reko.Core.Output.Formatter
Reko.Core.Types.TypeGraphWriter.VisitUnion(Reko.Core.Types.UnionType ut) -> Reko.Core.Output.Formatter
Reko.Core.Types.TypeGraphWriter.VisitUnknownType(Reko.Core.Types.UnknownType ut) -> Reko.Core.Output.Formatter
Reko.Core.Types.TypeGraphWriter.VisitVoidType(Reko.Core.Types.VoidType vt) -> Reko.Core.Output.Formatter
Reko.Core.Types.TypeGraphWriter.WriteQualifier(Reko.Core.Types.Qualifier q) -> Reko.Core.Output.Formatter
Reko.Core.Types.TypeReference
Reko.Core.Types.TypeReference.Referent.get -> Reko.Core.Types.DataType
Reko.Core.Types.TypeReference.Referent.set -> void
Reko.Core.Types.TypeReference.TypeReference(Reko.Core.Types.DataType dataType) -> void
Reko.Core.Types.TypeReference.TypeReference(string name) -> void
Reko.Core.Types.TypeReference.TypeReference(string name, Reko.Core.Types.DataType dataType) -> void
Reko.Core.Types.TypeStore
Reko.Core.Types.TypeStore.BuildEquivalenceClassDataTypes(Reko.Core.Types.TypeFactory factory) -> void
Reko.Core.Types.TypeStore.Clear() -> void
Reko.Core.Types.TypeStore.CopyClassDataTypesToTypeVariables() -> void
Reko.Core.Types.TypeStore.CreateTypeVariable(Reko.Core.Types.TypeFactory factory) -> Reko.Core.Types.TypeVariable
Reko.Core.Types.TypeStore.Dump() -> void
Reko.Core.Types.TypeStore.Dump(string dir, string filename) -> void
Reko.Core.Types.TypeStore.EnsureExpressionTypeVariable(Reko.Core.Types.TypeFactory factory, ulong uAddr, Reko.Core.Expressions.Expression e) -> Reko.Core.Types.TypeVariable
Reko.Core.Types.TypeStore.EnsureExpressionTypeVariable(Reko.Core.Types.TypeFactory factory, ulong uAddr, Reko.Core.Expressions.Expression e, string name) -> Reko.Core.Types.TypeVariable
Reko.Core.Types.TypeStore.ExpressionOf(Reko.Core.Types.TypeVariable tv) -> Reko.Core.Expressions.Expression
Reko.Core.Types.TypeStore.GetDataTypeOf(Reko.Core.Expressions.Expression exp) -> Reko.Core.Types.DataType
Reko.Core.Types.TypeStore.LinearAddressOf(Reko.Core.Types.TypeVariable tv) -> ulong?
Reko.Core.Types.TypeStore.MergeClasses(Reko.Core.Types.TypeVariable tv1, Reko.Core.Types.TypeVariable tv2) -> Reko.Core.Types.EquivalenceClass
Reko.Core.Types.TypeStore.SegmentTypes.get -> System.Collections.Generic.Dictionary<Reko.Core.ImageSegment, Reko.Core.Types.StructureType>
Reko.Core.Types.TypeStore.SetDataTypeOf(Reko.Core.Expressions.Expression expr, Reko.Core.Types.DataType dt) -> void
Reko.Core.Types.TypeStore.SetTypeVariableExpression(Reko.Core.Types.TypeVariable typeVariable, ulong uAddr, Reko.Core.Expressions.Expression binExp) -> void
Reko.Core.Types.TypeStore.TypeStore() -> void
Reko.Core.Types.TypeStore.TypeVariables.get -> System.Collections.Generic.List<Reko.Core.Types.TypeVariable>
Reko.Core.Types.TypeStore.UsedEquivalenceClasses.get -> System.Collections.Generic.IList<Reko.Core.Types.EquivalenceClass>
Reko.Core.Types.TypeStore.Write(bool showExprAddresses, System.IO.TextWriter w) -> void
Reko.Core.Types.TypeStore.Write(System.IO.TextWriter w) -> void
Reko.Core.Types.TypeStore.WriteEntry(Reko.Core.Types.TypeVariable tv, bool showExprAddresses, Reko.Core.Output.Formatter writer) -> void
Reko.Core.Types.TypeStore.WriteExpressionOf(Reko.Core.Types.TypeVariable tvMember, bool showExprAddresses, Reko.Core.Output.Formatter writer) -> void
Reko.Core.Types.TypeVariable
Reko.Core.Types.TypeVariable.Class.get -> Reko.Core.Types.EquivalenceClass
Reko.Core.Types.TypeVariable.Class.set -> void
Reko.Core.Types.TypeVariable.DataType.get -> Reko.Core.Types.DataType
Reko.Core.Types.TypeVariable.DataType.set -> void
Reko.Core.Types.TypeVariable.Number.get -> int
Reko.Core.Types.TypeVariable.OriginalDataType.get -> Reko.Core.Types.DataType
Reko.Core.Types.TypeVariable.OriginalDataType.set -> void
Reko.Core.Types.TypeVariable.TypeVariable(int n) -> void
Reko.Core.Types.TypeVariable.TypeVariable(string name, int n) -> void
Reko.Core.Types.Unifier
Reko.Core.Types.Unifier.AreCompatible(Reko.Core.Types.DataType a, Reko.Core.Types.DataType b) -> bool
Reko.Core.Types.Unifier.MakeUnion(Reko.Core.Types.DataType a, Reko.Core.Types.DataType b) -> Reko.Core.Types.UnionType
Reko.Core.Types.Unifier.Unifier() -> void
Reko.Core.Types.Unifier.Unifier(Reko.Core.Types.TypeFactory factory) -> void
Reko.Core.Types.Unifier.Unifier(Reko.Core.Types.TypeFactory factory, System.Diagnostics.TraceSwitch trace) -> void
Reko.Core.Types.Unifier.Unify(Reko.Core.Types.DataType a, Reko.Core.Types.DataType b) -> Reko.Core.Types.DataType
Reko.Core.Types.Unifier.UnifyArrays(Reko.Core.Types.ArrayType a, Reko.Core.Types.ArrayType b) -> Reko.Core.Types.DataType
Reko.Core.Types.Unifier.UnifyFunctions(Reko.Core.Types.FunctionType a, Reko.Core.Types.FunctionType b) -> Reko.Core.Types.DataType
Reko.Core.Types.Unifier.UnifyIntoUnion(Reko.Core.Types.UnionType u, Reko.Core.Types.DataType dt) -> void
Reko.Core.Types.Unifier.UnifyMemberPointer(Reko.Core.Types.MemberPointer mpA, Reko.Core.Types.DataType b) -> Reko.Core.Types.DataType
Reko.Core.Types.Unifier.UnifyPointer(Reko.Core.Types.Pointer ptrA, Reko.Core.Types.DataType b) -> Reko.Core.Types.DataType
Reko.Core.Types.Unifier.UnifyStructures(Reko.Core.Types.StructureType a, Reko.Core.Types.StructureType b) -> Reko.Core.Types.DataType
Reko.Core.Types.Unifier.UnifyUnions(Reko.Core.Types.UnionType u1, Reko.Core.Types.UnionType u2) -> Reko.Core.Types.UnionType
Reko.Core.Types.UnionAlternative
Reko.Core.Types.UnionAlternative.Clone() -> Reko.Core.Types.UnionAlternative
Reko.Core.Types.UnionAlternative.Index.get -> int
Reko.Core.Types.UnionAlternative.UnionAlternative(Reko.Core.Types.DataType dt, int index) -> void
Reko.Core.Types.UnionAlternative.UnionAlternative(string name, Reko.Core.Types.DataType dt, int index) -> void
Reko.Core.Types.UnionAlternativeCollection
Reko.Core.Types.UnionAlternativeCollection.Add(Reko.Core.Types.DataType dt) -> void
Reko.Core.Types.UnionAlternativeCollection.Add(Reko.Core.Types.UnionAlternative a) -> void
Reko.Core.Types.UnionAlternativeCollection.AddRange(System.Collections.Generic.IEnumerable<Reko.Core.Types.UnionAlternative> alternatives) -> void
Reko.Core.Types.UnionAlternativeCollection.UnionAlternativeCollection() -> void
Reko.Core.Types.UnionType
Reko.Core.Types.UnionType.AddAlternative(Reko.Core.Types.DataType dt) -> Reko.Core.Types.UnionAlternative
Reko.Core.Types.UnionType.Alternatives.get -> Reko.Core.Types.UnionAlternativeCollection
Reko.Core.Types.UnionType.FindAlternative(Reko.Core.Types.DataType dtOrig) -> Reko.Core.Types.UnionAlternative
Reko.Core.Types.UnionType.PreferredType.get -> Reko.Core.Types.DataType
Reko.Core.Types.UnionType.PreferredType.set -> void
Reko.Core.Types.UnionType.Simplify() -> Reko.Core.Types.DataType
Reko.Core.Types.UnionType.UnionType() -> void
Reko.Core.Types.UnionType.UnionType(string name, Reko.Core.Types.DataType preferredType) -> void
Reko.Core.Types.UnionType.UnionType(string name, Reko.Core.Types.DataType preferredType, bool userDefined, params Reko.Core.Types.DataType[] alternatives) -> void
Reko.Core.Types.UnionType.UnionType(string name, Reko.Core.Types.DataType preferredType, params Reko.Core.Types.DataType[] alternatives) -> void
Reko.Core.Types.UnionType.UnionType(string name, Reko.Core.Types.DataType preferredType, System.Collections.Generic.ICollection<Reko.Core.Types.DataType> alternatives) -> void
Reko.Core.Types.UnionType.UserDefined.get -> bool
Reko.Core.Types.UnknownType
Reko.Core.Types.UnknownType.UnknownType(int size = 0) -> void
Reko.Core.Types.VoidType
Reko.Core.UserCallData
Reko.Core.UserCallData.Address.get -> Reko.Core.Address
Reko.Core.UserCallData.Address.set -> void
Reko.Core.UserCallData.Comment.get -> string
Reko.Core.UserCallData.Comment.set -> void
Reko.Core.UserCallData.NoReturn.get -> bool
Reko.Core.UserCallData.NoReturn.set -> void
Reko.Core.UserCallData.Signature.get -> Reko.Core.Types.FunctionType
Reko.Core.UserCallData.Signature.set -> void
Reko.Core.UserCallData.UserCallData() -> void
Reko.Core.UserData
Reko.Core.UserData.AggressiveBranchRemoval.get -> bool
Reko.Core.UserData.AggressiveBranchRemoval.set -> void
Reko.Core.UserData.Annotations.get -> Reko.Core.AnnotationList
Reko.Core.UserData.Annotations.set -> void
Reko.Core.UserData.BlockLabels.get -> System.Collections.Generic.Dictionary<string, string>
Reko.Core.UserData.BlockLabels.set -> void
Reko.Core.UserData.Calls.get -> System.Collections.Generic.SortedList<Reko.Core.Address, Reko.Core.UserCallData>
Reko.Core.UserData.Calls.set -> void
Reko.Core.UserData.DebugTraceProcedures.get -> System.Collections.Generic.HashSet<string>
Reko.Core.UserData.DebugTraceProcedures.set -> void
Reko.Core.UserData.Environment.get -> string
Reko.Core.UserData.Environment.set -> void
Reko.Core.UserData.ExtractResources.get -> bool
Reko.Core.UserData.ExtractResources.set -> void
Reko.Core.UserData.Globals.get -> System.Collections.Generic.SortedList<Reko.Core.Address, Reko.Core.UserGlobal>
Reko.Core.UserData.Globals.set -> void
Reko.Core.UserData.Heuristics.get -> System.Collections.Generic.SortedSet<string>
Reko.Core.UserData.Heuristics.set -> void
Reko.Core.UserData.IndirectJumps.get -> System.Collections.Generic.SortedList<Reko.Core.Address, Reko.Core.UserIndirectJump>
Reko.Core.UserData.IndirectJumps.set -> void
Reko.Core.UserData.JumpTables.get -> System.Collections.Generic.SortedList<Reko.Core.Address, Reko.Core.ImageMapVectorTable>
Reko.Core.UserData.JumpTables.set -> void
Reko.Core.UserData.LoadAddress.get -> Reko.Core.Address
Reko.Core.UserData.LoadAddress.set -> void
Reko.Core.UserData.Loader.get -> string
Reko.Core.UserData.Loader.set -> void
Reko.Core.UserData.OnLoadedScript.get -> Reko.Core.Serialization.Script_v2
Reko.Core.UserData.OnLoadedScript.set -> void
Reko.Core.UserData.OutputFilePolicy.get -> string
Reko.Core.UserData.OutputFilePolicy.set -> void
Reko.Core.UserData.Patches.get -> System.Collections.Generic.Dictionary<Reko.Core.Address, Reko.Core.CodePatch>
Reko.Core.UserData.Patches.set -> void
Reko.Core.UserData.Procedures.get -> System.Collections.Generic.SortedList<Reko.Core.Address, Reko.Core.UserProcedure>
Reko.Core.UserData.Procedures.set -> void
Reko.Core.UserData.ProcedureSourceFiles.get -> System.Collections.Generic.Dictionary<Reko.Core.Address, string>
Reko.Core.UserData.ProcedureSourceFiles.set -> void
Reko.Core.UserData.Processor.get -> string
Reko.Core.UserData.Processor.set -> void
Reko.Core.UserData.RegisterValues.get -> System.Collections.Generic.SortedList<Reko.Core.Address, System.Collections.Generic.List<Reko.Core.UserRegisterValue>>
Reko.Core.UserData.RegisterValues.set -> void
Reko.Core.UserData.Segments.get -> System.Collections.Generic.List<Reko.Core.UserSegment>
Reko.Core.UserData.Segments.set -> void
Reko.Core.UserData.ShowAddressesInDisassembly.get -> bool
Reko.Core.UserData.ShowAddressesInDisassembly.set -> void
Reko.Core.UserData.ShowBytesInDisassembly.get -> bool
Reko.Core.UserData.ShowBytesInDisassembly.set -> void
Reko.Core.UserData.TextEncoding.get -> System.Text.Encoding
Reko.Core.UserData.TextEncoding.set -> void
Reko.Core.UserData.UserData() -> void
Reko.Core.UserGlobal
Reko.Core.UserGlobal.Address.get -> Reko.Core.Address
Reko.Core.UserGlobal.Address.set -> void
Reko.Core.UserGlobal.Comment.get -> string
Reko.Core.UserGlobal.Comment.set -> void
Reko.Core.UserGlobal.DataType.get -> Reko.Core.Serialization.SerializedType
Reko.Core.UserGlobal.DataType.set -> void
Reko.Core.UserGlobal.Name.get -> string
Reko.Core.UserGlobal.Name.set -> void
Reko.Core.UserGlobal.UserGlobal(Reko.Core.Address! address, string! name, Reko.Core.Serialization.SerializedType! dataType) -> void
Reko.Core.UserIndirectJump
Reko.Core.UserIndirectJump.Address.get -> Reko.Core.Address
Reko.Core.UserIndirectJump.Address.set -> void
Reko.Core.UserIndirectJump.IndexRegister.get -> Reko.Core.RegisterStorage
Reko.Core.UserIndirectJump.IndexRegister.set -> void
Reko.Core.UserIndirectJump.Table.get -> Reko.Core.ImageMapVectorTable
Reko.Core.UserIndirectJump.Table.set -> void
Reko.Core.UserIndirectJump.UserIndirectJump() -> void
Reko.Core.UserProcedure
Reko.Core.UserProcedure.Address.get -> Reko.Core.Address!
Reko.Core.UserProcedure.Address.set -> void
Reko.Core.UserProcedure.Assume.get -> System.Collections.Generic.List<Reko.Core.Serialization.RegisterValue_v2!>!
Reko.Core.UserProcedure.Assume.set -> void
Reko.Core.UserProcedure.Characteristics.get -> Reko.Core.Serialization.ProcedureCharacteristics!
Reko.Core.UserProcedure.Characteristics.set -> void
Reko.Core.UserProcedure.CSignature.get -> string?
Reko.Core.UserProcedure.CSignature.set -> void
Reko.Core.UserProcedure.Decompile.get -> bool
Reko.Core.UserProcedure.Decompile.set -> void
Reko.Core.UserProcedure.Name.get -> string!
Reko.Core.UserProcedure.Name.set -> void
Reko.Core.UserProcedure.Ordinal.get -> int
Reko.Core.UserProcedure.Ordinal.set -> void
Reko.Core.UserProcedure.OutputFile.get -> string?
Reko.Core.UserProcedure.OutputFile.set -> void
Reko.Core.UserProcedure.Signature.get -> Reko.Core.Serialization.SerializedSignature?
Reko.Core.UserProcedure.Signature.set -> void
Reko.Core.UserProcedure.UserProcedure(Reko.Core.Address! address, string! name) -> void
Reko.Core.UserRegisterValue
Reko.Core.UserRegisterValue.Register.get -> Reko.Core.Storage!
Reko.Core.UserRegisterValue.UserRegisterValue(Reko.Core.Storage! register, Reko.Core.Expressions.Constant! value) -> void
Reko.Core.UserRegisterValue.Value.get -> Reko.Core.Expressions.Constant!
Reko.Core.UserSegment
Reko.Core.UserSegment.AccessMode.get -> Reko.Core.AccessMode
Reko.Core.UserSegment.AccessMode.set -> void
Reko.Core.UserSegment.Address.get -> Reko.Core.Address
Reko.Core.UserSegment.Address.set -> void
Reko.Core.UserSegment.Architecture.get -> Reko.Core.IProcessorArchitecture
Reko.Core.UserSegment.Architecture.set -> void
Reko.Core.UserSegment.Length.get -> uint
Reko.Core.UserSegment.Length.set -> void
Reko.Core.UserSegment.Name.get -> string
Reko.Core.UserSegment.Name.set -> void
Reko.Core.UserSegment.Offset.get -> ulong
Reko.Core.UserSegment.Offset.set -> void
Reko.Core.UserSegment.UserSegment() -> void
Reko.Core.WarningDiagnostic
Reko.Core.WarningDiagnostic.WarningDiagnostic(string message) -> void
Reko.Core.WorkList
Reko.Core.WorkList<T>
Reko.Core.WorkList<T>.Add(T item) -> void
Reko.Core.WorkList<T>.AddRange(System.Collections.Generic.IEnumerable<T>! items) -> void
Reko.Core.WorkList<T>.Contains(T item) -> bool
Reko.Core.WorkList<T>.Count.get -> int
Reko.Core.WorkList<T>.IsEmpty.get -> bool
Reko.Core.WorkList<T>.Remove(T t) -> void
Reko.Core.WorkList<T>.TryGetWorkItem(out T item) -> bool
Reko.Core.WorkList<T>.WorkList() -> void
Reko.Core.WorkList<T>.WorkList(System.Collections.Generic.IEnumerable<T>! coll) -> void
Reko.Core.WorkStack<T>
Reko.Core.WorkStack<T>.Add(T item) -> void
Reko.Core.WorkStack<T>.AddRange(System.Collections.Generic.IEnumerable<T>! items) -> void
Reko.Core.WorkStack<T>.Count.get -> int
Reko.Core.WorkStack<T>.GetWorkItem(out T item) -> bool
Reko.Core.WorkStack<T>.IsEmpty.get -> bool
Reko.Core.WorkStack<T>.Remove(T t) -> void
Reko.Core.WorkStack<T>.WorkStack() -> void
Reko.Core.WorkStack<T>.WorkStack(System.Collections.Generic.IEnumerable<T>! coll) -> void
Reko.Core.XmlOptions
Reko.Core.XmlOptions.XmlOptions() -> void
static readonly Reko.Core.Address32.NULL -> Reko.Core.Address
static readonly Reko.Core.Address64.NULL -> Reko.Core.Address
static readonly Reko.Core.BitRange.Empty -> Reko.Core.BitRange
static readonly Reko.Core.Intrinsics.AtomicOps.atomic_compare_exchange_weak -> Reko.Core.IntrinsicProcedure
static readonly Reko.Core.Intrinsics.CommonOps.Abs -> Reko.Core.IntrinsicProcedure
static readonly Reko.Core.Intrinsics.CommonOps.Bit -> Reko.Core.IntrinsicProcedure
static readonly Reko.Core.Intrinsics.CommonOps.ClearBit -> Reko.Core.IntrinsicProcedure
static readonly Reko.Core.Intrinsics.CommonOps.CountLeadingOnes -> Reko.Core.IntrinsicProcedure
static readonly Reko.Core.Intrinsics.CommonOps.CountLeadingZeros -> Reko.Core.IntrinsicProcedure
static readonly Reko.Core.Intrinsics.CommonOps.CountTrailingOnes -> Reko.Core.IntrinsicProcedure
static readonly Reko.Core.Intrinsics.CommonOps.CountTrailingZeros -> Reko.Core.IntrinsicProcedure
static readonly Reko.Core.Intrinsics.CommonOps.Halt -> Reko.Core.IntrinsicProcedure
static readonly Reko.Core.Intrinsics.CommonOps.Halt_1 -> Reko.Core.IntrinsicProcedure
static readonly Reko.Core.Intrinsics.CommonOps.InvertBit -> Reko.Core.IntrinsicProcedure
static readonly Reko.Core.Intrinsics.CommonOps.Max -> Reko.Core.IntrinsicProcedure
static readonly Reko.Core.Intrinsics.CommonOps.Min -> Reko.Core.IntrinsicProcedure
static readonly Reko.Core.Intrinsics.CommonOps.Overflow -> Reko.Core.IntrinsicProcedure
static readonly Reko.Core.Intrinsics.CommonOps.ReverseBytes -> Reko.Core.IntrinsicProcedure
static readonly Reko.Core.Intrinsics.CommonOps.Rol -> Reko.Core.IntrinsicProcedure
static readonly Reko.Core.Intrinsics.CommonOps.RolC -> Reko.Core.IntrinsicProcedure
static readonly Reko.Core.Intrinsics.CommonOps.Ror -> Reko.Core.IntrinsicProcedure
static readonly Reko.Core.Intrinsics.CommonOps.RorC -> Reko.Core.IntrinsicProcedure
static readonly Reko.Core.Intrinsics.CommonOps.SetBit -> Reko.Core.IntrinsicProcedure
static readonly Reko.Core.Intrinsics.CommonOps.Syscall -> Reko.Core.IntrinsicProcedure
static readonly Reko.Core.Intrinsics.CommonOps.Syscall_0 -> Reko.Core.IntrinsicProcedure
static readonly Reko.Core.Intrinsics.CommonOps.Syscall_1 -> Reko.Core.IntrinsicProcedure
static readonly Reko.Core.Intrinsics.CommonOps.Syscall_2 -> Reko.Core.IntrinsicProcedure
static readonly Reko.Core.Intrinsics.CommonOps.WriteBit -> Reko.Core.IntrinsicProcedure
static readonly Reko.Core.Intrinsics.FpOps.AcosGeneric -> Reko.Core.IntrinsicProcedure
static readonly Reko.Core.Intrinsics.FpOps.AsinGeneric -> Reko.Core.IntrinsicProcedure
static readonly Reko.Core.Intrinsics.FpOps.AtanGeneric -> Reko.Core.IntrinsicProcedure
static readonly Reko.Core.Intrinsics.FpOps.AtanhGeneric -> Reko.Core.IntrinsicProcedure
static readonly Reko.Core.Intrinsics.FpOps.CosGeneric -> Reko.Core.IntrinsicProcedure
static readonly Reko.Core.Intrinsics.FpOps.CoshGeneric -> Reko.Core.IntrinsicProcedure
static readonly Reko.Core.Intrinsics.FpOps.ExpGeneric -> Reko.Core.IntrinsicProcedure
static readonly Reko.Core.Intrinsics.FpOps.fabs -> Reko.Core.IntrinsicProcedure
static readonly Reko.Core.Intrinsics.FpOps.FAbs32 -> Reko.Core.IntrinsicProcedure
static readonly Reko.Core.Intrinsics.FpOps.FAbs64 -> Reko.Core.IntrinsicProcedure
static readonly Reko.Core.Intrinsics.FpOps.fabsf -> Reko.Core.IntrinsicProcedure
static readonly Reko.Core.Intrinsics.FpOps.floor -> Reko.Core.IntrinsicProcedure
static readonly Reko.Core.Intrinsics.FpOps.floorf -> Reko.Core.IntrinsicProcedure
static readonly Reko.Core.Intrinsics.FpOps.FMax32 -> Reko.Core.IntrinsicProcedure
static readonly Reko.Core.Intrinsics.FpOps.FMax64 -> Reko.Core.IntrinsicProcedure
static readonly Reko.Core.Intrinsics.FpOps.FMin32 -> Reko.Core.IntrinsicProcedure
static readonly Reko.Core.Intrinsics.FpOps.FMin64 -> Reko.Core.IntrinsicProcedure
static readonly Reko.Core.Intrinsics.FpOps.FModGeneric -> Reko.Core.IntrinsicProcedure
static readonly Reko.Core.Intrinsics.FpOps.FRemGeneric -> Reko.Core.IntrinsicProcedure
static readonly Reko.Core.Intrinsics.FpOps.IsUnordered_f32 -> Reko.Core.IntrinsicProcedure
static readonly Reko.Core.Intrinsics.FpOps.IsUnordered_f64 -> Reko.Core.IntrinsicProcedure
static readonly Reko.Core.Intrinsics.FpOps.Log10Generic -> Reko.Core.IntrinsicProcedure
static readonly Reko.Core.Intrinsics.FpOps.Log2Generic -> Reko.Core.IntrinsicProcedure
static readonly Reko.Core.Intrinsics.FpOps.LogGeneric -> Reko.Core.IntrinsicProcedure
static readonly Reko.Core.Intrinsics.FpOps.SinGeneric -> Reko.Core.IntrinsicProcedure
static readonly Reko.Core.Intrinsics.FpOps.sqrt -> Reko.Core.IntrinsicProcedure
static readonly Reko.Core.Intrinsics.FpOps.sqrtf -> Reko.Core.IntrinsicProcedure
static readonly Reko.Core.Intrinsics.FpOps.SqrtGeneric -> Reko.Core.IntrinsicProcedure
static readonly Reko.Core.Intrinsics.FpOps.TanGeneric -> Reko.Core.IntrinsicProcedure
static readonly Reko.Core.Intrinsics.FpOps.TanhGeneric -> Reko.Core.IntrinsicProcedure
static readonly Reko.Core.Intrinsics.FpOps.TruncGeneric -> Reko.Core.IntrinsicProcedure
static readonly Reko.Core.IRFormat.Token.None -> Reko.Core.IRFormat.Token
static readonly Reko.Core.Machine.Decoder.trace -> System.Diagnostics.TraceSwitch
static readonly Reko.Core.Machine.MachineInstruction.NoOperands -> Reko.Core.Machine.MachineOperand[]
static readonly Reko.Core.NamingPolicy.Instance -> Reko.Core.NamingPolicy
static readonly Reko.Core.NativeInterface.Interop.DataTypes -> System.Collections.Generic.Dictionary<Reko.Core.NativeInterface.BaseType, Reko.Core.Types.DataType>
static readonly Reko.Core.Operators.Operator.AddrOf -> Reko.Core.Operators.UnaryOperator
static readonly Reko.Core.Operators.Operator.And -> Reko.Core.Operators.BinaryOperator
static readonly Reko.Core.Operators.Operator.Cand -> Reko.Core.Operators.BinaryOperator
static readonly Reko.Core.Operators.Operator.Comma -> Reko.Core.Operators.BinaryOperator
static readonly Reko.Core.Operators.Operator.Comp -> Reko.Core.Operators.UnaryOperator
static readonly Reko.Core.Operators.Operator.Cor -> Reko.Core.Operators.BinaryOperator
static readonly Reko.Core.Operators.Operator.Eq -> Reko.Core.Operators.ConditionalOperator
static readonly Reko.Core.Operators.Operator.FAdd -> Reko.Core.Operators.BinaryOperator
static readonly Reko.Core.Operators.Operator.FDiv -> Reko.Core.Operators.BinaryOperator
static readonly Reko.Core.Operators.Operator.Feq -> Reko.Core.Operators.ConditionalOperator
static readonly Reko.Core.Operators.Operator.Fge -> Reko.Core.Operators.ConditionalOperator
static readonly Reko.Core.Operators.Operator.Fgt -> Reko.Core.Operators.ConditionalOperator
static readonly Reko.Core.Operators.Operator.Fle -> Reko.Core.Operators.ConditionalOperator
static readonly Reko.Core.Operators.Operator.Flt -> Reko.Core.Operators.ConditionalOperator
static readonly Reko.Core.Operators.Operator.FMod -> Reko.Core.Operators.BinaryOperator
static readonly Reko.Core.Operators.Operator.FMul -> Reko.Core.Operators.BinaryOperator
static readonly Reko.Core.Operators.Operator.Fne -> Reko.Core.Operators.ConditionalOperator
static readonly Reko.Core.Operators.Operator.FNeg -> Reko.Core.Operators.UnaryOperator
static readonly Reko.Core.Operators.Operator.FSub -> Reko.Core.Operators.BinaryOperator
static readonly Reko.Core.Operators.Operator.Ge -> Reko.Core.Operators.ConditionalOperator
static readonly Reko.Core.Operators.Operator.Gt -> Reko.Core.Operators.ConditionalOperator
static readonly Reko.Core.Operators.Operator.IAdd -> Reko.Core.Operators.BinaryOperator
static readonly Reko.Core.Operators.Operator.IMod -> Reko.Core.Operators.BinaryOperator
static readonly Reko.Core.Operators.Operator.IMul -> Reko.Core.Operators.BinaryOperator
static readonly Reko.Core.Operators.Operator.ISub -> Reko.Core.Operators.BinaryOperator
static readonly Reko.Core.Operators.Operator.Le -> Reko.Core.Operators.ConditionalOperator
static readonly Reko.Core.Operators.Operator.Lt -> Reko.Core.Operators.ConditionalOperator
static readonly Reko.Core.Operators.Operator.Ne -> Reko.Core.Operators.ConditionalOperator
static readonly Reko.Core.Operators.Operator.Neg -> Reko.Core.Operators.UnaryOperator
static readonly Reko.Core.Operators.Operator.Not -> Reko.Core.Operators.UnaryOperator
static readonly Reko.Core.Operators.Operator.Or -> Reko.Core.Operators.BinaryOperator
static readonly Reko.Core.Operators.Operator.Sar -> Reko.Core.Operators.BinaryOperator
static readonly Reko.Core.Operators.Operator.SDiv -> Reko.Core.Operators.BinaryOperator
static readonly Reko.Core.Operators.Operator.Shl -> Reko.Core.Operators.BinaryOperator
static readonly Reko.Core.Operators.Operator.Shr -> Reko.Core.Operators.BinaryOperator
static readonly Reko.Core.Operators.Operator.SMod -> Reko.Core.Operators.BinaryOperator
static readonly Reko.Core.Operators.Operator.SMul -> Reko.Core.Operators.BinaryOperator
static readonly Reko.Core.Operators.Operator.UDiv -> Reko.Core.Operators.BinaryOperator
static readonly Reko.Core.Operators.Operator.Uge -> Reko.Core.Operators.ConditionalOperator
static readonly Reko.Core.Operators.Operator.Ugt -> Reko.Core.Operators.ConditionalOperator
static readonly Reko.Core.Operators.Operator.Ule -> Reko.Core.Operators.ConditionalOperator
static readonly Reko.Core.Operators.Operator.Ult -> Reko.Core.Operators.ConditionalOperator
static readonly Reko.Core.Operators.Operator.UMod -> Reko.Core.Operators.BinaryOperator
static readonly Reko.Core.Operators.Operator.UMul -> Reko.Core.Operators.BinaryOperator
static readonly Reko.Core.Operators.Operator.USub -> Reko.Core.Operators.BinaryOperator
static readonly Reko.Core.Operators.Operator.Xor -> Reko.Core.Operators.BinaryOperator
static readonly Reko.Core.Serialization.Json.JsonSymbols.OpNames -> System.Collections.Generic.Dictionary<Reko.Core.Operators.Operator, string>
static readonly Reko.Core.Serialization.Json.JsonSymbols.OpsByName -> System.Collections.Generic.Dictionary<string, Reko.Core.Operators.Operator>
static readonly Reko.Core.Serialization.Json.JsonSymbols.PrimitiveNames -> System.Collections.Generic.Dictionary<Reko.Core.Types.DataType, string>
static readonly Reko.Core.Serialization.Json.JsonSymbols.PrimitivesByName -> System.Collections.Generic.Dictionary<string, Reko.Core.Types.DataType>
static readonly Reko.Core.StridedInterval.All -> Reko.Core.StridedInterval
static readonly Reko.Core.StridedInterval.Empty -> Reko.Core.StridedInterval
static Reko.Core.Address.Create(Reko.Core.Types.DataType size, ulong bitPattern) -> Reko.Core.Address
static Reko.Core.Address.FromConstant(Reko.Core.Expressions.Constant value) -> Reko.Core.Address
static Reko.Core.Address.Max(Reko.Core.Address a, Reko.Core.Address b) -> Reko.Core.Address
static Reko.Core.Address.Min(Reko.Core.Address a, Reko.Core.Address b) -> Reko.Core.Address
static Reko.Core.Address.operator !=(Reko.Core.Address a, Reko.Core.Address b) -> bool
static Reko.Core.Address.operator +(Reko.Core.Address a, long off) -> Reko.Core.Address
static Reko.Core.Address.operator +(Reko.Core.Address a, ulong off) -> Reko.Core.Address
static Reko.Core.Address.operator -(Reko.Core.Address a, long delta) -> Reko.Core.Address
static Reko.Core.Address.operator -(Reko.Core.Address a, Reko.Core.Address b) -> long
static Reko.Core.Address.operator <(Reko.Core.Address a, Reko.Core.Address b) -> bool
static Reko.Core.Address.operator <=(Reko.Core.Address a, Reko.Core.Address b) -> bool
static Reko.Core.Address.operator ==(Reko.Core.Address a, Reko.Core.Address b) -> bool
static Reko.Core.Address.operator >(Reko.Core.Address a, Reko.Core.Address b) -> bool
static Reko.Core.Address.operator >=(Reko.Core.Address a, Reko.Core.Address b) -> bool
static Reko.Core.Address.ProtectedSegPtr(ushort seg, uint off) -> Reko.Core.Address
static Reko.Core.Address.Ptr16(ushort addr) -> Reko.Core.Address
static Reko.Core.Address.Ptr32(uint uAddr) -> Reko.Core.Address
static Reko.Core.Address.Ptr64(ulong addr) -> Reko.Core.Address
static Reko.Core.Address.SegPtr(ushort seg, uint off) -> Reko.Core.Address
static Reko.Core.Address.TryParse16(string s, out Reko.Core.Address result) -> bool
static Reko.Core.Address.TryParse32(string s, out Reko.Core.Address result) -> bool
static Reko.Core.Address.TryParse64(string s, out Reko.Core.Address result) -> bool
static Reko.Core.AddressRange.Empty.get -> Reko.Core.AddressRange
static Reko.Core.BinaryReaderExtensions.ReadNullTerminatedString(this System.IO.BinaryReader rdr) -> string
static Reko.Core.BinaryReaderStructureReader.ReadStruct<T>(this System.IO.BinaryReader rdr) -> T
static Reko.Core.BitRange.operator !=(Reko.Core.BitRange a, Reko.Core.BitRange b) -> bool
static Reko.Core.BitRange.operator &(Reko.Core.BitRange a, Reko.Core.BitRange b) -> Reko.Core.BitRange
static Reko.Core.BitRange.operator -(Reko.Core.BitRange a, Reko.Core.BitRange b) -> Reko.Core.BitRange
static Reko.Core.BitRange.operator <<(Reko.Core.BitRange a, int sh) -> Reko.Core.BitRange
static Reko.Core.BitRange.operator ==(Reko.Core.BitRange a, Reko.Core.BitRange b) -> bool
static Reko.Core.BitRange.operator |(Reko.Core.BitRange a, Reko.Core.BitRange b) -> Reko.Core.BitRange
static Reko.Core.Block.Coalesce(Reko.Core.Block block, Reko.Core.Block next) -> void
static Reko.Core.Block.ReplaceJumpsFrom(Reko.Core.Block block, Reko.Core.Block next) -> bool
static Reko.Core.Block.ReplaceJumpsTo(Reko.Core.Block block, Reko.Core.Block next) -> bool
static Reko.Core.ByteArrayExtensions.AsString(this byte[] arr, System.Text.Encoding encoding) -> string
static Reko.Core.BytePattern.FromHexBytes(string sBytes) -> byte[]
static Reko.Core.BytePattern.IsHexDigit(char c) -> bool
static Reko.Core.BytePattern.TryParseHexDigit(char c, out byte b) -> bool
static Reko.Core.CallingConventionEmitter.Align(int n, int quantum) -> int
static Reko.Core.CharacteristicsLibrary.Load(string filename, Reko.Core.Services.IFileSystemService fsSvc) -> Reko.Core.CharacteristicsLibrary
static Reko.Core.Code.CriticalInstruction.IsCritical(Reko.Core.Code.Instruction instr) -> bool
static Reko.Core.Code.CriticalInstruction.IsCritical(Reko.Core.Expressions.Expression expr) -> bool
static Reko.Core.Collections.BTreeDictionaryEx.TryGetLowerBound<K, V>(this Reko.Core.Collections.BTreeDictionary<K, V> list, K key, out V value) -> bool
static Reko.Core.Collections.BTreeDictionaryEx.TryGetLowerBoundIndex<K, V>(this Reko.Core.Collections.BTreeDictionary<K, V> list, K key, out int closestIndex) -> bool
static Reko.Core.Collections.BTreeDictionaryEx.TryGetLowerBoundKey<K, V>(this Reko.Core.Collections.BTreeDictionary<K, V> list, K key, out K closestKey) -> bool
static Reko.Core.Collections.BTreeDictionaryEx.TryGetUpperBound<K, V>(this Reko.Core.Collections.BTreeDictionary<K, V> list, K key, out V value) -> bool
static Reko.Core.Collections.BTreeDictionaryEx.TryGetUpperBoundIndex<K, V>(this Reko.Core.Collections.BTreeDictionary<K, V> list, K key, out int closestIndex) -> bool
static Reko.Core.Collections.BTreeDictionaryEx.TryGetUpperBoundKey<K, V>(this Reko.Core.Collections.BTreeDictionary<K, V> list, K key, out K closestKey) -> bool
static Reko.Core.Collections.ByteTrieMatch<T>.Empty.get -> Reko.Core.Collections.ByteTrieMatch<T>
static Reko.Core.Collections.EnumerableEx.Chunks<T>(this System.Collections.Generic.IEnumerable<T> enumerable, int chunkSize) -> System.Collections.Generic.IEnumerable<System.Collections.Generic.IEnumerable<T>>
static Reko.Core.Collections.EnumerableEx.EnqueueRange<T>(this System.Collections.Generic.Queue<T> queue, System.Collections.Generic.IEnumerable<T> items) -> void
static Reko.Core.Collections.EnumerableEx.Get<TKey, TValue>(this System.Collections.Generic.IDictionary<TKey, TValue> d, TKey key, TValue def = default(TValue)) -> TValue
static Reko.Core.Collections.EnumerableEx.ToSortedList<TSource, TKey, TElement>(this System.Collections.Generic.IEnumerable<TSource> source, System.Func<TSource, TKey> keySelector, System.Func<TSource, TElement> elementSelector) -> System.Collections.Generic.SortedList<TKey, TElement>
static Reko.Core.Collections.EnumerableEx.ToSortedList<TSource, TKey, TValue>(this System.Collections.Generic.IEnumerable<TSource> source, System.Func<TSource, TKey> keySelector, System.Func<TSource, TValue> valueSelector, System.Collections.Generic.IComparer<TKey> comparer) -> System.Collections.Generic.SortedList<TKey, TValue>
static Reko.Core.Collections.EnumerableEx.ToSortedList<TSource, TKey>(this System.Collections.Generic.IEnumerable<TSource> source, System.Func<TSource, TKey> keySelector) -> System.Collections.Generic.SortedList<TKey, TSource>
static Reko.Core.Collections.EnumerableEx.ToSortedList<TSource, TKey>(this System.Collections.Generic.IEnumerable<TSource> source, System.Func<TSource, TKey> keySelector, System.Collections.Generic.IComparer<TKey> comparer) -> System.Collections.Generic.SortedList<TKey, TSource>
static Reko.Core.Collections.EnumerableEx.ToSortedSet<TElement>(this System.Collections.Generic.IEnumerable<TElement> source) -> System.Collections.Generic.SortedSet<TElement>
static Reko.Core.Collections.EnumerableEx.ZipMany<TSource, TResult>(System.Collections.Generic.IEnumerable<System.Collections.Generic.IEnumerable<TSource>> source, System.Func<System.Collections.Generic.IEnumerable<TSource>, TResult> selector) -> System.Collections.Generic.IEnumerable<TResult>
static Reko.Core.Collections.FibonacciHeap<TKey, TValue>.Union(Reko.Core.Collections.FibonacciHeap<TKey, TValue> H1, Reko.Core.Collections.FibonacciHeap<TKey, TValue> H2) -> Reko.Core.Collections.FibonacciHeap<TKey, TValue>
static Reko.Core.Collections.Interval.Create<T>(T begin, T end) -> Reko.Core.Collections.Interval<T>
static Reko.Core.Collections.Interval<T>.operator !=(Reko.Core.Collections.Interval<T> a, Reko.Core.Collections.Interval<T> b) -> bool
static Reko.Core.Collections.Interval<T>.operator ==(Reko.Core.Collections.Interval<T> a, Reko.Core.Collections.Interval<T> b) -> bool
static Reko.Core.Collections.IntervalTree<T, TypeValue>.ComparerUtil.GetComparer() -> System.Collections.Generic.IComparer<T>
static Reko.Core.Collections.LinqAlgorithms.Scc(System.Collections.Generic.Dictionary<long, Reko.Core.Collections.LinqAlgorithms.Item> items, System.Collections.Generic.IEnumerable<Reko.Core.Collections.LinqAlgorithms.Link> links) -> void
static Reko.Core.Collections.SortedListEx.TryGetLowerBound<K, V>(this System.Collections.Generic.SortedList<K, V> list, K key, out V value) -> bool
static Reko.Core.Collections.SortedListEx.TryGetLowerBoundIndex<K, V>(this System.Collections.Generic.SortedList<K, V> list, K key, out int closestIndex) -> bool
static Reko.Core.Collections.SortedListEx.TryGetLowerBoundKey<K, V>(this System.Collections.Generic.SortedList<K, V> list, K key, out K closestKey) -> bool
static Reko.Core.Collections.SortedListEx.TryGetUpperBound<K, V>(this System.Collections.Generic.SortedList<K, V> list, K key, out V value) -> bool
static Reko.Core.Collections.SortedListEx.TryGetUpperBoundIndex<K, V>(this System.Collections.Generic.SortedList<K, V> list, K key, out int closestIndex) -> bool
static Reko.Core.Collections.SortedListEx.TryGetUpperBoundKey<K, V>(this System.Collections.Generic.SortedList<K, V> list, K key, out K closestKey) -> bool
static Reko.Core.Configuration.RekoConfigurationService.Load(System.IServiceProvider services) -> Reko.Core.Configuration.RekoConfigurationService
static Reko.Core.Configuration.RekoConfigurationService.Load(System.IServiceProvider services, string configFileName) -> Reko.Core.Configuration.RekoConfigurationService
static Reko.Core.Configuration.RekoConfigurationService.MakeInstallationRelativePath(string[] pathComponents) -> string
static Reko.Core.Dfa.Automaton.CreateFromPattern(string pattern) -> Reko.Core.Dfa.Automaton
static Reko.Core.Diagnostics.DebugEx.Break(bool launchIfTrue = true) -> void
static Reko.Core.Diagnostics.DebugEx.Error(this System.Diagnostics.TraceSwitch trace, string message, params object[] args) -> void
static Reko.Core.Diagnostics.DebugEx.Inform(this System.Diagnostics.TraceSwitch trace, string message, params object[] args) -> void
static Reko.Core.Diagnostics.DebugEx.Verbose(this System.Diagnostics.TraceSwitch trace, string message) -> void
static Reko.Core.Diagnostics.DebugEx.Verbose(this System.Diagnostics.TraceSwitch trace, string message, params object[] args) -> void
static Reko.Core.Diagnostics.DebugEx.Warn(this System.Diagnostics.TraceSwitch trace, string message, params object[] args) -> void
static Reko.Core.EndianServices.Big.get -> Reko.Core.EndianServices
static Reko.Core.EndianServices.Little.get -> Reko.Core.EndianServices
static Reko.Core.EventEx.Fire(this System.EventHandler eh, object sender) -> void
static Reko.Core.EventEx.Fire<T>(this System.EventHandler<T> eh, object sender, T e) -> void
static Reko.Core.Expressions.BigConstant.CreateUnsigned(Reko.Core.Types.DataType dt, System.Numerics.BigInteger value) -> Reko.Core.Expressions.BigConstant
static Reko.Core.Expressions.BigConstant.Replicate(Reko.Core.Types.DataType dt, Reko.Core.Expressions.Constant valueToReplicate) -> Reko.Core.Expressions.BigConstant
static Reko.Core.Expressions.BinaryExpression.Commutes(Reko.Core.Operators.Operator op) -> bool
static Reko.Core.Expressions.ConditionCodeEx.Invert(this Reko.Core.Expressions.ConditionCode cc) -> Reko.Core.Expressions.ConditionCode
static Reko.Core.Expressions.Constant.Bool(bool f) -> Reko.Core.Expressions.Constant
static Reko.Core.Expressions.Constant.Byte(byte c) -> Reko.Core.Expressions.Constant
static Reko.Core.Expressions.Constant.Create(Reko.Core.Types.DataType! dt, long value) -> Reko.Core.Expressions.Constant!
static Reko.Core.Expressions.Constant.Create(Reko.Core.Types.DataType! dt, System.Numerics.BigInteger value) -> Reko.Core.Expressions.Constant!
static Reko.Core.Expressions.Constant.Create(Reko.Core.Types.DataType! dt, ulong value) -> Reko.Core.Expressions.Constant!
static Reko.Core.Expressions.Constant.DoubleFromBitpattern(long bits) -> Reko.Core.Expressions.Constant
static Reko.Core.Expressions.Constant.False() -> Reko.Core.Expressions.Constant
static Reko.Core.Expressions.Constant.FloatFromBitpattern(long bits) -> Reko.Core.Expressions.Constant
static Reko.Core.Expressions.Constant.Int(Reko.Core.Types.DataType dt, long l) -> Reko.Core.Expressions.Constant
static Reko.Core.Expressions.Constant.Int16(short s) -> Reko.Core.Expressions.Constant
static Reko.Core.Expressions.Constant.Int32(int i) -> Reko.Core.Expressions.Constant
static Reko.Core.Expressions.Constant.Int32BitsToFloat(int bits) -> float
static Reko.Core.Expressions.Constant.Int64(long l) -> Reko.Core.Expressions.Constant
static Reko.Core.Expressions.Constant.IntPow(double b, int e) -> double
static Reko.Core.Expressions.Constant.Lg10() -> Reko.Core.Expressions.Constant
static Reko.Core.Expressions.Constant.LgE() -> Reko.Core.Expressions.Constant
static Reko.Core.Expressions.Constant.Ln2() -> Reko.Core.Expressions.Constant
static Reko.Core.Expressions.Constant.Log2() -> Reko.Core.Expressions.Constant
static Reko.Core.Expressions.Constant.MakeReal(int exponent, int expBias, long mantissa, int mantissaSize) -> double
static Reko.Core.Expressions.Constant.Pi() -> Reko.Core.Expressions.Constant
static Reko.Core.Expressions.Constant.Real32(float f) -> Reko.Core.Expressions.Constant
static Reko.Core.Expressions.Constant.Real64(double d) -> Reko.Core.Expressions.Constant
static Reko.Core.Expressions.Constant.Real80(Reko.Core.Lib.Float80 f80) -> Reko.Core.Expressions.Constant
static Reko.Core.Expressions.Constant.RealFromBitpattern(Reko.Core.Types.PrimitiveType dt, Reko.Core.Expressions.Constant bits) -> Reko.Core.Expressions.Constant
static Reko.Core.Expressions.Constant.Replicate(Reko.Core.Types.DataType! dt, Reko.Core.Expressions.Constant! valueToReplicate) -> Reko.Core.Expressions.Constant!
static Reko.Core.Expressions.Constant.SByte(sbyte p) -> Reko.Core.Expressions.Constant
static Reko.Core.Expressions.Constant.String(string str, Reko.Core.Types.StringType strType) -> Reko.Core.Expressions.Constant
static Reko.Core.Expressions.Constant.True() -> Reko.Core.Expressions.Constant
static Reko.Core.Expressions.Constant.UInt16(ushort u) -> Reko.Core.Expressions.Constant
static Reko.Core.Expressions.Constant.UInt32(uint w) -> Reko.Core.Expressions.Constant
static Reko.Core.Expressions.Constant.UInt64(ulong ul) -> Reko.Core.Expressions.Constant
static Reko.Core.Expressions.Constant.Word(int bitSize, long value) -> Reko.Core.Expressions.Constant
static Reko.Core.Expressions.Constant.Word(int bitSize, ulong value) -> Reko.Core.Expressions.Constant
static Reko.Core.Expressions.Constant.Word16(ushort n) -> Reko.Core.Expressions.Constant
static Reko.Core.Expressions.Constant.Word32(int n) -> Reko.Core.Expressions.Constant
static Reko.Core.Expressions.Constant.Word32(uint n) -> Reko.Core.Expressions.Constant
static Reko.Core.Expressions.Constant.Word64(long n) -> Reko.Core.Expressions.Constant
static Reko.Core.Expressions.Constant.Word64(ulong n) -> Reko.Core.Expressions.Constant
static Reko.Core.Expressions.Constant.Zero(Reko.Core.Types.DataType dataType) -> Reko.Core.Expressions.Constant
static Reko.Core.Expressions.ConstantReal.Create(Reko.Core.Types.DataType dt, double value) -> Reko.Core.Expressions.Constant
static Reko.Core.Expressions.ExpressionMatcher.AnyConstant() -> Reko.Core.Expressions.Expression
static Reko.Core.Expressions.ExpressionMatcher.AnyConstant(string label) -> Reko.Core.Expressions.Expression
static Reko.Core.Expressions.ExpressionMatcher.AnyDataType(string label) -> Reko.Core.Types.DataType
static Reko.Core.Expressions.ExpressionMatcher.AnyExpression(string label) -> Reko.Core.Expressions.Expression
static Reko.Core.Expressions.ExpressionMatcher.AnyId(string label = null) -> Reko.Core.Expressions.Identifier
static Reko.Core.Expressions.ExpressionMatcher.AnyOperator(string label) -> Reko.Core.Operators.Operator
static Reko.Core.Expressions.ExpressionReplacer.Replace(Reko.Core.Expressions.Expression original, Reko.Core.Expressions.Expression replacement, Reko.Core.Expressions.Expression root) -> Reko.Core.Expressions.Expression
static Reko.Core.Expressions.Identifier.Create(Reko.Core.Storage reg) -> Reko.Core.Expressions.Identifier
static Reko.Core.Expressions.Identifier.CreateTemporary(string name, Reko.Core.Types.DataType dt) -> Reko.Core.Expressions.Identifier
static Reko.Core.Expressions.Identifier.Global(string name, Reko.Core.Types.DataType dt) -> Reko.Core.Expressions.Identifier
static Reko.Core.Expressions.InvalidConstant.Create(Reko.Core.Types.DataType dt) -> Reko.Core.Expressions.InvalidConstant
static Reko.Core.Expressions.MemoryAccess.Create(Reko.Core.Expressions.Expression baseRegister, int offset, Reko.Core.Types.DataType dt) -> Reko.Core.Expressions.MemoryAccess
static Reko.Core.Expressions.MemoryAccess.CreateEffectiveAddress(Reko.Core.Expressions.Expression baseRegister, int offset) -> Reko.Core.Expressions.Expression
static Reko.Core.Expressions.MemoryIdentifier.GlobalMemory.get -> Reko.Core.Expressions.MemoryIdentifier
static Reko.Core.Expressions.SegmentedAccess.Create(Reko.Core.Expressions.Expression segRegister, Reko.Core.Expressions.Expression baseRegister, int offset, Reko.Core.Types.DataType dt) -> Reko.Core.Expressions.SegmentedAccess
static Reko.Core.Graphs.Dijkstra<T>.ShortestPath(Reko.Core.Graphs.DirectedGraph<T>! Graph, T source, System.Func<T, T, double>! weight) -> Reko.Core.Graphs.Dijkstra<T>!
static Reko.Core.Graphs.LTDominatorGraph<TNode>.Create(Reko.Core.Graphs.DirectedGraph<TNode> graph, TNode root) -> System.Collections.Generic.Dictionary<TNode, TNode>
static Reko.Core.Graphs.SccFinder.FindAll<TNode>(Reko.Core.Graphs.DirectedGraph<TNode> graph) -> System.Collections.Generic.List<TNode[]>
static Reko.Core.Graphs.SccFinder.RobustTopologicalSort<TNode>(Reko.Core.Graphs.DirectedGraph<TNode> graph) -> System.Collections.Generic.List<TNode[]>
static Reko.Core.Graphs.SccFinder.TopologicalSort<TNode>(Reko.Core.Graphs.DirectedGraph<TNode> graph) -> System.Collections.Generic.List<TNode>
static Reko.Core.Hll.C.CLexer.GccKeywords.get -> System.Collections.Generic.Dictionary<string, Reko.Core.Hll.C.CTokenType>
static Reko.Core.Hll.C.CLexer.MsvcCeKeywords.get -> System.Collections.Generic.Dictionary<string, Reko.Core.Hll.C.CTokenType>
static Reko.Core.Hll.C.CLexer.MsvcKeywords.get -> System.Collections.Generic.Dictionary<string, Reko.Core.Hll.C.CTokenType>
static Reko.Core.Hll.C.CLexer.StdKeywords.get -> System.Collections.Generic.Dictionary<string, Reko.Core.Hll.C.CTokenType>
static Reko.Core.Hll.C.NameExtractor.GetName(System.Collections.Generic.IEnumerable<Reko.Core.Hll.C.DeclSpec> declspecs, Reko.Core.Hll.C.Declarator declarator, Reko.Core.Hll.C.ParserState state) -> string
static Reko.Core.Hll.C.ParseResult.Ok<T>(T item) -> Reko.Core.Hll.C.ParseResult<T>
static Reko.Core.Hll.C.UserSignatureBuilder.IsValidCIdentifier(string id) -> bool
static Reko.Core.Hll.Pascal.ParameterDeclaration.Write(System.IO.TextWriter writer, Reko.Core.Hll.Pascal.ParameterDeclaration decl) -> void
static Reko.Core.Hll.Pascal.PascalSyntax.WriteList(System.IO.TextWriter writer, string sep, System.Collections.Generic.IEnumerable<Reko.Core.Hll.Pascal.PascalSyntax> items) -> void
static Reko.Core.Hll.Pascal.PascalSyntax.WriteList<T>(System.IO.TextWriter writer, string sep, System.Collections.Generic.IEnumerable<T> items, System.Action<System.IO.TextWriter, T> wr) -> void
static Reko.Core.Hll.Pascal.Primitive.Char() -> Reko.Core.Hll.Pascal.Primitive
static Reko.Core.Hll.Pascal.Primitive.Integer() -> Reko.Core.Hll.Pascal.Primitive
static Reko.Core.Hll.Pascal.Record.WriteField(System.IO.TextWriter writer, Reko.Core.Hll.Pascal.Field field) -> void
static Reko.Core.ImageLocation.FromUri(string uri) -> Reko.Core.ImageLocation
static Reko.Core.ImageSymbol.Create(Reko.Core.SymbolType type, Reko.Core.IProcessorArchitecture arch, Reko.Core.Address address, string name = null, Reko.Core.Types.DataType dataType = null, bool decompile = true) -> Reko.Core.ImageSymbol
static Reko.Core.ImageSymbol.DataObject(Reko.Core.IProcessorArchitecture arch, Reko.Core.Address address, string name = null, Reko.Core.Types.DataType dataType = null) -> Reko.Core.ImageSymbol
static Reko.Core.ImageSymbol.ExternalProcedure(Reko.Core.IProcessorArchitecture arch, Reko.Core.Address address, string name) -> Reko.Core.ImageSymbol
static Reko.Core.ImageSymbol.Location(Reko.Core.IProcessorArchitecture arch, Reko.Core.Address address) -> Reko.Core.ImageSymbol
static Reko.Core.ImageSymbol.Procedure(Reko.Core.IProcessorArchitecture arch, Reko.Core.Address address, string name = null, Reko.Core.Types.DataType dataType = null, Reko.Core.Serialization.SerializedSignature signature = null, Reko.Core.ProcessorState state = null) -> Reko.Core.ImageSymbol
static Reko.Core.Intrinsics.IntrinsicBuilder.Binary(string intrinsicName, Reko.Core.Types.DataType dt) -> Reko.Core.IntrinsicProcedure
static Reko.Core.Intrinsics.IntrinsicBuilder.GenericBinary(string name) -> Reko.Core.IntrinsicProcedure
static Reko.Core.Intrinsics.IntrinsicBuilder.GenericBinary(string name, bool hasSideEffect) -> Reko.Core.IntrinsicProcedure
static Reko.Core.Intrinsics.IntrinsicBuilder.GenericTernary(string name) -> Reko.Core.IntrinsicProcedure
static Reko.Core.Intrinsics.IntrinsicBuilder.GenericUnary(string name) -> Reko.Core.IntrinsicProcedure
static Reko.Core.Intrinsics.IntrinsicBuilder.Predicate(string intrinsicName, params Reko.Core.Types.DataType[] dataTypes) -> Reko.Core.IntrinsicProcedure
static Reko.Core.Intrinsics.IntrinsicBuilder.Ternary(string intrinsicName, Reko.Core.Types.DataType dt) -> Reko.Core.IntrinsicProcedure
static Reko.Core.Intrinsics.IntrinsicBuilder.Unary(string intrinsicName, Reko.Core.Types.PrimitiveType dt) -> Reko.Core.IntrinsicProcedure
static Reko.Core.IO.SpanExtensions.Cast<T>(this System.ReadOnlySpan<byte> data) -> System.ReadOnlySpan<T>
static Reko.Core.IO.SpanExtensions.Cast<T>(this System.Span<byte> data) -> System.Span<T>
static Reko.Core.IO.SpanExtensions.CopyTo<TFrom, TTo>(this System.Memory<TFrom> data, System.Memory<TTo> dest, int dstOffset) -> void
static Reko.Core.IO.SpanExtensions.CopyTo<TFrom, TTo>(this System.Span<TFrom> data, System.Span<TTo> dest, int dstOffset) -> void
static Reko.Core.IO.SpanExtensions.Read<T>(this System.ReadOnlySpan<byte> data, int offset) -> T
static Reko.Core.IO.SpanExtensions.Read<T>(this System.Span<byte> data, int offset) -> T
static Reko.Core.IO.SpanExtensions.Write<T>(this System.Span<byte> data, int offset, T value) -> void
static Reko.Core.IO.SpanExtensions.WriteBytes(this System.Span<byte> data, int offset, byte[] bytes) -> void
static Reko.Core.Lib.Bitfield.ReadFields(Reko.Core.Lib.Bitfield[] bitfields, uint u) -> uint
static Reko.Core.Lib.Bitfield.ReadFields(Reko.Core.Lib.Bitfield[] bitfields, ulong u) -> ulong
static Reko.Core.Lib.Bitfield.ReadSignedFields(Reko.Core.Lib.Bitfield[] fields, uint u) -> int
static Reko.Core.Lib.Bitfield.ReadSignedFields(Reko.Core.Lib.Bitfield[] fields, ulong ul) -> long
static Reko.Core.Lib.Bits.BitCount(ulong u) -> int
static Reko.Core.Lib.Bits.CountLeadingZeros(int wordSize, ulong x) -> int
static Reko.Core.Lib.Bits.IsBitSet(uint u, int pos) -> bool
static Reko.Core.Lib.Bits.IsBitSet(ulong u, int pos) -> bool
static Reko.Core.Lib.Bits.IsEvenPowerOfTwo(long n) -> bool
static Reko.Core.Lib.Bits.IsSingleBitSet(uint w) -> bool
static Reko.Core.Lib.Bits.Log2(uint value) -> int
static Reko.Core.Lib.Bits.Mask(int lsb, int bitsize) -> ulong
static Reko.Core.Lib.Bits.Mask(int maskWidth) -> System.Numerics.BigInteger
static Reko.Core.Lib.Bits.Replicate64(ulong pattern, int length, int times) -> ulong
static Reko.Core.Lib.Bits.Reverse(uint u) -> uint
static Reko.Core.Lib.Bits.RotateL64(ulong u, int s) -> ulong
static Reko.Core.Lib.Bits.RotateR(int wordSize, ulong u, int s) -> ulong
static Reko.Core.Lib.Bits.RotateR32(uint u, int s) -> uint
static Reko.Core.Lib.Bits.SignExtend(uint w, int b) -> uint
static Reko.Core.Lib.Bits.SignExtend(ulong w, int b) -> ulong
static Reko.Core.Lib.Bits.ZeroExtend(ulong w, int b) -> ulong
static Reko.Core.Lib.Float16.IsNaN(Reko.Core.Lib.Float16 a) -> bool
static Reko.Core.Lib.Float16.operator -(Reko.Core.Lib.Float16 a) -> Reko.Core.Lib.Float16
static Reko.Core.Lib.Float80.operator -(Reko.Core.Lib.Float80 a) -> Reko.Core.Lib.Float80
static Reko.Core.Lib.Float96.operator -(Reko.Core.Lib.Float96 a) -> Reko.Core.Lib.Float96
static Reko.Core.Lib.Rational.FromDouble(double x) -> Reko.Core.Lib.Rational
static Reko.Core.Lib.Rational.FromIntegers(long num, long den) -> Reko.Core.Lib.Rational
static Reko.Core.Lib.Rational.operator +(int n, Reko.Core.Lib.Rational r) -> Reko.Core.Lib.Rational
static Reko.Core.Lib.Rational.operator +(Reko.Core.Lib.Rational r, long n) -> Reko.Core.Lib.Rational
static Reko.Core.Lib.Rational.operator /(Reko.Core.Lib.Rational r, long n) -> Reko.Core.Lib.Rational
static Reko.Core.Lib.SuffixArray.Create(byte[] arr) -> Reko.Core.Lib.SuffixArray<byte>
static Reko.Core.Lib.SuffixArray.Create(string str) -> Reko.Core.Lib.SuffixArray<char>
static Reko.Core.Lib.SuffixArray.Load<T>(T[] arr, int[] intArray) -> Reko.Core.Lib.SuffixArray<T>
static Reko.Core.Lib.SuffixArray2.Create(byte[] a) -> Reko.Core.Lib.SuffixArray2
static Reko.Core.LinearInductionVariable.Gcd(int a, int b) -> int
static Reko.Core.LinearInductionVariable.Merge(Reko.Core.LinearInductionVariable liv1, Reko.Core.LinearInductionVariable liv2) -> Reko.Core.LinearInductionVariable
static Reko.Core.Loading.ResourceType.MakeDictionary(System.Type type) -> System.Collections.Generic.Dictionary<int, Reko.Core.Loading.ResourceType>
static Reko.Core.Loading.ResourceType.operator !=(Reko.Core.Loading.ResourceType a, Reko.Core.Loading.ResourceType b) -> bool
static Reko.Core.Loading.ResourceType.operator ==(Reko.Core.Loading.ResourceType a, Reko.Core.Loading.ResourceType b) -> bool
static Reko.Core.Machine.AbstractMachineOperand.FormatSignedValue(Reko.Core.Expressions.Constant! c, bool forceSign = true, string! format = "{0}{1}") -> string!
static Reko.Core.Machine.AbstractMachineOperand.FormatUnsignedValue(Reko.Core.Expressions.Constant! c, string! format = "{0}{1}") -> string!
static Reko.Core.Machine.AbstractMachineOperand.FormatValue(Reko.Core.Expressions.Constant! c, bool forceSignForSignedIntegers = true, string! integerFormat = "{0}{1}") -> string!
static Reko.Core.Machine.AddressOperand.Create(Reko.Core.Address! addr) -> Reko.Core.Machine.AddressOperand!
static Reko.Core.Machine.AddressOperand.Ptr16(ushort a) -> Reko.Core.Machine.AddressOperand!
static Reko.Core.Machine.AddressOperand.Ptr32(uint a) -> Reko.Core.Machine.AddressOperand!
static Reko.Core.Machine.AddressOperand.Ptr64(ulong a) -> Reko.Core.Machine.AddressOperand!
static Reko.Core.Machine.Decoder.DumpMaskedInstruction(int instrBitSize, uint wInstr, Reko.Core.Lib.Bitfield[] bitfields, string tag) -> void
static Reko.Core.Machine.Decoder.DumpMaskedInstruction(int instrBitSize, ulong wInstr, ulong shMask, string tag) -> void
static Reko.Core.Machine.Decoder<TDasm, TMnemonic, TInstr>.DumpMaskedInstruction(uint wInstr, uint shMask, TMnemonic mnemonic) -> void
static Reko.Core.Machine.Decoder<TDasm, TMnemonic, TInstr>.DumpMaskedInstruction64(uint wInstr, uint shMask, TMnemonic mnemonic) -> void
static Reko.Core.Machine.DisassemblerBase.Bf(params (int pos, int len)[] fields) -> Reko.Core.Lib.Bitfield[]
static Reko.Core.Machine.DisassemblerBase<TInstr, TMnemonic>.If<TDasm>(int bitpos, int bitlen, System.Predicate<uint> predicate, Reko.Core.Machine.Decoder<TDasm, TMnemonic, TInstr> decoderTrue) -> Reko.Core.Machine.IfDecoder<TDasm, TMnemonic, TInstr>
static Reko.Core.Machine.DisassemblerBase<TInstr, TMnemonic>.If<TDasm>(System.Predicate<uint> predicate, Reko.Core.Machine.Decoder<TDasm, TMnemonic, TInstr> decoderTrue) -> Reko.Core.Machine.IfDecoder<TDasm, TMnemonic, TInstr>
static Reko.Core.Machine.DisassemblerBase<TInstr, TMnemonic>.Instr<TDasm>(TMnemonic mnemonic, params Reko.Core.Machine.Mutator<TDasm!>![]! mutators) -> Reko.Core.Machine.Decoder<TDasm!, TMnemonic, TInstr!>!
static Reko.Core.Machine.DisassemblerBase<TInstr, TMnemonic>.Instr<TDasm>(TMnemonic mnemonic, Reko.Core.InstrClass iclass, params Reko.Core.Machine.Mutator<TDasm>[] mutators) -> Reko.Core.Machine.Decoder<TDasm, TMnemonic, TInstr>
static Reko.Core.Machine.DisassemblerBase<TInstr, TMnemonic>.Mask<TDasm>(int bitPos, int bitLength, params Reko.Core.Machine.Decoder<TDasm!, TMnemonic, TInstr!>![]! decoders) -> Reko.Core.Machine.MaskDecoder<TDasm!, TMnemonic, TInstr!>!
static Reko.Core.Machine.DisassemblerBase<TInstr, TMnemonic>.Mask<TDasm>(int bitPos, int bitLength, string! tag, params Reko.Core.Machine.Decoder<TDasm!, TMnemonic, TInstr!>![]! decoders) -> Reko.Core.Machine.MaskDecoder<TDasm!, TMnemonic, TInstr!>!
static Reko.Core.Machine.DisassemblerBase<TInstr, TMnemonic>.Mask<TDasm>(int p1, int l1, int p2, int l2, string tag, params Reko.Core.Machine.Decoder<TDasm, TMnemonic, TInstr>[] decoders) -> Reko.Core.Machine.BitfieldDecoder<TDasm, TMnemonic, TInstr>
static Reko.Core.Machine.DisassemblerBase<TInstr, TMnemonic>.Mask<TDasm>(Reko.Core.Lib.Bitfield[] bitfields, params Reko.Core.Machine.Decoder<TDasm, TMnemonic, TInstr>[] decoders) -> Reko.Core.Machine.BitfieldDecoder<TDasm, TMnemonic, TInstr>
static Reko.Core.Machine.DisassemblerBase<TInstr, TMnemonic>.Mask<TDasm>(Reko.Core.Lib.Bitfield[] bitfields, string tag, params Reko.Core.Machine.Decoder<TDasm, TMnemonic, TInstr>[] decoders) -> Reko.Core.Machine.BitfieldDecoder<TDasm, TMnemonic, TInstr>
static Reko.Core.Machine.DisassemblerBase<TInstr, TMnemonic>.Select<TDasm>((int, int) fieldSpecifier, System.Predicate<uint> predicate, Reko.Core.Machine.Decoder<TDasm, TMnemonic, TInstr> decoderTrue, Reko.Core.Machine.Decoder<TDasm, TMnemonic, TInstr> decoderFalse) -> Reko.Core.Machine.ConditionalDecoder<TDasm, TMnemonic, TInstr>
static Reko.Core.Machine.DisassemblerBase<TInstr, TMnemonic>.Select<TDasm>((int, int) fieldSpecifier, System.Predicate<uint> predicate, string tag, Reko.Core.Machine.Decoder<TDasm, TMnemonic, TInstr> decoderTrue, Reko.Core.Machine.Decoder<TDasm, TMnemonic, TInstr> decoderFalse) -> Reko.Core.Machine.ConditionalDecoder<TDasm, TMnemonic, TInstr>
static Reko.Core.Machine.DisassemblerBase<TInstr, TMnemonic>.Select<TDasm>(Reko.Core.Lib.Bitfield[] fields, System.Predicate<uint> predicate, Reko.Core.Machine.Decoder<TDasm, TMnemonic, TInstr> decoderTrue, Reko.Core.Machine.Decoder<TDasm, TMnemonic, TInstr> decoderFalse) -> Reko.Core.Machine.ConditionalDecoder<TDasm, TMnemonic, TInstr>
static Reko.Core.Machine.DisassemblerBase<TInstr, TMnemonic>.Select<TDasm>(Reko.Core.Lib.Bitfield[] fields, System.Predicate<uint> predicate, string tag, Reko.Core.Machine.Decoder<TDasm, TMnemonic, TInstr> decoderTrue, Reko.Core.Machine.Decoder<TDasm, TMnemonic, TInstr> decoderFalse) -> Reko.Core.Machine.ConditionalDecoder<TDasm, TMnemonic, TInstr>
static Reko.Core.Machine.DisassemblerBase<TInstr, TMnemonic>.Select<TDasm>(System.Predicate<uint> predicate, Reko.Core.Machine.Decoder<TDasm, TMnemonic, TInstr> decoderTrue, Reko.Core.Machine.Decoder<TDasm, TMnemonic, TInstr> decoderFalse) -> Reko.Core.Machine.ConditionalDecoder<TDasm, TMnemonic, TInstr>
static Reko.Core.Machine.DisassemblerBase<TInstr, TMnemonic>.Sparse<TDasm>(int bitPosition, int bits, Reko.Core.Machine.Decoder<TDasm, TMnemonic, TInstr> defaultDecoder, params (uint, Reko.Core.Machine.Decoder<TDasm, TMnemonic, TInstr>)[] sparseDecoders) -> Reko.Core.Machine.MaskDecoder<TDasm, TMnemonic, TInstr>
static Reko.Core.Machine.DisassemblerBase<TInstr, TMnemonic>.Sparse<TDasm>(int bitPosition, int bits, string tag, Reko.Core.Machine.Decoder<TDasm, TMnemonic, TInstr> defaultDecoder, params (uint, Reko.Core.Machine.Decoder<TDasm, TMnemonic, TInstr>)[] sparseDecoders) -> Reko.Core.Machine.MaskDecoder<TDasm, TMnemonic, TInstr>
static Reko.Core.Machine.DisassemblerBase<TInstr, TMnemonic>.WideSparse<TDasm>(int bitPosition, int bits, string tag, Reko.Core.Machine.WideDecoder<TDasm, TMnemonic, TInstr> defaultDecoder, params (uint, Reko.Core.Machine.WideDecoder<TDasm, TMnemonic, TInstr>)[] sparseDecoders) -> Reko.Core.Machine.WideMaskDecoder<TDasm, TMnemonic, TInstr>
static Reko.Core.Machine.ImmediateOperand.Byte(byte value) -> Reko.Core.Machine.ImmediateOperand!
static Reko.Core.Machine.ImmediateOperand.Int16(short value) -> Reko.Core.Machine.AbstractMachineOperand!
static Reko.Core.Machine.ImmediateOperand.Int32(int value) -> Reko.Core.Machine.ImmediateOperand!
static Reko.Core.Machine.ImmediateOperand.SByte(sbyte value) -> Reko.Core.Machine.ImmediateOperand!
static Reko.Core.Machine.ImmediateOperand.UInt16(ushort value) -> Reko.Core.Machine.ImmediateOperand!
static Reko.Core.Machine.ImmediateOperand.UInt32(uint value) -> Reko.Core.Machine.ImmediateOperand!
static Reko.Core.Machine.ImmediateOperand.Word128(ulong value) -> Reko.Core.Machine.ImmediateOperand!
static Reko.Core.Machine.ImmediateOperand.Word16(ushort value) -> Reko.Core.Machine.AbstractMachineOperand!
static Reko.Core.Machine.ImmediateOperand.Word32(int value) -> Reko.Core.Machine.ImmediateOperand!
static Reko.Core.Machine.ImmediateOperand.Word32(uint value) -> Reko.Core.Machine.ImmediateOperand!
static Reko.Core.Machine.ImmediateOperand.Word64(long value) -> Reko.Core.Machine.ImmediateOperand!
static Reko.Core.Machine.ImmediateOperand.Word64(ulong value) -> Reko.Core.Machine.ImmediateOperand!
static Reko.Core.Machine.MachineInstructionRendererOptions.Default.get -> Reko.Core.Machine.MachineInstructionRendererOptions
static Reko.Core.MaskedPattern.Load(string? sBytes, string? sMask) -> Reko.Core.MaskedPattern?
static Reko.Core.Memory.ByteMemoryArea.CompareArrays(byte[] src, int iSrc, byte[] dst, int cb) -> bool
static Reko.Core.Memory.ByteMemoryArea.ReadBeDouble(byte[] abImage, long off) -> Reko.Core.Expressions.Constant
static Reko.Core.Memory.ByteMemoryArea.ReadBeFloat(byte[] abImage, long off) -> Reko.Core.Expressions.Constant
static Reko.Core.Memory.ByteMemoryArea.ReadBeInt16(byte[] img, long offset) -> short
static Reko.Core.Memory.ByteMemoryArea.ReadBeInt32(byte[] abImage, long off) -> int
static Reko.Core.Memory.ByteMemoryArea.ReadBeInt64(byte[] image, long off) -> long
static Reko.Core.Memory.ByteMemoryArea.ReadBeUInt16(byte[] abImage, long off) -> ushort
static Reko.Core.Memory.ByteMemoryArea.ReadBeUInt32(byte[] abImage, long off) -> uint
static Reko.Core.Memory.ByteMemoryArea.ReadBeUInt64(byte[] abImage, long off) -> ulong
static Reko.Core.Memory.ByteMemoryArea.ReadLeDouble(byte[] abImage, long off) -> Reko.Core.Expressions.Constant
static Reko.Core.Memory.ByteMemoryArea.ReadLeFloat(byte[] abImage, long off) -> Reko.Core.Expressions.Constant
static Reko.Core.Memory.ByteMemoryArea.ReadLeInt16(byte[] abImage, long offset) -> short
static Reko.Core.Memory.ByteMemoryArea.ReadLeInt32(byte[] abImage, long off) -> int
static Reko.Core.Memory.ByteMemoryArea.ReadLeInt64(byte[] image, long off) -> long
static Reko.Core.Memory.ByteMemoryArea.ReadLeUInt16(byte[] img, long off) -> ushort
static Reko.Core.Memory.ByteMemoryArea.ReadLeUInt32(byte[] img, long off) -> uint
static Reko.Core.Memory.ByteMemoryArea.ReadLeUInt64(byte[] img, long off) -> ulong
static Reko.Core.Memory.ByteMemoryArea.TryReadBe(byte[] abImage, long imageOffset, Reko.Core.Types.DataType type, out Reko.Core.Expressions.Constant value) -> bool
static Reko.Core.Memory.ByteMemoryArea.TryReadBeInt16(byte[] img, long offset, out short value) -> bool
static Reko.Core.Memory.ByteMemoryArea.TryReadBeInt32(byte[] abImage, long off, out int value) -> bool
static Reko.Core.Memory.ByteMemoryArea.TryReadBeInt64(byte[] image, long off, out long value) -> bool
static Reko.Core.Memory.ByteMemoryArea.TryReadBeUInt16(byte[] img, long offset, out ushort value) -> bool
static Reko.Core.Memory.ByteMemoryArea.TryReadBeUInt32(byte[] abImage, long off, out uint value) -> bool
static Reko.Core.Memory.ByteMemoryArea.TryReadBeUInt64(byte[] image, long off, out ulong value) -> bool
static Reko.Core.Memory.ByteMemoryArea.TryReadByte(byte[] img, long off, out byte b) -> bool
static Reko.Core.Memory.ByteMemoryArea.TryReadLe(byte[] abImage, long imageOffset, Reko.Core.Types.DataType type, out Reko.Core.Expressions.Constant c) -> bool
static Reko.Core.Memory.ByteMemoryArea.TryReadLeInt16(byte[] img, long offset, out short value) -> bool
static Reko.Core.Memory.ByteMemoryArea.TryReadLeInt32(byte[] abImage, uint off, out int value) -> bool
static Reko.Core.Memory.ByteMemoryArea.TryReadLeInt64(byte[] image, long off, out long value) -> bool
static Reko.Core.Memory.ByteMemoryArea.TryReadLeReal80(byte[] image, long off, out Reko.Core.Lib.Float80 value) -> bool
static Reko.Core.Memory.ByteMemoryArea.TryReadLeUInt16(byte[] abImage, long offset, out ushort us) -> bool
static Reko.Core.Memory.ByteMemoryArea.TryReadLeUInt32(byte[] abImage, long off, out uint value) -> bool
static Reko.Core.Memory.ByteMemoryArea.TryReadLeUInt64(byte[] image, long off, out ulong value) -> bool
static Reko.Core.Memory.ByteMemoryArea.WriteBeUInt32(byte[] abImage, uint offset, uint dw) -> void
static Reko.Core.Memory.ByteMemoryArea.WriteBytes(byte[] srcBytes, long offset, int count, byte[] dstBytes) -> void
static Reko.Core.Memory.ByteMemoryArea.WriteLeInt16(byte[] abImage, long offset, short w) -> void
static Reko.Core.Memory.ByteMemoryArea.WriteLeUInt32(byte[] abImage, uint offset, uint dw) -> void
static Reko.Core.MemoryStorage.Instance.get -> Reko.Core.MemoryStorage
static Reko.Core.NamingPolicy.SanitizeIdentifierName(string name) -> string
static Reko.Core.Output.MockGenerator.DumpClass(Reko.Core.Procedure proc) -> void
static Reko.Core.Output.MockGenerator.DumpMethod(Reko.Core.Procedure proc) -> void
static Reko.Core.Output.OutputFilePolicy.CreateOutputPolicy(System.IServiceProvider services, Reko.Core.Program program, string sPolicy) -> Reko.Core.Output.OutputFilePolicy
static Reko.Core.Output.TypeFormatter.WriteQualifier(Reko.Core.Types.Qualifier q, Reko.Core.Output.Formatter writer) -> Reko.Core.Output.Formatter
static Reko.Core.Procedure.Create(Reko.Core.IProcessorArchitecture arch, Reko.Core.Address addr, Reko.Core.Frame f) -> Reko.Core.Procedure
static Reko.Core.Procedure.Create(Reko.Core.IProcessorArchitecture arch, string name, Reko.Core.Address addr, Reko.Core.Frame f) -> Reko.Core.Procedure
static Reko.Core.Project.FromSingleProgram(Reko.Core.Program program) -> Reko.Core.Project
static Reko.Core.RegisterStorage.None.get -> Reko.Core.RegisterStorage
static Reko.Core.RegisterStorage.Reg16(string name, int number) -> Reko.Core.RegisterStorage
static Reko.Core.RegisterStorage.Reg32(string name, int number) -> Reko.Core.RegisterStorage
static Reko.Core.RegisterStorage.Reg64(string name, int number) -> Reko.Core.RegisterStorage
static Reko.Core.RegisterStorage.Reg8(string name, int number) -> Reko.Core.RegisterStorage
static Reko.Core.RegisterStorage.Sysreg(string name, int number, Reko.Core.Types.PrimitiveType size) -> Reko.Core.RegisterStorage
static Reko.Core.Rtl.RtlInstruction.FormatClass(Reko.Core.InstrClass rtlClass) -> string
static Reko.Core.Rtl.RtlLocation.Loc16(ushort uAddr, int index) -> Reko.Core.Rtl.RtlLocation
static Reko.Core.Rtl.RtlLocation.Loc32(uint uAddr, int index) -> Reko.Core.Rtl.RtlLocation
static Reko.Core.Rtl.RtlLocation.Loc64(ulong uAddr, int index) -> Reko.Core.Rtl.RtlLocation
static Reko.Core.Rtl.RtlLocation.Min(Reko.Core.Rtl.RtlLocation a, Reko.Core.Rtl.RtlLocation b) -> Reko.Core.Rtl.RtlLocation
static Reko.Core.Rtl.RtlLocation.operator !=(Reko.Core.Rtl.RtlLocation a, Reko.Core.Rtl.RtlLocation b) -> bool
static Reko.Core.Rtl.RtlLocation.operator <(Reko.Core.Rtl.RtlLocation a, Reko.Core.Rtl.RtlLocation b) -> bool
static Reko.Core.Rtl.RtlLocation.operator <=(Reko.Core.Rtl.RtlLocation a, Reko.Core.Rtl.RtlLocation b) -> bool
static Reko.Core.Rtl.RtlLocation.operator ==(Reko.Core.Rtl.RtlLocation a, Reko.Core.Rtl.RtlLocation b) -> bool
static Reko.Core.Rtl.RtlLocation.operator >(Reko.Core.Rtl.RtlLocation a, Reko.Core.Rtl.RtlLocation b) -> bool
static Reko.Core.Rtl.RtlLocation.operator >=(Reko.Core.Rtl.RtlLocation a, Reko.Core.Rtl.RtlLocation b) -> bool
static Reko.Core.Serialization.DefaultProcedureCharacteristics.Instance.get -> Reko.Core.Serialization.DefaultProcedureCharacteristics
static Reko.Core.Serialization.MemoryMap_v1.ConvertAccess(string attributes) -> Reko.Core.AccessMode
static Reko.Core.Serialization.MemoryMap_v1.Deserialize(System.IO.Stream stm) -> Reko.Core.Serialization.MemoryMap_v1
static Reko.Core.Serialization.MemoryMap_v1.LoadSegment(Reko.Core.Serialization.MemorySegment_v1 segment, Reko.Core.IPlatform platform, Reko.Core.Services.DecompilerEventListener listener) -> Reko.Core.ImageSegment
static Reko.Core.Serialization.PointerType_v1.Create(Reko.Core.Serialization.SerializedType dt, int n) -> Reko.Core.Serialization.SerializedType
static Reko.Core.Serialization.PrimitiveType_v1.Bool(int byteSize = 1) -> Reko.Core.Serialization.SerializedType
static Reko.Core.Serialization.PrimitiveType_v1.Char8() -> Reko.Core.Serialization.SerializedType
static Reko.Core.Serialization.PrimitiveType_v1.Int16() -> Reko.Core.Serialization.SerializedType
static Reko.Core.Serialization.PrimitiveType_v1.Int32() -> Reko.Core.Serialization.SerializedType
static Reko.Core.Serialization.PrimitiveType_v1.Int64() -> Reko.Core.Serialization.SerializedType
static Reko.Core.Serialization.PrimitiveType_v1.Ptr32() -> Reko.Core.Serialization.SerializedType
static Reko.Core.Serialization.PrimitiveType_v1.Real32() -> Reko.Core.Serialization.SerializedType
static Reko.Core.Serialization.PrimitiveType_v1.Real64() -> Reko.Core.Serialization.SerializedType
static Reko.Core.Serialization.PrimitiveType_v1.Real80() -> Reko.Core.Serialization.SerializedType
static Reko.Core.Serialization.PrimitiveType_v1.SChar8() -> Reko.Core.Serialization.SerializedType
static Reko.Core.Serialization.PrimitiveType_v1.UChar8() -> Reko.Core.Serialization.SerializedType
static Reko.Core.Serialization.PrimitiveType_v1.UInt16() -> Reko.Core.Serialization.SerializedType
static Reko.Core.Serialization.PrimitiveType_v1.UInt32() -> Reko.Core.Serialization.SerializedType
static Reko.Core.Serialization.PrimitiveType_v1.UInt64() -> Reko.Core.Serialization.SerializedType
static Reko.Core.Serialization.PrimitiveType_v1.WChar16() -> Reko.Core.Serialization.SerializedType
static Reko.Core.Serialization.ProjectPersister.ConvertToAbsoluteLocation(Reko.Core.ImageLocation! projectLocation, string? projectRelativeUri) -> Reko.Core.ImageLocation?
static Reko.Core.Serialization.ProjectPersister.ConvertToAbsolutePath(string projectAbsPath, string projectRelative) -> string
static Reko.Core.Serialization.ProjectVersionMigrator.MigrateDecompilerInput(Reko.Core.Serialization.DecompilerInput_v4 v4) -> Reko.Core.Serialization.DecompilerInput_v5
static Reko.Core.Serialization.ProjectVersionMigrator.MigrateProject(Reko.Core.Serialization.Project_v4 v4) -> Reko.Core.Serialization.Project_v5
static Reko.Core.Serialization.SerializedLibrary.CreateSerializer() -> System.Xml.Serialization.XmlSerializer
static Reko.Core.Serialization.SerializedLibrary.CreateSerializer(System.Type rootType, string namespace) -> System.Xml.Serialization.XmlSerializer
static Reko.Core.Serialization.SerializedLibrary.CreateSerializer_v1(System.Type rootType) -> System.Xml.Serialization.XmlSerializer
static Reko.Core.Serialization.SerializedLibrary.CreateSerializer_v4(System.Type rootType) -> System.Xml.Serialization.XmlSerializer
static Reko.Core.Serialization.SerializedLibrary.CreateSerializer_v5(System.Type rootType) -> System.Xml.Serialization.XmlSerializer
static Reko.Core.Serialization.SerializedLibrary.LoadFromStream(System.IO.Stream stm) -> Reko.Core.Serialization.SerializedLibrary
static Reko.Core.Serialization.SerializedType.GetAttributeOverrides(System.Collections.Generic.IEnumerable<System.Type> typesToDecorate, string xmlNamespace) -> System.Xml.Serialization.XmlAttributeOverrides
static Reko.Core.Services.NullDecompilerEventListener.Instance.get -> Reko.Core.Services.DecompilerEventListener!
static Reko.Core.StridedInterval.Constant(Reko.Core.Expressions.Constant c) -> Reko.Core.StridedInterval
static Reko.Core.StridedInterval.Create(int stride, long low, long high) -> Reko.Core.StridedInterval
static Reko.Core.TypedServiceProvider.AddService<T>(this System.ComponentModel.Design.IServiceContainer sc, T service) -> void
static Reko.Core.TypedServiceProvider.GetService<T>(this System.IServiceProvider sp) -> T
static Reko.Core.TypedServiceProvider.RequireService<T>(this System.IServiceProvider sp) -> T
static Reko.Core.Types.DataTypeComparer.Instance.get -> Reko.Core.Types.DataTypeComparer
static Reko.Core.Types.EquivalenceClass.Merge(Reko.Core.Types.EquivalenceClass class1, Reko.Core.Types.EquivalenceClass class2) -> Reko.Core.Types.EquivalenceClass
static Reko.Core.Types.FunctionType.Action(params Reko.Core.Expressions.Identifier[] parameters) -> Reko.Core.Types.FunctionType
static Reko.Core.Types.FunctionType.Create(Reko.Core.Expressions.Identifier returnId, params Reko.Core.Expressions.Identifier[] formals) -> Reko.Core.Types.FunctionType
static Reko.Core.Types.FunctionType.Func(Reko.Core.Expressions.Identifier returnId, params Reko.Core.Expressions.Identifier[] formals) -> Reko.Core.Types.FunctionType
static Reko.Core.Types.PrimitiveType.AllTypes.get -> System.Collections.Concurrent.ConcurrentDictionary<string, Reko.Core.Types.PrimitiveType>
static Reko.Core.Types.PrimitiveType.Bcd80.get -> Reko.Core.Types.PrimitiveType
static Reko.Core.Types.PrimitiveType.Bool.get -> Reko.Core.Types.PrimitiveType
static Reko.Core.Types.PrimitiveType.Byte.get -> Reko.Core.Types.PrimitiveType
static Reko.Core.Types.PrimitiveType.Char.get -> Reko.Core.Types.PrimitiveType
static Reko.Core.Types.PrimitiveType.Create(Reko.Core.Types.Domain dom, int bitSize) -> Reko.Core.Types.PrimitiveType
static Reko.Core.Types.PrimitiveType.CreateBitSlice(int bitlength) -> Reko.Core.Types.PrimitiveType
static Reko.Core.Types.PrimitiveType.CreateWord(int bitSize) -> Reko.Core.Types.PrimitiveType
static Reko.Core.Types.PrimitiveType.CreateWord(uint bitSize) -> Reko.Core.Types.PrimitiveType
static Reko.Core.Types.PrimitiveType.GenerateName(Reko.Core.Types.Domain dom, int bitSize) -> string
static Reko.Core.Types.PrimitiveType.Int128.get -> Reko.Core.Types.PrimitiveType
static Reko.Core.Types.PrimitiveType.Int16.get -> Reko.Core.Types.PrimitiveType
static Reko.Core.Types.PrimitiveType.Int32.get -> Reko.Core.Types.PrimitiveType
static Reko.Core.Types.PrimitiveType.Int64.get -> Reko.Core.Types.PrimitiveType
static Reko.Core.Types.PrimitiveType.Int8.get -> Reko.Core.Types.PrimitiveType
static Reko.Core.Types.PrimitiveType.Offset16.get -> Reko.Core.Types.PrimitiveType
static Reko.Core.Types.PrimitiveType.Ptr16.get -> Reko.Core.Types.PrimitiveType
static Reko.Core.Types.PrimitiveType.Ptr32.get -> Reko.Core.Types.PrimitiveType
static Reko.Core.Types.PrimitiveType.Ptr64.get -> Reko.Core.Types.PrimitiveType
static Reko.Core.Types.PrimitiveType.Real128.get -> Reko.Core.Types.PrimitiveType
static Reko.Core.Types.PrimitiveType.Real16.get -> Reko.Core.Types.PrimitiveType
static Reko.Core.Types.PrimitiveType.Real32.get -> Reko.Core.Types.PrimitiveType
static Reko.Core.Types.PrimitiveType.Real64.get -> Reko.Core.Types.PrimitiveType
static Reko.Core.Types.PrimitiveType.Real80.get -> Reko.Core.Types.PrimitiveType
static Reko.Core.Types.PrimitiveType.Real96.get -> Reko.Core.Types.PrimitiveType
static Reko.Core.Types.PrimitiveType.SByte.get -> Reko.Core.Types.PrimitiveType
static Reko.Core.Types.PrimitiveType.SegmentSelector.get -> Reko.Core.Types.PrimitiveType
static Reko.Core.Types.PrimitiveType.SegPtr32.get -> Reko.Core.Types.PrimitiveType
static Reko.Core.Types.PrimitiveType.SegPtr48.get -> Reko.Core.Types.PrimitiveType
static Reko.Core.Types.PrimitiveType.TryParse(string primitiveTypeName, out Reko.Core.Types.PrimitiveType type) -> bool
static Reko.Core.Types.PrimitiveType.UInt128.get -> Reko.Core.Types.PrimitiveType
static Reko.Core.Types.PrimitiveType.UInt16.get -> Reko.Core.Types.PrimitiveType
static Reko.Core.Types.PrimitiveType.UInt32.get -> Reko.Core.Types.PrimitiveType
static Reko.Core.Types.PrimitiveType.UInt64.get -> Reko.Core.Types.PrimitiveType
static Reko.Core.Types.PrimitiveType.UInt8.get -> Reko.Core.Types.PrimitiveType
static Reko.Core.Types.PrimitiveType.WChar.get -> Reko.Core.Types.PrimitiveType
static Reko.Core.Types.PrimitiveType.Word128.get -> Reko.Core.Types.PrimitiveType
static Reko.Core.Types.PrimitiveType.Word16.get -> Reko.Core.Types.PrimitiveType
static Reko.Core.Types.PrimitiveType.Word256.get -> Reko.Core.Types.PrimitiveType
static Reko.Core.Types.PrimitiveType.Word32.get -> Reko.Core.Types.PrimitiveType
static Reko.Core.Types.PrimitiveType.Word512.get -> Reko.Core.Types.PrimitiveType
static Reko.Core.Types.PrimitiveType.Word64.get -> Reko.Core.Types.PrimitiveType
static Reko.Core.Types.PrimitiveType.Word80.get -> Reko.Core.Types.PrimitiveType
static Reko.Core.Types.StringType.LengthPrefixedStringType(Reko.Core.Types.PrimitiveType charType, Reko.Core.Types.PrimitiveType lengthPrefixType) -> Reko.Core.Types.StringType
static Reko.Core.Types.StringType.NullTerminated(Reko.Core.Types.DataType charType) -> Reko.Core.Types.StringType
static Reko.Core.Types.StructureField.ToOffset(Reko.Core.Expressions.Constant offset) -> int?
static Reko.Core.Types.VoidType.Instance.get -> Reko.Core.Types.VoidType
static Reko.Core.UserGlobal.GenerateDefaultName(Reko.Core.Address address) -> string
static Reko.Core.WorkList.Create<T>(System.Collections.Generic.IEnumerable<T>! items) -> Reko.Core.WorkList<T>!
static Reko.Core.XmlOptions.LoadIntoDictionary(System.Xml.XmlElement![]? options, System.StringComparer! comparer) -> System.Collections.Generic.Dictionary<string!, object!>!
virtual Reko.Core.ApplicationBuilder.BindArguments(Reko.Core.Expressions.Identifier[] parameters, bool isVariadic, Reko.Core.Serialization.ProcedureCharacteristics chr) -> System.Collections.Generic.List<Reko.Core.Expressions.Expression>
virtual Reko.Core.Code.Assignment.IsAlias.get -> bool
virtual Reko.Core.Code.InstructionTransformer.TransformAssignment(Reko.Core.Code.Assignment a) -> Reko.Core.Code.Instruction
virtual Reko.Core.Code.InstructionTransformer.TransformBranch(Reko.Core.Code.Branch b) -> Reko.Core.Code.Instruction
virtual Reko.Core.Code.InstructionTransformer.TransformCallInstruction(Reko.Core.Code.CallInstruction ci) -> Reko.Core.Code.Instruction
virtual Reko.Core.Code.InstructionTransformer.TransformComment(Reko.Core.Code.CodeComment codeComment) -> Reko.Core.Code.Instruction
virtual Reko.Core.Code.InstructionTransformer.TransformDeclaration(Reko.Core.Code.Declaration decl) -> Reko.Core.Code.Instruction
virtual Reko.Core.Code.InstructionTransformer.TransformDefInstruction(Reko.Core.Code.DefInstruction def) -> Reko.Core.Code.Instruction
virtual Reko.Core.Code.InstructionTransformer.TransformGotoInstruction(Reko.Core.Code.GotoInstruction gotoInstruction) -> Reko.Core.Code.Instruction
virtual Reko.Core.Code.InstructionTransformer.TransformPhiAssignment(Reko.Core.Code.PhiAssignment phi) -> Reko.Core.Code.Instruction
virtual Reko.Core.Code.InstructionTransformer.TransformReturnInstruction(Reko.Core.Code.ReturnInstruction ret) -> Reko.Core.Code.Instruction
virtual Reko.Core.Code.InstructionTransformer.TransformSideEffect(Reko.Core.Code.SideEffect side) -> Reko.Core.Code.Instruction
virtual Reko.Core.Code.InstructionTransformer.TransformStore(Reko.Core.Code.Store store) -> Reko.Core.Code.Instruction
virtual Reko.Core.Code.InstructionTransformer.TransformSwitchInstruction(Reko.Core.Code.SwitchInstruction si) -> Reko.Core.Code.Instruction
virtual Reko.Core.Code.InstructionTransformer.TransformUseInstruction(Reko.Core.Code.UseInstruction u) -> Reko.Core.Code.Instruction
virtual Reko.Core.Code.InstructionTransformer.VisitAddress(Reko.Core.Address addr) -> Reko.Core.Expressions.Expression
virtual Reko.Core.Code.InstructionTransformer.VisitApplication(Reko.Core.Expressions.Application appl) -> Reko.Core.Expressions.Expression
virtual Reko.Core.Code.InstructionTransformer.VisitArrayAccess(Reko.Core.Expressions.ArrayAccess acc) -> Reko.Core.Expressions.Expression
virtual Reko.Core.Code.InstructionTransformer.VisitBinaryExpression(Reko.Core.Expressions.BinaryExpression binExp) -> Reko.Core.Expressions.Expression
virtual Reko.Core.Code.InstructionTransformer.VisitCast(Reko.Core.Expressions.Cast cast) -> Reko.Core.Expressions.Expression
virtual Reko.Core.Code.InstructionTransformer.VisitConditionalExpression(Reko.Core.Expressions.ConditionalExpression cond) -> Reko.Core.Expressions.Expression
virtual Reko.Core.Code.InstructionTransformer.VisitConstant(Reko.Core.Expressions.Constant c) -> Reko.Core.Expressions.Expression
virtual Reko.Core.Code.InstructionTransformer.VisitConversion(Reko.Core.Expressions.Conversion conversion) -> Reko.Core.Expressions.Expression
virtual Reko.Core.Code.InstructionTransformer.VisitDereference(Reko.Core.Expressions.Dereference deref) -> Reko.Core.Expressions.Expression
virtual Reko.Core.Code.InstructionTransformer.VisitFieldAccess(Reko.Core.Expressions.FieldAccess acc) -> Reko.Core.Expressions.Expression
virtual Reko.Core.Code.InstructionTransformer.VisitIdentifier(Reko.Core.Expressions.Identifier id) -> Reko.Core.Expressions.Expression
virtual Reko.Core.Code.InstructionTransformer.VisitMemberPointerSelector(Reko.Core.Expressions.MemberPointerSelector mps) -> Reko.Core.Expressions.Expression
virtual Reko.Core.Code.InstructionTransformer.VisitMemoryAccess(Reko.Core.Expressions.MemoryAccess access) -> Reko.Core.Expressions.Expression
virtual Reko.Core.Code.InstructionTransformer.VisitMkSequence(Reko.Core.Expressions.MkSequence seq) -> Reko.Core.Expressions.Expression
virtual Reko.Core.Code.InstructionTransformer.VisitOutArgument(Reko.Core.Expressions.OutArgument outArg) -> Reko.Core.Expressions.Expression
virtual Reko.Core.Code.InstructionTransformer.VisitPhiFunction(Reko.Core.Expressions.PhiFunction phi) -> Reko.Core.Expressions.Expression
virtual Reko.Core.Code.InstructionTransformer.VisitPointerAddition(Reko.Core.Expressions.PointerAddition pa) -> Reko.Core.Expressions.Expression
virtual Reko.Core.Code.InstructionTransformer.VisitProcedureConstant(Reko.Core.Expressions.ProcedureConstant pc) -> Reko.Core.Expressions.Expression
virtual Reko.Core.Code.InstructionTransformer.VisitScopeResolution(Reko.Core.Expressions.ScopeResolution scope) -> Reko.Core.Expressions.Expression
virtual Reko.Core.Code.InstructionTransformer.VisitSegmentedAccess(Reko.Core.Expressions.SegmentedAccess access) -> Reko.Core.Expressions.Expression
virtual Reko.Core.Code.InstructionTransformer.VisitSlice(Reko.Core.Expressions.Slice slice) -> Reko.Core.Expressions.Expression
virtual Reko.Core.Code.InstructionTransformer.VisitTestCondition(Reko.Core.Expressions.TestCondition tc) -> Reko.Core.Expressions.Expression
virtual Reko.Core.Code.InstructionTransformer.VisitUnaryExpression(Reko.Core.Expressions.UnaryExpression unary) -> Reko.Core.Expressions.Expression
virtual Reko.Core.Code.InstructionVisitorBase.VisitAddress(Reko.Core.Address addr) -> void
virtual Reko.Core.Code.InstructionVisitorBase.VisitApplication(Reko.Core.Expressions.Application appl) -> void
virtual Reko.Core.Code.InstructionVisitorBase.VisitArrayAccess(Reko.Core.Expressions.ArrayAccess acc) -> void
virtual Reko.Core.Code.InstructionVisitorBase.VisitAssignment(Reko.Core.Code.Assignment a) -> void
virtual Reko.Core.Code.InstructionVisitorBase.VisitBinaryExpression(Reko.Core.Expressions.BinaryExpression binExp) -> void
virtual Reko.Core.Code.InstructionVisitorBase.VisitBranch(Reko.Core.Code.Branch b) -> void
virtual Reko.Core.Code.InstructionVisitorBase.VisitCallInstruction(Reko.Core.Code.CallInstruction ci) -> void
virtual Reko.Core.Code.InstructionVisitorBase.VisitCast(Reko.Core.Expressions.Cast cast) -> void
virtual Reko.Core.Code.InstructionVisitorBase.VisitComment(Reko.Core.Code.CodeComment comment) -> void
virtual Reko.Core.Code.InstructionVisitorBase.VisitConditionalExpression(Reko.Core.Expressions.ConditionalExpression cond) -> void
virtual Reko.Core.Code.InstructionVisitorBase.VisitConditionOf(Reko.Core.Expressions.ConditionOf cof) -> void
virtual Reko.Core.Code.InstructionVisitorBase.VisitConstant(Reko.Core.Expressions.Constant c) -> void
virtual Reko.Core.Code.InstructionVisitorBase.VisitConversion(Reko.Core.Expressions.Conversion conversion) -> void
virtual Reko.Core.Code.InstructionVisitorBase.VisitDeclaration(Reko.Core.Code.Declaration decl) -> void
virtual Reko.Core.Code.InstructionVisitorBase.VisitDefInstruction(Reko.Core.Code.DefInstruction def) -> void
virtual Reko.Core.Code.InstructionVisitorBase.VisitDereference(Reko.Core.Expressions.Dereference deref) -> void
virtual Reko.Core.Code.InstructionVisitorBase.VisitFieldAccess(Reko.Core.Expressions.FieldAccess acc) -> void
virtual Reko.Core.Code.InstructionVisitorBase.VisitGotoInstruction(Reko.Core.Code.GotoInstruction g) -> void
virtual Reko.Core.Code.InstructionVisitorBase.VisitIdentifier(Reko.Core.Expressions.Identifier id) -> void
virtual Reko.Core.Code.InstructionVisitorBase.VisitMemberPointerSelector(Reko.Core.Expressions.MemberPointerSelector mps) -> void
virtual Reko.Core.Code.InstructionVisitorBase.VisitMemoryAccess(Reko.Core.Expressions.MemoryAccess access) -> void
virtual Reko.Core.Code.InstructionVisitorBase.VisitMkSequence(Reko.Core.Expressions.MkSequence seq) -> void
virtual Reko.Core.Code.InstructionVisitorBase.VisitOutArgument(Reko.Core.Expressions.OutArgument outArg) -> void
virtual Reko.Core.Code.InstructionVisitorBase.VisitPhiAssignment(Reko.Core.Code.PhiAssignment phi) -> void
virtual Reko.Core.Code.InstructionVisitorBase.VisitPhiFunction(Reko.Core.Expressions.PhiFunction phi) -> void
virtual Reko.Core.Code.InstructionVisitorBase.VisitPointerAddition(Reko.Core.Expressions.PointerAddition pa) -> void
virtual Reko.Core.Code.InstructionVisitorBase.VisitProcedureConstant(Reko.Core.Expressions.ProcedureConstant pc) -> void
virtual Reko.Core.Code.InstructionVisitorBase.VisitReturnInstruction(Reko.Core.Code.ReturnInstruction ret) -> void
virtual Reko.Core.Code.InstructionVisitorBase.VisitScopeResolution(Reko.Core.Expressions.ScopeResolution scope) -> void
virtual Reko.Core.Code.InstructionVisitorBase.VisitSegmentedAccess(Reko.Core.Expressions.SegmentedAccess access) -> void
virtual Reko.Core.Code.InstructionVisitorBase.VisitSideEffect(Reko.Core.Code.SideEffect side) -> void
virtual Reko.Core.Code.InstructionVisitorBase.VisitSlice(Reko.Core.Expressions.Slice slice) -> void
virtual Reko.Core.Code.InstructionVisitorBase.VisitStore(Reko.Core.Code.Store store) -> void
virtual Reko.Core.Code.InstructionVisitorBase.VisitSwitchInstruction(Reko.Core.Code.SwitchInstruction si) -> void
virtual Reko.Core.Code.InstructionVisitorBase.VisitTestCondition(Reko.Core.Expressions.TestCondition tc) -> void
virtual Reko.Core.Code.InstructionVisitorBase.VisitUnaryExpression(Reko.Core.Expressions.UnaryExpression unary) -> void
virtual Reko.Core.Code.InstructionVisitorBase.VisitUseInstruction(Reko.Core.Code.UseInstruction u) -> void
virtual Reko.Core.CodeEmitter.Alias(Reko.Core.Expressions.Identifier dst, Reko.Core.Expressions.Expression src) -> Reko.Core.Code.AliasAssignment
virtual Reko.Core.CodeEmitter.Assign(Reko.Core.Expressions.Identifier dst, bool f) -> Reko.Core.Code.Assignment
virtual Reko.Core.CodeEmitter.Assign(Reko.Core.Expressions.Identifier dst, int n) -> Reko.Core.Code.Assignment
virtual Reko.Core.CodeEmitter.Assign(Reko.Core.Expressions.Identifier dst, Reko.Core.Expressions.Expression src) -> Reko.Core.Code.Assignment
virtual Reko.Core.CodeEmitter.Goto(uint linearAddress) -> Reko.Core.Code.GotoInstruction
virtual Reko.Core.CodeEmitter.Local16(string name, int offset) -> Reko.Core.Expressions.Identifier
virtual Reko.Core.CodeEmitter.Local32(string name, int offset) -> Reko.Core.Expressions.Identifier
virtual Reko.Core.CodeEmitter.Return() -> void
virtual Reko.Core.CodeEmitter.Return(Reko.Core.Expressions.Expression exp) -> void
virtual Reko.Core.CodeEmitter.Temp(Reko.Core.Types.DataType type, string name) -> Reko.Core.Expressions.Identifier
virtual Reko.Core.Configuration.PlatformDefinition.Architectures.get -> System.Collections.Generic.List<Reko.Core.Configuration.PlatformArchitectureDefinition>
virtual Reko.Core.Configuration.PlatformDefinition.CharacteristicsLibraries.get -> System.Collections.Generic.List<Reko.Core.Configuration.TypeLibraryDefinition>
virtual Reko.Core.Configuration.PlatformDefinition.Load(System.IServiceProvider services, Reko.Core.IProcessorArchitecture arch) -> Reko.Core.IPlatform
virtual Reko.Core.Configuration.PlatformDefinition.Options.get -> System.Collections.Generic.Dictionary<string, object>
virtual Reko.Core.Configuration.PlatformDefinition.SignatureFiles.get -> System.Collections.Generic.List<Reko.Core.Configuration.SignatureFileDefinition>
virtual Reko.Core.Configuration.PlatformDefinition.TypeLibraries.get -> System.Collections.Generic.List<Reko.Core.Configuration.TypeLibraryDefinition>
virtual Reko.Core.Configuration.RekoConfigurationService.GetArchitectures() -> System.Collections.Generic.ICollection<Reko.Core.Configuration.ArchitectureDefinition>
virtual Reko.Core.Configuration.RekoConfigurationService.GetEnvironments() -> System.Collections.Generic.ICollection<Reko.Core.Configuration.PlatformDefinition>
virtual Reko.Core.Configuration.RekoConfigurationService.GetImageLoader(string loaderName) -> Reko.Core.Configuration.LoaderDefinition
virtual Reko.Core.Configuration.RekoConfigurationService.GetImageLoaders() -> System.Collections.Generic.ICollection<Reko.Core.Configuration.LoaderDefinition>
virtual Reko.Core.Configuration.RekoConfigurationService.GetRawFile(string rawFileFormat) -> Reko.Core.Configuration.RawFileDefinition
virtual Reko.Core.Configuration.RekoConfigurationService.GetRawFiles() -> System.Collections.Generic.ICollection<Reko.Core.Configuration.RawFileDefinition>
virtual Reko.Core.Configuration.RekoConfigurationService.GetSignatureFiles() -> System.Collections.Generic.ICollection<Reko.Core.Configuration.SignatureFileDefinition>
virtual Reko.Core.Configuration.RekoConfigurationService.GetSymbolSources() -> System.Collections.Generic.ICollection<Reko.Core.Configuration.SymbolSourceDefinition>
virtual Reko.Core.Diagnostic.ImageKey.get -> string
virtual Reko.Core.Expressions.Constant.DoDepositBits(Reko.Core.Expressions.Constant bits, int offset) -> Reko.Core.Expressions.Constant
virtual Reko.Core.Expressions.Constant.DoSlice(Reko.Core.Types.DataType dt, int offset) -> Reko.Core.Expressions.Constant
virtual Reko.Core.Expressions.Constant.IsIntegerOne.get -> bool
virtual Reko.Core.Expressions.Constant.IsIntegerZero.get -> bool
virtual Reko.Core.Expressions.Constant.IsMaxUnsigned.get -> bool
virtual Reko.Core.Expressions.Constant.IsNegative.get -> bool
virtual Reko.Core.Expressions.Constant.IsValid.get -> bool
virtual Reko.Core.Expressions.Constant.Negate() -> Reko.Core.Expressions.Constant
virtual Reko.Core.Expressions.Constant.Slice(Reko.Core.Types.DataType dt, int offset) -> Reko.Core.Expressions.Constant
virtual Reko.Core.Expressions.Constant.ToBoolean() -> bool
virtual Reko.Core.Expressions.Constant.ToFloat() -> float
virtual Reko.Core.Expressions.Constant.ToReal64() -> double
virtual Reko.Core.Expressions.Expression.Invert() -> Reko.Core.Expressions.Expression
virtual Reko.Core.Expressions.Expression.IsZero.get -> bool
virtual Reko.Core.Expressions.ExpressionEmitter.Mem(Reko.Core.Expressions.MemoryIdentifier mid, Reko.Core.Types.DataType dt, Reko.Core.Expressions.Expression ea) -> Reko.Core.Expressions.MemoryAccess
virtual Reko.Core.Expressions.ExpressionEmitter.Mem16(Reko.Core.Expressions.Expression ea) -> Reko.Core.Expressions.MemoryAccess
virtual Reko.Core.Expressions.ExpressionEmitter.Mem32(Reko.Core.Expressions.Expression ea) -> Reko.Core.Expressions.MemoryAccess
virtual Reko.Core.Expressions.ExpressionEmitter.Mem64(Reko.Core.Expressions.Expression ea) -> Reko.Core.Expressions.MemoryAccess
virtual Reko.Core.Expressions.ExpressionEmitter.Mem8(Reko.Core.Expressions.Expression ea) -> Reko.Core.Expressions.MemoryAccess
virtual Reko.Core.Expressions.ExpressionEmitter.SegMem(Reko.Core.Expressions.MemoryIdentifier mid, Reko.Core.Types.DataType dt, Reko.Core.Expressions.Expression basePtr, Reko.Core.Expressions.Expression offset) -> Reko.Core.Expressions.SegmentedAccess
virtual Reko.Core.Expressions.ExpressionEmitter.SegMem(Reko.Core.Types.DataType dt, Reko.Core.Expressions.Expression basePtr, Reko.Core.Expressions.Expression offset) -> Reko.Core.Expressions.SegmentedAccess
virtual Reko.Core.Expressions.ExpressionVisitorBase.VisitAddress(Reko.Core.Address addr) -> void
virtual Reko.Core.Expressions.ExpressionVisitorBase.VisitApplication(Reko.Core.Expressions.Application appl) -> void
virtual Reko.Core.Expressions.ExpressionVisitorBase.VisitConversion(Reko.Core.Expressions.Conversion conversion) -> void
virtual Reko.Core.Expressions.ExpressionVisitorBase.VisitIdentifier(Reko.Core.Expressions.Identifier id) -> void
virtual Reko.Core.Expressions.ExpressionVisitorBase.VisitOutArgument(Reko.Core.Expressions.OutArgument outArg) -> void
virtual Reko.Core.Expressions.ExpressionVisitorBase<T>.VisitAddress(Reko.Core.Address addr) -> T
virtual Reko.Core.Expressions.ExpressionVisitorBase<T>.VisitApplication(Reko.Core.Expressions.Application appl) -> T
virtual Reko.Core.Expressions.ExpressionVisitorBase<T>.VisitArrayAccess(Reko.Core.Expressions.ArrayAccess acc) -> T
virtual Reko.Core.Expressions.ExpressionVisitorBase<T>.VisitBinaryExpression(Reko.Core.Expressions.BinaryExpression binExp) -> T
virtual Reko.Core.Expressions.ExpressionVisitorBase<T>.VisitCast(Reko.Core.Expressions.Cast cast) -> T
virtual Reko.Core.Expressions.ExpressionVisitorBase<T>.VisitConditionalExpression(Reko.Core.Expressions.ConditionalExpression cond) -> T
virtual Reko.Core.Expressions.ExpressionVisitorBase<T>.VisitConditionOf(Reko.Core.Expressions.ConditionOf cof) -> T
virtual Reko.Core.Expressions.ExpressionVisitorBase<T>.VisitConstant(Reko.Core.Expressions.Constant c) -> T
virtual Reko.Core.Expressions.ExpressionVisitorBase<T>.VisitConversion(Reko.Core.Expressions.Conversion conversion) -> T
virtual Reko.Core.Expressions.ExpressionVisitorBase<T>.VisitDereference(Reko.Core.Expressions.Dereference deref) -> T
virtual Reko.Core.Expressions.ExpressionVisitorBase<T>.VisitFieldAccess(Reko.Core.Expressions.FieldAccess acc) -> T
virtual Reko.Core.Expressions.ExpressionVisitorBase<T>.VisitIdentifier(Reko.Core.Expressions.Identifier id) -> T
virtual Reko.Core.Expressions.ExpressionVisitorBase<T>.VisitMemberPointerSelector(Reko.Core.Expressions.MemberPointerSelector mps) -> T
virtual Reko.Core.Expressions.ExpressionVisitorBase<T>.VisitMemoryAccess(Reko.Core.Expressions.MemoryAccess access) -> T
virtual Reko.Core.Expressions.ExpressionVisitorBase<T>.VisitMkSequence(Reko.Core.Expressions.MkSequence seq) -> T
virtual Reko.Core.Expressions.ExpressionVisitorBase<T>.VisitOutArgument(Reko.Core.Expressions.OutArgument outArg) -> T
virtual Reko.Core.Expressions.ExpressionVisitorBase<T>.VisitPhiFunction(Reko.Core.Expressions.PhiFunction phi) -> T
virtual Reko.Core.Expressions.ExpressionVisitorBase<T>.VisitPointerAddition(Reko.Core.Expressions.PointerAddition pa) -> T
virtual Reko.Core.Expressions.ExpressionVisitorBase<T>.VisitProcedureConstant(Reko.Core.Expressions.ProcedureConstant pc) -> T
virtual Reko.Core.Expressions.ExpressionVisitorBase<T>.VisitScopeResolution(Reko.Core.Expressions.ScopeResolution scopeResolution) -> T
virtual Reko.Core.Expressions.ExpressionVisitorBase<T>.VisitSegmentedAccess(Reko.Core.Expressions.SegmentedAccess access) -> T
virtual Reko.Core.Expressions.ExpressionVisitorBase<T>.VisitSlice(Reko.Core.Expressions.Slice slice) -> T
virtual Reko.Core.Expressions.ExpressionVisitorBase<T>.VisitTestCondition(Reko.Core.Expressions.TestCondition tc) -> T
virtual Reko.Core.Expressions.ExpressionVisitorBase<T>.VisitUnaryExpression(Reko.Core.Expressions.UnaryExpression unary) -> T
virtual Reko.Core.FieldAttribute.ReadValue(System.Reflection.FieldInfo f, Reko.Core.Memory.EndianImageReader rdr, Reko.Core.ReaderContext ctx) -> object
virtual Reko.Core.FrameApplicationBuilder.VisitFpuStackStorage(Reko.Core.FpuStackStorage fpu) -> Reko.Core.Expressions.Expression
virtual Reko.Core.Hll.C.CDirectiveLexer.ReadPragma(string pragma) -> Reko.Core.Hll.C.CToken
virtual Reko.Core.Hll.C.CGrammar.Bin(Reko.Core.Hll.C.CTokenType op, Reko.Core.Hll.C.CExpression left, Reko.Core.Hll.C.CExpression right) -> Reko.Core.Hll.C.CExpression
virtual Reko.Core.ImageSegment.IsInRange(ulong linearAddress) -> bool
virtual Reko.Core.IO.SpanStream.ReadRemaining() -> byte[]
virtual Reko.Core.Loading.AbstractHierarchicalArchive.AddFile(string! path, System.Func<Reko.Core.Loading.IArchive!, Reko.Core.Loading.ArchiveDirectoryEntry?, string!, Reko.Core.Loading.ArchivedFile!>! fileCreator) -> Reko.Core.Loading.ArchivedFile!
virtual Reko.Core.Loading.AbstractHierarchicalArchive.GetRootPath(Reko.Core.Loading.ArchiveDirectoryEntry? entry) -> string!
virtual Reko.Core.Loading.ProgramImageLoader.AddSegmentReference(Reko.Core.Address addr, ushort seg) -> Reko.Core.ImageSegment
virtual Reko.Core.Loading.ProgramImageLoader.LoadProgram(Reko.Core.Address addrLoad, Reko.Core.IProcessorArchitecture arch, Reko.Core.IPlatform platform) -> Reko.Core.Program
virtual Reko.Core.Machine.DisassemblerBase.Dispose(bool disposing) -> void
virtual Reko.Core.Machine.DisassemblerBase<TInstr, TMnemonic>.GetEnumerator() -> System.Collections.Generic.IEnumerator<TInstr!>!
virtual Reko.Core.Machine.DisassemblerBase<TInstr, TMnemonic>.MakeInstruction(Reko.Core.InstrClass iclass, TMnemonic mnemonic) -> TInstr!
virtual Reko.Core.Machine.InstructionComparer.Equals(Reko.Core.Machine.MachineInstruction x, Reko.Core.Machine.MachineInstruction y) -> bool
virtual Reko.Core.Machine.MachineInstruction.DoRender(Reko.Core.Machine.MachineInstructionRenderer renderer, Reko.Core.Machine.MachineInstructionRendererOptions options) -> void
virtual Reko.Core.Machine.MachineInstruction.RenderOperand(Reko.Core.Machine.MachineOperand operand, Reko.Core.Machine.MachineInstructionRenderer renderer, Reko.Core.Machine.MachineInstructionRendererOptions options) -> void
virtual Reko.Core.Memory.ByteImageReader.ReadAt<T>(long offset, System.Func<Reko.Core.Memory.ImageReader!, T>! action) -> T
virtual Reko.Core.Memory.ByteImageReader.ReadStruct<T>() -> T
virtual Reko.Core.Memory.EndianByteImageReader.Clone() -> Reko.Core.Memory.EndianImageReader
virtual Reko.Core.MetadataLoader.Load(Reko.Core.IPlatform platform, string moduleName, Reko.Core.TypeLibrary dstLib) -> Reko.Core.TypeLibrary
virtual Reko.Core.NamingPolicy.BlockName(Reko.Core.Address addr) -> string
virtual Reko.Core.NamingPolicy.BlockName(Reko.Core.Rtl.RtlLocation loc) -> string
virtual Reko.Core.NamingPolicy.GlobalName(Reko.Core.Types.StructureField field) -> string
virtual Reko.Core.NamingPolicy.ProcedureName(Reko.Core.Address addr) -> string
virtual Reko.Core.NamingPolicy.StackArgumentName(Reko.Core.Types.DataType type, int cbOffset, string nameOverride) -> string
virtual Reko.Core.NamingPolicy.StackLocalName(Reko.Core.Types.DataType type, int cbOffset, string nameOverride) -> string
virtual Reko.Core.NativeInterface.NativeRtlEmitter.CreateAddress(ulong linear) -> Reko.Core.Address
virtual Reko.Core.Operators.Operator.ApplyConstants(Reko.Core.Expressions.Constant c1, Reko.Core.Expressions.Constant c2) -> Reko.Core.Expressions.Constant
virtual Reko.Core.Operators.Operator.AsCompound() -> string
virtual Reko.Core.Operators.Operator.Invert() -> Reko.Core.Operators.Operator
virtual Reko.Core.Output.BlockDecorator.AfterBlock(Reko.Core.Block block, System.Collections.Generic.List<string> lines) -> void
virtual Reko.Core.Output.BlockDecorator.BeforeBlock(Reko.Core.Block block, System.Collections.Generic.List<string> lines) -> void
virtual Reko.Core.Output.BlockDecorator.WriteBlockGraphEdges(Reko.Core.Block block, System.Collections.Generic.List<string> lines) -> void
virtual Reko.Core.Output.CodeFormatter.UnsignedFormatString(Reko.Core.Types.PrimitiveType type, ulong value) -> string
virtual Reko.Core.Output.CodeFormatter.VisitConstant(Reko.Core.Expressions.Constant c) -> void
virtual Reko.Core.Output.CodeFormatter.VisitProcedureConstant(Reko.Core.Expressions.ProcedureConstant pc) -> void
virtual Reko.Core.Output.Formatter.Indent() -> void
virtual Reko.Core.Output.MemoryFormatter.DoRenderAsText(Reko.Core.Memory.ImageReader rdr, int cUnits, System.Text.Encoding enc) -> string
virtual Reko.Core.Output.MemoryFormatter.DoRenderUnit(Reko.Core.Address addr, Reko.Core.Expressions.Constant c, Reko.Core.Output.IMemoryFormatterOutput output) -> void
virtual Reko.Core.Output.PrettyPrinterOutput.WriteIndentation() -> void
virtual Reko.Core.Output.PrettyPrinterOutput.WriteLine() -> void
virtual Reko.Core.Output.TypeReferenceFormatter.WritePrimitiveTypeName(Reko.Core.Types.PrimitiveType t) -> void
virtual Reko.Core.Output.TypeReferenceFormatter.WriteVoidType(Reko.Core.Types.VoidType t) -> void
virtual Reko.Core.Platform.AdjustProcedureAddress(Reko.Core.Address addr) -> Reko.Core.Address
virtual Reko.Core.Platform.CreateAbsoluteMemoryMap() -> Reko.Core.SegmentMap?
virtual Reko.Core.Platform.CreateCParser(System.IO.TextReader! rdr, Reko.Core.Hll.C.ParserState? state) -> Reko.Core.Hll.C.CParser!
virtual Reko.Core.Platform.CreateEmulator(Reko.Core.SegmentMap segmentMap, System.Collections.Generic.Dictionary<Reko.Core.Address, Reko.Core.ImportReference> importReferences) -> Reko.Core.Emulation.IPlatformEmulator
virtual Reko.Core.Platform.DataTypeFromImportName(string importName) -> (string, Reko.Core.Serialization.SerializedType, Reko.Core.Serialization.SerializedType)?
virtual Reko.Core.Platform.DefaultTextEncoding.get -> System.Text.Encoding
virtual Reko.Core.Platform.DefaultTextEncoding.set -> void
virtual Reko.Core.Platform.DetermineCallingConvention(Reko.Core.Types.FunctionType! signature) -> string?
virtual Reko.Core.Platform.EnsureTypeLibraries(string! envName) -> void
virtual Reko.Core.Platform.FindDispatcherProcedureByAddress(Reko.Core.Address addr) -> Reko.Core.Serialization.DispatchProcedure_v1
virtual Reko.Core.Platform.FindMainProcedure(Reko.Core.Program! program, Reko.Core.Address! addrStart) -> Reko.Core.ImageSymbol?
virtual Reko.Core.Platform.FindService(Reko.Core.Rtl.RtlInstruction rtl, Reko.Core.ProcessorState state, Reko.Core.SegmentMap segmentMap) -> Reko.Core.SystemService
virtual Reko.Core.Platform.FindService(string name) -> Reko.Core.SystemService
virtual Reko.Core.Platform.FormatProcedureName(Reko.Core.Program! program, Reko.Core.Procedure! proc) -> string!
virtual Reko.Core.Platform.FramePointerType.get -> Reko.Core.Types.PrimitiveType
virtual Reko.Core.Platform.GetPrimitiveTypeName(Reko.Core.Types.PrimitiveType! pt, string! language) -> string?
virtual Reko.Core.Platform.GetTrampolineDestination(Reko.Core.Address addrInstr, System.Collections.Generic.IEnumerable<Reko.Core.Rtl.RtlInstruction> instrs, Reko.Core.IRewriterHost host) -> Reko.Core.ProcedureBase
virtual Reko.Core.Platform.InjectProcedureEntryStatements(Reko.Core.Procedure proc, Reko.Core.Address addr, Reko.Core.CodeEmitter emitter) -> void
virtual Reko.Core.Platform.IsImplicitArgumentRegister(Reko.Core.RegisterStorage reg) -> bool
virtual Reko.Core.Platform.IsPossibleArgumentRegister(Reko.Core.RegisterStorage reg) -> bool
virtual Reko.Core.Platform.LoadUserOptions(System.Collections.Generic.Dictionary<string, object> options) -> void
virtual Reko.Core.Platform.LookupCharacteristicsByName(string procName) -> Reko.Core.Serialization.ProcedureCharacteristics
virtual Reko.Core.Platform.LookupProcedureByAddress(Reko.Core.Address addr) -> Reko.Core.ExternalProcedure
virtual Reko.Core.Platform.LookupProcedureByOrdinal(string moduleName, int ordinal) -> Reko.Core.ExternalProcedure
virtual Reko.Core.Platform.MakeAddressFromConstant(Reko.Core.Expressions.Constant c, bool codeAlign) -> Reko.Core.Address
virtual Reko.Core.Platform.MakeAddressFromLinear(ulong uAddr, bool codeAlign) -> Reko.Core.Address
virtual Reko.Core.Platform.MemoryMap.get -> Reko.Core.Serialization.MemoryMap_v1
virtual Reko.Core.Platform.MemoryMap.set -> void
virtual Reko.Core.Platform.Metadata.get -> Reko.Core.TypeLibrary
virtual Reko.Core.Platform.Metadata.set -> void
virtual Reko.Core.Platform.PointerType.get -> Reko.Core.Types.PrimitiveType
virtual Reko.Core.Platform.PossibleReturnValue(System.Collections.Generic.IEnumerable<Reko.Core.Storage> storages) -> Reko.Core.Storage
virtual Reko.Core.Platform.ResolveImportByName(string moduleName, string globalName) -> Reko.Core.Expressions.Expression
virtual Reko.Core.Platform.ResolveImportByOrdinal(string moduleName, int ordinal) -> Reko.Core.Expressions.Expression
virtual Reko.Core.Platform.ResolveIndirectCall(Reko.Core.Rtl.RtlCall instr) -> Reko.Core.Address
virtual Reko.Core.Platform.SaveUserOptions() -> System.Collections.Generic.Dictionary<string, object>
virtual Reko.Core.Platform.SignatureFromName(string fnName) -> Reko.Core.Serialization.ProcedureBase_v1
virtual Reko.Core.Platform.TryParseAddress(string sAddress, out Reko.Core.Address addr) -> bool
virtual Reko.Core.Platform.WriteMetadata(Reko.Core.Program program, string path) -> void
virtual Reko.Core.PointerScanner<T>.ProbeForPointer(Reko.Core.Memory.EndianImageReader rdr, out T linAddrInstr) -> bool
virtual Reko.Core.ProcessorArchitecture.CreateAssembler(string asmDialect) -> Reko.Core.Assemblers.IAssembler
virtual Reko.Core.ProcessorArchitecture.CreateEmulator(Reko.Core.SegmentMap segmentMap, Reko.Core.Emulation.IPlatformEmulator envEmulator) -> Reko.Core.Emulation.IProcessorEmulator
virtual Reko.Core.ProcessorArchitecture.CreateFpuStackAccess(Reko.Core.IStorageBinder binder, int offset, Reko.Core.Types.DataType dataType) -> Reko.Core.Expressions.Expression
virtual Reko.Core.ProcessorArchitecture.CreateFrameApplicationBuilder(Reko.Core.IStorageBinder binder, Reko.Core.Code.CallSite site, Reko.Core.Expressions.Expression callee) -> Reko.Core.FrameApplicationBuilder
virtual Reko.Core.ProcessorArchitecture.CreateMemoryArea(Reko.Core.Address addr, byte[] bytes) -> Reko.Core.Memory.MemoryArea
virtual Reko.Core.ProcessorArchitecture.CreateStackAccess(Reko.Core.IStorageBinder binder, int cbOffset, Reko.Core.Types.DataType dataType) -> Reko.Core.Expressions.Expression
virtual Reko.Core.ProcessorArchitecture.GetCallingConvention(string name) -> Reko.Core.CallingConvention
virtual Reko.Core.ProcessorArchitecture.GetFlags() -> Reko.Core.FlagGroupStorage[]
virtual Reko.Core.ProcessorArchitecture.GetSubFlags(Reko.Core.FlagGroupStorage flags) -> System.Collections.Generic.IEnumerable<Reko.Core.FlagGroupStorage>
virtual Reko.Core.ProcessorArchitecture.InlineCall(Reko.Core.Address addrCallee, Reko.Core.Address addrContinuation, Reko.Core.Memory.EndianImageReader rdr, Reko.Core.IStorageBinder binder) -> System.Collections.Generic.List<Reko.Core.Rtl.RtlInstruction>
virtual Reko.Core.ProcessorArchitecture.IsStackArgumentOffset(long frameOffset) -> bool
virtual Reko.Core.ProcessorArchitecture.LoadUserOptions(System.Collections.Generic.Dictionary<string, object> options) -> void
virtual Reko.Core.ProcessorArchitecture.MakeSegmentedAddress(Reko.Core.Expressions.Constant seg, Reko.Core.Expressions.Constant offset) -> Reko.Core.Address
virtual Reko.Core.ProcessorArchitecture.PostprocessProgram(Reko.Core.Program program) -> void
virtual Reko.Core.ProcessorArchitecture.ReinterpretAsFloat(Reko.Core.Expressions.Constant rawBits) -> Reko.Core.Expressions.Constant
virtual Reko.Core.ProcessorArchitecture.RenderInstructionOpcode(Reko.Core.Machine.MachineInstruction instr, Reko.Core.Memory.EndianImageReader rdr) -> string
virtual Reko.Core.ProcessorArchitecture.ReturnAddressOnStack.get -> int
virtual Reko.Core.ProcessorArchitecture.SaveUserOptions() -> System.Collections.Generic.Dictionary<string, object>
virtual Reko.Core.ProcessorArchitecture.TryRead(Reko.Core.Memory.EndianImageReader rdr, Reko.Core.Types.PrimitiveType dt, out Reko.Core.Expressions.Constant value) -> bool
virtual Reko.Core.ProcessorState.InstructionPointer.get -> Reko.Core.Address
virtual Reko.Core.ProcessorState.InstructionPointer.set -> void
virtual Reko.Core.Program.CreateSymbolTable() -> Reko.Core.Hll.C.SymbolTable
virtual Reko.Core.Program.LookupCharacteristicsByName(string procName) -> Reko.Core.Serialization.ProcedureCharacteristics
virtual Reko.Core.RegisterStorage.SetRegisterStateValues(Reko.Core.Expressions.Expression value, bool isValid, System.Collections.Generic.Dictionary<Reko.Core.Storage, Reko.Core.Expressions.Expression> ctx) -> void
virtual Reko.Core.Rtl.RtlInstruction.Class.get -> Reko.Core.InstrClass
virtual Reko.Core.Rtl.RtlInstruction.Class.set -> void
virtual Reko.Core.Serialization.ProcedureCharacteristics.IsAlloca.get -> bool
virtual Reko.Core.Serialization.ProcedureCharacteristics.IsAlloca.set -> void
virtual Reko.Core.Serialization.ProcedureCharacteristics.Terminates.get -> bool
virtual Reko.Core.Serialization.ProcedureCharacteristics.Terminates.set -> void
virtual Reko.Core.Serialization.ProcedureCharacteristics.VarargsParserClass.get -> string
virtual Reko.Core.Serialization.ProcedureCharacteristics.VarargsParserClass.set -> void
virtual Reko.Core.Storage.BitSize.get -> ulong
virtual Reko.Core.Storage.BitSize.set -> void
virtual Reko.Core.Storage.Exceeds(Reko.Core.Storage that) -> bool
virtual Reko.Core.Storage.GetBitRange() -> Reko.Core.BitRange
virtual Reko.Core.Storage.Serialize() -> Reko.Core.Serialization.SerializedKind
virtual Reko.Core.TypeNamingPolicy.ShortPrefix(Reko.Core.Types.DataType dt) -> string
virtual Reko.Core.TypeNamingPolicy.StructureFieldName(Reko.Core.Types.StructureField field, string userGivenName) -> string
virtual Reko.Core.TypeNamingPolicy.UnionAlternativeName(Reko.Core.Types.UnionAlternative alt, string userGivenName) -> string
virtual Reko.Core.Types.DataType.BitSize.get -> int
virtual Reko.Core.Types.DataType.IsComplex.get -> bool
virtual Reko.Core.Types.DataType.IsIntegral.get -> bool
virtual Reko.Core.Types.DataType.IsPointer.get -> bool
virtual Reko.Core.Types.DataType.IsReal.get -> bool
virtual Reko.Core.Types.DataType.IsWord.get -> bool
virtual Reko.Core.Types.DataType.Name.get -> string
virtual Reko.Core.Types.DataType.Name.set -> void
virtual Reko.Core.Types.DataTypeTransformer.VisitArray(Reko.Core.Types.ArrayType at) -> Reko.Core.Types.DataType
virtual Reko.Core.Types.DataTypeTransformer.VisitClass(Reko.Core.Types.ClassType ct) -> Reko.Core.Types.DataType
virtual Reko.Core.Types.DataTypeTransformer.VisitCode(Reko.Core.Types.CodeType c) -> Reko.Core.Types.DataType
virtual Reko.Core.Types.DataTypeTransformer.VisitEnum(Reko.Core.Types.EnumType e) -> Reko.Core.Types.DataType
virtual Reko.Core.Types.DataTypeTransformer.VisitEquivalenceClass(Reko.Core.Types.EquivalenceClass eq) -> Reko.Core.Types.DataType
virtual Reko.Core.Types.DataTypeTransformer.VisitFunctionType(Reko.Core.Types.FunctionType ft) -> Reko.Core.Types.DataType
virtual Reko.Core.Types.DataTypeTransformer.VisitMemberPointer(Reko.Core.Types.MemberPointer memptr) -> Reko.Core.Types.DataType
virtual Reko.Core.Types.DataTypeTransformer.VisitPointer(Reko.Core.Types.Pointer ptr) -> Reko.Core.Types.DataType
virtual Reko.Core.Types.DataTypeTransformer.VisitPrimitive(Reko.Core.Types.PrimitiveType pt) -> Reko.Core.Types.DataType
virtual Reko.Core.Types.DataTypeTransformer.VisitReference(Reko.Core.Types.ReferenceTo refTo) -> Reko.Core.Types.DataType
virtual Reko.Core.Types.DataTypeTransformer.VisitString(Reko.Core.Types.StringType str) -> Reko.Core.Types.DataType
virtual Reko.Core.Types.DataTypeTransformer.VisitStructure(Reko.Core.Types.StructureType str) -> Reko.Core.Types.DataType
virtual Reko.Core.Types.DataTypeTransformer.VisitTypeReference(Reko.Core.Types.TypeReference typeref) -> Reko.Core.Types.DataType
virtual Reko.Core.Types.DataTypeTransformer.VisitTypeVariable(Reko.Core.Types.TypeVariable tv) -> Reko.Core.Types.DataType
virtual Reko.Core.Types.DataTypeTransformer.VisitUnion(Reko.Core.Types.UnionType ut) -> Reko.Core.Types.DataType
virtual Reko.Core.Types.DataTypeTransformer.VisitUnknownType(Reko.Core.Types.UnknownType unk) -> Reko.Core.Types.DataType
virtual Reko.Core.Types.DataTypeTransformer.VisitVoidType(Reko.Core.Types.VoidType vt) -> Reko.Core.Types.DataType
virtual Reko.Core.Types.Unifier.UnifyTypeVariables(Reko.Core.Types.TypeVariable tA, Reko.Core.Types.TypeVariable tB) -> Reko.Core.Types.DataType